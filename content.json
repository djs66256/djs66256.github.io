[{"title":"支持 visionOS App 播放沉浸视频","date":"2025-06-10T15:54:00.000Z","path":"2025/06/10/2025-06-10-wwdc2025_296/","text":"了解如何在 visionos app 中播放沉浸视频。我们将介绍各种沉浸感十足的渲染模式、查看支持这些模式的框架，并讲解如何在你的 app 中渲染沉浸视频。为了充分利用好本次视频，我们建议你先观看 wwdc25 讲座“探索 visionos 的视频体验”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 支持 visionOS App 播放沉浸视频随着 visionOS 的不断发展，开发者现在可以利用多种框架在应用中实现沉浸式视频播放体验。本文将详细介绍如何在 visionOS 26 中通过 Quick Look、AVKit 和 RealityKit 支持沉浸式视频播放，并探讨相关技术实现和最佳实践。 介绍在 visionOS 26 中，Apple 引入了多种新的沉浸式媒体配置文件，包括 Apple Projected Media Profile (APMP) 和 Apple 沉浸视频。这些新特性为开发者提供了丰富的工具集，以创建引人入胜的沉浸式视频体验。Quick Look、AVKit 和 RealityKit 是三个主要框架，它们各自适用于不同的场景需求：从快速预览到完全自定义的沉浸式播放。 接下来的内容将分为几个部分：首先回顾支持的视频配置文件，然后逐步讲解如何使用 Quick Look 和 AVKit 实现沉浸式视频播放，最后深入探讨如何通过 RealityKit 创建高度定制化的沉浸体验。 visionOS 26 中支持的视频配置文件visionOS 26 支持多种视频配置文件，涵盖了从传统的 2D 和 3D 视频到更具沉浸感的 Apple Projected Media Profile（包括 180°、360° 和宽视场视频）以及 Apple 沉浸视频。不同类型的视频配置文件各有特点，例如 APMP 提供了广泛的沉浸视角选择，而 Apple 沉浸视频则专注于极致的沉浸体验。 为了充分利用这些视频配置文件，开发者需要根据应用的需求选择合适的框架。Quick Look 适合快速呈现媒体内容；AVKit 提供了一致且增强的播放控制功能；而 RealityKit 则专为需要高度定制化体验的应用设计，例如游戏环境中的视频播放。 Quick Look 中的沉浸视频播放Quick Look 在 visionOS 26 中得到了显著增强，能够支持空间照片和视频的展示。QLPreviewController API 可用于在一个应用程序窗口或模态展示风格中预览媒体，同时支持 Apple 沉浸视频和 APMP 配置文件。 对于已经实现了 Quick Look API 的应用，所有新支持的沉浸式媒体配置文件将自动生效。开发者可以通过 WWDC 相关视频进一步了解如何实现 QLPreviewController 和 PreviewApplication API，从而提升应用的沉浸式媒体支持能力。 使用 AVKit 进行沉浸视频播放AVKit 在 visionOS 26 中新增了对沉浸式视频播放的支持，通过 AVExperienceController API 可以实现向新沉浸体验的过渡。开发者可以选择使用 Expanded 或 Immersive 体验模式来满足不同需求。 自动过渡与手动控制在 Expanded 模式下，AutomaticTransitionToImmersive 属性允许开发者控制是否自动切换到沉浸体验。以下代码展示了如何禁用自动过渡并手动管理沉浸体验： 12345678910import AVKitlet controller = AVPlayerViewController()let experienceController = controller.experienceControllerexperienceController.allowedExperiences = .recommended(including: [.expanded, .immersive])experienceController.configuration.expanded.automaticTransitionToImmersive = .noneawait experienceController.transition(to: .expanded) 手动转换到沉浸模式要显式地转换到沉浸模式，开发者可以使用 configuration.placement API 来指定沉浸式视频播放的位置。以下代码演示了如何通过指定目标窗口场景完成这一操作： 1234567891011import AVKitlet controller = AVPlayerViewController()let experienceController = controller.experienceControllerexperienceController.allowedExperiences = .recommended(including: [.immersive])let myScene = getMyPreferredWindowUIScene()experienceController.configuration.placement = .over(scene: myScene)await experienceController.transition(to: .immersive) 此外，AVExperienceController 的委托协议提供了灵活的状态管理方法，例如 didChangeAvailableExperiences 和 prepareForTransitionUsing，使开发者能够精确控制沉浸式体验的过渡过程。 舒适缓解检测沉浸式视频可能会因显著的摄像机运动导致观众不适。为解决这一问题，visionOS 26 在 Quick Look 和 AVKit 中引入了舒适缓解检测功能，能够自动检测高运动并降低沉浸水平。用户还可以通过设置应用调整相关选项，确保播放行为符合个人偏好。 RealityKit 中的自定义播放对于需要更高定制化程度的应用，RealityKit 提供了强大的工具集来渲染和管理沉浸式视频播放。其核心组件 VideoPlayerComponent 能够根据当前 AVPlayer 的内容动态生成网格和材质，从而简化开发流程。 渐进沉浸模式在 RealityKit 中，渐进沉浸模式是一种全新的 API，允许用户通过数码表冠调整沉浸级别，从而在享受视频的同时保持与周围环境的联系。以下代码展示了如何在门户模式下渲染 180° 视频： 123456789101112131415161718import AVFoundationimport RealityKitimport SwiftUIstruct PortalVideoView: View &#123; var body: some View &#123; RealityView &#123; content in guard let url = URL(string: &quot;https://cdn.example.com/My180.m3u8&quot;) else &#123; return &#125; let player = AVPlayer(playerItem: AVPlayerItem(url: url)) let videoEntity = Entity() var videoPlayerComponent = VideoPlayerComponent(avPlayer: player) videoPlayerComponent.desiredImmersiveViewingMode = .portal videoEntity.components.set(videoPlayerComponent) videoEntity.scale *= 0.4 content.add(videoEntity) &#125; &#125;&#125; 如果希望切换到渐进沉浸模式，只需将 desiredImmersiveViewingMode 设置为 .progressive，并在 SwiftUI 场景中使用 ImmersiveSpace 包装视图： 12345678910111213import AVFoundationimport RealityKitimport SwiftUI@mainstruct ImmersiveVideoApp: App &#123; var body: some Scene &#123; ImmersiveSpace &#123; ProgressiveVideoView() &#125; .immersionStyle(selection: .constant(.progressive(0.1...1, initialAmount: 1.0)), in: .progressive) &#125;&#125; 空间视频渲染RealityKit 还支持空间视频的原生播放，并提供完全空间样式的渲染选项。通过设置 desiredSpatialVideoMode 属性，开发者可以灵活选择渲染方式。例如，以下代码展示了如何在门户模式下渲染空间视频： 1234567891011121314151617181920import AVFoundationimport RealityKitimport SwiftUIstruct PortalSpatialVideoView: View &#123; var body: some View &#123; RealityView &#123; content in let url = Bundle.main.url(forResource: &quot;MySpatialVideo&quot;, withExtension: &quot;mov&quot;)! let player = AVPlayer(url: url) let videoEntity = Entity() var videoPlayerComponent = VideoPlayerComponent(avPlayer: player) videoPlayerComponent.desiredViewingMode = .stereo videoPlayerComponent.desiredSpatialVideoMode = .spatial videoPlayerComponent.desiredImmersiveViewingMode = .portal videoEntity.components.set(videoPlayerComponent) videoEntity.scale *= 0.4 content.add(videoEntity) &#125; &#125;&#125; 若需进一步扩展视频至全沉浸模式，可将 desiredImmersiveViewingMode 设置为 .full 并移除缩放操作： 1234567891011121314151617181920import AVFoundationimport RealityKitimport SwiftUIstruct PortalSpatialVideoView: View &#123; var body: some View &#123; RealityView &#123; content in let url = Bundle.main.url(forResource: &quot;MySpatialVideo&quot;, withExtension: &quot;mov&quot;)! let player = AVPlayer(url: url) let videoEntity = Entity() var videoPlayerComponent = VideoPlayerComponent(avPlayer: player) videoPlayerComponent.desiredViewingMode = .stereo videoPlayerComponent.desiredSpatialVideoMode = .spatial videoPlayerComponent.desiredImmersiveViewingMode = .full videoEntity.position = [0, 1.5, -1] videoEntity.components.set(videoPlayerComponent) content.add(videoEntity) &#125; &#125;&#125; 结论通过 Quick Look、AVKit 和 RealityKit，开发者可以在 visionOS 应用中实现丰富多样的沉浸式视频播放体验。无论是快速预览还是深度定制，Apple 提供的工具集都为开发者创造了无限可能。建议开发者进一步探索相关文档和示例代码，以充分发挥这些框架的潜力。 相关视频了解 Apple 沉浸视频技术了解 Apple Projected Media Profile探索 visionOS 的视频体验空间网页的新功能深入探究空间容器和沉浸式空间使用 RealityKit 增强你的空间计算 App 文档AVFoundationAVKitHTTP Live Streaming ExamplesRealityKit","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"深入探索 Metal 4 游戏","date":"2025-06-10T15:53:59.000Z","path":"2025/06/10/2025-06-10-wwdc2025_211/","text":"深入了解 metal 4 的最新改进。我们将介绍全新光线追踪功能，助你将复杂度极高且视觉效果丰富的工作负载成功移植到 apple 芯片上。了解 metalfx 如何通过渲染画质提升、帧插值和场景去噪来扩展工作负载。 为了充分从这个讲座中获益，我们建议你先观看“探索 metal 4”和“探索 metal 4 游戏”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深入探索 Metal 4 游戏Metal 4 的推出为 Apple 平台上的游戏开发者带来了全新的可能性，特别是在光线追踪、渲染性能和视觉效果提升方面。本次演讲由 Matias Koskela 主讲，深入探讨了如何利用 MetalFX 和 Metal 4 的新特性来优化游戏性能，并将复杂的工作负载成功移植到 Apple 芯片上。以下是对演讲内容的全面解析。 简介随着游戏画质的不断提升，实时渲染的复杂性和计算成本也在显著增加。例如《赛博朋克2077》这样的现代游戏，通过实时路径追踪技术实现了令人惊叹的画面效果，但这也对硬件性能提出了更高的要求。Metal 提供了一系列工具和 API，帮助开发者在 iPhone 到 Mac 的所有 Apple 平台上实现高质量的图形渲染。MetalFX Upscaling 和帧插值等技术可以有效应对高分辨率和高帧率带来的挑战，而新的光线追踪功能则进一步提升了渲染的真实感。 为了更好地理解这些新技术，建议先观看“探索 Metal 4”和“探索 Metal 4 游戏”，以获得关于 Metal 4 基础知识及其游戏应用的背景信息。 放大渲染放大渲染是一种广泛使用的技术，它可以帮助开发者在不牺牲质量的前提下提高渲染性能。MetalFX 提供了一个基于机器学习的放大器，自 2022 年起便成为 Apple 平台的一部分，并逐年改进。以下是实现高质量放大的关键技术要点： 曝光参数设置正确设置曝光输入参数对于放大器的输出质量至关重要。如果传递的曝光值与色调映射器不匹配，可能会导致闪烁或鬼影现象。为此，MetalFX 提供了一个名为“曝光调试器”的工具，可以通过设置环境变量 MTLFX_EXPOSURE_TOOL_ENABLED 来启用。该工具会在帧上叠加一个灰色棋盘格图案，并根据曝光值调整其亮度。如果曝光值设置正确，棋盘格应保持恒定的中灰色。 12// 在主机代码中启用曝光调试器setenv(&quot;MTLFX_EXPOSURE_TOOL_ENABLED&quot;, &quot;1&quot;, 1); 动态分辨率支持许多游戏采用动态分辨率渲染以适应不同场景的复杂度。MetalFX 时间放大器现在支持动态大小的输入，允许每帧传递不同分辨率的纹理。在高缩放比率下，建议将最大缩放比例限制在 2 倍以内，以确保缩放质量。 反应掩码当渲染透明效果或粒子时（如烟花），这些元素通常不会被写入运动和深度纹理中，从而可能导致伪影或鬼影问题。MetalFX 引入了反应掩码功能，用于标记这些效果覆盖的区域。 12345// 在着色器中创建反应掩码设置out.reactivity = m_material_id == eRain ? (m_material_id == eSpark ? 1.0f : 0.0f) : 0.8f;// 在主机上编码放大器之前设置反应掩码temporalUpscaler.reactiveMask = reactiveMaskTexture; 通过合理使用反应掩码，可以显著改善透明效果的渲染质量。 插值帧帧插值是提高刷新率的一种有效方法，特别适用于需要流畅体验的游戏。MetalFX 帧插值器能够通过已渲染的像素生成插值帧，从而实现更高的帧率。 集成帧插值器要使用 MetalFX 帧插值器，首先需要设置插值器对象并绑定必要的纹理输入，包括颜色、深度和运动矢量纹理。 12345678910111213141516// 创建并配置插值器描述符MTLFXFrameInterpolatorDescriptor* desc = [MTLFXFrameInterpolatorDescriptor new];desc.scaler = temporalScaler;// 创建插值器并设置参数id&lt;MTLFXFrameInterpolator&gt; interpolator = [desc newFrameInterpolatorWithDevice:device];interpolator.motionVectorScaleX = mvecScaleX;interpolator.motionVectorScaleY = mvecScaleY;interpolator.depthReversed = YES;// 设置输入纹理interpolator.colorTexture = colorTexture;interpolator.prevColorTexture = prevColorTexture;interpolator.depthTexture = depthTexture;interpolator.motionTexture = motionTexture;interpolator.outputTexture = outputTexture; UI 渲染策略在插值帧中渲染 UI 是一个关键步骤。常见的三种方法包括合成 UI、离屏 UI 和每帧 UI。每种方法都有其优缺点，开发者可以根据需求选择最适合的方案。 合成 UI：插值器会尝试移除原始帧中的 UI 并将其放置在插值帧中的正确位置。 离屏 UI：将 UI 渲染到独立的纹理中，然后由插值器进行合成。 每帧 UI：完全由开发者负责更新插值帧的 UI，可提供最流畅的体验。 帧节奏协调插值帧的呈现顺序和间隔对游戏的整体流畅性至关重要。通过使用 Metal HUD 工具，开发者可以轻松识别帧节奏是否偏离目标刷新率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;sys/event.h&gt;#include &lt;mach/mach_time.h&gt;class PresentThread&#123; int m_timerQueue; std::thread m_encodingThread, m_pacingThread; std::mutex m_mutex; std::condition_variable m_scheduleCV, m_threadCV, m_pacingCV; float m_minDuration; uint32_t m_width, m_height; MTLPixelFormat m_pixelFormat; const static uint32_t kNumBuffers = 3; uint32_t m_bufferIndex, m_inputIndex; bool m_renderingUI, m_presentsPending; CAMetalLayer *m_metalLayer; id&lt;MTLCommandQueue&gt; m_presentQueue; id&lt;MTLEvent&gt; m_event; id&lt;MTLSharedEvent&gt; m_paceEvent, m_paceEvent2; uint64_t m_eventValue; uint32_t m_paceCount; int32_t m_numQueued, m_framesInFlight; id&lt;MTLTexture&gt; m_backBuffers[kNumBuffers]; id&lt;MTLTexture&gt; m_interpolationOutputs[kNumBuffers]; id&lt;MTLTexture&gt; m_interpolationInputs[2]; id&lt;MTLRenderPipelineState&gt; m_copyPipeline; std::function&lt;void(id&lt;MTLRenderCommandEncoder&gt;)&gt; m_uiCallback = nullptr; void PresentThreadFunction(); void PacingThreadFunction(); void CopyTexture(id&lt;MTLCommandBuffer&gt; commandBuffer, id&lt;MTLTexture&gt; dest, id&lt;MTLTexture&gt; src, NSString *label);public: PresentThread(float minDuration, CAMetalLayer *metalLayer); ~PresentThread() &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); m_numQueued = -1; m_threadCV.notify_one(); m_encodingThread.join(); &#125; void StartFrame(id&lt;MTLCommandBuffer&gt; commandBuffer) &#123; [commandBuffer encodeWaitForEvent:m_event value:m_eventValue++]; &#125; void StartUI(id&lt;MTLCommandBuffer&gt; commandBuffer) &#123; assert(m_uiCallback == nullptr); if(!m_renderingUI) &#123; CopyTexture(commandBuffer, m_interpolationInputs[m_inputIndex], m_backBuffers[m_bufferIndex], @&quot;Copy HUDLESS&quot;); m_renderingUI = true; &#125; &#125; void Present(id&lt;MTLFXFrameInterpolator&gt; frameInterpolator, id&lt;MTLCommandQueue&gt; queue); id&lt;MTLTexture&gt; GetBackBuffer() &#123; return m_backBuffers[m_bufferIndex]; &#125; void Resize(uint32_t width, uint32_t height, MTLPixelFormat pixelFormat); void DrainPendingPresents() &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); while(m_presentsPending) m_scheduleCV.wait(lock); &#125; bool UICallbackEnabled() const &#123; return m_uiCallback != nullptr; &#125; void SetUICallback(std::function&lt;void(id&lt;MTLRenderCommandEncoder&gt;)&gt; callback) &#123; m_uiCallback = callback; &#125; &#125;;PresentThread::PresentThread(float minDuration, CAMetalLayer *metalLayer) : m_encodingThread(&amp;PresentThread::PresentThreadFunction, this) , m_pacingThread(&amp;PresentThread::PacingThreadFunction, this) , m_minDuration(minDuration) , m_numQueued(0) , m_metalLayer(metalLayer) , m_inputIndex(0u) , m_bufferIndex(0u) , m_renderingUI(false) , m_presentsPending(false) , m_framesInFlight(0) , m_paceCount(0) , m_eventValue(0)&#123; id&lt;MTLDevice&gt; device = metalLayer.device; m_presentQueue = [device newCommandQueue]; m_presentQueue.label = @&quot;presentQ&quot;; m_timerQueue = kqueue(); metalLayer.maximumDrawableCount = 3; Resize(metalLayer.drawableSize.width, metalLayer.drawableSize.height, metalLayer.pixelFormat); m_event = [device newEvent]; m_paceEvent = [device newSharedEvent]; m_paceEvent2 = [device newSharedEvent];&#125;void PresentThread::Present(id&lt;MTLFXFrameInterpolator&gt; frameInterpolator, id&lt;MTLCommandQueue&gt; queue)&#123; id&lt;MTLCommandBuffer&gt; commandBuffer = [queue commandBuffer]; if(m_renderingUI) &#123; frameInterpolator.colorTexture = m_interpolationInputs[m_inputIndex]; frameInterpolator.prevColorTexture = m_interpolationInputs[m_inputIndex^1]; frameInterpolator.uiTexture = m_backBuffers[m_bufferIndex]; &#125; else &#123; frameInterpolator.colorTexture = m_backBuffers[m_bufferIndex]; frameInterpolator.prevColorTexture = m_backBuffers[(m_bufferIndex + kNumBuffers - 1) % kNumBuffers]; frameInterpolator.uiTexture = nullptr; &#125; frameInterpolator.outputTexture = m_interpolationOutputs[m_bufferIndex]; [frameInterpolator encodeToCommandBuffer:commandBuffer]; [commandBuffer addCompletedHandler:^(id&lt;MTLCommandBuffer&gt; _Nonnull) &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); m_framesInFlight--; m_scheduleCV.notify_one(); m_paceCount++; m_pacingCV.notify_one(); &#125;]; [commandBuffer encodeSignalEvent:m_event value:m_eventValue++]; [commandBuffer commit]; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); m_framesInFlight++; m_numQueued++; m_presentsPending = true; m_threadCV.notify_one(); while((m_framesInFlight &gt;= 2) || (m_numQueued &gt;= 2)) m_scheduleCV.wait(lock); m_bufferIndex = (m_bufferIndex + 1) % kNumBuffers; m_inputIndex = m_inputIndex^1u; m_renderingUI = false;&#125;void PresentThread::CopyTexture(id&lt;MTLCommandBuffer&gt; commandBuffer, id&lt;MTLTexture&gt; dest, id&lt;MTLTexture&gt; src, NSString *label)&#123; MTLRenderPassDescriptor *desc = [MTLRenderPassDescriptor new]; desc.colorAttachments[0].texture = dest; desc.colorAttachments[0].loadAction = MTLLoadActionDontCare; desc.colorAttachments[0].storeAction = MTLStoreActionStore; id&lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:desc]; [renderEncoder setFragmentTexture:src atIndex:0]; [renderEncoder setRenderPipelineState:m_copyPipeline]; [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3]; if(m_uiCallback) m_uiCallback(renderEncoder); renderEncoder.label = label; [renderEncoder endEncoding];&#125;void PresentThread::PacingThreadFunction()&#123; NSThread *thread = [NSThread currentThread]; [thread setName:@&quot;PacingThread&quot;]; [thread setQualityOfService:NSQualityOfServiceUserInteractive]; [thread setThreadPriority:1.f]; mach_timebase_info_data_t info; mach_timebase_info(&amp;info); // maximum delta (0.1ms) in machtime units const uint64_t maxDeltaInNanoSecs = 100000000; const uint64_t maxDelta = maxDeltaInNanoSecs * info.denom / info.numer; uint64_t time = mach_absolute_time(); uint64_t paceEventValue = 0; for(;;) &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); while(m_paceCount == 0) m_pacingCV.wait(lock); m_paceCount--; lock.unlock(); // we get signal... const uint64_t prevTime = time; time = mach_absolute_time(); m_paceEvent.signaledValue = ++paceEventValue; const uint64_t delta = std::min(time - prevTime, maxDelta); const uint64_t timeStamp = time + ((delta*31)&gt;&gt;6); struct kevent64_s timerEvent, eventOut; struct timespec timeout; timeout.tv_nsec = maxDeltaInNanoSecs; timeout.tv_sec = 0; EV_SET64(&amp;timerEvent, 0, EVFILT_TIMER, EV_ADD | EV_ONESHOT | EV_ENABLE, NOTE_CRITICAL | NOTE_LEEWAY | NOTE_MACHTIME | NOTE_ABSOLUTE, timeStamp, 0, 0, 0); kevent64(m_timerQueue, &amp;timerEvent, 1, &amp;eventOut, 1, 0, &amp;timeout); // main screen turn on... m_paceEvent2.signaledValue = ++paceEventValue; &#125;&#125;void PresentThread::PresentThreadFunction()&#123; NSThread *thread = [NSThread currentThread]; [thread setName:@&quot;PresentThread&quot;]; [thread setQualityOfService:NSQualityOfServiceUserInteractive]; [thread setThreadPriority:1.f]; uint64_t eventValue = 0; uint32_t bufferIndex = 0; uint64_t paceEventValue = 0; for(;;) &#123; std::unique_lock&lt;std::mutex&gt; lock(m_mutex); if(m_numQueued == 0) &#123; m_presentsPending = false; m_scheduleCV.notify_one(); &#125; while(m_numQueued == 0) m_threadCV.wait(lock); if(m_numQueued &lt; 0) break; lock.unlock(); @autoreleasepool &#123; id&lt;CAMetalDrawable&gt; drawable = [m_metalLayer nextDrawable]; lock.lock(); m_numQueued--; m_scheduleCV.notify_one(); lock.unlock(); id&lt;MTLCommandBuffer&gt; commandBuffer = [m_presentQueue commandBuffer]; [commandBuffer encodeWaitForEvent:m_event value:++eventValue]; CopyTexture(commandBuffer, drawable.texture, m_interpolationOutputs[bufferIndex], @&quot;Copy Interpolated&quot;); [commandBuffer encodeSignalEvent:m_event value:++eventValue]; [commandBuffer encodeWaitForEvent:m_paceEvent value:++paceEventValue]; if(m_minDuration &gt; 0.f) [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration]; else [commandBuffer presentDrawable:drawable]; [commandBuffer commit]; &#125; @autoreleasepool &#123; id&lt;MTLCommandBuffer&gt; commandBuffer = [m_presentQueue commandBuffer]; id&lt;CAMetalDrawable&gt; drawable = [m_metalLayer nextDrawable]; CopyTexture(commandBuffer, drawable.texture, m_backBuffers[bufferIndex], @&quot;Copy Rendered&quot;); [commandBuffer encodeWaitForEvent:m_paceEvent2 value:++paceEventValue]; if(m_minDuration &gt; 0.f) [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration]; else [commandBuffer presentDrawable:drawable]; [commandBuffer commit]; &#125; bufferIndex = (bufferIndex + 1) % kNumBuffers; &#125;&#125;void PresentThread::Resize(uint32_t width, uint32_t height, MTLPixelFormat pixelFormat)&#123; if((m_width != width) || (m_height != height) || (m_pixelFormat != pixelFormat)) &#123; id&lt;MTLDevice&gt; device = m_metalLayer.device; if(m_pixelFormat != pixelFormat) &#123; id&lt;MTLLibrary&gt; lib = [device newDefaultLibrary]; MTLRenderPipelineDescriptor *pipelineDesc = [MTLRenderPipelineDescriptor new]; pipelineDesc.vertexFunction = [lib newFunctionWithName:@&quot;FSQ_VS_V4T2&quot;]; pipelineDesc.fragmentFunction = [lib newFunctionWithName:@&quot;FSQ_simpleCopy&quot;]; pipelineDesc.colorAttachments[0].pixelFormat = pixelFormat; m_copyPipeline = [device newRenderPipelineStateWithDescriptor:pipelineDesc error:nil]; m_pixelFormat = pixelFormat; &#125; DrainPendingPresents(); m_width = width; m_height = height; MTLTextureDescriptor *texDesc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat width:width height:height mipmapped:NO]; texDesc.storageMode = MTLStorageModePrivate; for(uint32_t i = 0; i &lt; kNumBuffers; i++) &#123; texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageShaderWrite|MTLTextureUsageRenderTarget; m_backBuffers[i] = [device newTextureWithDescriptor:texDesc]; texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget; m_interpolationOutputs[i] = [device newTextureWithDescriptor:texDesc]; &#125; texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget; m_interpolationInputs[0] = [device newTextureWithDescriptor:texDesc]; m_interpolationInputs[1] = [device newTextureWithDescriptor:texDesc]; &#125;&#125;; 正确的帧节奏表现为平坦的线或规律的重复模式，具体取决于目标刷新率。 使用 Metal 4 追踪光线光线追踪技术在高端渲染场景中越来越普及，Metal 4 提供了多项新功能来简化光线追踪的实现和优化。 交集函数缓冲区交集函数缓冲区是一个包含指向场景交集函数句柄的参数缓冲区，允许开发者轻松管理多个交集函数。通过在实例和几何级别设置交集函数表偏移，可以灵活地定义每个几何体的交集行为。 123456789// 在主机端几何描述符上设置交集函数表偏移NSMutableArray&lt;MTLAccelerationStructureGeometryDescriptor *&gt; *geomDescs ...;for (auto g = 0; g &lt; geomList.size(); ++g)&#123; MTLAccelerationStructureGeometryDescriptor *descriptor = ...; descriptor.intersectionFunctionTableOffset = g; ... [geomDescs addObject:descriptor];&#125; 加速结构构建优化Metal 4 提供了更多控制加速结构构建的选项，包括快速交集和最小化内存使用。这些选项可以通过标志按需设置，以满足不同场景的需求。 12345678// 光线追踪交集函数缓冲区intersection_function_buffer_arguments ifb_arguments;ifb_arguments.intersection_function_buffer = raytracingResources.ifbBuffer;ifb_arguments.intersection_function_buffer_size = raytracingResources.ifbBufferSize;ifb_arguments.intersection_function_stride = raytracingResources.ifbBufferStride;metal::raytracing::ray r = &#123; origin, direction &#125;;auto result = trace.intersect(r, ads, ifb_arguments); 在放大时去噪实时光线追踪的应用范围不断扩大，从混合光线追踪到复杂的路径追踪都得到了广泛应用。然而，光线追踪的性能和质量权衡始终是一个挑战。MetalFX 去噪放大器结合了去噪和放大功能，能够显著简化渲染管线的实现。 去噪放大器集成去噪放大器的集成非常简单，只需在典型的时间放大器基础上添加额外的输入纹理，包括法线、漫反射反照率、粗糙度和镜面反照率。 12345// 设置去噪放大器的输入纹理denoisingUpscaler.normalTexture = normalTexture;denoisingUpscaler.albedoTexture = albedoTexture;denoisingUpscaler.roughnessTexture = roughnessTexture;denoisingUpscaler.specularTexture = specularTexture; 提高质量的技巧去噪放大器的效果可以通过一些可选输入进一步提升，例如镜面命中距离、去噪强度掩码和透明度叠加。同时，需要注意避免输入过于嘈杂的问题，建议采用先进的采样技术，如重要性采样和下一次事件估计。 下一步Metal 4 和 MetalFX 的新功能为开发者提供了强大的工具，用以优化游戏性能和提升视觉效果。无论是通过帧插值实现更高的刷新率，还是通过去噪放大器减少光线预算，这些技术都能显著改善玩家的体验。如果你尚未开始使用 MetalFX 放大器，这是一个值得尝试的机会。 相关视频探索 Metal 4探索 Metal 4 游戏用于打造沉浸式 App 的 Metal 渲染的新功能Metal 光线追踪指南利用 MetalFX Upscaling 提升性能","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"Platforms State of the Union","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_102/","text":"深入了解 apple 平台上的最新进展。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 2025年Apple平台发展现状：Liquid Glass设计与智能体验革新Apple在2025年WWDC大会上公布了平台发展现状，全面展示了硬件、软件和技术生态的最新进展，为开发者提供了丰富的工具和API来打造更卓越的应用体验。 Apple芯片的强劲动力Apple芯片为所有平台带来了突破性的性能表现，具备以下关键特性： 前所未有的性能与能效平衡 统一内存架构最大化硬件潜力 专用加速器优化视频处理与机器学习任务 安全隔离区确保系统完整性 软件技术生态这些强大的硬件基础支撑着Apple的软件技术栈： Metal：底层API套件释放硬件全部潜能 Apple智能：整合生成式模型与隐私保护功能 Swift：提供系统级性能与安全性 SwiftUI：助力构建丰富交互和自适应设计 平台还深度整合了： 隐私保护技术 无障碍功能 国际化支持 全新的Liquid Glass设计今年Apple推出了标志性的设计革新——Liquid Glass，开启了软件设计新纪元。这一设计理念融合了玻璃的光学特性与流体的灵动质感，将UI体验提升到新高度。 设计三大目标 优化核心内容体验：创造沉浸式的阅读、创作和观看体验 统一设计语言：保持跨平台一致性同时保留产品个性 创新交互设计：利用硬件技术进步打造新颖交互 三大指导原则 层次感建立 控件和导航悬浮于应用上方 矩形元素适配设备圆角 内容可延伸至屏幕边缘 颜色智能调整 协调感营造 优化UI元素适应现代设备 新圆角符合手指几何形状 全面更新字体排版 组件形状更柔和 一致性保持 跨平台统一设计语言 macOS与iOS/iPadOS更协调 watchOS突出内容显示 实现路径开发者可通过三个步骤实现Liquid Glass设计： 用新版SDK重新编译应用 使用新API优化初始效果 运用Liquid Glass效果更新自定义视图 常见视图会自动获得新设计： TabView呈现Liquid Glass标签栏 NavigationSplitView显示Liquid Glass边栏 工具栏项置于玻璃体中 菜单和弹出窗口自动变形 新增API提供更多控制选项： 工具栏项目分组和风格调整 ToolbarSpacer创建额外分组 为关键操作设置醒目风格 TabView底部自定义配件 搜索功能全面革新 应用图标革新Liquid Glass也为应用图标带来全新表现力： 经典全色模式 更丰富的着色模式 全新透明模式 Icon Composer新工具简化图标创作流程，支持： 矢量内容导入 多种渲染模式 模糊和透明度效果 高光效果测试 单一源文件生成 Apple智能体验Apple将AI和机器学习能力深度整合到所有平台中，提供： 写作工具 智绘表情 图乐园 Foundation Models框架这一新框架让每个应用都能使用设备端基础模型，特点包括： 隐私保护(数据永不离开设备) 离线可用 无需账户或API密钥 仅需三行代码即可使用：123import FoundationModelslet session = LLMSession()let response = try await session.respond(to: &quot;提示文本&quot;) 引导式生成功能让模型输出结构化数据，简化应用集成流程。 机器学习增强所有机器学习API和工具都得到增强： 语音API更新 Core ML优化性能 MLX开源库训练模型 App Intents提升功能可见性 开发者工具革新Xcode 26亮点 预测代码补全增强 整合ChatGPT(与OpenAI合作) 编码助理快速实现功能 历史记录滑块回溯更改 性能工具定位瓶颈 Swift 6.2新功能 内联数组提升性能 span类型安全访问内存 增强C++互操作性 WebAssembly支持 简化单线程代码编写 Containerization新框架简化服务器开发： 本地创建和运行Linux容器 基于Apple芯片优化 开源提供 框架增强SwiftUI增强 全新Web API 富文本编辑器支持 3D图表 性能大幅提升 更灵活的SwiftData visionOS 26新功能 视体API 共享体验增强 沉浸式媒体工具 企业功能 SwiftUI空间布局改进 游戏开发更新 Metal 4支持神经网络渲染 游戏移植工具包增强 输入系统升级 GameSave云存档 低功耗模式优化 其他重要更新 iPad菜单栏支持 后台任务API增强 CarPlay实时活动 终端新外观 HTML 3D模型元素 企业visionOS功能 值得注意的是，macOS Tahoe将是最后一个支持Intel的版本，Apple鼓励开发者完成向Apple芯片的迁移。 Apple准备了100多场深度讲座，开发者可通过实验室和开发者论坛获取更多信息。这些全面的平台革新为开发者提供了前所未有的机遇，期待看到开发社区创造出更多创新应用。 相关视频： WWDC 2025 Keynote Introducing Liquid Glass Design Foundation Models Framework 文档： Liquid Glass Design Guidelines Foundation Models API Reference","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"了解 ManagedApp 框架","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_203/","text":"了解 managedapp 框架如何帮助你的 app 适应受管理环境。我们将介绍如何接收配置数据、如何安全地管理 app 密钥，以及如何根据组织提供的设置来定制 app 的行为。我们还将通过一些真实示例来说明如何为企业和教育环境打造更灵活、更易于管理的 app。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com ManagedApp框架：打造无缝的企业级应用体验引言在当今企业IT环境中，Apple设备的普及率持续攀升，从办公室到教室，从零售店到创意工作室，这些设备正成为生产力工具的重要组成部分。然而，企业级应用的管理和部署过程往往充满挑战——复杂的初始配置、安全凭证分发、组织定制化需求等因素都可能导致用户体验下降。为应对这些挑战，Apple推出了ManagedApp框架，旨在为企业与教育机构提供更安全、更易用的应用管理解决方案。 ManagedApp框架概述框架定位与优势ManagedApp框架是一个专为受管理环境设计的自动化配置系统，它允许管理员预先配置应用及其扩展，无需用户手动设置即可直接使用。该框架的核心价值在于： 消除复杂设置流程：应用从首次启动即可直接使用，提升用户采纳率 降低支持成本：减少因配置错误导致的技术支持请求 安全分发凭证：保护组织敏感数据免受泄露风险 灵活定制：允许开发者定义自己的配置规范 技术基础与兼容性该框架要求iOS 18.4、iPadOS 18.4和VisionOS 2.4及以上版本，并需要MDM服务器使用声明式设备管理来管理应用。它支持： 所有MDM注册类型 绝大多数应用扩展类型 从应用安装或接管时开始工作 运行时配置更新通知 核心功能解析数据类型支持ManagedApp框架提供四类关键数据： 应用特定配置：开发者自定义的任意数据结构（设置、选项、小型资源文件） 密码：安全存储的字符串凭证 证书：用于安全通信的加密材料 身份凭证：包括PKCS #12文件、SCEP身份或ACME身份（支持硬件绑定密钥） 系统架构与流程系统工作流程分为三个主要阶段：1231. 管理员通过MDM服务器发送管理命令和配置数据2. 设备安全存储配置和机密数据3. 应用启动时请求数据并立即应用配置 当配置更新时，框架会主动通知正在运行的应用，确保变更及时生效。 典型应用场景许可管理优化传统许可令牌方案存在安全风险，ManagedApp框架提供了更安全的解决方案： 123// 使用硬件绑定密钥替代传统令牌let provider = ManagedAppIdentitiesProvider()let identity = try await provider.identity(for: &quot;license_auth&quot;) 优势对比： 传统令牌：存储在文件系统，可能被提取 框架方案：私钥设备生成永不移动，支持硬件绑定 VPN扩展安全框架为VPN扩展提供了企业级安全认证能力： 123// 获取VPN专用身份凭证let vpnIdentity = try await ManagedAppIdentitiesProvider() .identity(for: &quot;org_vpn_auth&quot;) 该方案支持硬件绑定密钥和受管理设备证明，解决了VPN管理员最关心的认证安全问题。 身份提供商集成与可扩展单点登录(SSO)结合时，框架支持多种认证材料： 硬件绑定身份 临时密码 组织绑定令牌 注册期间可用配置 实现指南配置接收与处理以教学用Landmarks应用为例，展示配置处理流程： 1234567891011121314151617struct LandmarksManagedConfig: Decodable &#123; let managedCollection: String? let assetURL: URL? enum CodingKeys: String, CodingKey &#123; case managedCollection = &quot;managed_collection&quot; case assetURL = &quot;asset_url&quot; &#125;&#125;Task &#123; for await config in ManagedAppConfigurationProvider().configurations( of: LandmarksManagedConfig.self ) &#123; modelData.managedCollection = config?.managedCollection &#125;&#125; 关键实现要点： 定义符合Decodable的配置结构体 使用Swift并发接收异步配置更新 自动响应配置变更 身份凭证使用实现mTLS连接时的身份获取： 12345678let identityProvider = ManagedAppIdentitiesProvider()guard let identity = try await identityProvider.identity(for: &quot;asset_server_auth&quot;) else &#123; // 处理无凭证情况 return&#125;// 使用SecIdentity建立安全连接let credential = URLCredential(identity: identity, certificates: nil, persistence: .forSession) 最佳实践开发建议 数据规模控制：配置数据保持KB级，大资源通过URL引用 安全编程：机密数据用后即弃，每次重新获取 配置设计：避免”万能开关”，提供细致控制项 兼容性考虑：解码器应忽略未知键，支持渐进升级 迁移与审核对于使用旧版managed app configuration的应用： 过渡期可双方案并行 优先采用ManagedApp框架 逐步淘汰旧实现 App Store审核注意事项： 提供演示模式或功能视频 在审核备注中说明管理配置方法 确保核心功能可被验证 结论ManagedApp框架代表了企业应用管理的重要进化，它赋予开发者构建”零配置”体验的能力，同时满足组织级安全要求。通过灵活的配置机制和安全的凭证分发，该框架有望显著提升管理效率和使用体验。开发者应评估现有企业应用的配置方案，考虑迁移到ManagedApp框架以获取其安全与管理优势。 随着企业移动生态的持续发展，ManagedApp框架将帮助开发者创造更无缝、更安全的管理应用体验，最终实现用户满意度和IT管理效率的双赢。 相关视频Apple 设备管理和身份管理方面的新动向 文档资源Apple School Manager用户指南ManagedApp框架文档Apple平台部署支持","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"商务-&-教育","slug":"商务-教育","permalink":"http://djs66256.github.io/tags/%E5%95%86%E5%8A%A1-%E6%95%99%E8%82%B2/"}]},{"title":"Platforms State of the Union (ASL)","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_112/","text":"深入了解 apple 平台上的最新进展。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 2025 年度苹果平台国情咨文：开发者全新机遇解析苹果在2025年度平台国情咨文中展示了一系列令人振奋的新技术、API和工具更新，为开发者提供了打造更卓越应用和游戏的全新可能性。本文将全面解析这些创新功能及其应用场景。 革命性的液态玻璃设计语言苹果今年推出了全方位的设计革新，液态玻璃(Glassmorphism)成为这一代UI设计的核心特征。这种设计语言巧妙结合了玻璃光学特性和流体质感，通过镜面高光、折射和半透明效果，创造出前所未有的深度感和活力体验。 液态玻璃设计遵循三大原则： 层次感构建：控件和导航栈悬浮显示，增加深度维度 协调感营造：元素形状与设备外形协调，提升一致性 跨平台一致性：确保用户在各个苹果设备上获得统一体验 在具体实现上，开发者可以通过以下步骤轻松适配新设计：123456// 使用glassEffect修饰符实现液态玻璃效果Button(action: &#123;&#125;) &#123; Text(&quot;液态玻璃按钮&quot;)&#125;.buttonStyle(.glass).glassEffect() Apple Intelligence与设备端AI能力苹果将生成式AI深度集成于操作系统中，推出了全新的Foundation Models框架。该框架让开发者能够轻松调用苹果优化的设备端基础模型，只需三行代码即可实现AI功能： 123let model = FoundationModels.shared.textGeneratorlet prompt = &quot;写一篇关于苹果新技术的简短介绍&quot;let result = try await model.generateText(with: prompt) 这项技术的亮点在于： 完全设备端运行，确保用户隐私 无需API密钥或服务器配置 提供引导式生成功能，自动解析模型输出 支持工具调用，模型能识别需要额外信息的任务 Xcode 26与开发工具革新Xcode 26引入了一系列提升开发效率的新功能： 预测代码补全改进 ChatGPT集成，可直接在IDE中使用OpenAI模型 Coding Tools功能，可生成预览、文档或修复问题 Playground宏帮助探索非UI代码 历史记录滑块实现更改回溯 演示代码展示了AI辅助开发的强大能力：123456789101112131415161718// AI生成的统计视图代码struct StatisticsView: View &#123; @ObservedObject var model: DataModel var body: some View &#123; VStack &#123; Text(&quot;访问统计&quot;) .font(.title) Chart(model.visits) &#123; visit in BarMark( x: .value(&quot;日期&quot;, visit.date), y: .value(&quot;访问量&quot;, visit.count) ) &#125; &#125; .padding() &#125;&#125; Swift 6.2与性能提升Swift语言迎来6.2版本，主要改进包括： 内联数组和span类型，提升数据处理效率 增强的C++互操作性 WebAssembly官方工具链支持 并发模型改进，简化单线程代码编写 全新Containerization框架，简化服务器端开发 SwiftUI与visionOS增强功能SwiftUI获得多项重大升级： 强大的新Web API 富文本编辑支持 3D图表功能 列表加载速度提升6倍(macOS) 增量更改速度最高提升16倍 visionOS 26的新特性包括： 新的视图API和共享功能 沉浸式媒体工具 企业功能支持 附近窗口共享功能 ARKit共享现实场景锚点 Metal 4与游戏开发游戏开发者将受益于Metal 4的先进功能： 神经网络渲染支持 游戏移植工具包增强 PlayStation DualSense控制器支持 新的Touch Controller API GameSave框架云存档功能 特别值得注意的是，macOS Tahoe将是最后一个支持Intel Mac的版本，苹果强烈建议开发者尽快迁移到Apple芯片版本。 其他重要更新平台国情咨文还提到了多项值得关注的改进： iPad菜单栏支持 iOS/iPadOS后台任务API增强 CarPlay实时活动功能 macOS终端新外观 HTML模型元素支持 视线滚动(Look to Scroll)功能 全新PermissionKit框架 App Store辅助功能展示区 开发者资源与展望苹果为这些新技术准备了100多场深度讲座，开发者可以通过实验室和开发者论坛获取更多支持。从液态玻璃设计到设备端AI，从Swift语言进化到Metal图形技术，2025年的苹果平台为开发者提供了前所未有的创新工具和可能性。 相关视频： 液态玻璃设计实践 Foundation Models框架详解 Swift 6.2新特性 文档： 液态玻璃设计指南 Foundation Models API参考 Metal 4编程指南","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"深入探索 MapKit","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_204/","text":"了解 mapkit 和 mapkit js 的最新更新。我们将介绍一种新的路线类型——骑行路线，并向你展示如何在网页上启用 3d 环视图像。了解新的 geocoding api 如何支持坐标与地址之间的转换，以及如何使用 address representations api 来获取某一区域最恰当的地址。最后，我们将介绍一种新的地点引用方式，确保你的 app 能与 app intents 无缝协作。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com MapKit 与 MapKit JS 最新功能解析在 WWDC 2024 上，Apple 为开发者带来了 MapKit 和 MapKit JS 的一系列重要更新。本文将详细介绍这些新功能，包括新的骑行路线、3D 环视图像支持、改进的地理编码 API 以及全新的地点引用方式。 新功能概览本次更新主要包含以下内容： PlaceDescriptor：一种新型的地点查找和引用方式 地理编码改进：将 CLGeocoder 功能迁移至 MapKit 框架 地址表示优化：通过 Address Representations API 获取最适合显示的地址格式 骑行路线支持：为地图应用新增骑行路线规划功能 环视 API 增强：在网页中支持 3D 环视图像展示 PlaceDescriptor：灵活的地点引用方式PlaceDescriptor 是一种结构化地点描述方式，它包含三个核心组成部分： commonName：地点的通用名称（如”埃菲尔铁塔”） representations：通用地理信息表示（地址、坐标或设备位置） supportingRepresentations：可选的非通用信息（如服务标识符） 12345// 创建带有坐标和名称的 PlaceDescriptorlet descriptor = PlaceDescriptor( representations: [.coordinate(coordinates)], commonName: &quot;安娜利维娅喷泉&quot;) PlaceDescriptor 的优势在于： 无需依赖 MapKit 特定标识符 可与 App Intents 无缝配合 支持多种地理信息表示方式 适用于跨框架交互场景 地理编码与地址表示地理编码功能已从 CoreLocation 迁移至 MapKit，提供更一致的 API 体验： 123// 逆向地理编码示例let request = MKReverseGeocodingRequest(location: location)let mapItems = try await request.mapItems MapItem 提供两种地址访问方式： MKAddress：包含完整地址(fullAddress)和精简地址(shortAddress) MKAddressRepresentations：提供多种显示优化方案 正向地理编码同样简单： 123// 正向地理编码示例let request = MKGeocodingRequest(addressString: &quot;1 Ferry Building, San Francisco&quot;)let mapItem = try await request?.mapItems.first 路线与环视功能骑行路线支持MapKit 现在支持骑行路线规划： 1234// 获取骑行路线request.transportType = .cyclinglet directions = MKDirections(request: request)let response = try await directions.calculate() 环视功能扩展MapKit JS 现在支持两种环视视图： 123456// 创建交互式环视视图const lookAround = new mapkit.LookAround(containerElement, place, &#123; openDialog: true, showsDialogControl: true, showsCloseControl: true&#125;); 开发者可以通过事件监听器管理视图生命周期： 1234lookAround.addEventListener(&quot;close&quot;, event =&gt; &#123; app.closeView(); event.preventDefault();&#125;); 总结与展望本次 MapKit 更新带来了诸多实用功能： PlaceDescriptor 提供了更灵活的地点引用方式 地理编码功能迁移至 MapKit 框架 地址表示优化提升了用户体验 新增的骑行路线丰富了导航选择 MapKit JS 的环视功能扩展了网页地图能力 这些改进将使开发者能够创建更丰富、更灵活的地图应用。 相关视频使用 MapKit 充分优化位置相关功能认识 SwiftUI 版 MapKitMapKit 的新功能 文档Adopting unified Maps URLs","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"地图和位置","slug":"地图和位置","permalink":"http://djs66256.github.io/tags/%E5%9C%B0%E5%9B%BE%E5%92%8C%E4%BD%8D%E7%BD%AE/"}]},{"title":"探索 Metal 4","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_205/","text":"了解如何开始利用 metal 4 强大的新功能，让你的现有 metal app 更上一层楼。我们将介绍 metal 如何助你充分发挥 apple 芯片的优势，并以更高效的方式进行硬件编程。你还将了解如何借助 metal 4 的新功能，将机器学习整合到 metal 代码中。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Metal 4：Apple 芯片性能的全面释放Metal 是 Apple 平台上核心的低阶图形与计算 API，经过十余年的演进，Metal 4 为开发者带来了前所未有的性能优化与功能增强。本文将系统介绍 Metal 4 的关键技术创新点，帮助开发者理解如何将现有 Metal 应用升级至新高度。 革命性的指令编码模型Metal 4 对指令编码系统进行了重新设计，引入了全新的 MTL4CommandQueue 和 MTL4CommandBuffer 架构。与旧版本不同，Metal 4 将命令缓冲区与队列解耦，使应用能够并行编码命令缓冲区，显著提升多线程环境下的编码效率。 新的统一计算编码器整合了位块传输和加速结构命令编码功能，减少了编码器切换的开销。MTL4RenderCommandEncoder 则引入了附件映射功能，允许动态切换颜色附件，无需创建额外编码器。 12345// 创建 MTL4CommandQueuelet commandQueue = device.makeCommandQueue(type: .MTL4)// 创建 MTL4CommandBufferlet commandBuffer = commandQueue.makeCommandBuffer() 高效资源管理机制现代图形应用使用的资源数量呈爆炸式增长，Metal 4 提供了全新的资源管理方案： MTL4ArgumentTable：取代传统的固定资源绑定点，支持无绑定渲染模式，大幅减少CPU设置时间 Residency集：明确指定GPU需要访问的资源集合，优化内存使用 放置稀疏资源：允许动态控制资源的内存占用，支持更广泛的设备适配 《Control Ultimate Edition》的案例表明，合理使用Residency集可以显著降低内存管理开销和内存使用量。 着色器编译优化Metal 4 引入了 MTL4Compiler 接口，使着色器编译过程更可控： 编译器与设备分离，允许明确的编译时间控制 灵活渲染管线状态支持Metal IR重用，减少重复编译 编译器服务质量继承，确保关键着色器优先编译 12// 创建 MTL4Compilerlet compiler = device.makeCompiler() 机器学习无缝集成Metal 4 将机器学习能力深度整合到图形管线中： 张量支持：原生支持多维数据容器，简化机器学习数据结构处理 机器学习命令编码器：可直接执行CoreML转换的网络 Metal性能原语：提供优化的着色器原语，支持小型网络嵌入 这使得神经材质评估、升频等先进技术可以高效实现。 MetalFX 性能加速套件MetalFX 是Metal 4配套的高性能解决方案： 升频技术：允许渲染低分辨率图像并智能放大，节省GPU时间 帧插值：生成中间帧实现更高帧率 光线追踪降噪：改善光线追踪效果 升级路径与开发工具Metal 4 采用模块化设计，开发者可以分阶段升级： 先从着色器编译优化开始 逐步采用新的命令编码模型 最后集成先进的资源管理功能 Xcode 26 提供了新的Metal 4项目模板，Metal调试器和性能HUD等工具也全面支持Metal 4，为开发者提供完善的调试和优化支持。 相关资源开发者可以参考以下资源深入了解Metal 4： 相关视频： 实现 Metal 4 机器学习与图形应用程序的完美融合 探索 Metal 4 游戏 深入探索 Metal 4 游戏 文档： Understanding the Metal 4 core API Using the Metal 4 compilation API Metal 4 为Apple平台上的图形和计算应用开辟了新的可能性，开发者现在就可以开始在新项目或现有应用中采用这些先进功能。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"开始使用 Game Center","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_214/","text":"探索 game center 的功能并了解如何开始使用。我们将展示实现成就、挑战、排行榜和活动的最佳实践，助你最大限度地提高游戏的曝光度、吸引新玩家并提升用户参与度。 为了充分从这个讲座中获益，我们还建议你观看“通过 apple games app 吸引玩家”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 开始使用 Game Center：提升游戏曝光与玩家参与度前言Game Center 作为苹果生态系统中的重要组件，为游戏开发者提供了一套完整的社交和竞争功能解决方案。通过集成 Game Center 功能，开发者不仅能提升玩家参与度，还能显著增加游戏在苹果平台上的曝光机会。 Game Center 的核心价值Game Center 的核心功能包括成就系统、排行榜、挑战和活动。这些功能共同构建了一个完整的社交游戏生态系统： 成就系统：奖励玩家达成游戏里程碑，增加游戏成就感 排行榜：促进玩家间的竞争，提高游戏重玩价值 挑战功能：将单人游戏转化为社交体验 活动功能：提供深度链接，引导玩家进入特定游戏内容 特别值得注意的是，从今年秋季开始预装在苹果设备上的新 Games 应用，将进一步放大 Game Center 的曝光优势。游戏在”最常玩游戏”排行榜和”朋友正在玩”版块的展示，都将显著提升发现率。 技术集成指南项目初始配置集成 Game Center 只需两个关键步骤： 添加 Game Center 权限： 在 Xcode 中通过”Signing and Capabilities”标签添加”Game Center”能力 Unity 开发者可使用苹果提供的专用插件简化流程 初始化 GameKit 框架：通过简单的代码实现 Game Center 初始化： 123GKLocalPlayer.local.authenticateHandler = &#123; _, error in print(&quot;\\(GKLocalPlayer.local.alias) is ready to play!&quot;)&#125; Unity 版本的初始化同样简洁： 12var player = await GKLocalPlayer.Authenticate();Debug.Log($&quot;&#123;player.alias&#125; is ready to play!&quot;); 功能开发与测试Xcode 26 引入的 GameKit 包为开发者带来了显著便利： 本地测试能力：可直接在 Xcode 中测试成就、排行榜和活动 配置同步：与 App Store Connect 保持同步 版本控制友好：配置自动包含在代码审查和版本控制中 以”The Coast”游戏为例，添加”Capecod”排行榜的流程展示了 GameKit 包的高效性： 通过模板选择器创建 GameKit 包 从 App Store Connect 拉取现有游戏信息 添加新排行榜并配置相关参数 设置多语言本地化支持 创新功能详解挑战系统挑战功能基于现有排行榜，无需额外代码即可实现： 特点： 有时间限制的个性化竞赛 可自定义参与者和尝试次数 支持不同持续时间选项（1天、3天或1周） 实现方式：通过现有的 submitScore() API 自动支持挑战： 1234GKLeaderboard.submitScore(points, context: 0, player: GKLocalPlayer.local, leaderboardIDs: [&quot;thecoast.lb.capecod&quot;]) 最佳实践： 定期更新的排行榜可设为”不可重复”挑战 应在游戏关卡结束时提交分数 避免提交累计终身分数 活动功能活动功能提供了深度链接能力，可直接将玩家引导至特定游戏内容： 应用场景： 快速进入特定关卡 直接跳转到成就相关场景 精准定位游戏内活动 实现优势： 提升玩家参与效率 增加特定内容的访问量 与 Game Center 其他功能无缝集成 总结与展望Game Center 提供了一套完整的工具集，帮助开发者提升游戏社交性、竞争性和可发现性。通过合理配置成就、排行榜、挑战和活动功能，开发者可以： 显著提升游戏在 App Store 和新 Games 应用中的曝光率 增强玩家留存率和参与度 创造更具吸引力的社交游戏体验 随着苹果游戏生态的持续发展，Game Center 的功能和价值将进一步提升。开发者应充分利用这些工具，创造更具吸引力的游戏体验。 相关视频通过 Apple Games App 吸引玩家 文档Game Center 开发者文档App Store Connect API 文档","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"让游戏更上一层楼","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_209/","text":"了解如何让你的游戏在统一游戏平台上大放异彩。我们将介绍一些可用于让你的游戏更上一层楼并进一步提升玩家体验的技术。简要了解构建、调试和分析游戏所必需的基本工具。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 让游戏更上一层楼：WWDC 2025游戏技术全面解析在WWDC 2025中，苹果展示了如何通过统一游戏平台和最新技术提升游戏品质与玩家体验。本文将详细解读演讲中介绍的关键技术，帮助开发者充分利用苹果生态系统打造卓越游戏。 系统体验优化游戏模式是提升游戏性能的核心功能。该模式通过优化系统行为为游戏分配更多资源，减少后台活动，使游戏获得更多CPU时间处理复杂任务。同时，它改善了蓝牙延迟，使输入设备和耳机响应更迅捷。 在macOS和iOS上，当玩家全屏启动游戏时即会启用游戏模式。开发者只需在info.plist中添加LSSupportsGameMode键并设为true即可启用。持续执行模式则进一步将性能限制在稳定状态，确保玩家获得稳定体验。 苹果还为开发者提供了低电量模式API，包括static let NSProcessInfoPowerStateDidChange: NSNotification.Name和var isLowPowerModeEnabled: Bool &#123; get &#125;，帮助游戏适应不同电源状态。 增强玩家互动体验Game Center作为苹果的社交游戏网络，连接玩家与好友，提供成就、排行榜、挑战和活动等功能。新版Game Center配置完全集成至Xcode，支持创建成就、设置本地化、配置挑战等操作。 全新的Apple Games应用为玩家提供了一站式游戏中心，预装在Mac、iPad和iPhone上，深度集成于操作系统各处，包括小组件、通知和App Store。 关键技术实现快速开玩技术Managed Background Assets框架允许开发者将游戏内容分成两部分：玩家只需下载教程关卡必需的小部分内容，其余内容在后台下载。新版API改进并简化了工作流，提供高达200GB的苹果托管容量。 跨设备云存档GameSave框架基于iCloud构建，注重用户隐私和数据安全，自动同步同一iCloud账户下的设备数据。开发者可以通过以下步骤启用： 在Xcode的”Signing &amp; Capabilities”工具中添加iCloud权限 勾选iCloud Documents选项并添加iCloud容器权限 登录开发者账户将该权限包含在配置文件中 基础实现代码示例展示了如何用容器标识符开始iCloud同步，在后台同步期间调用finishSyncing完成处理程序。 输入方式支持Game Controller框架支持键盘、鼠标和游戏控制器等外设输入。新的Touch Controls框架为现有游戏添加触控支持提供了简单方案，直接与Metal集成以确保最佳性能。 图形性能突破Metal 4 API显著提升了图形表现，减少了图形命令编码的CPU开销，并允许在渲染管线中使用机器学习。MetalFX超采样支持空间和时间两种方式，结合帧插值可进一步提升帧率。 Metal 4还提供了全面的分析调试工具： 运行时API和着色器验证工具 Metal性能HUD实时显示多种性能指标 Xcode中的Metal调试器展示GPU工作详细分析数据 Instruments中的Metal系统追踪洞察CPU和GPU使用情况 游戏移植工具包3加入了Metal 4支持，Metal-cpp具备完整的Metal 4特性支持，Metal Shader Converter可将HLSL着色器转换为Metal。 总结与资源通过整合系统性能功能、社交功能以及最新游戏技术，开发者可以在苹果平台上打造具有稳定帧率、丰富社交体验和出色图形的游戏。 相关视频: 开始使用 Game Center 探索 Apple 托管的 Background Assets 探索 Metal 4 深入探索 Metal 4 游戏 文档: Human Interface Guidelines: Designing for games","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"针对 CarPlay 车载优化你的 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_216/","text":"了解如何将实时活动和小组件引入 carplay 车载和 carplay 车载 ultra，以便用户查看活动进度并一目了然地掌握相关信息。探索所有 carplay 车载 app 均可使用的新增模板选项，并了解导航类 app 如何提供逐向导航元数据，以便显示在车载仪表盘或 hud 上。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为 CarPlay 车载优化你的应用：iOS 26 新功能详解随着 iOS 26 的发布，苹果为 CarPlay 车载系统带来了一系列创新功能，使开发者能够为用户提供更加安全、便捷的车载体验。本文将详细介绍这些新功能及其实现方式。 核心功能概述iOS 26 为 CarPlay 引入了三大关键改进： 小组件支持 - 让驾驶者快速获取关键信息 实时活动 - 显示重要进度和状态更新 导航元数据 - 在仪表盘和HUD上显示转向信息 这些功能不仅适用于专门开发的CarPlay应用，也支持仅提供小组件或实时活动的iPhone应用。 小组件集成CarPlay现在支持显示iPhone应用的小组件，即使该应用没有专门的CarPlay版本。驾驶者可以在CarPlay仪表盘左侧查看这些小组件。 技术实现要点开发者为CarPlay添加小组件支持非常简单，只需满足以下条件： 支持systemSmall小组件家族 遵循CarPlay特定的设计规范 对于不适合CarPlay的小组件（如游戏类或需要复杂交互的），可以使用disfavoredLocations修饰符将其标记为”非优选”： 12WidgetConfiguration() .disfavoredLocations([.carPlay], for: [.systemSmall]) 设计最佳实践 内容简洁直观 - 避免高密度文本和与驾驶无关的信息 自动适应布局 - widgetContentMargins会根据CarPlay需求自动调整 使用系统字体和颜色 - 确保文本可读性 可选背景移除 - 通过containerBackgroundRemovable修饰符实现 实时活动支持iOS 26将iPhone的实时活动功能扩展到了CarPlay。当iPhone上开启支持的实时活动时，它会自动出现在CarPlay仪表盘。 技术规格 显示尺寸 - CarPlay使用activity family small尺寸类 交互限制 - CarPlay中的实时活动不支持交互 通知机制 - 当仪表盘不可见时，会在屏幕底部显示通知提醒 实现建议 只传达关键状态信息 优先实现activity family small尺寸 无需考虑交互功能 开发者可以使用macOS的CarPlay模拟器应用进行测试，无需实际车辆。 CarPlay框架增强CarPlay框架为各类车载应用提供了优化的UI模板。iOS 26带来了多项改进： 列表模板升级 CPListImageRowItem新增自定义选项 支持禁用单个行元素 允许多行显示 引入pinned元素API用于显示重要元素 123456var headerGridButtons: [CPGridButton]?class CPGridButtoninit(titleVariants: [String], image: UIImage, handler: ((CPGridButton) -&gt; Void)?) 音频应用新功能体育赛事音频应用现在可以使用专门的”正在播放”模板变体： 12345678910111213141516let clock = CPNowPlayingSportsClock(elapsedTime: time, paused: false)let status = CPNowPlayingSportsEventStatus( eventStatusText: [&quot;1st&quot;], eventStatusImage: UIImage(named: &quot;Semifinals&quot;), eventClock: clock)let sports = CPNowPlayingModeSports( leftTeam: getLeftTeam(), rightTeam: getRightTeam(), eventStatus: status, backgroundArtwork: getBackgroundArtwork())CPNowPlayingTemplate.sharedTemplate.nowPlayingMode = sports 导航应用改进 按钮自动获得Liquid Glass外观 支持多点触控交互 仪表盘地图显示 转向导航元数据支持 转向导航元数据允许在车辆仪表盘或HUD上显示导航信息： 123456789func mapTemplateShouldProvideNavigationMetadata(_ mapTemplate: CPMapTemplate) -&gt; Bool &#123; true&#125;cpNavigationSession.add(maneuvers)cpNavigationSession.add(laneGuidance)cpNavigationSession.pauseTrip(for: .rerouting, description: &quot;重新规划路线&quot;)cpNavigationSession.resumeTrip(updatedRouteInformation: cpRouteInformation) 性能优化建议 观察设备温度级别，适当降低渲染细节 利用CADisplayLink的自动帧率调整 主屏幕和仪表盘地图可采用不同显示模式 预先提供转向信息优化性能 总结iOS 26为CarPlay带来了显著的增强，使开发者能够创建更丰富、更智能的车载体验。通过小组件、实时活动和导航元数据等新功能，应用可以在不分散驾驶注意力的情况下，提供更多有价值的信息和服务。 开发者应充分利用这些新功能，同时遵循苹果的设计规范和性能建议，确保为用户提供安全、流畅的车载体验。 相关视频小组件的新功能通过 Instruments 优化 CPU 性能了解新一代 CarPlay 车载架构了解新一代 CarPlay 车载设计系统利用 CarPlay 车载让您的 App 一日千里 文档Adding StandBy and CarPlay support to your widget","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"通过 Apple Games App 吸引玩家","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_215/","text":"认识一下 games app，这是一个全新的一站式平台，供玩家了解所玩游戏的最新动态、发现新游戏并与朋友一起玩。了解如何在 games app 中设置游戏以提升曝光度，如何整合 game center 以打造社交游戏，以及如何通过“app 内活动”来吸引玩家再次参与游戏。 为了充分从这个讲座中获益，我们还建议观看“开始使用 game center”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 通过 Apple Games App 吸引玩家：开发者指南Apple 在 WWDC 上隆重推出全新的 Games app，为游戏开发者提供了一个前所未有的平台来展示游戏、吸引玩家并维持用户参与度。本文将详细介绍如何充分利用这一全新平台的功能。 Games App 概览Games app 是 Apple 生态系统中的全新一体化游戏中心，预装于 iPhone、iPad 和 Mac 设备上。这一应用深度集成于操作系统，会出现在小组件、通知和 App Store 中，将成为玩家每日娱乐的枢纽。 Games app 包含四个主要标签页： 首页：展示游戏中正在进行的活动、好友游戏动态、Game Center 好友动态和精选游戏合集 一起玩：查看好友游戏动态、比较分数记录、发起挑战 游戏库：管理已安装游戏和重新下载已购游戏 搜索：发现新游戏的起点 游戏信息设置要使游戏出现在 Games app 中，开发者需要确保： 将游戏的主类别或次类别设为”游戏” 在 App Store Connect 中完善游戏信息，包括： 名称和副标题 高质量图标（应用会自动生成背景） 年龄分级和子类别（如动作类） 支持手柄操作的需在 Xcode 添加 Game Controller 能力 示例代码（Swift）： let controllerCapability = GKControllerCapability()controllerCapability.isSupported = true 上传吸引人的预览视频和截图 设置精准搜索关键词 考虑使用预购功能为未发布游戏造势 Game Center 功能整合Game Center 是一套强大的工具，能够显著提升玩家参与度和游戏曝光度。主要功能包括： 成就系统 追踪游戏进度 鼓励玩家探索全部内容 所有成就均可本地化 排行榜 今年新增描述字段 支持循环排行榜（显示重置倒计时） 可使用分数后缀（如”pts”） 挑战赛 将单人游戏转化为社交体验 支持设置尝试次数和持续时间 可在游戏中内置邀请流程 活动功能 定义游戏目的地并使用深度链接直达 特别适合多人游戏体验 支持生成跨平台分享的派对代码 保持玩家参与度的策略长期维持玩家热情的关键在于： App 内活动：突出限时内容、季节活动或特别促销 会出现在首页、游戏库、搜索结果和游戏页面 支持设置优先级和预定时间 可使用深度链接直达游戏内活动 定期更新内容：策划新活动和挑战来保持游戏新鲜感 高质量视觉素材：上传循环展示的视频和高清艺术图 开发者后续步骤已有游戏的开发者应： 检查 Games app 中的展示信息 确保启用 Game Center 并整合未添加的功能 策划新活动来增添游戏活力 考虑设置季节性内容和限时挑战 新的 Games app 为开发者提供了前所未有的机会来展示游戏、吸引新玩家并维持现有玩家的参与度。通过合理利用 Game Center 功能和 app 内活动，开发者可以显著提升游戏的可见性和玩家留存率。 相关视频开始使用 Game Center让游戏更上一层楼App Store 预定的新功能利用虚拟和物理游戏手柄认识 App Store 上的 app 内活动 文档为游戏创建活动从排行榜创建引人入胜的挑战人机界面指南：Game Center","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"针对辅助功能标签评估你的 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_224/","text":"在你的 app store 产品页面上使用辅助功能标签，以突出展示你的 app 支持的辅助功能。你将了解如何评估 app 的辅助功能 (如“旁白”、“更大字体”、“字幕”等)，并选择准确且描述性的辅助功能标签。你还将了解如何在整个设计阶段解决辅助功能问题。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为你的应用评估辅助功能标签：全面指南在当今数字时代，应用的可访问性已成为衡量产品质量的重要标准。Apple推出的辅助功能营养标签为开发者提供了展示应用包容性设计的绝佳机会，同时也帮助用户快速了解应用是否满足他们的特殊需求。 辅助功能营养标签的重要性辅助功能营养标签在App Store产品页面上清晰展示应用支持的辅助功能，如”旁白”、”更大字体”、”字幕”等。这些标签不仅为用户提供了关键信息，也体现了开发者对包容性设计的重视。 要准确评估应用的辅助功能支持情况，开发者首先需要明确应用的”常规任务”。这些任务包括用户下载应用的主要功能以及基础操作流程，如首次启动体验、登录、购买和设置等。只有确保用户能够无障碍地完成所有这些常规任务，才能标注应用对某项辅助功能的支持。 评估应用的无障碍性评估过程应遵循几个核心原则： 视觉设计优化：确保颜色对比度达标，支持深色模式，并避免仅通过颜色传递重要信息。Landmarks应用的案例表明，即使特意使用了高对比配色，仍可能发现某些颜色未达到最低对比标准，需要进行调整。 文本可读性：应用至少应支持文本放大到默认大小的200%。使用Dynamic Type是实现这一目标的最佳方式。开发者需注意文本截断和对齐问题，确保信息获取无障碍。 动效控制：为对动效敏感的用户提供支持，避免可能引起眩晕或恶心的动画效果。如果应用没有已知触发因素，可以标注支持”减弱动效”。 辅助技术集成： 语音控制：确保所有可触摸元素都有适当的可访问性元数据 旁白支持：让用户无需看屏幕就能操作界面，准确描述元素并提供流畅的导航体验 123456// 示例：为按钮添加可访问性标签Button &#123;&#125; label: &#123; Image(systemName: &quot;square.arrow.up&quot;)&#125;.accessibilityLabel(&quot;分享&quot;) 媒体内容无障碍性对于包含视频或音频内容的应用，需要提供： 字幕：为听障用户提供对话和声音的文字描述 音频描述：在媒体主音频的间隙描述视觉内容 如果应用不包含这类媒体内容，则无需标注相关支持。 实施与标注完成评估后，开发者可以在App Store Connect中为产品页面添加辅助功能营养标签，并链接到网站提供更多无障碍详情。Landmarks应用经过评估后，确认支持了足够对比度、深色界面、不依赖颜色区分、减弱动效、语音控制和旁白等功能。 值得注意的是，与需要辅助功能的用户直接合作是了解应用可访问性的最有效方法之一。”没有我们的参与，就不要做关于我们的决定”这一残障社区的理念强调了用户参与测试的重要性。 结语通过在设计中考虑无障碍性，使用辅助功能进行评估，并在产品页面上准确标注支持的功能，开发者可以创建更具包容性的应用。这不仅扩大了潜在用户群，也体现了对多元用户需求的尊重和关怀。 相关视频动态字体体验入门 文档Accessibility Human Interface Guidelines: Accessibility Overview of Accessibility Nutrition Labels","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"完成后台任务","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_227/","text":"探索后台任务执行方面的最新进展，并了解系统如何进行运行时调度。我们将讨论如何充分利用后台运行时，让你的 app 既能在后台提供功能，又能保持出色的前台体验。我们还将介绍各种 api 如何为你的 app 提供后台运行时环境，以及每个 api 是怎样针对不同用例量身定制的 — 其中包括 ios 和 ipados 26 中的新 api，这些 api 让你的 app 能够在从前台过渡到后台时顺利完成任务。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 后台任务处理：iOS与iPadOS 26的后台运行时优化引言在现代移动操作系统中，后台任务处理一直是开发者面临的重要挑战。iOS系统以其严格的资源管理和卓越的电池优化著称，同时也为开发者提供了多种API来实现高效且用户友好的后台功能。WWDC演讲深入探讨了iOS和iPadOS 26中后台任务处理的最新进展，特别是新引入的BGContinuedProcessingTask API，为开发者提供了更灵活的后台任务管理工具。 前台与后台的运行机制当应用在前台运行时，它拥有最高优先级，可以完全访问系统资源，包括CPU、内存和网络等。此时的应用界面是设备的焦点，用户可以享受开发者精心打造的交互体验。 但当用户离开应用时，该应用便进入后台状态。默认情况下，后台应用会被系统挂起，不再占用CPU资源。这种设计有效地保护了电池寿命，维护了用户隐私，并为前台应用释放了宝贵的系统资源。然而，在某些情况下，应用可以请求后台执行时间来完成关键任务。 后台任务的行为约束iOS系统对后台任务执行设定了明确的约束和原则： 能耗管理：系统会在设备唤醒时合并工作，减少全天的非必要后台活动。 资源优先级：前台应用享有内存、CPU时间和网络带宽的优先使用权。 弹性设计：后台任务必须能够处理提前终止的情况，并保存中间状态。 用户控制：用户通过低电量模式、后台应用刷新等设置影响任务调度。 iOS 26还引入了更详细的电池性能分析工具，让用户能够清晰地了解各个应用对电池寿命的影响。 后台任务API概述iOS提供了多种后台任务API，每种都针对特定用例进行了优化： 1. BGAppRefreshTask此API最适合用于从服务器获取最新内容。系统会根据应用使用历史智能调度这些任务，频繁使用的应用更可能获得后台运行机会。 在SwiftUI中使用BGAppRefreshTask的示例： 1234567891011121314import BackgroundTasksimport SwiftUI@mainstruct ColorFeed: App &#123; var body: some Scene &#123; WindowGroup &#123; // ... &#125; .backgroundTask(.appRefresh(&quot;com.colorfeed.wwdc25.appRefresh&quot;)) &#123; await self.handleAppRefreshTask() &#125; &#125;&#125; 2. 后台推送通知与BGAppRefreshTask不同，后台推送通知是由服务器触发的内容更新机制。这些通知以低优先级发送并合并处理，以减少系统开销。 3. BGProcessingTask此API设计用于非时间敏感的维护工作，如运行ML模型或数据库清理。开发者可以配置任务仅在特定条件下运行（如设备充电且联网时）。 1234567891011121314151617181920212223242526import BackgroundTasksimport UIKitclass AppDelegate: UIResponder, UIApplicationDelegate &#123; func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? ) -&gt; Bool &#123; BGTaskScheduler.shared.register( forTaskWithIdentifier: &quot;com.example.apple-samplecode.ColorFeed.db_cleaning&quot;, using: nil ) &#123; task in self.handleAppRefresh(task: task as! BGProcessingTask) &#125; &#125; func submitProcessingTaskRequest() &#123; let request = BGProcessingTaskRequest( identifier: &quot;com.example.apple-samplecode.ColorFeed.db_cleaning&quot; ) request.requiresNetworkConnectivity = true request.requiresExternalPower = true BGTaskScheduler.shared.submit(request)! &#125;&#125; 4. 开始和结束后台任务对于需要在应用转入后台时完成的关键工作（如保存状态或关闭资源），可以使用beginBackgroundTask和endBackgroundTask API： 12345678910111213141516171819202122import UIKit@mainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; var backgroundTaskID: UIBackgroundTaskIdentifier = .invalid func saveState() &#123; /* ... */ &#125; func handlePersistence() &#123; let app = UIApplication.shared guard backgroundTaskID != .invalid else &#123; return &#125; backgroundTaskID = app.beginBackgroundTask(withName: &quot;Finish Export&quot;) &#123; app.endBackgroundTask(self.backgroundTaskID) self.backgroundTaskID = .invalid &#125; self.saveState() app.endBackgroundTask(backgroundTaskID) backgroundTaskID = .invalid &#125;&#125; iOS 26新特性：BGContinuedProcessingTaskiPadOS和iOS 26引入了BGContinuedProcessingTask，这是专门为支持用户发起的后台操作而设计的新API。与之前的后台任务不同，持续处理任务具有以下特点： 明确用户意图：每个任务必须由明确的用户动作（如按钮点击）触发 可视化进度：系统提供UI展示任务进度，用户可随时取消 动态标识符：支持通配符形式的动态任务标识符 GPU支持：在支持的设备上可进行后台GPU处理 持续处理任务的实现首先需要在Info.plist中添加任务标识符。然后通过以下代码注册和管理任务： 12345678910111213141516171819202122import BackgroundTasksfunc handleDialogConfirmation() &#123; BGTaskScheduler.shared.register(&quot;com.colorfeed.wwdc25.userTask&quot;) &#123; task in let task = task as! BGContinuedProcessingTask var shouldContinue = true task.expirationHandler = &#123; shouldContinue = false &#125; task.progress.totalUnitCount = 100 task.progress.completedUnitCount = 0 while shouldContinue &#123; // 执行某些工作 task.progress.completedUnitCount += 1 &#125; task.setTaskCompleted(success: true) &#125;&#125; 提交持续处理任务请求时需要提供清晰的任务描述： 12345678910111213import BackgroundTasksfunc submitContinuedProcessingTaskRequest() &#123; let request = BGContinuedProcessingTaskRequest( identifier: &quot;com.colorfeed.wwdc25.userTask&quot;, title: &quot;简洁标题&quot;, subtitle: &quot;实用且信息丰富的副标题&quot; ) request.strategy = .fail BGTaskScheduler.shared.submit(request)!&#125; 开发者还可以指定任务提交策略： 默认策略：如果不能立即运行，任务将加入队列 .fail策略：如果不能立即运行，提交将失败 最佳实践与总结为了实现高效的后台任务处理，开发者应遵循以下原则： 明确任务目标：确保每个后台任务只做一件事并高效完成 尊重系统约束：考虑电池状态、网络条件和用户偏好 弹性设计：任务应能处理中断并保存中间状态 合理使用新API：BGContinuedProcessingTask最适合用户明确发起的操作 iOS的后台任务API生态系统为开发者提供了丰富的工具，从简单的状态保存到复杂的持续处理任务。iOS 26引入的BGContinuedProcessingTask特别适合那些需要将前台操作平滑过渡到后台完成的使用场景，如文件导出或内容发布。 通过合理利用这些API，开发者可以创造更智能、更高效的后台体验，同时保持iOS系统一贯的流畅性和电池效率。 相关文档Background TasksPerforming long-running tasks on iOS and iPadOS","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"借助 Wi-Fi Aware 增强设备连接性能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_228/","text":"了解如何使用 wi-fi aware 建立对等网络连接。我们还将介绍如何以带宽更高、延迟更低的网络连接性能实时共享视频、传输大文件，以及操控配件。此外，你将了解如何借助 devicediscoveryui、accessorysetupkit 和 network 框架，在自己的 app 中使用 wi-fi aware。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 通过 Wi-Fi Aware 实现高效设备间通信概述在 WWDC 演讲中，苹果详细介绍了其最新推出的 Wi-Fi Aware 框架，该技术为 iOS 设备间的点对点通信提供了全新的解决方案。Wi-Fi Aware 允许设备之间建立高带宽、低延迟的直接连接，无需依赖路由器或互联网接入点，同时保持高安全性标准。本文将深入剖析该技术的实现原理与应用场景。 技术特性Wi-Fi Aware 技术具有以下显著优势： 直接通信：设备间可建立点对点连接，不依赖任何中间设备 并行工作：可同时保持常规 Wi-Fi 网络连接 高安全性：全链路采用认证加密机制 高吞吐量：支持大文件快速传输 低延迟：适合实时媒体传输场景 该技术基于 Wi-Fi 联盟制定的全球标准，确保不同厂商设备间的互操作性。典型应用场景包括媒体共享、配件控制、多人协作等，这些功能可同时运行而不相互干扰。 实现流程服务配置Wi-Fi Aware 采用服务发现机制，每个服务由特定格式的名称标识： 1_服务名._协议 开发者需要在应用的 Info.plist 文件中声明支持的服务类型，示例如下： 12345678910&lt;key&gt;WiFiAwareServices&lt;/key&gt;&lt;dict&gt; &lt;key&gt;_file-service._tcp&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Publishable&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Subscribable&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/dict&gt; 服务名称需遵循特定规范：不超过15个字符，仅包含字母、数字和连字符。建议在IANA注册服务名称以避免冲突。 设备配对配对过程分为三个关键步骤： 从周边设备列表中选择目标设备 输入对方显示的PIN码进行授权 系统自动完成安全配对流程 苹果提供了两种配对方案： DeviceDiscoveryUI：适用于应用间的连接场景 AccessorySetupKit：针对硬件配件优化的配对方案，支持多协议同时配对 以下是使用DeviceDiscoveryUI的代码示例： 123456789// 发布方DevicePairingView(.wifiAware(.connecting(to: .fileService, from: .selected([])))) &#123; // 前置视图&#125;// 订阅方DevicePicker(.wifiAware(.connecting(to: .selected([]), from: .fileService))) &#123; endpoint in // 处理配对端点&#125; 连接建立完整的连接流程分为四个阶段： 发布方启动监听服务 订阅方扫描周边可用的服务设备 系统提供可连接的端点信息 应用建立实际的网络连接 关键实现代码如下： 12345678// 发布方监听let listener = try NetworkListener(for: .wifiAware(.connecting(to: .fileService, from: .matching(deviceFilter)))// 订阅方连接let connection = NetworkConnection(to: endpoint, using: .parameters &#123; TLS()&#125;) 性能优化Wi-Fi Aware 提供了精细的性能调节选项： 性能模式 Bulk：默认模式，以节能为主要目标 Realtime：优先保证低延迟 服务等级 Background：后台任务 BestEffort：默认平衡模式 InteractiveVideo/Voice：实时交互应用 配置示例： 12.wifiAware &#123; $0.performanceMode = .realtime &#125;.serviceClass(.interactiveVideo) 开发者可以获取性能报告来监控连接质量： 1let report = connection.currentPath?.wifiAware?.performance 总结Wi-Fi Aware 框架为 iOS 设备间的直接通信提供了标准化、高性能的解决方案。通过简单的API集成，开发者即可为应用添加高效的设备间通信能力。该技术特别适合需要高带宽、低延迟的实时交互场景，同时保证了通信过程的安全性和可靠性。 相关资源相关视频了解 AccessorySetupKit 文档资源Wi-Fi Aware","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"跟着视频学编程：使用 Xcode 探索本地化","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_225/","text":"探索如何使用 xcode 将你的 app 本地化为其他语言。我们将逐步介绍创建 string catalog、翻译文本以及与外部翻译器交换文件的流程。你将了解为翻译器提供必要语境信息的最佳实践，以及 xcode 如何帮你自动提供这类信息。对于大型项目，我们将还深入探讨使用类型安全的 swift 代码来管理复杂度并简化字符串管理的实用技巧。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com WWDC 课程：使用 Xcode 进行应用程序本地化实践指南在全球化时代，应用程序的多语言支持已成为开发者必备技能。苹果在 WWDC 上展示了如何利用 Xcode 进行高效本地化的完整流程，从基础设置到复杂项目管理，本文将为您解析这些关键技术与最佳实践。 本地化基础入门字符串目录（String Catalog） 是 Xcode 本地化的核心工具。开发者只需通过文件菜单添加一个名为 “Localizable” 的字符串目录并将其放置在 Resources 组中，Xcode 就会在每次构建后自动发现并添加可本地化的字符串。这种自动同步机制极大地简化了本地化流程。 在代码层面，大多数 SwiftUI API 如 Text 和 Button 默认支持本地化。对于非 SwiftUI 代码，开发者可以使用 String(localized:) 方法。示例代码展示了典型用法： 123Text(&quot;Featured Landmark&quot;, comment: &quot;英雄图片中特色地标的大标题&quot;)Button(&quot;Keep&quot;) &#123; &#125;String(localized: &quot;New Collection&quot;, comment: &quot;用户新建收藏的默认名称&quot;) 当涉及复数形式时，Xcode 提供了便捷的处理方式。开发者只需在字符串目录中选择”按复数变化”，即可分别设置单数和复数形式的翻译，系统会根据数量自动选择正确的显示形式。 多语言协作流程添加新语言只需点击字符串目录底部的加号按钮并选择目标语言（如德语）。开发者可以直接在目录中进行翻译，翻译完成后状态会从 NEW 变为 TRANSLATED。 对于专业翻译工作，Xcode 支持导出标准 XLIFF 格式文件。通过产品菜单的”导出本地化”功能，开发者可以生成包含所有待翻译字符串的文件包。翻译完成后，通过”导入本地化”功能即可将翻译结果导入项目。 测试特定语言版本时，开发者可以在方案编辑器的”运行 &gt; 选项”中将应用程序语言更改为目标语言（如德语）进行调试运行。 翻译上下文优化高质量的翻译依赖于充分的上下文。Xcode 提供了两种添加注释的方式： 在代码中直接添加： 12Text(&quot;Delete&quot;, comment: &quot;确认删除收藏的警报中显示的删除按钮&quot;)String(localized: &quot;Shared by Friends&quot;, comment: &quot;朋友分享的帖子副标题&quot;) 在字符串目录的注释列中添加 Xcode 26 引入了自动注释生成功能，使用设备端模型分析代码并生成注释。开发者可以： 对未注释的字符串使用”生成注释”上下文菜单选项 在设置中启用”自动生成字符串目录注释”以实现自动化 注释应包含： 界面元素类型（按钮、选项卡等） 周边UI环境描述 占位符内容解释 生成的注释会被标注为”auto-generated”并包含在导出的XLIFF文件中：12345&lt;trans-unit id=&quot;Grand Canyon&quot; xml:space=&quot;preserve&quot;&gt; &lt;source&gt;Grand Canyon&lt;/source&gt; &lt;target state=&quot;new&quot;&gt;Grand Canyon&lt;/target&gt; &lt;note from=&quot;auto-generated&quot;&gt;地标搜索建议&lt;/note&gt;&lt;/trans-unit&gt; 大规模项目管理策略当项目涉及多个模块时，bundle参数变得至关重要： 12345// 主应用Text(&quot;My Collections&quot;, comment: &quot;用户创建收藏的上方章节标题&quot;)// 框架/包Text(&quot;My Collections&quot;, bundle: #bundle, comment: &quot;用户创建收藏的上方章节标题&quot;) #bundle 宏是Xcode的新功能，它能自动识别当前目标的资源包，兼容旧系统且无需开发者手动处理。 字符串分组可以通过tableName参数实现： 1Text(&quot;My Collections&quot;, tableName: &quot;Discover&quot;, comment: &quot;用户创建收藏的上方章节标题&quot;) 这会将字符串组织到指定的”Discover.xcstrings”目录中。建议按功能或屏幕分组字符串以提高可维护性。 类型安全字符串管理Xcode 26 引入了符号生成工作流程，开发者可以： 手动添加字符串键值对 使用生成的类型安全符号引用字符串：1.navigationSubtitle(.subtitle(friendsPosts: 42)) 该功能特点包括： 自动根据键和值生成Swift符号 对含占位符的字符串生成带参数标签的函数 生成的符号是LocalizedStringResource类型 支持SwiftUI视图、修饰符和Foundation API 开发者可以通过构建设置”Generate String Catalog Symbols”启用此功能。Xcode还提供重构工具，可在提取字符串和符号引用两种工作流间轻松转换。 工作流程选择建议苹果推荐： 初期开发：优先使用字符串提取工作流，便于快速迭代和理解代码 项目成熟：考虑转向符号引用，获得更好的组织控制和类型安全 大型项目：结合使用分组(tableName)、模块化(#bundle)和符号生成 两种工作流各有优势，开发者应根据项目需求灵活选择。Xcode的重构功能使两者间的转换变得简单可靠。 扩展学习资源想深入了解字符串目录的更多细节，可以参考WWDC视频：探索字符串目录 通过掌握这些本地化技术和工具，开发者可以构建真正全球化的应用程序，为世界各地的用户提供优质的本地体验。Xcode不断进化的本地化功能，正使这一过程变得更加高效和可靠。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"让所有人都能更方便地使用你的 Mac App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_229/","text":"了解如何整合那些可充分利用 macos 强大功能和灵活性的辅助功能。深入探索如何支持“旁白”和“语音控制”，如何改进视图的布局，以及辅助技术如何导航你的内容，等等。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 让你的 Mac 应用对所有人都更易用：深入无障碍功能开发指南引言在当今数字时代，确保应用对所有用户都具有可访问性已成为开发者的重要责任。WWDC 2024 演讲中，无障碍团队工程师 Nicholas 分享了如何充分利用 macOS 的强大功能和灵活性，将无障碍特性深度整合到 Mac 应用的开发中。本文将详细介绍这些专业技巧，帮助开发者创建更友好的应用体验。 布局优化：构建高效的无障碍元素结构Mac 应用通常设计用于键盘和鼠标交互，具有密集的用户界面和强大的多任务处理能力。这些特性带来了独特的无障碍考量要点。SwiftUI 将应用中的各个视图呈现为无障碍元素，这些元素包含无障碍技术理解和与应用交互所需的关键信息。 旁白(VoiceOver)作为 macOS 内置的屏幕阅读器，能够将应用界面转化为语音或盲文输出。Mac 上的旁白主要通过键盘快捷键控制，用户可以通过快捷键在元素间移动。为了优化旁白导航体验，SwiftUI 提供了将无障碍元素分组到容器的功能。 开发者需要注意，Mac 上的容器通常包含嵌套容器，形成树状的无障碍元素结构。合理地将相关元素分组到容器中可以使旁白导航更高效，但过多的嵌套层级反而会降低使用体验。 SwiftUI 提供了三种主要的行为选项来优化容器： 包含子视图(.contain)：将子视图包含在无障碍容器中 合并子视图(.combine)：将子视图合并为一个无障碍元素 忽略子视图(.ignore)：从无障碍中隐藏子视图 通过合理使用这些选项，开发者可以显著改善旁白用户的导航体验。例如，在文本编辑应用中，可以将样式预设视图分组为容器，避免用户必须遍历每个预设才能到达下一个功能区。 导航增强：转子与焦点管理优化应用的无障碍结构后，进一步改善导航体验的方法是利用转子和焦点管理功能。转子是旁白的重要功能，它允许用户定义应用中的视图或文本范围集合，实现快速导航。 在文本编辑应用的例子中，可以创建专门的书签转子，让旁白用户能够直接跳转到书签页面，而无需遍历每个页面检查是否有书签标记。这种设计实现了与视觉用户相似的便捷体验。 macOS 和 iOS 26 还引入了accessibilityDefaultFocus修饰符，允许应用为旁白等无障碍技术建议初始焦点位置。开发者可以使用AccessibilityFocusState属性包装器来管理旁白焦点状态，确保用户首次进入应用时能够直接访问最重要的内容。 交互优化：超越鼠标与触控板确保所有交互方式对所有用户都可用是开发无障碍应用的关键。许多 Mac 应用依赖鼠标悬停或触控板手势来触发特定功能，但这些交互方式对某些用户可能不可行。 针对这种情况，SwiftUI 提供了替代的交互实现方式。例如，可以为悬停显示的按钮添加无障碍动作，确保使用旁白的用户也能执行相同功能。开发者应该为应用中的常见任务添加快捷键，这不仅提升了高级用户的工作效率，也为无法使用鼠标的用户提供了替代交互方式。 对于自定义控件，开发者需要特别注意为其提供完整的无障碍信息。标准的 SwiftUI 控件通常已内置无障碍支持，但自定义控件可能需要额外的工作才能确保良好的可访问性。 结论与后续资源通过优化布局结构、增强导航体验和完善交互方式，开发者可以显著提升 Mac 应用的无障碍性。演讲中建议开发者使用旁白测试自己的应用，研究可以添加自定义转子的地方，并通过无障碍营养标签展示应用的无障碍特性。 如需深入了解相关内容，可以参考以下资源： 相关视频：了解 SwiftUI 中的辅助功能SwiftUI 辅助功能：超越基础功能 文档：AccessibilityHuman Interface Guidelines: Accessibility","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"分析并优化 App 的功耗","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_226/","text":"了解如何优化你的 app，以充分延长电池续航时间。探索如何查明 app 功耗问题的根本原因，无论是在连接到 xcode 时还是出行期间遇到这类问题，都可以查明。了解如何测量功耗，以便你可以就新功能做出更明智的决策，并主动构建更高效的 app。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 分析与优化应用的功耗概述在现代移动应用开发中，功耗优化是保证用户体验的关键因素之一。苹果公司软件工程师 Wiam 在本次演讲中分享了如何利用工具和技术来分析和优化应用的功耗表现。本文将详细介绍如何识别、诊断和解决应用功耗问题，帮助开发者构建更高效节能的应用程序。 调试可复现的问题发现功耗问题开发者常常会遇到这样的情况：在Xcode的能耗报告中发现CPU使用率突然上升，导致性能下降和电池续航缩短。演讲中使用的案例是一款名为Destination Video的视频流应用，在添加Library面板功能后出现了明显的性能退化。 使用Power Profiler工具Instruments中的Power Profiler是分析这类问题的理想工具。它允许开发者在应用运行时记录功耗轨迹，并进行可视化分析。使用步骤包括： 无线连接iPhone设备 通过Xcode的Product菜单选择Profile 在Instruments中选择空白模板并勾选Power Profiler和CPU Profiler 开始录制并重现问题场景 分析功耗数据Power Profiler提供两个关键指标： 系统功耗使用轨道：显示整体能耗情况 应用级功耗影响指标：包括CPU、GPU、显示和网络等子系统的功耗影响 在案例中，当打开Library面板时，CPU功耗影响从平均1跃升至21，这表明存在严重的CPU性能问题。 定位问题根源通过CPU Profiler的Call Tree视图，分析显示大量时间花费在VideoCardView上。进一步检查发现LibraryThumbnailView为每个视频生成并加载所有缩略图视图，无论它们是否可见。这种实现方式导致了不必要的CPU负载。 优化解决方案使用SwiftUI的LazyVStack替代普通VStack，实现了按需加载和渲染。优化后： 应用响应速度提升 CPU功耗影响从21降至4.3 解决了性能退化问题 发现隐藏问题真实场景中的功耗问题有些问题在开发环境中难以复现，比如： CarPlay导航中的真实行为 AR功能的户外电力消耗 数小时后才出现的后台电池问题 设备端功耗分析Power Profiler支持在不连接Xcode的情况下收集数据： 在设备设置中开启开发者模式 进入开发者设置的Performance Trace 启用Power Profiler并选择要分析的应用 通过控制中心开始/停止录制 案例分析在Destination Video应用中，用户报告了严重的电池问题。通过收集的设备日志分析发现： CPU功耗呈现周期性波动 主要消耗源是videoSuggestionsForLocation函数 该函数在位置变化时频繁执行 问题根源在于： 每次位置变化都重新读取和解析JSON规则文件 文件I/O和JSON解析是资源密集型操作 优化方案是懒加载并缓存规则数据，避免重复处理。 比较功耗使用优化策略的选择在发布前，开发者经常面临不同优化方案的选择。Power Profiler的比较功能可以帮助： 分析不同实现方案的功耗影响 评估权衡因素（如CPU vs网络活动） 确定最优解决方案 比较方法 分别分析不同方法的功耗数据 考虑温度、设备状态和系统压力等影响因素 在典型使用条件下进行测试 结论通过系统化的功耗分析和优化方法，开发者可以显著提升应用的电池使用效率。Power Profiler工具提供了从开发环境到真实场景的全面分析能力，帮助开发者： 快速定位功耗问题根源 验证优化效果 选择最佳实现方案 最终目标是构建既功能强大又高效节能的应用，为用户提供持久的优质体验。 相关视频通过 Instruments 优化 CPU 性能","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"借助 NetworkExtension 优化网络流量过滤和隧道","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_234/","text":"了解 networkextension 框架中提供的 api，这些 api 让你的 app 能够灵活地扩展系统的核心网络功能 — 例如实现网络内容过滤器、创建和管理 vpn 配置等。在 ios、ipados 和 macos 26 中，你现在可以构建更为强大的内容过滤器，让它根据整个 url (而不仅是主机名) 来做出流量决策，同时确保隐私和安全丝毫不受影响。我们将首先简要介绍 networkextension 框架的一些主要用例，包括网络中继和 vpn。然后，我们将深入探讨这一全新的 url 过滤器 api 及其关键组件，包括 private information retrieval、privacy pass 等。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 利用 NetworkExtension 优化网络流量过滤与隧道技术概述NetworkExtension 框架为开发者提供了一系列强大的 API，用于扩展和定制 Apple 平台的核心网络功能。在 iOS、iPadOS 和 macOS 26 中，该框架引入了全新的 URL 过滤器 API，使得开发者能够基于完整 URL 而不仅仅是主机名来进行流量过滤决策，同时确保了用户的隐私和安全。 NetworkExtension 框架简介NetworkExtension 是一个功能丰富的框架，允许开发者构建能够扩展和定制 Apple 平台网络能力的应用。该框架与整个网络堆栈紧密集成，包括 Network 框架、CFNetwork、WebKit 和 Sockets API，同时也与系统级组件如路由、流量策略和各类系统管理深度整合。 主要功能NetworkExtension 框架支持多种网络定制方式： Wi-Fi 管理和热点 API（仅 iOS）：允许应用配置 Wi-Fi 设置并与 Wi-Fi 热点交互 本地推送 API：适用于无法访问 Apple 推送通知服务的网络环境 DNS 配置和代理 API：用于构建保护 DNS 流量免受攻击的安全应用 透明代理 API（仅 macOS）：可将特定网站流量重定向至云端安全服务 远程资源安全访问：通过隧道技术保护网络流量 内容过滤：实现对网络流量的监控和过滤 远程资源访问技术NetworkExtension 提供了两种主要的方法来实现安全的远程资源访问： 网络中继网络中继适合需要隧道传输 TCP 或 UDP 流量以访问特定应用的场景。MASQUE 协议提供了安全代理且性能优化，平台内置支持无需额外扩展。 基于 IP 的 VPNIP VPN 适合企业将公司网络扩展至远程员工，或高安全要求的组织需要将所有管理设备流量通过企业网络传输。 开发者可以通过以下方式创建 IP VPN 隧道： 使用 NEVPNManager API 内置协议（IKEv2/IPsec） 使用 NEPacketTunnelProvider 实现自定义隧道协议 重要注意事项： NetworkExtension 是构建 VPN 应用的唯一官方支持 API 禁止使用 Packet Filter 或直接修改 Mac 路由表 NEPacketTunnelProvider 仅应用于 IP 层流量隧道传输 内容过滤技术NetworkExtension 的内容过滤 API 允许开发者检查设备流量进行监控或过滤决策。传统的内容过滤器存在以下局限： 只能基于流量级信息（如主机和端口）做决策 HTTPS 加密导致无法获取 URL 详细内容 无法精准过滤特定资源 iOS 26 全新 URL 过滤器iOS 26 引入了全新的 URL 过滤器功能，允许基于完整 URL 进行内容过滤决策。该技术具有以下特点： 应用场景 家长控制应用屏蔽有害网站 学校应用限制社交媒体/赌博等内容 企业屏蔽与工作无关的内容 隐私保护设计 采用最先进加密技术 URL 敏感信息不会泄露给应用 后端服务器查询完全匿名化 Apple 和服务器都无法获取内容与身份信息 技术实现四大支柱 Bloom 过滤器：快速预过滤（可能假阳性但无假阴性） 私有信息检索 (PIR)：使用同态加密实现加密查询 隐私通行证 (Privacy Pass)：匿名认证机制 无感 HTTP 中继 (Oblivious HTTP Relay)：隐藏客户端 IP 地址 实现步骤开发者可以通过以下步骤实现 URL 过滤器： 设置 PIR 服务器 构建 Bloom 过滤器 构建 URL 过滤应用 构建应用扩展 示例代码：12345678let manager = NEURLFilterManager.sharedtry await manager.loadFromPreferences()try manager.setConfiguration( pirServerURL: URL(string:&quot;https://pir.example.com&quot;)!, pirPrivacyPassIssuerURL: URL(string:&quot;https://privacypass.example.com&quot;)!, pirAuthenticationToken: &quot;1234&quot;, controlProviderBundleIdentifier: &quot;com.example.myURLFilter.extension&quot;)manager.prefilterFetchInterval = 86400 // 每日更新 总结NetworkExtension 框架为开发者提供了强大的工具，使其能够： 使用网络中继安全访问 TCP/UDP 流量 构建完整的 VPN 解决方案 通过 URL 过滤 API 创建强大的内容过滤器 开发者可以立即查看相关示例和文档开始开发工作。 相关视频将隐私保护融入开发流程适用于现代 Mac 的网络扩展 文档资源按 URL 过滤流量NEHotspotManagerNetwork ExtensionNEURLFilterManagerPIRServiceTN3120：网络扩展包隧道提供商的预期用例TN3165：包过滤器不是 APIverdict(for:))","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"空间网页的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_237/","text":"了解 visionos 26 上适用于网页的最新空间功能。我们将介绍如何使用全新的 html 模型元素来显示内联 3d 模型。我们还将分享模型照明、交互和动画等强大功能。了解如何在你的网站上嵌入新支持的沉浸式媒体，例如 360 度视频和 apple 沉浸视频。另外，你还将抢先体验如何在网页中添加自定环境。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 空间网页新功能：visionOS 26带来HTML模型元素与沉浸式体验随着visionOS 26的发布，网页开发领域迎来了突破性的空间计算功能。这些创新技术将彻底改变用户在Web上浏览3D内容和沉浸式媒体的体验。 3D模型嵌入的革命传统的HTML Image元素在网页上展示二维图片已有数十年历史，而全新的HTML Model元素开启了3D内容展示的新篇章。这一标准提案经过多年发展，现在被visionOS的Safari浏览器原生支持。 基础实现与准备工作开发者可以通过简单的标记语言将3D模型嵌入网页： 1&lt;model src=&quot;teapot.usdz&quot;&gt;&lt;/model&gt; 实现这一功能首先需要准备USDZ格式的3D模型文件。获取途径包括： 使用iPhone的Reality Composer应用或Object Capture API捕捉实物对象 通过macOS的Preview或命令行工具转换现有3D模型 使用专业3D软件如Blender、Houdini导出 技术细节与优化技巧为提升兼容性和性能表现，开发者可采用以下优化策略： 服务器配置需正确识别USDZ文件类型： 1234# NGINX mime.types配置types &#123; model/vnd.usdz+zip usdz;&#125; 渐进增强策略可确保在不同设备上提供适当体验： 123&lt;model src=&quot;camera.usdz&quot;&gt; &lt;img src=&quot;camera.png&quot; alt=&quot;相机模型&quot;&gt;&lt;/model&gt; JavaScript检测支持情况： 123if (window.HTMLModelElement) &#123; // 浏览器支持Model元素&#125; 高级渲染与交互功能模型元素支持立体渲染，用户可直接感知对象深度。通过环境光照设置可获得更真实的视觉效果： 1&lt;model src=&quot;camera.usdz&quot; environmentmap=&quot;sunset.exr&quot;&gt;&lt;/model&gt; 交互功能方面，开发者可以： 启用内联旋转功能：stagemode=&quot;orbit&quot; 通过JavaScript控制模型变换 管理内置动画播放 沉浸式媒体体验升级visionOS 26扩展了沉浸式媒体支持范围，包括： 空间视频 180/360度视频 Apple沉浸式视频 实现方式与传统视频元素一致： 1&lt;video src=&quot;spatial_video.mov&quot;&gt;&lt;/video&gt; 全景和空间照片新增controls属性，引导用户进入全屏沉浸体验： 1&lt;img src=&quot;spatial.heic&quot; id=&quot;img&quot; controls&gt; 开发者预览：网站环境创新的网站环境功能允许开发者指定USDZ作为虚拟背景： 1&lt;link rel=&quot;spatial-backdrop&quot; href=&quot;office.usdz&quot; environmentmap=&quot;lighting.hdr&quot;&gt; 用户可通过页面菜单或数码表冠控制环境展示程度。 技术展望与学习资源这些新功能为Web开发开辟了全新可能。开发者可访问webkit.org查看具体示例，并通过Vision Pro设备亲身体验效果。随着空间计算技术的发展，网页体验正迈向更具沉浸感和交互性的未来。 相关视频：了解 Apple Projected Media Profile探索 visionOS 的视频体验支持 visionOS App 播放沉浸视频Safari 浏览器和 WebKit 的新功能为你的沉浸式 visionOS App 创建自定环境探索 USD 生态系统认识 Reality Composer Pro","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"了解 App Intents","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_244/","text":"了解 app intents 框架及其在 apple 开发者平台中愈显关键的作用。我们将向你全面介绍意图、实体、查询等核心概念。你将了解如何综合运用这些概念，以便使你的 app 与 apple 设备 (从“聚焦”和“快捷指令”等软件功能到操作按钮等硬件功能) 实现整合。我们还将介绍如何将 app intents 作为你 app 的入口，以便将来实现与 apple 智能的整合。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深度解析 App Intents：打造全系统可用的应用功能引言App Intents 框架作为 Apple 开发者生态中的重要组成部分，正在为应用带来前所未有的系统级集成能力。本文将详细解析该框架的核心概念与实现方法，帮助开发者理解如何通过 App Intents 让应用功能突破自身边界，融入整个 Apple 生态系统。 App Intents 核心概念框架定位与价值App Intents 不仅仅是一个功能构建框架，更是一个应用能力辐射系统。通过该框架，开发者可以实现： 聚焦搜索中的个性化结果展示 操作按钮的情境感知体验 小部件的可配置交互 控制中心的便捷控件 Apple Pencil Pro 的自定义操作 特别值得注意的是，今年新增的 Mac 版聚焦搜索功能已能随处调用应用操作，进一步扩展了应用与系统的交互场景。 基础元素解析在 App Intents 框架中，主要包含三类核心元素： Intent（意图）：代表应用的”动词”，描述可执行的操作 App Enum（枚举）：表示固定值集合的类型 App Entity（实体）：表示动态类型 这些元素共同构成了应用的语义模型，使其能够被系统理解和调用。 实践指南创建首个 App Intent以一个全球地标旅行应用为例，创建一个导航至地标列表的 intent 需要以下步骤： 12345678910struct NavigateIntent: AppIntent &#123; static let title: LocalizedStringResource = &quot;导航至地标&quot; static let supportedModes: IntentModes = .foreground @MainActor func perform() async throws -&gt; some IntentResult &#123; Navigator.shared.navigate(to: .landmarks) return .result() &#125;&#125; 这段代码定义了符合 AppIntent 协议的结构体，包含本地化标题和执行逻辑的 perform 方法。由于导航操作需要在主线程执行，perform 方法被标记为 @MainActor。 参数化 Intent为了扩展导航功能，可以创建 App Enum 定义导航选项： 12345678910111213enum NavigationOption: String, AppEnum &#123; case landmarks case map case collections static let typeDisplayRepresentation = &quot;导航选项&quot; static let caseDisplayRepresentations = [ .landmarks: &quot;地标&quot;, .map: &quot;地图&quot;, .collections: &quot;收藏集&quot; ]&#125; 然后在 intent 中添加参数： 12345struct NavigateIntent: AppIntent &#123; @Parameter(title: &quot;版块&quot;, requestValueDialog: &quot;要导航到哪个版块？&quot;) var navigationOption: NavigationOption //...其余实现&#125; 优化用户体验通过 ParameterSummary 提供流畅的语句式描述： 123static var parameterSummary: some ParameterSummary &#123; Summary(&quot;导航至\\(\\.$navigationOption)版块&quot;)&#125; 今年新增的功能是：当 intent 包含完整 ParameterSummary 时，用户可直接从 Mac 的聚焦搜索运行该操作。 系统集成App Shortcuts 创建对于核心 intent，可以通过 App Shortcuts 使其在安装后立即可用： 12345678910111213struct TravelTrackingAppShortcuts: AppShortcutsProvider &#123; static var appShortcuts: [AppShortcut] &#123; AppShortcut( intent: NavigateIntent(), phrases: [ &quot;在\\(.applicationName)中导航&quot;, &quot;在\\(.applicationName)中导航到\\(\\.$navigationOption)&quot; ], shortTitle: &quot;导航&quot;, systemImageName: &quot;arrowshape.forward&quot; ) &#125;&#125; 这些快捷方式会突出显示在聚焦搜索中，并支持通过 Siri 语音触发。 数据建模动态实体实现地标作为应用的核心概念，需要创建 App Entity 进行建模： 1234567891011struct LandmarkEntity: AppEntity &#123; var id: Int &#123; landmark.id &#125; @ComputedProperty var name: String &#123; landmark.name &#125; static let typeDisplayRepresentation = TypeDisplayRepresentation(name: &quot;地标&quot;) var displayRepresentation: DisplayRepresentation &#123; ... &#125; static let defaultQuery = LandmarkEntityQuery()&#125; 实体必须提供查询机制（EntityQuery）来回答系统查询： 1234567struct LandmarkEntityQuery: EntityQuery &#123; @Dependency var modelData: ModelData func entities(for identifiers: [Int]) async throws -&gt; [LandmarkEntity] &#123; modelData.landmarks(for: identifiers).map(LandmarkEntity.init) &#125;&#125; 进阶功能实体功能扩展通过实现更多协议，可以扩展实体功能： Transferable 协议：支持图像分享 IndexedEntity 协议：实现聚焦搜索索引 OpenIntent：实现深度链接 例如实现深度链接： 123456789struct OpenLandmarkIntent: OpenIntent, TargetContentProvidingIntent &#123; @Parameter(title: &quot;地标&quot;) var target: LandmarkEntity&#125;// 在 SwiftUI 中处理导航.onAppIntentExecution(OpenLandmarkIntent.self) &#123; intent in path.append(intent.target.landmark)&#125; 查询增强通过实现更多查询协议，可以提供更丰富的实体发现方式： EnumerableEntityQuery：返回所有实体 EntityStringQuery：支持文本搜索 EntityPropertyQuery：支持属性过滤和排序 底层原理App Intents 采用编译时生成机制，应用源代码在构建时会被解析，生成的应用意图表示直接嵌入应用包中。这种设计使得系统在安装后即可理解应用能力，无需实际运行应用。 当在多个 target 间共享类型时，需要定义 AppIntentsPackage： 123456789// 在Swift包中public struct TravelTrackingKitPackage: AppIntentsPackage &#123;&#125;// 在主target中struct TravelTrackingPackage: AppIntentsPackage &#123; static var includedPackages: [any AppIntentsPackage.Type] &#123; [TravelTrackingKitPackage.self] &#125;&#125; 今年新增了对 Swift 包和静态库的支持。 总结与建议App Intents 框架为开发者提供了强大的系统集成能力，建议从小处着手，先添加一个 App Shortcut，再逐步探索框架的其他功能。通过将应用的核心功能转化为系统可理解的意图和实体，开发者可以创造更加无缝的用户体验。 相关资源相关视频使用 App Intents 针对”快捷指令”和”聚焦”进行开发设计交互式摘要卡片利用 App Intents 为用户奉上 App 的核心功能利用 App Intents 设计提升系统体验带你的 App 登陆 SiriApp Intents 的新功能 文档App intent domainsApp IntentsApp ShortcutsCreating your first app intentIntegrating actions with Siri and Apple IntelligenceMaking actions and content discoverable and widely available","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"UIKit 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_243/","text":"借助 uikit 最新推出的多种 api，对你的 app 进行现代化改造，这些更新包括增强的菜单栏支持、自动观察跟踪、全新 ui 更新方法，以及动画效果改进。我们还将介绍如何在 uikitapp 中包含 swiftui 场景，并探讨 sf symbols、hdr 颜色选择器等内容。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com UIKit 新特性全面解析：现代化升级指南随着 iOS/iPadOS 26 的发布，UIKit 框架迎来了一系列重大更新，为开发者提供了更强大的工具来构建现代化应用体验。本文将从设计系统、菜单栏支持、架构改进等多个维度，深入解析 UIKit 的最新特性。 全新设计系统：Liquid Glass 材质UIKit 在 iOS/iPadOS 26 中引入了创新的 Liquid Glass 设计系统，其核心是兼具半透明特性和动态效果的材质。这种材质包含镜面高光和折射等光学特性，为系统组件带来了前所未有的视觉表现。 开发者可通过以下新工具实现设计升级： 背景延展视图：让内容显示在玻璃面板下方，保持视觉连贯性 自定义组件玻璃材质：为自制控件添加专业玻璃效果 全新滚动边缘效果：内容滚动时呈现优雅渐变动画，提升工具栏可视性 导航过渡现在支持流畅且可中断的动画，用户无需等待动画完成即可与内容互动，显著提升交互体验。 菜单栏系统：iPadOS 的重大升级iOS/iPadOS 26 将 macOS 的菜单栏体验带到了 iPad 平台。用户只需从屏幕顶部轻扫即可调出完整应用菜单，无需硬件键盘即可访问所有功能。 主菜单系统配置 API新 API 允许开发者深度定制菜单系统： 1234var config = UIMainMenuSystem.Configuration()config.printingPreference = .includedconfig.inspectorPreference = .removedconfig.findingConfiguration.style = .search 12345UIMainMenuSystem.shared.setBuildConfiguration(config) &#123; builder in builder.insertElements([...], afterCommand: #selector(copy(_:))) let deleteKeyCommand = UIKeyCommand(...) builder.replace(command: #selector(delete(_:)), withElements: [deleteKeyCommand])&#125; 动态菜单支持对于需要动态内容的菜单项（如浏览历史），可使用基于焦点的延迟菜单元素： 1234let historyDeferredElement = UIDeferredMenuElement.usingFocus( identifier: .browserHistory, shouldCacheItems: false) 架构改进：Swift Observable 原生支持iOS 26 将 Swift Observation 整合到 UIKit 核心中，实现了自动依赖追踪。 1234567891011@Observable class UnreadMessagesModel &#123; var showStatus: Bool var statusText: String&#125;class MessageListViewController: UIViewController &#123; override func viewWillLayoutSubviews() &#123; statusLabel.alpha = unreadMessagesModel.showStatus ? 1.0 : 0.0 statusLabel.text = unreadMessagesModel.statusText // 自动建立依赖关系 &#125;&#125; 全新UI更新流程UIKit 引入了 updateProperties() 方法，将属性更新与布局更新分离，优化性能。 123override func updateProperties() &#123; folderButton.badge = model.badgeCount.map &#123; .count($0) &#125; // 仅更新徽章计数&#125; 新的更新流程顺序为： 更新特征集合 调用 updateProperties() 执行 layoutSubviews() 显示流程 渲染帧 HDR 色彩与 SF Symbols 7iOS 26 扩展了 HDR 支持到色彩领域： 1let hdrRed = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0, linearExposure: 2.5) SF Symbols 7 新增了多种绘制效果和动画功能： 12var configuration = UIButton.Configuration.plain()configuration.symbolContentTransition = UISymbolContentTransition(.replace) 迁移指南建议开发者： 使用 iOS 26 SDK 重新编译应用 评估应用在新设计系统中的表现 采用 UISplitViewController 等标准容器 使用新菜单 API 采用 updateProperties 和观察追踪 迁移到场景化生命周期 通过这些改进，开发者可以为用户打造更强大、愉悦的应用体验。建议参考相关视频和文档获取更详细的技术指导。 相关视频了解全新设计系统使用全新设计系统构建 UIKit App提升 iPad App 设计让你的 UIKit App 更加灵活SF Symbols 7 的新功能利用 HDR 为 App 打造动态图像体验在 App 中为符号添加动画效果在你的 App 中支持 HDR 图像使您的 iPad App 更上一层楼 文档人机界面指南UIKit 更新","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"针对辅助访问自定 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_238/","text":"辅助访问是一种独具特色、突出重点的 ios 体验，让有认知障碍的用户可以更轻松地独立使用 iphone 和 ipad。在 ios 和 ipados 26 中，你可以对 app 在辅助访问模式下的运行效果进行自定，为用户提供更大的便利性和独立性。了解如何使用 assistiveaccess swiftui 场景类型来定制你的 app，并探索可以帮助你为每一个人打造高质量辅助触控体验的关键设计原则。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为辅助访问定制应用：构建包容性体验的技术指南引言在iOS和iPadOS 26中，Apple为开发者提供了全新的AssistiveAccess SwiftUI场景类型，使应用能够更好地融入辅助访问模式。辅助访问是一种经过简化的系统体验，专为认知障碍用户设计，通过大控件、简洁界面和清晰的成功路径降低认知负荷。本文将详细介绍如何利用新技术优化应用，以及设计高质量辅助触控体验的关键原则。 辅助访问概述辅助访问最初在iOS和iPadOS 17中推出，重新定义了设备交互方式，提炼出应用和控件的核心功能。这种体验具有以下特点： 精简版内置应用（如相机和信息）采用统一设计语言 大控件和简洁界面提升可操作性 可视化文本替代方案减少认知负担 对于未经优化的应用，系统会显示在缩小窗口中，底部提供返回主屏幕按钮。而专门设计的应用（如AAC辅助沟通应用）则可实现全屏显示，只需在Info.plist中设置UISupportsFullScreenInAssistiveAccess为true。 创建辅助访问场景iOS/iPadOS 26引入的AssistiveAccess场景类型，使开发者能够创建符合内置应用风格的定制界面。实现步骤如下： 在Info.plist设置UISupportsAssistiveAccess为true 采用AssistiveAccess场景类型构建精简体验 SwiftUI应用示例代码： 1234567891011@mainstruct WWDCDrawApp: App &#123; var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; AssistiveAccess &#123; // 新增辅助访问场景 AssistiveAccessContentView() &#125; &#125;&#125; 使用#Preview(traits: .assistiveAccess)宏可预览辅助访问场景。UIKit应用则可通过UIHostingSceneDelegate定义SwiftUI场景，并在AppDelegate中激活配置。 应用定制原则为辅助访问优化应用时，应遵循以下核心设计原则： 功能精简保留1-2个核心功能，移除次要功能减少干扰。例如绘图应用可保留”绘制”和”画廊”两个主要功能。 显性控件避免隐藏手势或嵌套UI，使用醒目易见的控件。所有操作都应直观可见。 无时效限制取消自动状态变更，允许用户按自身节奏操作。避免时间敏感的操作流程。 分步引导采用渐进式流程而非一次性展示所有选项。例如颜色选择可作为绘制的必经步骤，而非可选功能。 安全防护移除不可逆操作或设置双重确认。例如从画布移除撤销功能，在画廊移除删除选项。 多模态呈现为所有控件和导航标题同时提供图标和文本标签。使用.assistiveAccessNavigationIcon修饰符添加配套图标。 测试与优化完成初步开发后，建议通过辅助访问社区获取真实用户反馈。持续的测试和优化可确保应用提供最佳的无障碍体验。遵循这些原则，开发者能够创建真正包容的应用，服务于认知障碍用户群体。 相关视频SwiftUI 的新功能了解 Assistive Access 文档AssistiveAccess人机界面指南：无障碍功能UISupportsFullScreenInAssistiveAccess","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"Xcode 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_247/","text":"了解 xcode 26 中最新的效率和性能改进。了解如何在开发流程中充分利用大语言模型。探索编辑和调试方面的增强功能、性能和测试工具的改进，以及 xcode 使用的开源构建系统引擎 swift build。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Xcode 新特性：全面提升开发效率与性能Xcode 26的发布为开发者带来了全方位的改进，从安装包大小到编程智能辅助，从调试性能到构建系统，每项优化都旨在提升开发者的工作效率和应用性能。本文将详细介绍Xcode 26的核心更新内容。 性能与安装优化Xcode团队持续致力于减少安装包体积，今年实现了24%的缩减，使安装包比2014年的Xcode 6还要小。这一改进主要通过以下方式实现： 模拟器运行时默认不再包含Intel支持 Metal工具链变为可选下载项 组件化安装方式让开发者只需下载所需部件 在性能方面，Xcode 26显著提升了文本输入响应速度，复杂表达式输入延迟最高降低50%。工作区加载速度也提升了40%，这对大型项目开发者尤为有利。 编辑器与工作区增强源代码编辑器获得了多项实用改进： 标签页管理： 采用类似Safari的直观行为 支持起始页功能 提供多种布局选项（单标签页、独立标签页或分组管理） 搜索功能升级：新引入的”多词搜索”模式采用搜索引擎技术，可以： 查找项目中符合条件的关键词组合 支持跨越多行代码的搜索 结果按相关性排序 支持任意词序排列 辅助功能突破：新增语音控制Swift代码编写功能，能够： 理解Swift语法规则（包括空格、运算符和命名规范） 实现完全免键盘操作 Playground宏： 允许快速迭代任意代码 执行结果自动显示在画布标签页中 现已开源，支持跨平台使用 智能编程辅助Xcode 26整合了大语言模型能力，提供智能编程辅助： 编程助手功能： 支持通用Swift问题解答 提供与具体代码相关的修改建议 通过@符号引用项目特定元素 支持附加图像作为查询参考 代码修改管理： 自动提供项目背景 保留修改历史快照 可选择应用或回退每组更改 模型接入选项： 快速启用ChatGPT（有限额） 支持Anthropic等第三方API 可运行Ollama等本地模型 支持多提供商配置和快速切换 调试与性能工具Xcode 26在调试和性能分析方面带来重要更新： Swift并发调试： 支持跨线程跟踪异步函数 显示任务ID和优先级信息 变量视图呈现更清晰的并发类型 隐私权限辅助： 自动识别缺少的隐私使用说明 可直接跳转到设置界面添加权限 支持批量修改隐私权限 Instruments改进： Processor Trace： 取代传统采样分析器 在M4芯片和iPhone 16上以极低开销捕捉所有线程调用 提供高保真执行可视化 CPU Counters工具： 采用预设分析模式（如CPU Bottlenecks） 分解指令吞吐量为有效工作与瓶颈工作 SwiftUI工具： 列表更新速度最高提升16倍 新增时间线和”View Body Updates”摘要 因果图帮助追踪过度更新根源 Power Profiler： 新增”被动”记录模式 可视化系统功耗和设备散热状态 分析各组件（CPU/GPU/网络）能耗影响 Xcode Organizer： 新增Trending Insights功能（标识异常趋势） Metrics区域提供基于类似应用的优化建议 构建系统革新Xcode 16引入的显式构建模块现已默认支持Swift代码。这种三阶段构建方式（扫描、构建模块、最终构建）优化了构建管道，提高效率与可靠性，同时加速Swift代码调试（调试器可复用已构建模块）。 重大变化： Apple开源了Swift Build构建引擎 正将其整合至Swift Package Manager 实现跨平台统一构建体验（支持Linux/Windows/Android等） 安全增强：新增Enhanced Security功能为应用提供与原生Apple应用同等的安全保护（如指针验证），特别建议高风险应用（如社交媒体、即时通讯）启用。 测试体验升级UI测试获得多项改进： 自动化录制增强： 配合全新代码生成系统 直观记录交互操作并转化为最优测试代码 测试报告改进： 集成自动化管理器 支持回放测试录像 检查元素属性并生成修正代码 硬件交互支持： 新增键盘和按钮操作测试能力 性能测量： XCTHitchMetric帮助测试UI灵敏度 报告卡顿指标（如Hitch Time Ratio） 测试计划扩展： 包含更多运行时API检查 Thread Performance Checker检测主线程上的非UI工作 可将违规情况标记为测试失败 总结Xcode 26通过全方位的改进，显著提升了开发者的工作效率和应用性能。无论是通过精简的安装包、智能的编程辅助，还是强大的调试和测试工具，Xcode 26都致力于成为开发者在各开发阶段的得力助手。开发者现在即可下载Xcode 26，体验这些新特性带来的便利。 相关视频了解焕然一新的 App 图标使用 Icon Composer 构建图标分析并优化 App 的功耗录制、重播和查看：使用 Xcode 实现 UI 自动化跟着视频学编程：使用 Xcode 探索本地化通过 Instrument 优化 SwiftUI 性能通过 Instruments 优化 CPU 性能Swift 的新功能SwiftUI 的新功能揭秘显式构建的模块探索 UI 动画阻碍与渲染循环 文档资源使用 Processor Trace 分析 CPU 使用情况为应用启用增强安全功能使用 Power Profiler 测量应用功耗理解与优化 SwiftUI 性能Xcode 更新日志","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"Swift 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_245/","text":"与我们一起了解 swift 的最新更新。我们将讨论有助于提高效率的工作流程改进，以及用于处理基本编程任务的全新现代 api 资源库。我们还将举例说明 swift 在软件堆栈各层的广泛采用情况。最后，我们将探索新的语言特性，这些特性有助于提高并发易用性，同时确保在需要时实现最佳性能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Swift 的新功能引言Swift 6.2 带来了从开发工具到语言特性的全方位改进。本文全面解析这些新功能，帮助开发者了解如何利用这些改进提升开发效率、编写更安全的代码以及在不同平台上部署 Swift 应用。 开发工作流程改进编写代码体验优化VS Code 开发体验得到显著提升，swift.org 验证的 Swift 扩展带来了多项新功能： 后台索引支持使代码导航保持实时更新 智能代码补全功能更加精准 调试配置自动完成 新增项目面板简化依赖管理 实时文档预览功能实现边写代码边查看文档更新 构建系统改进Swift 6.2 构建性能显著提升： 宏 API 项目构建时间大幅缩短 预构建的 swift-syntax 依赖项消除额外构建步骤 编译器诊断信息更加详细 新增灵活的警告控制机制 调试功能增强异步代码调试体验全面升级： LLDB 支持跟随异步函数跨线程执行 调试器理解任务模型并显示任务信息 新增 swift task info 等调试命令 “显式构建模块”功能加速调试会话 现代化 API 库子进程处理新 Subprocess 包简化了脚本编写： 12import Subprocesslet result = try await run(.name(&quot;pwd&quot;)) 支持进程状态检查与精细控制，当前为 0.1 版本，期待开发者反馈。 Foundation 改进通知 API 升级为类型安全版本： 123center.addObserver(of: screen, for: .keyboardWillShow) &#123; keyboardState in let startFrame = keyboardState.startFrame&#125; 消除了类型转换样板代码，同时支持线程位置指定。 观察模式Observation 库提供状态自动追踪： 1234@Observableclass Player &#123; var score: Int = 0&#125; Observations 类型生成异步序列确保事务性更新。 测试框架Swift Testing 新增功能： 诊断附件记录测试相关数据 退出测试验证预期终止的代码 123456@Testfunc invalidProposalPrefix() async throws &#123; await #expect(processExitsWith: .failure) &#123; // 测试代码 &#125;&#125; 全栈 Swift 应用嵌入式开发Embedded Swift 扩展支持更多功能： 完整字符串 API 受限类协议的 any 类型 新标准库类型 InlineArray 和 Span 用于 iOS 底层软件如内存权限管理。 安全增强新增”严格内存安全”模式： 要求明确标记不安全 API 新增 C/C++ 头文件注释 WebKit 等关键组件已采用 服务器端Swift 在 Apple 服务中表现优异： 密码服务吞吐量提升 40% Things App 响应时间缩短 400% 生态系统更新包括 gRPC 2.0 和新的容器化库。 平台扩展新增支持： FreeBSD 服务器平台 WebAssembly 虚拟机平台 SwiftWasm 实现 JS 互操作 语言特性演进性能优化新增高效类型： InlineArray：固定大小数组 Span：安全内存访问替代指针 1let numbers: InlineArray&lt;3, Int&gt; = [1, 2, 3] 并发改进关键优化包括： 未绑定 Actor 函数安全执行 隔离协议实现 可选主 Actor 推断模式 @concurrent 标记 CPU 密集型任务 12@concurrent static func extractSubject(from data: Data) async -&gt; Sticker &#123;&#125; 总结Swift 6.2 通过开发工具、API 库、平台支持和语言特性等多方面改进，显著提升了开发效率和代码安全性。这些变化源于社区协作，欢迎开发者参与 Swift 未来发展。 相关视频了解 Containerization优化 Swift 代码的内存使用和性能安全地混合使用 C、C ++ 和 Swift探索 Swift 和 Java 互操作性跟着视频学编程：使用 Swift 并发机制提升 App 性能采用 Swift 并发利用 Embedded Swift 实现轻量级开发探索 Swift 性能揭秘显式构建的模块 文档Swift 官方网站","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"探索设备端基础模型的提示设计和安全","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_248/","text":"设计充分发挥 foundation models 框架优势的生成式 ai 体验。首先我们将展示如何为 apple 智能核心的设备端大语言模型设计提示。然后，我们将介绍 ai 安全方面的关键理念，并提供切实可行的具体策略来助你打造安全、可靠且令人愉悦的生成式 ai 功能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索设备端基础模型的提示设计与安全引言在WWDC演讲中，Apple详细介绍了如何为设备端大语言模型（LLM）设计高效安全的提示（prompt），以及如何构建注重AI安全的生成式AI体验。本文将深入解析这些关键内容，帮助开发者充分利用Foundation Models框架的能力。 设备端LLM的设计策略Apple的设备端语言模型虽然经过优化和压缩（约30亿参数），仍能处理多种常见语言任务： 摘要生成 分类 多轮对话 文本创作与修订 文本标签生成 与云端数千亿参数的大模型相比，设备端LLM存在一些重要限制： 任务复杂度：复杂推理任务需分解为简单步骤 数学运算：建议使用传统代码处理 代码生成：未经优化，应避免使用 世界知识：训练数据时效性有限，不可完全依赖其提供事实 开发者需特别注意”幻觉”现象——模型对未知知识可能完全虚构答案。在需要准确事实的场合，建议： 12// 最佳实践：在提示中写入已验证信息let verifiedPrompt = &quot;基于以下已验证信息：(百吉饼主要成分是面粉、水、酵母和盐)，请描述原味百吉饼的特点&quot; 提示工程最佳实践提示工程是发挥模型潜力的关键。Apple分享了几个实用技巧： 控制输出长度： “只写一段” “用三句话” “详细描述” 风格控制： 1let stylePrompt = &quot;扮演用莎士比亚英语说话的狐狸，写一篇日记&quot; 清晰指令设计： 单一明确任务 提供少量示例(少于5个) 使用”DO NOT”终止不良输出 Xcode的Playground功能是实验提示的理想工具： 123#Playground// 尝试不同提示并实时查看结果let testPrompt = &quot;生成一个适合6岁儿童的太空冒险故事&quot; 指令与提示的协作指令作为Foundation Models框架的特殊提示类型，能持久影响模型行为： 12345// 设置全局指令let instruction = &quot;你是一个乐于助人的助手，专门为青少年生成适合的恐怖故事&quot;// 后续提示将遵循该指令let followUpPrompt = &quot;写一首关于百吉饼的诗&quot; // 输出将是恐怖风格的百吉饼诗 AI安全的多层防护策略Apple为Foundation Models框架构建了完整的安全体系： 内置安全防护：拦截有害的输入/输出 安全指令：优先于普通提示 输入控制：谨慎处理用户输入 场景缓解：针对应用特性定制防护 安全错误处理示例： 123456do &#123; try await model.generate(with: prompt)&#125; catch &#123; // 对用户发起的功能提供适当反馈 showAlert(&quot;内容无法生成，请尝试其他提示&quot;)&#125; 评估与测试方法开发生成式AI功能时，建议： 构建质量和安全测试数据集 设计自动化测试方案 人工检查关键场景 异常路径测试 持续监控改进 结论通过合理运用提示工程技术和多层安全防护，开发者可以在设备端创建既强大又安全的生成式AI体验。Apple的Foundation Models框架提供了必要的工具和防护，而开发者需要针对具体应用场景完善设计和测试。 相关文档人机界面指南：生成式 AI人机界面指南：机器学习提升生成模型输出的安全性","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"将隐私保护融入开发流程","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_246/","text":"从规划阶段到部署，了解如何在你的 app 中内置隐私保护功能。我们会介绍在开发生命周期各个阶段整合隐私保护功能的实用方法，重点关注数据最小化、设备端处理以及透明度和控制权。探索如何使用 apple 丰富的工具和框架来保护用户数据，打造尊重隐私的 app 体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 将隐私保护融入开发流程：从规划到部署的全方位实践概述在当今数据驱动的应用生态中，隐私保护已成为开发者不可忽视的关键要素。Apple隐私工程师Joey Tyson在WWDC演讲中系统性地分享了如何将隐私保护理念贯穿应用开发的完整生命周期。本文将从Apple的隐私理念出发，详解规划、设计、开发等各阶段的具体实践方法，帮助开发者构建真正尊重用户隐私的应用。 Apple的隐私理念解析Apple对隐私的定义源于Steve Jobs在2010年提出的核心理念：让用户清楚地理解并同意数据处理的方式。Tim Cook进一步阐述了Apple的隐私支柱原则： 数据最小化：仅收集必要数据 设备端处理：尽可能在本地处理数据 透明度和控制权：确保用户知情并拥有选择权 安全保护：通过技术手段保障数据安全 这些原则构成了Apple平台隐私技术的理论基础，也是开发者应当遵循的指导方针。 开发阶段的隐私实践规划阶段：定义隐私承诺规划阶段是建立应用隐私故事的起点。开发者应当在此阶段明确隐私承诺，即关于用户数据处理的概括性声明。以虚构应用”Pal About”为例，其隐私承诺可包括： “我们仅保留聚合使用数据”（数据最小化） “搜索时默认不存储您的位置”（强默认值） “建议地点仅使用设备端数据生成”（设备端处理） “上传照片需用户明确选择用于模型训练”（透明度与控制） “无法读取传输中的消息”（安全保护） 这些承诺不仅指导开发方向，也是与用户建立信任的基础。 设计阶段：构建信任体验优秀的设计能够自然地教育用户而不造成负担。Apple建议遵循以下设计准则： 主动设定预期：首次启动时展示隐私摘要，提供详细信息链接 明确状态变化：使用视觉反馈（如Siri动画、麦克风指示器） 情境化选择：在最相关时机提供有实质影响的选项 例如，连接流媒体设备的功能应当在用户决定使用时才请求网络权限，并清晰说明原因。更多设计规范可参考Apple的”人机界面指南”。 开发阶段：技术实现用户界面隐私优化Apple平台提供了多种减少权限请求的技术方案： PhotosPicker：避免全图库访问，仅获取用户选择的照片 123456789// 示例代码：使用PhotosPickerimport PhotosUIvar body: some View &#123; PhotosPicker(selection: $selectedItems, matching: .images) &#123; Label(&quot;Select photos&quot;, systemImage: &quot;photo&quot;) &#125;&#125; 位置按钮：一键分享当前位置，系统验证用户意图 123456789// 示例代码：添加位置按钮import CoreLocationUIvar body: some View &#123; LocationButton &#123; // 处理位置获取 &#125; .labelStyle(.titleAndIcon)&#125; 其他方案还包括联系人选择器、UIPasteControl按钮等，这些工具显著降低了用户的认知负担。 客户端-服务器交互 CloudKit端到端加密：123// 示例代码：使用CloudKit加密let record = CKRecord(recordType: &quot;PrivateNote&quot;)record.encryptedValues[&quot;content&quot;] = &quot;Secret message&quot; 开发者应避免在查询谓词中使用加密字段，因为CloudKit不支持加密字段索引。 同态加密与PIR：允许服务器处理加密数据而不知内容，特别适合敏感场景如位置查询。 反欺诈与广告归因： 私有访问令牌替代CAPTCHA DeviceCheck API追踪设备状态 AdAttributionKit实现隐私友好的广告效果衡量 本地资源处理Core ML支持完全设备端的模型训练与推理，结合优化技术可运行各类开源或自定义模型，确保敏感数据不离开设备。 测试与部署阶段虽然演讲稿未详细展开，但测试阶段应验证所有隐私承诺的实现情况，部署阶段需确保隐私政策与实际操作一致。持续的隐私审核和维护同样重要。 总结将隐私保护融入开发流程需要从规划开始的全方位考虑。通过Apple提供的丰富工具链和遵循隐私设计原则，开发者既能创造出色的用户体验，又能尊重用户的数据主权。正如Joey Tyson强调的，隐私不是事后的附加功能，而是需要从第一天就开始构建的核心价值。 相关视频与文档 在应用中嵌入照片选择器 - WWDC23 认识位置按钮 - WWDC21 CloudKit新功能 - WWDC21 用私有访问令牌取代CAPTCHA - WWDC22 用App Attest和DeviceCheck减少欺诈 - WWDC21 认识AdAttributionKit - WWDC24 AdAttributionKit新功能 - WWDC24 Apple人机界面指南","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"将结构化并发代码与 Network 框架搭配使用","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_250/","text":"network 框架是在 apple 平台上建立底层网络连接的最佳方式，而在 ios、ipados、和 macos 26 上，它非常适合与你的结构化并发代码搭配使用。我们将探索如何建立连接、发送和接收数据与分帧处理的信息、监听传入连接以及浏览网络上的服务。在此期间，我们还将介绍一些关键的最佳做法。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 Network 框架中的结构化并发编程Network 框架作为 Apple 平台底层网络连接的核心解决方案，在 iOS、iPadOS 和 macOS 26 系统中迎来了重大革新。该框架现已深度整合 Swift 的结构化并发特性，为开发者提供了更加现代化、简洁高效的网络编程体验。 现代化网络连接的构建Network 框架彻底摒弃了传统 socket 编程的复杂性，无需开发者处理 sockaddr 结构体或晦涩的 ioctl 调用。取而代之的是优雅的声明式 API 设计和自动化的网络管理功能。 框架内置的关键特性包括： 自动域名解析的”按名连接”(Connect by Name)功能 动态选择最优路径的”快乐眼珠”(Happy Eyeballs)算法 原生的 TLS 加密支持 智能网络接口切换和代理支持 现代传输协议如 QUIC 的原生集成 这些特性使开发者能够专注于业务逻辑，而不必操心底层网络细节。 声明式连接建立在 iOS/macOS 26 中，建立网络连接变得前所未有的简单。开发者只需指定三个核心要素： 端点(Endpoint) - 定义连接目标 协议栈(Protocol Stack) - 规定连接方式 参数(Parameters) - 细化连接配置 一个典型的 TLS 加密连接示例： 123let connection = NetworkConnection(to: .hostPort(host: &quot;www.example.com&quot;, port: 1029)) &#123; TLS()&#125; 框架会自动推断并添加必要的 TCP 和 IP 协议层。如需进一步自定义，开发者可以使用嵌套式的声明语法： 12345678let connection = NetworkConnection(to: .hostPort(host: &quot;www.example.com&quot;, port: 1029) &#123; TLS &#123; TCP &#123; IP() .fragmentationEnabled(false) &#125; &#125;&#125; 智能化数据传输Network 框架的数据收发操作完全采用异步设计，与 Swift 的结构化并发完美融合。基本的数据收发操作简洁明了： 1234let outgoingData = Data(&quot;Hello, world!&quot;.utf8)try await connection.send(outgoingData)let incomingData = try await connection.receive(exactly: 98).content 对于不确定长度的数据流，框架提供了灵活的接收模式： 1234while remaining &gt; 0 &#123; let imageChunk = try await connection.receive(atLeast: 1, atMost: remaining).content remaining -= imageChunk.count&#125; 消息分帧与对象传输为解决流式协议的消息边界问题，iOS/macOS 26 引入了 TLV (Type-Length-Value) 分帧器： 123456789enum GameMessage: Int &#123; case selectedCharacter = 0 case move = 1&#125;let connection = NetworkConnection(to: .hostPort(host: &quot;www.example.com&quot;, port: 1029)) &#123; TLV &#123; TLS() &#125;&#125;try await connection.send(characterData, type: GameMessage.selectedCharacter.rawValue) 更令人惊喜的是对 Swift Codable 的原生支持，开发者可以直接收发对象： 12345678910enum GameMessage: Codable &#123; case selectedCharacter(String) case move(row: Int, column: Int)&#125;let connection = NetworkConnection(to: .hostPort(host: &quot;www.example.com&quot;, port: 1029)) &#123; Coder(GameMessage.self, using: .json) &#123; TLS() &#125;&#125;try await connection.send(GameMessage.selectedCharacter(&quot;🐨&quot;))let message = try await connection.receive().content 服务监听与设备发现处理入站连接的 NetworkListener 采用了与 NetworkConnection 类似的设计模式： 1234567try await NetworkListener &#123; Coder(GameMessage.self, using: .json) &#123; TLS() &#125;&#125;.run &#123; connection in for try await (gameMessage, _) in connection.messages &#123; // 处理游戏消息 &#125;&#125; 设备发现方面，新的 NetworkBrowser 整合了 Wi-Fi Aware 技术，支持跨平台点对点发现： 123let endpoint = try await NetworkBrowser(for: .wifiAware(.connecting(to: .allPairedDevices, from: .ticTacToeService))).run &#123; endpoints in .finish(endpoints.first!)&#125; 协议选择指南开发者可根据不同场景选择合适的协议组合： 与第三方服务通信：遵循对方协议规范 自主应用间通信：推荐 Codable + TLS/QUIC 现有 URLSession 用户：可继续使用现有方案 总结iOS/macOS 26 为 Network 框架带来的革新包括： 三大核心组件：NetworkConnection、NetworkListener、NetworkBrowser 新型消息分帧器和对象传输支持 声明式 API 设计语言 深度结构化并发集成 这些改进使网络编程更加现代化、高效，同时保持了框架原有的灵活性和强大功能。开发者现在可以更轻松地构建可靠、安全的网络应用，充分发挥 Swift 并发的优势。 相关视频借助 Wi-Fi Aware 增强设备连接性能采用 Swift 并发Introducing Network.framework: A modern alternative to Sockets 文档资源NetworkNetworkBrowserNetworkConnectionNetworkListener","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"利用拍摄控件提升你的相机体验","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_253/","text":"了解如何为你的相机体验自定拍摄控件。我们将向你展示如何使用各种实体拍摄控件 (包括新增的 airpods 支持) 拍摄照片，以及如何使用相机控制来调整设置。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 利用拍摄控件提升相机体验在WWDC 2024技术分享中，苹果工程师详细介绍了如何利用拍摄控件API为相机应用构建更丰富的交互体验。本文将系统梳理这些创新功能，包括物理按键控制、AirPods远程拍摄以及iPhone 16相机控制功能等核心技术。 物理拍摄控制概述AVCaptureEventInteraction API为开发者提供了将物理按键映射到相机操作的强大能力。该技术允许用户通过音量键、操作按钮等硬件控制直接触发拍照或录像功能，无需依赖屏幕触控。 iOS系统通过三个阶段精确捕捉物理按键的整个按压生命周期： began阶段标识按键按下时刻 cancelled阶段处理意外中断 ended阶段对应按键释放动作 关键技术实现在SwiftUI环境中，开发者可以通过onCameraCaptureEvent视图修饰符轻松实现物理按键控制。以下代码展示了如何构建基础拍摄功能： 12345.onCameraCaptureEvent &#123; event in if event.phase == .ended &#123; camera.capturePhoto() &#125;&#125; 值得注意的是，API区分了主次操作按键。主操作由音量减小键、操作键和相机控制键触发，而次操作则专属音量增大键。这种设计既保证了操作逻辑的清晰性，又为不同拍摄场景提供了灵活性。 AirPods远程控制创新iOS 26引入了通过AirPods进行远程相机控制的新功能。配备H2芯片的AirPods可以通过耳柄点击触发拍摄操作，为使用者带来全新的远程拍摄体验。 系统提供了默认的音频反馈机制，但开发者也可以根据应用场景进行自定义： 12345678.onCameraCaptureEvent(defaultSoundDisabled: true) &#123; event in if event.phase == .ended &#123; if event.shouldPlaySound &#123; event.play(.cameraShutter) &#125; &#125; camera.capturePhoto()&#125; 该功能特别适合需要远距离拍摄的场景，如团体合影或野生动物摄影，大大扩展了iPhone相机的使用场景。 iPhone 16相机控制功能iPhone 16引入的相机控制功能将物理硬件与软件体验完美结合。该功能支持三种主要操作模式： 点击启动相机应用 作为快门按钮使用 通过滑动进行快速参数调整 系统提供了两种控制类型供开发者使用： 数值滑块（包括连续型和离散型） 列表选择器 以下代码展示了如何在应用中添加系统预置的变焦控制： 123let zoomControl = AVCaptureSystemZoomSlider(device: device) &#123; [weak self] zoomFactor in self?.updateUI(zoomFactor: zoomFactor)&#125; 对于需要自定义控制的场景，开发者可以创建效果选择器等个性化交互元素。关键是要确保控制逻辑与拍摄体验紧密相关，避免引入不必要的复杂性。 最佳实践与注意事项在实现拍摄控件时，开发者需要注意以下几点： 必须正确处理所有事件阶段，避免按键失效 后台应用不会接收拍摄事件 自定义音频反馈应符合场景需求 相机控制应专注于影响拍摄效果的参数 需考虑UI与硬件控制的同步问题 开发资源与参考苹果开发者网站提供了丰富的相关资源，包括： 相机控制的人机界面指南 AirPods测试配置指南 多种示例代码和技术文档 通过合理运用这些API和技术，开发者可以为用户打造媲美原生相机应用的优质体验，充分利用iPhone的硬件优势和创新功能。 相关视频打造出色的锁定屏幕相机拍摄体验在 iPadOS App 中支持外部摄像头探索 tvOS 连续互通相机 文档资源Accessing the camera while multitaskingAVFoundationCapture setupCapturing Photos with DepthCreating a camera experience for the Lock ScreenCreating a camera extension with Core Media I/ODockKitScanning data with the cameraSupporting Continuity Camera in your tvOS app","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"针对 visionOS 设计小组件","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_255/","text":"了解如何为 visionos 26 设计美观的小组件，确保完美融入用户周围的环境。了解如何在小组件设计中添加深度，并为空间计算自定材质、尺寸和风格。我们将介绍如何针对 visionos 调整你现有的小组件，或设计出类似真实物体的全新小组件。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为 visionOS 设计小组件：打造沉浸式空间体验概述在 WWDC 的「为 visionOS 设计小组件」专题演讲中，Jonathan 和 Moritz 详细介绍了如何在 visionOS 26 平台上设计美观且功能强大的小组件。这些三维小组件将打破传统屏幕限制，自然融入用户周围环境，为空间计算体验带来革命性变化。 核心设计原则visionOS 的小组件设计建立在四大核心原则之上： 持久性：空间中的恒定存在一旦用户将小组件放置在环境中，它就会永久驻留在选定位置。这种持久性体现在： 多实例支持：同一小组件可在空间中有多个副本 物理吸附特性：仅附着于真实物理表面，不会存在于虚拟环境中 自动排列：墙面放置时会自动形成网格布局 固定尺寸：现实世界的比例感visionOS 的小组件采用真实物理尺度： 提供多种与现实物体匹配的模板尺寸 用户可在75%-125%范围内缩放 设计需考虑不同放置场景（墙面、桌面等） 视觉风格与定制化Moritz 详细介绍了 visionOS 小组件的两大视觉风格系统： 纸张风格 模拟实体印刷品质感 完全响应环境光照 由框架、内容层和反射涂层构成 适合需要与环境高度融合的场景 玻璃风格 强调内容清晰度和对比度 前景元素不受环境光影响 多层结构创造深度感 适合信息密集型内容展示 用户可通过丰富的选项个性化小组件： 14种系统调色板选择（7浅色+7深色） 两种悬挂样式（凸起式/嵌入式） 五种可调框架宽度 开发者可扩展配置UI加入专属选项 距离感知与交互设计visionOS 小组件的独特能力在于： 根据用户距离动态调整布局 提供默认（近）和简化（远）两种显示状态 保持核心元素在不同距离下的连续性 优化交互区域的可触达性 设计建议： 远距离时精简信息，保留核心内容 近距离时展示更多细节 确保交互元素大小适合不同距离操作 实现路径对于开发者而言，有两种主要实现方式： 兼容模式：现有iPad小组件自动获得空间化呈现 原生构建：专门为visionOS设计，可充分利用平台特性 特别推荐观看「WidgetKit新特性」会议获取技术实现细节。 设计最佳实践总结关键设计要点： 考虑小组件在真实环境中的使用场景 选择适合内容特性的模板尺寸 决定采用纸张还是玻璃风格 实现合理的距离感知响应 提供有意义的定制选项 相关文档：为 visionOS 更新小组件 visionOS 为小组件设计开启了全新维度，开发者现在有机会创造既实用又极具沉浸感的3D空间体验，让数字内容真正成为用户环境的一部分。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"探索 Metal 4 游戏","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_254/","text":"了解如何借助 metal 4 的最新改进来优化游戏引擎。我们将介绍如何统一命令编码来充分降低 cpu 开销，如何扩大图形资源管理来支持海量场景并最大限度地提高内存预算，以及如何快速载入大型管道状态库。 为了充分从这个讲座中获益，请先观看“探索 metal 4”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Metal 4游戏技术深度解析：优化引擎性能的全新能力引言Metal 4作为苹果新一代图形API，专为满足现代游戏引擎的高性能需求而设计。本文将详细解析Metal 4在命令编码、资源管理和管线加载三大核心领域的技术革新，帮助开发者充分挖掘Apple芯片的图形处理潜力。 统一命令编码系统计算操作的统一处理Metal 4将所有计算操作（包括内核调度、块传输和加速结构构建）统一整合到单一计算编码器中实现。这种设计允许开发者在单个编码器内完成多种计算任务，显著降低了CPU开销。 关键技术实现包括：1234567891011// 在编码器中同步访问缓冲区id&lt;MTL4ComputeCommandEncoder&gt; encoder = [commandBuffer computeCommandEncoder];[encoder copyFromBuffer:src sourceOffset:0 toBuffer:buffer1 destinationOffset:0 size:64];[encoder barrierAfterEncoderStages:MTLStageBlit beforeEncoderStages:MTLStageDispatch visibilityOptions:MTL4VisibilityOptionDevice];[encoder setComputePipelineState:pso];[argTable setAddress:buffer1.gpuAddress atIndex:0];[encoder setArgumentTable:argTable];[encoder dispatchThreads:threadsPerGrid threadsPerThreadgroup:threadsPerThreadgroup];[encoder endEncoding]; 渲染编码的优化颜色附件映射技术允许开发者通过动态调整颜色输出与附件的对应关系，减少所需渲染编码器的数量。实现流程包括： 配置支持附件映射的渲染通道描述符： 123MTL4RenderPassDescriptor *desc = [MTLRenderPassDescriptor renderPassDescriptor];desc.supportColorAttachmentMapping = YES;desc.colorAttachments[0].texture = colortex0; 创建逻辑与物理索引的映射表： 12[myAttachmentRemap setPhysicalIndex:0 forLogicalIndex:0];[myAttachmentRemap setPhysicalIndex:3 forLogicalIndex:1]; 高效资源管理命令内存管理Metal 4引入命令分配器概念，开发者可以： 重置已完成任务的分配器以复用内存 采用多分配器策略实现GPU工作期间的持续编码 需要注意分配器的非线程安全特性，不同线程应使用独立分配器 多线程编码支持Metal 4命令缓冲区支持多线程编码，典型使用模式：12345id&lt;MTL4RenderCommandEncoder&gt; enc0 = [cmdbuf0 renderCommandEncoderWithDescriptor:desc options:MTL4RenderEncoderOptionSuspending];id&lt;MTL4RenderCommandEncoder&gt; enc1 = [cmdbuf1 renderCommandEncoderWithDescriptor:desc options:MTL4RenderEncoderOptionResuming | MTL4RenderEncoderOptionSuspending]; [commandQueue commit:cmdbufs count:3]; 资源绑定与同步参数表与驻留集技术实现了： 单个参数表索引数千资源 驻留集统一管理GPU资源可见性 新增队列等待与信号接口实现精确同步：1234[queue waitForDrawable:drawable];// 编码渲染命令...[queue signalDrawable:drawable];[drawable present]; 管线状态优化Metal 4在管线状态管理方面提供三项重大改进： 灵活渲染管线状态：先创建未特化管线，再快速生成特化版本 12345pipelineDescriptor.colorAttachments[i].pixelFormat = MTLPixelFormatUnspecialized;id&lt;MTLRenderPipelineState&gt; transparentPipeline = [compiler newRenderPipelineStateBySpecializationWithDescriptor:pipelineDescriptor pipeline:unspecializedPipeline error:&amp;error]; 多线程编译：通过GCD或自定义线程池加速编译 预编译管线：开发期生成二进制归档，运行时直接加载 总结与应用建议Metal 4为游戏引擎优化提供了全方位技术支持，开发者应重点关注： 编码效率提升：统一编码器、内存复用、多线程编码 资源管理优化：参数表、驻留集、队列屏障 管线加载加速：特化编译、多线程优化、预编译方案 建议开发者： 使用Instruments分析性能关键管线 对关键管线保持完整编译确保最佳性能 合理使用多分配器策略优化内存使用 充分利用预编译技术减少玩家等待时间 相关视频探索 Metal 4深入探索 Metal 4 游戏用于打造沉浸式 App 的 Metal 渲染的新功能让游戏更上一层楼 文档人机界面指南：游戏设计理解 Metal 4 核心 API使用 Metal 4 编译 API","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"提升 App 的音频录制功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_251/","text":"了解如何提升 app 的音频录制功能。探索如何通过 ios 和 ipados 26 上的输入选择器交互来灵活地选择音频设备。了解有哪些 api 可帮助你通过 airpods 进行高质量录音。我们还将介绍空间音频录制和编辑功能，这些功能可让你隔离语音和环境背景音，所有这些功能均可使用 audiotoolbox、avfoundation 和 cinematic 框架实现。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 增强应用的音频录制能力：iOS 26音频技术全面解析引言在iOS 26和iPadOS 26中，苹果为开发者带来了一系列强大的音频录制功能增强。从灵活的输入设备选择到专业级的空间音频处理，这些新特性为音频类应用开辟了新的可能性。本文将详细解析这些技术革新，帮助开发者充分利用这些功能提升应用体验。 输入设备选择新方式传统上，用户在应用中切换音频输入设备需要跳转到系统设置，这种体验不够流畅。iOS 26通过AVKit框架引入了全新的输入选择机制。 集成输入选择器开发者现在可以在应用中直接展示一个输入设备选择菜单。该菜单不仅列出可用设备，还能实时显示各设备的音量电平。以下是关键实现步骤： 12345678910111213import AVKitclass AppViewController &#123; let inputPickerInteraction = AVInputPickerInteraction() inputPickerInteraction.delegate = self @IBOutlet weak var selectMicButton: UIButton! self.selectMicButton.addInteraction(self.inputPickerInteraction) @IBAction func handleSelectMicButton(_ sender: UIButton) &#123; inputPickerInteraction.present() &#125;&#125; 系统会自动记忆用户的选择，在应用下次启动时保持相同的输入配置。这种设计特别适合播客录制、音乐创作等需要频繁切换设备的应用场景。 专业级AirPods录音AirPods因其便携性成为许多用户的录音首选，iOS 26为其新增了高质量录音模式。 技术实现该模式通过两种方式启用： 对于AVAudioSession用户： 1AVAudioSessionCategoryOptions.bluetoothHighQualityRecording 对于AVCaptureSession用户： 1session.configuresApplicationAudioSessionForBluetoothHighQualityRecording = true 该模式优化了蓝牙连接稳定性，并提供了类似专业LAV麦克风的音质平衡，特别适合人声录制。当高质量模式不可用时，系统会自动回退到标准蓝牙模式。 空间音频录制与处理空间音频技术为音频体验增加了三维沉浸感，iOS 26在该领域有显著增强。 录制技术原理空间音频录制使用麦克风阵列捕获3D场景信息，并转换为Ambisonics格式（一种基于球面谐波的音频编码方式）。具体来说，它记录： 一个全向声压分量 三个方向性分量（X/Y/Z轴） API更新iOS 26新增了.qta格式支持，使纯音频应用也能保存空间音频数据。开发者可以： 12// 设置多声道音频模式multichannelAudioMode = .firstOrderAmbisonics 专业音频混音控制Cinematic框架新增的音频混音功能让开发者能精确控制人声与环境音的平衡。 关键API12345678import Cinematicvar intensity: Float32 = 0.5var style = CNSpatialAudioRenderingStyle.cinematiclet audioInfo = try await CNAssetSpatialAudioInfo(asset: myAVAsset)let newAudioMix = audioInfo.audioMix(effectIntensity: intensity, renderingStyle: style)myAVPlayerItem.audioMix = newAudioMix 系统提供三种预设模式（Cinematic、Studio和In-Frame）以及六种扩展模式，满足不同场景需求。 结论与最佳实践iOS 26的音频技术革新为开发者提供了更专业的工具链。建议开发者： 集成AVInputPickerInteraction提升输入切换体验 为AirPods用户启用高质量录音模式 利用空间音频API创造沉浸式体验 使用音频混音功能优化音效平衡 这些功能组合使用，可以显著提升音乐、播客、视频编辑等类型应用的专业性和用户体验。 相关资源相关视频利用拍摄控件提升你的相机体验在你的App中录制电影效果视频 文档AVFoundationCinematicTN3177: Understanding alternate audio track groups in movie files","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"使用 EnergyKit 优化家庭用电量","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_257/","text":"了解如何在你的 app 中支持 energykit，以便用户可以优化家庭用电量。这可以帮助用户在电力更清洁、更便宜的时段运行电器或为电动汽车充电。详细了解如何进行设置，如何生成充电计划，以及如何通过用电量反馈向用户提供能耗洞察信息等详情。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 EnergyKit 优化家庭用电量EnergyKit 是一个强大的框架，帮助开发者将电网洞察信息整合到住宅应用中，使用户能够更智能地管理家庭用电。本篇文章将详细介绍如何将 EnergyKit 集成到应用中，帮助用户在更清洁且可能更便宜的时段运行电器或为电动汽车充电。 什么是 EnergyKit？EnergyKit 是苹果推出的一个框架，旨在帮助开发者获取电网预测信息，优化家庭用电。该框架支持开发者获取用电指导、生成充电计划，并通过用电量反馈向用户提供能耗洞察信息。通过 EnergyKit，用户可以了解电网中相对清洁的电力供应时段，从而优化用电行为。 加入 EnergyKit将 EnergyKit 集成到应用的第一步是让用户选择加入”清洁能源充电”体验。用户需要为每个希望使用更清洁电力充电的地点进行选择。在应用中，可以通过一个开关控件让用户选择是否启用”清洁能源充电”功能。 加入流程的核心是 EnergyVenue，它代表一个物理场所，设备从电网消耗电力。开发者可以通过 EnergyVenue.venue(for: venueID) 方法检索用户选择的地点。每次应用启动时，都应检查用户之前选择的场所是否仍然有效。 以下是检索 EnergyVenue 的代码示例： 12345678910111213141516// Retrieve an EnergyVenueimport EnergyKitimport Foundation@Observable final class EnergyVenueManager &#123; let venue: EnergyVenue init?(venueID: UUID) async &#123; guard let energyVenue = await EnergyVenue.venue(for: venueID) else &#123; return nil &#125; venue = energyVenue &#125;&#125; 生成充电计划选择 EnergyVenue 后，下一步是生成”清洁能源充电计划”。计划的基础是”用电指导”（Electricity Guidance），它提供用电优化的建议。”用电指导”分为两种类型： 减少（Reduce）：适用于智能恒温器等减少用电量的设备。 转移（Shift）：适用于电动汽车等可以调整用电时段的设备。 通过 ElectricityGuidance.sharedService.guidance(using:query,at:venueID) 方法可以获取用电指导。以下是获取用电指导的代码示例： 1234567891011121314151617181920212223// Fetch ElectricityGuidanceimport EnergyKitimport Foundation@Observable final class EnergyVenueManager &#123; // The current active guidance. var guidance: ElectricityGuidance? fileprivate func streamGuidance( venueID: UUID, update: (_ guidance: ElectricityGuidance) -&gt; Void ) async throws &#123; let query = ElectricityGuidance.Query(suggestedAction: .shift) for try await currentGuidance in ElectricityGuidance.sharedService.guidance( using: query, at: venueID ) &#123; update(currentGuidance) break &#125; &#125;&#125; 用电量反馈与洞察为了让 EnergyKit 提供准确的用电洞察，开发者需要提交充电设备的用电数据。这些数据通过 LoadEvents 提交，并在充电过程中定期更新。用电量按电网清洁度和电价分类： 清洁度分类： 清洁（Clean） 减少（Reduced） 避免（Avoided） 电价分类（如果有费率计划信息）： 超级非高峰（Super Off-Peak） 非高峰（Off-Peak） 部分高峰（Partial Peak） 高峰（Peak） 关键高峰（Critical Peak） 以下是创建和提交 LoadEvents 的代码示例： 123456789101112131415161718192021222324// Update charging measurementsimport EnergyKit// A controller that handles an electric vehicle@Observable class ElectricVehicleController &#123; fileprivate func chargingMeasurement() -&gt; ElectricVehicleLoadEvent.ElectricalMeasurement &#123; let stateOfCharge = Int(configuration.state.stateOfCharge.rounded(.down)) let power = Measurement&lt;UnitPower&gt;( value: configuration.properties.chargingPower * 1000000, unit: .milliwatts ) let energy = Measurement&lt;UnitEnergy&gt;( value: configuration.state.cummulativeEnergy * 1000000, unit: .EnergyKit.milliwattHours ) return ElectricVehicleLoadEvent.ElectricalMeasurement( stateOfCharge: stateOfCharge, direction: .imported, power: power, energy: energy ) &#125;&#125; 获取用电洞察提交 LoadEvents 后，开发者可以通过 ElectricityInsightQuery 获取用电洞察。以下是查询洞察的代码示例： 1234567891011121314// Create an insight queryimport EnergyKit@Observable final class EnergyVenueManager &#123; func createInsightsQuery(on date: Date) -&gt; ElectricityInsightQuery &#123; return ElectricityInsightQuery( options: .cleanliness.union(.tariff), range: self.dayInterval(date: date), granularity: .daily, flowDirection: .imported ) &#125;&#125; 总结EnergyKit 为开发者提供了强大的工具，帮助用户优化家庭用电。通过以下步骤可以完成集成： 用户加入：让用户选择加入”清洁能源充电”体验。 获取用电指导：使用 ElectricityGuidance 获取优化建议。 提交用电数据：通过 LoadEvents 反馈充电行为。 生成洞察：利用 ElectricityInsightQuery 提供用户用电报告。 开发者可以访问苹果官方文档进一步了解 EnergyKit 的实现细节，并通过示例代码优化应用功能。 相关视频完成后台任务探索 SwiftUI 中的并发机制 文档Apple 2030","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"SwiftUI 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_256/","text":"了解 swiftui 中用于为任一 apple 平台打造出色 app 的新功能。我们将探索如何通过 liquid glass 为你的 app 提供焕然一新的外观和风格。了解如何通过框架增强功能和新的 instrument 来提升性能，以及如何整合网页内容和多信息文本编辑等先进功能。我们还将向你展示 swiftui 如何扩充自身的应用范围，包括在三维空间中布局视图。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com SwiftUI 新特性深度解析：从设计革新到功能扩展苹果在最新 WWDC 大会上展示了 SwiftUI 框架的一系列重大更新，从视觉设计革新到底层性能优化，再到功能范围的扩展，为开发者构建跨平台应用提供了更强大的工具。 全新视觉设计系统本次更新最引人注目的变化之一是全新的设计语言——Liquid Glass（液态玻璃）。这种设计风格在所有 Apple 平台上实现了明亮流畅的一致体验，为应用界面带来焕然一新的视觉效果。 在 iPad 和 macOS 上，侧边栏现在呈现玻璃质感，能够反射周围内容；在 iPhone 上，工具栏项目采用了更紧凑的新外观。开发人员可以使用新的 glassEffect() 修饰符为自定义视图添加玻璃反射效果： 1.glassEffect() 工具栏布局也得到了改进，新增的 ToolbarSpacer API 允许开发者灵活调整工具栏项目间的间距： 1ToolbarSpacer(.fixed, placement: .primaryAction) 搜索功能的人机交互体验也得到优化，在 iPhone 上搜索栏现在位于屏幕底部更符合人体工学的位置，而开发者无需修改原有代码即可获得这一改进： 1234.searchable( text: $query, prompt: &quot;What are you looking for?&quot;) 性能与基础架构增强SwiftUI 在性能方面进行了多方面的优化，特别是在列表处理、滚动体验和分析工具方面： macOS 列表性能显著提升，加载 10 万+项目的列表速度提升 6 倍，更新速度提升最高达 16 倍 滚动性能改进降低了丢帧概率，保持高帧率流畅滚动 新增 Xcode 性能工具帮助开发者快速定位视图更新或平台视图问题 在动画方面，新引入的 @Animatable 宏简化了动画属性的定义过程： 1234@Animatablestruct LoadingArc: Shape &#123; @AnimatableIgnored var drawPathClockwise: Bool&#125; 三维空间布局与 visionOS 支持SwiftUI 首次将布局能力扩展到了三维空间，为 visionOS 开发提供了强大支持。新增的 Alignment3D 类型和 spatialOverlay 修饰符允许开发者在三维空间中精确定位视图： 12345.spatialOverlay( alignment: timeAlignment) &#123; Sun()&#125; 对于 visionOS 中的物体交互，新的 manipulable() 修饰符配合场景吸附 API 实现了自然的物理交互体验： 123.manipulable().opacity( snappingInfo.classification == .table ? 1.0 : 0.0) 视图功能扩展与系统整合SwiftUI 在功能扩展方面也取得了重大进展： 新增 WebView 组件为应用提供了完整的网页浏览能力 Swift Charts 现在支持 3D 图表，可用于展示地形等三维数据 TextEditor 增强了对 AttributedString 的支持，实现了富文本编辑功能 在系统整合方面，SwiftUI 的场景支持得到了扩展： 新增 RemoteImmersiveSpace 场景用于 Vision Pro 的立体内容渲染 辅助访问场景类型帮助认知障碍用户使用应用 小组件现在支持 visionOS 和 CarPlay 平台 学习资源与后续步骤开发者可以通过以下官方资源深入了解这些新特性： 相关视频：了解 SwiftUI 空间布局了解适用于 SwiftUI 的 WebKit使用全新设计系统构建 SwiftUI 应用借助 SwiftUI 在 visionOS 中设置场景将 Swift Charts 扩展成三维图表 文档资源：采用 Liquid Glass拖放操作 API)人机界面指南 这些新特性为开发者提供了更强大的工具来构建跨 Apple 平台的卓越应用，从视觉设计到性能表现，再到功能范围，SwiftUI 正变得越来越成熟和完善。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"Apple 设备管理和身份管理方面的新动向","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_258/","text":"本次讲座主要面向 it 管理员、mdm 开发者和身份提供商，内容涵盖声明式设备管理、apple 商务管理、apple 校园教务管理、平台单点登录等方面的最新更新。了解如何利用这些改进来简化部署流程、增强安全性，并提升用户体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple设备管理与身份管理新功能详解在最近的WWDC演讲中，Apple设备管理团队详细介绍了针对IT管理员、MDM开发者和身份提供商的一系列新功能。这些改进涵盖了从设备管理到身份集成的多个方面，旨在帮助组织更轻松地部署和保护Apple设备。 Apple服务更新Apple商务管理和Apple校园教务管理作为基础服务，获得了多项重要更新。首先是托管式Apple账户的强化功能： 域名锁定：允许IT接管特定域名创建的Apple账户 账户列表下载：方便管理员通知用户更新账户 访问管理扩展：禁止在组织设备上登录个人Apple账户 设备库存功能也得到增强，现在可以查看： 激活锁状态和设备存储 蜂窝网络信息（IMEI/EID） 设备释放记录 即将推出的MAC地址信息 AppleCare保修状态 特别值得一提的是新推出的Apple商务/校园教务管理API，它支持： 查询设备信息 设备管理服务分配 批量活动状态获取 设备管理增强设备管理方面，Apple带来了以下改进： 软件更新 声明式设备管理的更新控制扩展至Vision Pro和Apple TV 正式弃用传统MDM软件更新管理方式 Safari管理 声明式配置的书签管理 默认主页设置 现有限制整合 设备重置服务 iPhone/iPad可保留托管应用（仅清除用户数据） Vision Pro新增”为下个用户重置”选项 锁定界面长按数码表冠也可触发重置 其他更新包括： iPad电池健康信息 默认消息/通话应用设置 按SIM卡限制信息/FaceTime 临时使用AirPods/Beats耳机支持 应用管理新能力应用管理获得了重大改进，包括： iOS/iPadOS托管应用配置新增： 按应用定义更新行为 强制/禁用自动更新选项 版本锁定功能 实时安装进度反馈 macOS Tahoe新增： 声明式管理部署App Store/自定义应用 必需或可选部署选项 安装状态反馈 开发者方面，新增的ManagedApp框架支持： 安全部署应用配置 定制体验实现 API令牌获取 硬件绑定密钥等场景 身份集成改进身份验证是部署的关键环节，新功能包括： 平台单点登录（Platform SSO）优化： 自动设备注册期间完成注册 认证成功后同步创建本地账户 支持账户头像同步 认证访客模式： 直接从登录窗口使用云身份验证 登出后清除所有会话数据 可搭配自动推进功能 革命性的轻触登录功能： 用户轻触iPhone/Apple Watch即可登录Mac 密钥存储在安全飞地 支持Express模式 总结与资源这些新功能将帮助组织： 改善托管Apple账户用户体验 自动化常见管理任务 简化MDM服务器切换 优化应用管理实践 实现Vision Pro设备共享 创新身份验证方式 更多详细信息可以参考以下资源： 相关视频了解 ManagedApp 框架借助 NetworkExtension 优化网络流量过滤和隧道 文档Apple School Manager User GuideManagedAppSupport - Apple Platform Deployment","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"商务-&-教育","slug":"商务-教育","permalink":"http://djs66256.github.io/tags/%E5%95%86%E5%8A%A1-%E6%95%99%E8%82%B2/"}]},{"title":"实现 Metal 4 机器学习与图形应用程序的完美融合","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_262/","text":"了解如何使用 metal 4 将机器学习无缝融入你的图形应用程序中。我们将介绍用于在 gpu 时间线上连同渲染和计算工作一同运行模型的张量资源和 ml 编码器。了解如何使用着色器 ml 将神经网络直接嵌入着色器中，以实现高级效果和性能提升。我们还将通过示例 app 来展示适用于 metal 4 ml 工作负载的新调试工具的实际应用。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Metal 4 机器学习与图形应用的完美融合概述在最新 WWDC 会议上，Apple 展示了 Metal 4 如何将机器学习与图形技术深度融合，为游戏和图形应用开发者带来全新可能。Metal 框架团队工程师 Preston Provins 和 Scott 详细介绍了专为 GPU 时序同步设计的张量资源、ML 编码器、着色器 ML 以及调试工具。 核心技术创新张量资源革命Metal 4 引入了 MTLTensor 这一全新资源类型，专门针对机器学习工作流优化： 突破了传统 MTLBuffer 和 MTLTexture 的维度限制 内置多维数据布局管理，简化了复杂索引计算 支持直接从设备或现有缓冲区创建，提供最优性能配置 开发者可以通过 MTLTensorDescriptor 精确控制数据布局，其创建流程与 Metal 现有资源体系保持高度一致，降低了学习曲线。 机器学习编码器MTL4MachineLearningCommandEncoder 实现了三大突破： 将完整模型推理纳入 GPU 时序 与计算/渲染命令共享资源 支持 Metal 4 同步原语 其工作流程分为离线准备和运行时执行两个阶段，开发者可以： 将 PyTorch/TensorFlow 模型转换为 CoreML 包 动态调整输入尺寸 通过同步屏障精确控制执行顺序 实战案例展示了如何在全帧处理流程中无缝集成神经网络预测，证明了其在实时预算内的可行性。 着色器 ML 革新Shader ML 技术允许直接在片段着色器中运行小型神经网络，带来了四大优势： 消除步骤间内存往返 仅着色必要像素，优化资源使用 显著降低内存带宽需求 提供细粒度控制能力 通过 Metal 性能基元提供的矩阵乘/卷积等高性能算子，开发者可以在着色器中高效执行神经网络推理，实现诸如神经材质压缩等创新技术。 调试工具强化Metal 4 引入了完整的 ML 工作负载调试方案： 依赖关系视图验证同步正确性 MTLTensor 查看器检查输入/输出数据 ML 网络调试器进行逐层分析 这些工具与原有 Metal 调试链无缝集成，帮助开发者快速定位如网络层计算错误等复杂问题。 应用前景Metal 4 的机器学习集成将为游戏和图形应用带来革命性改变： 超分辨率缩放提升渲染性能 神经着色创造独特视觉效果 高级材质压缩降低存储需求 动画混合实现更自然运动 开发者现在可以充分利用这些技术，在保持高性能的同时实现前所未有的视觉效果和用户体验。 参考资料开发者可访问以下资源深入了解 Metal 4 的机器学习能力： Metal 4 文档 CoreML 转换指南 Metal 性能基元 API 相关视频探索 Metal 4探索 Metal 4 游戏深入探索 Metal 4 游戏用于打造沉浸式 App 的 Metal 渲染的新功能利用 Metal 加快机器学习基于 Apple GPU 训练机器学习和 AI 模型 文档Customizing a PyTorch operationMetal Performance Shaders","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"使用 App Intents 针对“快捷指令”和“聚焦”进行开发","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_260/","text":"了解如何构建 app intents，以使操作在 mac 上的“快捷指令”和“聚焦”中可用，并能够与这两个 app 中的新功能实现完美搭配。我们将介绍你的操作如何与“快捷指令”app 中提供的新 apple 智能操作相结合并产生令人惊叹的效果。我们将深入探讨全新“使用模型”操作的工作方式，以及它如何与 app 的实体进行交互。我们还将讨论如何使用 app intents api 让你的操作在“聚焦”中可用。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 App Intents 为快捷指令和聚焦搜索赋能开发在 WWDC 2023 的技术演讲中，苹果详细介绍了如何通过 App Intents 框架将应用功能深度整合到快捷指令和聚焦搜索中。以下是本次演讲的核心内容和技术要点。 App Intents 框架概述App Intents 框架为开发者提供了强大的工具，使其应用功能能够获得更高的平台可见性。通过该框架，用户可以在快捷指令和聚焦搜索等多种场景中直接使用应用的核心功能，极大地提升了应用的可用性和自动化潜力。 快捷指令中的智能操作今年快捷指令 App 引入了多项革命性的智能操作，其中”使用模型”功能尤为突出。这项操作让用户能够在自己的快捷指令中调用 Apple 智能模型，将原本复杂的任务变得简单高效。 模型选项与使用场景开发者可以选择三种不同的模型处理方式： 服务器端模型：处理复杂请求，同时保护用户隐私 设备端模型：处理无需联网的简单请求 ChatGPT：利用其广泛知识和技能 典型的使用场景包括： 筛选特定行程相关的日历事件 生成网页内容摘要 查询最新趋势信息 模型输出处理技术模型输出的处理是确保应用与模型无缝衔接的关键，开发者需要注意以下技术要点： 文本处理AttributedString 类型是处理富文本内容的最佳选择，它能够完美保留模型输出的各种格式样式，包括粗体、斜体、列表和表格等。 字典输出字典输出适用于结构化数据的传递，能将非结构化数据转换为应用可直接使用的格式。 应用实体处理当应用实体传入模型时，系统会将其转换为 JSON 格式传递。开发者需要确保： 关键信息在实体定义中公开 所有属性都会转为字符串包含在 JSON 中 包含类型名称和显示信息 聚焦搜索集成优化今年，Mac 上的聚焦搜索获得了重大升级，用户可以直接在其中运行应用提供的各种操作。 聚焦搜索显示条件要使意图显示在聚焦搜索中，开发者需要： 确保参数摘要包含所有必要无默认值参数 意图未被设置为隐藏状态 提供有效的 perform 方法 用户体验优化要点 建议提供：通过 SuggestedEntities 或 allEntities 提供参数建议 搜索体验：实现 EntityStringQuery 或 IndexedEntity 支持深度搜索 运行方式：合理区分后台意图和前台意图 Mac 自动化新功能Mac 今年新增了个人自动化功能，包括针对文件夹和外接硬盘的自动化触发机制。所有在 macOS 可用的意图都能用于这些自动化场景，为用户提供更丰富的自动化可能。 开发建议根据演讲内容，开发者应采取以下关键步骤： 将应用内容作为适合快捷指令的实体公开 使用 AttributedString 支持富文本输入 优化 Mac 聚焦搜索中的意图呈现效果 相关资源开发者可参考以下资源深入了解相关内容： 相关视频为聚焦设计快捷指令使用 App 快捷指令突出你的 App 文档资源App IntentsApp ShortcutsDonating ShortcutsHuman Interface Guidelines: App Shortcuts","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"跟着视频学编程：使用 Foundation Models 框架将设备端 AI 引入你的 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_259/","text":"使用 foundation models 框架为你的 swiftui app 开发生成式 ai 功能。首先，应用这个框架的基本要素来创建一个出色的功能。然后，观看一些分步示例以了解如何使用你构建的工具来完善模型、流式传输结果，并进行进一步优化以提升性能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 Foundation Models 框架为 App 集成设备端 AI概述Foundation Models 框架为开发者提供了直接在苹果设备上运行生成式 AI 的能力，无需依赖云服务即可为应用添加智能功能。该框架支持 macOS、iPadOS、iOS 和 visionOS 平台，所有计算都在设备端完成，既保障了用户数据隐私，又不会增加应用体积。 核心功能实现提示工程与 Playground 迭代提示设计是获得优质结果的关键。开发者可以利用 Xcode 的 Playground 功能进行实时迭代： 12345import FoundationModels// 创建会话并发送请求let session = FMSession()let response = try await session.prompt(&quot;为约书亚树国家公园创建3天行程&quot;) 对于结构化数据输出，需要自定义数据结构并遵循 Generable 协议： 1234567891011121314import FoundationModels@Generablestruct Itinerary &#123; let title: String let description: String let days: [DayPlan]&#125;@Generablestruct DayPlan &#123; let dayNumber: Int let activities: [String]&#125; 使用 Guide 宏可以添加更精确的输出控制： 12345@Guide(description: &quot;行程标题应简短吸引人&quot;)@Guide(description: &quot;days数组应始终包含3个元素&quot;)struct Itinerary &#123; // ...&#125; 工具调用扩展能力Foundation Models 框架支持通过工具协议扩展模型能力，接入外部数据源： 12345678910111213141516171819202122struct LandmarkTool: Tool &#123; static let name = &quot;landmark_tool&quot; static let description = &quot;获取地标的兴趣点信息&quot; enum Category: String, Generable &#123; case visitorCenter, trail, campground &#125; struct Arguments: Generable &#123; let category: Category let query: String &#125; func call(_ input: Arguments) async throws -&gt; [MKMapItem] &#123; let request = MKLocalSearch.Request() request.naturalLanguageQuery = input.query request.resultTypes = .pointOfInterest request.region = MKCoordinateRegion(/* 坐标和范围 */) let search = MKLocalSearch(request: request) return try await search.start().mapItems &#125;&#125; 流式输出优化体验将响应类型改为 PartiallyGenerated 可实现内容流式传输： 123456789101112131415struct ItineraryPlanner &#123; @Published var itinerary: PartiallyGenerated&lt;Itinerary&gt;? func generateItinerary() async &#123; let session = FMSession(tools: [LandmarkTool()]) let stream = try await session.prompt( &quot;为约书亚树国家公园创建3天行程&quot;, responseType: PartiallyGenerated&lt;Itinerary&gt;.self ) for await partial in stream &#123; itinerary = partial &#125; &#125;&#125; 性能优化策略实测分析发现性能瓶颈主要集中在三个方面： 模型加载时间：可通过预热策略优化，在用户可能发起请求时提前加载模型 输入令牌数：在多轮对话后续请求中设置 IncludeSchemaInPrompt 为 false 推理时间：使用 Instruments 的 Foundation Models 工具进行精细分析 应用场景与优势以旅行规划应用为例，Foundation Models 框架可提供以下优势： 隐私保护：所有数据处理均在设备端完成 离线能力：预置模型无需网络连接 响应速度：流式输出提供即时反馈 扩展性：通过工具协议接入各类数据源 深入学习资源开发者可进一步参考以下资源深入了解 Foundation Models 框架： 相关视频了解 Foundation Models 框架探索 Apple 平台上的机器学习和 AI 框架探索设备端基础模型的提示设计和安全深入了解 Foundation Models 框架 文档Generating content and performing tasks with Foundation ModelsHuman Interface Guidelines: Generative AI Foundation Models 框架为苹果生态应用开启了设备端智能的新篇章，开发者现在可以构建既强大又隐私的生成式 AI 功能，为用户创造更智能、更安全的体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"跟着视频学编程：使用 Swift 并发机制提升 App 性能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_270/","text":"通过更新一个现有的示例 app，我们将向你介绍如何通过 swift 并发机制来优化 app 的用户体验。我们将从一个主 actor app 入手，然后根据需要逐步引入异步代码。我们将使用任务来优化主 actor 上运行的代码，并探索如何通过将工作转移到后台来实现代码并行运行。我们将探讨数据争用安全机制提供的功能，并讲解如何解读和修复数据争用安全错误。最后，我们将展示如何在 app 情境中充分利用结构化并发机制。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 利用 Swift 并发机制提升 App 性能：从主线程到结构化并发的演进之路本文将深入剖析如何运用 Swift 并发机制优化 App 性能，通过一个贴纸生成应用的实例，展示从单线程到结构化并发的完整演进过程。 应用背景与架构该示例应用是一个能将任意照片转为贴纸包的创意工具，包含两个核心组件： 贴纸轮播视图（StickerCarousel）：展示带有渐变色背景的照片贴纸 网格预览视图（StickerGrid）：提供贴纸包的导出分享功能 应用的底层架构采用 PhotoProcessor 结构体处理照片，执行两项核心操作： 从照片中提取贴纸图像 计算照片的主色调（用于生成渐变色背景） 性能优化演进路径初始问题：主线程阻塞最初的实现将所有逻辑放在主线程执行，导致以下问题： 照片加载时界面冻结 图像处理耗时超过10秒 滚动体验卡顿 12345678// 初始同步实现（导致主线程阻塞）struct PhotoProcessor &#123; func process(data: Data) -&gt; ProcessedPhoto? &#123; let sticker = extractSticker(from: data) // 耗时操作 let colors = extractColors(from: data) // 耗时操作 return ProcessedPhoto(sticker: sticker, colorScheme: colors) &#125;&#125; 第一步：异步加载照片通过引入 async/await 机制，将照片加载移至后台： 123456// 异步加载实现func loadPhoto(_ item: SelectedPhoto) async &#123; var data: Data? = try? await item.loadTransferable(type: Data.self) guard let data else &#123; return &#125; processedPhotos[item.id] = Image(data: data)&#125; 在视图中使用 task 修饰符触发异步加载： 1234StickerPlaceholder() .task &#123; await viewModel.loadPhoto(selectedPhoto) &#125; 第二步：后台图像处理运用 Swift 6.1 的并发特性，将图像处理移至后台： 123456nonisolated struct PhotoProcessor &#123; @concurrent func process(data: Data) async -&gt; ProcessedPhoto? &#123; // 后台执行的处理逻辑 &#125;&#125; 第三步：并行处理优化通过 async let 并行执行相互独立的操作： 12async let sticker = extractSticker(from: data) // 并行执行async let colors = extractColors(from: data) // 并行执行 处理数据竞争问题的方法： 1234private func extractColors(from data: Data) -&gt; PhotoColorScheme? &#123; let colorExtractor = ColorExtractor() // 每次创建新实例 return colorExtractor.extractColors(from: data)&#125; 第四步：结构化并发与批量处理使用 TaskGroup 实现高效的批量照片处理： 123456789101112func processAllPhotos() async &#123; await withTaskGroup &#123; group in for item in selection &#123; group.addTask &#123; // 并行处理每个照片 &#125; &#125; for await result in group &#123; // 收集处理结果 &#125; &#125;&#125; 关键技术与最佳实践 主线程优化策略 使用 await 创建暂停点 通过 task 修饰符管理异步任务生命周期 后台执行控制 nonisolated 标记脱离主线程 @concurrent 确保方法在后台执行 并行处理模式 async let 并行独立任务 避免共享可变状态 数据竞争防护 Swift 6 编译时检查 采用 Sendable 值类型 必要时隔离到主线程 结构化并发 TaskGroup 批量任务管理 结果有序收集机制 性能优化成果经过上述优化步骤，应用实现了： 主线程保持高响应性 图像处理时间大幅缩短 滚动体验流畅 批量处理效率显著提升 相关资源相关视频探索 SwiftUI 中的并发机制采用 Swift 并发使用 Instruments 分析挂起超越结构化并发的基础 文档Swift Migration Guide","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"了解 SwiftUI 空间布局","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_273/","text":"探索使用 swiftui 开发空间体验的新工具。了解 visionos 上 3d swiftui 视图的基本知识，借助深度对齐功能来自定现有布局，并使用修饰符在空间中旋转和放置视图。探索如何使用空间容器在同一 3d 空间中对齐视图，打造更沉浸、更引人入胜的 app。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 SwiftUI 空间布局：构建沉浸式3D体验的新工具在visionOS平台上，SwiftUI为开发者提供了一套全新的3D布局工具，让构建空间体验变得更加简单高效。本文将详细介绍这些新工具的功能和应用场景。 3D视图基础visionOS平台上的SwiftUI视图具备真正的三维特性。布局系统不仅计算视图的宽度、高度和X/Y位置，还会计算深度维度(Z轴)。视图可分为两类： 深度为零的平面视图：如Image、Color和Text等传统2D元素 具有实际深度的3D视图：如Model3D、RealityView和GeometryReader3D等 开发者可以使用scaledToFit3D修饰符保持模型比例同时适应可用空间。值得注意的是，窗口内容和体积在深度提议上存在差异： 窗口内容接收固定的根深度提议，超出深度的内容可能被裁剪 体积提议则允许宽度、高度和深度调整 深度对齐定制visionOS 26引入了自定义深度对齐功能。通过定义符合DepthAlignmentID协议的新结构体，开发者可以创建个性化的对齐方式。例如： 12345struct DepthPodiumAlignment: DepthAlignmentID &#123; static func defaultValue(in dimensions: ViewDimensions) -&gt; Double &#123; dimensions[.bottom] &#125;&#125; 这种机制让开发者能够灵活控制视图在深度维度上的排列方式，比如让特定元素(如”最喜欢的机器人”)更加突出。 旋转布局技术SwiftUI提供了两种不同的旋转机制： rotation3DEffect修饰符：仅影响视觉呈现，不改变布局框架 rotation3DLayout修饰符：真正修改视图在3D空间中的布局框架 开发者可以利用这些工具构建复杂的3D布局，如机器人旋转木马效果。实现步骤包括： 使用RadialLayout圆型排列元素 应用rotation3DLayout使元素水平展示 空间容器工具SwiftUI引入了两类新型3D布局容器： SpatialContainer：允许多个视图共享相同的3D空间 spatialOverlay：在同一个3D空间上叠加单个视图 这些工具特别适合创建沉浸式效果，如实现选中机器人的视觉反馈环，确保其与机器人底部完美对齐。 调试与可视化为帮助开发者理解3D布局，文中介绍了debugBorder3D修饰符的实现方法，该工具为视图添加可视边框，清晰展示其3D框架边界。 混合开发策略虽然SwiftUI在3D布局方面能力强大，但某些复杂场景(如物理模拟)仍需结合RealityKit使用。Apple鼓励开发者在同一应用中灵活搭配这两个框架，充分发挥各自优势。 相关资源开发者可通过以下资源进一步学习： 相关视频搭配使用更出色：SwiftUI 和 RealityKit使用 SwiftUI 构建自定布局利用 SwiftUI 构建自定视图 文档Human Interface Guidelines: Designing for visionOS SwiftUI的空间布局工具为visionOS应用开发开辟了新的可能性，开发者现在可以用熟悉的声明式语法创建丰富的3D体验。随着这些技术的成熟，期待看到更多创新应用的诞生。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"搭配使用更出色：SwiftUI 和 RealityKit","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_274/","text":"了解如何在 visionos 26 中无缝整合 swiftui 和 realitykit 的强大功能。我们将探索 model3d 的增强功能 (包括动画和 configurationcatalog 支持)，并展示如何顺利过渡到 realityview。你将了解如何借助 swiftui 动画实现 realitykit 组件更改、实现交互式操控、使用新增 swiftui 组件打造更丰富的互动体验，以及从 swiftui 代码中观察 realitykit 的变化。我们还将介绍如何利用统一坐标转换进行跨框架坐标变换。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com SwiftUI 与 RealityKit 的无缝协作：visionOS 26 的新特性解析在 visionOS 26 中，Apple 进一步强化了 SwiftUI 与 RealityKit 之间的协作能力，为开发者提供了更流畅的 2D 与 3D 内容整合方案。本文将详细介绍这些新特性及其应用场景。 Model3D 的增强功能作为 SwiftUI 家族的 3D 内容展示组件，Model3D 在 visionOS 26 中获得了两项重要升级： 动画播放支持开发者现在可以通过 Model3DAsset 加载场景资源并创建 AnimationPlaybackController 来控制动画播放。更值得注意的是，AnimationPlaybackController 现在支持 Observable 协议，使得 SwiftUI 视图能够实时响应动画状态变化。 ConfigurationCatalog 支持这项新功能允许开发者轻松切换 3D 模型的不同配置样式，只需通过弹出菜单选择即可实现模型的”换装”效果，大大简化了多样式 3D 内容的展示流程。 从 Model3D 到 RealityView 的平滑过渡当需求超出 Model3D 的能力范围时，开发者可以平滑过渡到功能更强大的 RealityView： 只需将视图类型改为 RealityView 在 make 闭包中加载模型实体 使用 .realityViewLayoutBehavior(.fixedSize) 修饰符保持视图的自适应特性 这种过渡特别适合需要添加粒子系统(ParticleEmitterComponent)等高级特效的场景。通过 RealityKit 的”实体组件系统”架构，开发者可以实现精细的 3D 交互效果。 对象操控 APIvisionOS 26 引入了全新的 Object Manipulation API，支持以下交互方式： 单手移动 单手/双手旋转 双指缩放 两手间传递对象 对于不同类型的对象，启用方式有所不同： SwiftUI 视图：添加 .manipulable 修饰符 RealityKit 实体：使用 ManipulationComponent.configureEntity() 方法 该 API 自动处理碰撞检测、输入响应和悬停效果，开发者只需关注交互逻辑的实现。 三大新增 SwiftUI 组件为深化交互体验，visionOS 26 提供了三个关键组件： ViewAttachmentComponent：将 SwiftUI 视图直接附加到实体 GestureComponent：让实体响应触控手势 PresentationComponent：在 3D 场景中呈现 SwiftUI 弹窗 这些组件大幅简化了 3D 场景中 2D 交互元素的集成过程。 双向数据流动与坐标转换visionOS 26 实现了 SwiftUI 与 RealityKit 之间的双向数据通信： SwiftUI → RealityKit：通过 RealityView 的 update 闭包 RealityKit → SwiftUI：通过观察实体属性 新增的 CoordinateSpace3D 协议解决了跨框架坐标转换的难题，开发者可以轻松计算不同坐标系下对象间的距离和相对位置。 SwiftUI 动画驱动 RealityKit 组件现在，SwiftUI 动画可以隐式驱动 RealityKit 组件的变化，有两种实现方式： 在 RealityView 的 content.animate() 块中设置组件新值 调用 Entity.animate() 方法并传递 SwiftUI 动画 这种集成特别适合创建生动的交互反馈效果，如弹性动画等。 总结visionOS 26 中 SwiftUI 与 RealityKit 的深度合作为开发者提供了前所未有的 2D/3D 内容整合能力。从简单的 Model3D 展示到复杂的 RealityView 交互，从基础动画到高级粒子效果，这套工具链能满足各种空间计算应用的需求。建议开发者根据具体场景选择合适的技术组合： 简单 3D 内容展示：Model3D 复杂交互式 3D 内容：RealityView 2D/3D 混合交互：新增 SwiftUI 组件 通过合理利用这些新特性，开发者可以创造出更加沉浸式和交互式的空间应用体验。 相关视频在 Reality Composer Pro 中编写交互式 3D 内容探索 SwiftUI 中的观察深入了解 RealityKit 2SwiftUI 中的数据要素","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"BNNS Graph 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_276/","text":"借助 bnns graph builder api，开发者现在可以使用熟悉的 swift 语言来编写操作图，从而生成预处理和后处理例程以及小型机器学习模型。bnns 可在执行前先编译图形，并支持那些具有实时性和延迟敏感性的应用场景，例如音频处理。在本次讲座中，我们将重温去年的比特失真器示例，通过移除对单独 python 文件的依赖性来简化 swift 组件，并转而完全用 swift 实现音频效果。此外，bnns graph builder api 还适用于在将图像数据传递到机器学习模型之前对数据进行预处理。本次讲座还将演示如何裁剪一张带有 alpha 通道的图像中的透明像素。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com BNNS Graph 新功能：用 Swift 构建高性能机器学习处理图在 WWDC 演讲中，Apple 的向量与数值计算组工程师 Simon Gladman 介绍了 BNNS Graph 的最新功能——BNNS Graph Builder API，这项技术让开发者能够使用 Swift 语言创建高效的机器学习预处理/后处理图和小型模型。 技术背景与概述BNNS（Basic Neural Network Subroutines）是 Apple 提供的高性能机器学习库，特别适合需要实时处理和低延迟的应用场景，如音频处理和图像分析。在去年的 WWDC 中，Apple 推出了 BNNSGraph API，它能够将整个模型作为一个图对象处理，带来显著的性能优化和能效提升。 今年新增的 BNNS Graph Builder API 进一步简化了开发流程，开发者现在可以直接使用 Swift 语言编写操作图，无需依赖外部工具或文件。 BNNSGraph 的核心优势BNNSGraph 的主要优势在于其对模型整体的优化能力，包括： 数学变换优化（如操作重排序） 层融合（将多个操作合并为单操作） 内存优化（消除不必要的复制和共享内存） 权重重新打包（改善缓存局部性） 与传统方法相比，开发者不再需要手动编写每一层的代码，只需描述整个计算图即可获得这些优化好处。 BNNS Graph Builder API 工作流新的 Builder API 提供了更加直接的工作流程： 使用 Swift 编写操作图 通过单次函数调用创建执行上下文 重复使用优化后的上下文进行推理 这种方法消除了中间步骤，特别适合小型模型和预处理/后处理操作图的创建。 新 API 的技术亮点强类型 Swift 接口1234let x: BNNSNDArrayDescriptor = ...let y: BNNSNDArrayDescriptor = ...let product = x * ylet mean = product.mean() 这种强类型系统带来多项优势： 编译时类型检查 Xcode 自动补全 运行时错误减少 中间张量属性可查询 丰富的操作支持BNNS Graph Builder 支持广泛的操作类型： 数学运算（矩阵乘法、卷积等） 归约操作 数据重组操作（填充、重塑、转置） 算术和逻辑运算符 高效的切片操作12let centerCrop = SliceRange(from: 240, upTo: 880)let croppedImage = image[centerCrop, centerCrop] 切片操作通过引用而非复制来实现，大大提高了内存效率。 实际应用案例图像预处理开发者可以通过简单的 Swift 代码实现复杂的预处理：123let grayscale = input.mean(axis: -1) // 转换为灰度let threshold = grayscale &gt; meanValue // 阈值处理let binary = threshold.to(.float16) // 转换为二进制输出 模型后处理123let softmaxOutput = modelOutput.softmax()let (topValues, topIndices) = softmaxOutput.topK(5)return (topValues.array(), topIndices.array()) 音频处理升级去年的 Bitcrusher 音频效果示例现在可以完全用 Swift 实现，无需依赖 PyTorch 或 CoreML 中间文件。 性能与适用性BNNS Graph Builder 特别适合： 实时音频处理（如 Logic Pro 插件） 延迟敏感型应用 需要高能效的场景 小型机器学习模型 开发者还可以通过简单的类型别名切换（如 FP16 和 FP32）来优化性能，在演示案例中，FP16 版本表现出显著的性能优势。 总结BNNS Graph Builder API 代表了 Apple 在机器学习基础设施上的重要进步，它让开发者能够使用熟悉的 Swift 语言创建高效的计算图，同时享受编译时检查和运行时优化的双重好处。这项技术特别适合需要实时处理和低延迟的应用场景，为开发者提供了强大的新工具来构建高性能的机器学习功能。 学习资源对于希望深入了解 BNNS Graph 的开发者，Apple 提供了以下资源： 相关视频探索 Apple 平台上的机器学习和 AI 框架在 CPU 上助力实现实时 ML 推理 文档BNNSvImage.PixelBuffer","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"通行密钥的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_279/","text":"了解 ios、ipados、macos 和 visionos 26 在通行密钥方面的增强功能。我们将探索的重要更新包括：简化注册流程的全新账户创建 api、确保通行密钥保持最新的措施、通过自动通行密钥升级和通行密钥管理端点驱动通行密钥升级的新方式，以及通行密钥的安全导入/导出。了解这些改进如何提升用户体验和安全性，以及如何在 app 中实施这些更新以便提供更流畅、更安全的身份验证体验。为了充分从这个讲座中获益，请先观看 wwdc22 讲座“通行密钥简介”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com iOS、iPadOS、macOS 和 visionOS 26 中通行密钥的新功能苹果公司在 WWDC24 上展示了 iOS、iPadOS、macOS 和 visionOS 26 中针对通行密钥的五大重要更新，旨在进一步提升身份认证的安全性和用户体验。 引言：迈向无密码未来通行密钥作为密码的替代方案，从根本上解决了传统密码认证的安全性和可用性问题。根据 FIDO Alliance 2025年的研究，69%的受访者至少拥有一个通行密钥。Google的数据显示，使用通行密钥登录的成功率是密码的四倍，而TikTok更是达到了97%的成功率。 随着行业向仅由不可钓鱼因素保护的身份认证转型，苹果在新系统中推出了五项关键改进，帮助开发者更轻松地实现这一目标。 1. 账户创建 API：快速安全的注册体验全新的账户创建 API 彻底简化了用户注册流程。与传统需要填写复杂表格的方式不同，新API提供了预填信息的简化界面： 12345678let provider = ASAuthorizationAccountCreationProvider()let request = provider.createPlatformPublicKeyCredentialRegistrationRequest( acceptedContactIdentifiers: [.email, .phoneNumber], shouldRequestName: true, relyingPartyIdentifier: &quot;example.com&quot;, challenge: try await fetchChallenge(), userID: try await fetchUserID()) 这种注册方式消除了密码创建的步骤，整个过程快速、简单且安全。用户注册后，其通行密钥会自动保存在密码应用中，并在所有设备上可用。 2. 保持通行密钥更新：确保信息准确性账户信息会随时间变化，新的API允许应用通知凭证管理器这些变更： 123456789101112131415// 更新用户名try await ASCredentialUpdater() .reportPublicKeyCredentialUpdate( relyingPartyIdentifier: &quot;example.com&quot;, userHandle: userHandle, newName: &quot;new@example.com&quot; ) // 撤销通行密钥try await ASCredentialUpdater() .reportAllAcceptedPublicKeyCredentials( relyingPartyIdentifier: &quot;example.com&quot;, userHandle: userHandle, acceptedCredentialIDs: acceptedCredentialIDs ) 这些API确保凭证管理器显示的信息始终是最新的，防止因过时信息导致的登录问题。 3. 自动通行密钥升级：无缝过渡到更安全认证对于仍使用密码的账户，系统提供了自动升级为通行密钥的无缝路径： 123456let request = provider.createCredentialRegistrationRequest( challenge: try await fetchChallenge(), name: accountDetails.userName, userID: accountDetails.userID, requestStyle: .conditional) 当用户用密码登录后，如果账户没有通行密钥，系统会自动尝试创建，整个过程在后台完成，不会中断用户体验。 4. 通行密钥管理端点：提升可发现性通过实现well-known URL端点，应用可以： 提供通行密钥注册页面的链接 让用户直接从凭证管理器升级到通行密钥 不需要任何客户端代码修改 这个标准化的方法适用于所有参与凭证管理器。 5. 安全导入/导出通行密钥新系统允许通行密钥在参与凭证管理器之间安全传输： 用户发起且受Face ID等本地认证保护 不使用不安全的中介文件 基于FIDO Alliance标准的数据格式 无需应用做任何适配 结论：共同构建无密码未来这些改进使通行密钥更易于创建、使用和管理。开发者可以通过以下步骤改善用户体验： 采用账户创建API简化注册 使用信号API保持信息更新 启用自动通行密钥升级 提供通行密钥管理端点 随着行业共同努力，无密码的未来正在成为现实。 相关视频利用通行密钥升级和凭证管理器简化登录体验通行密钥简介 文档ASCredentialExportManagerASCredentialProviderViewControllerPerforming fast account creation with passkeys","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"使用 Vision 框架读取文档","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_272/","text":"了解 vision 框架的最新进展。我们将介绍 recognizedocumentsrequest，并介绍如何使用该工具读取文本行并将其分组为段落、读取表格等。此外，我们将深入探讨相机镜头污渍检测，以及如何在照片图库或你自己的相机拍摄管道中识别可能有污渍的图像。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Vision框架新功能解析：文档读取与镜头污渍检测在WWDC 2024上，苹果Vision框架团队工程师Megan Williams介绍了两项重要的新功能：RecognizeDocumentsRequest文档结构识别和DetectLensSmudgeRequest镜头污渍检测，以及手部姿态检测模型的更新。这些新功能为开发者提供了更强大的计算机视觉处理能力。 结构化文档识别：RecognizeDocumentsRequest传统的RecognizeTextRequest只能提取文本行，而全新的RecognizeDocumentsRequest则能够识别文档中的结构化元素。该API支持26种语言的文本识别，能够： 检测表格、列表等文档结构 将文本行智能分组为段落 识别二维码等机器可读代码 提取电子邮件、电话号码等重要信息 实用示例：签到表解析以一个商店顾客签到表为例，开发者可以轻松提取表格中的联系人信息。通过表格的层次结构，可以逐行读取姓名、邮箱和电话号码。 123456789101112/// 处理图像并返回检测到的第一个表格func extractTable(from image: Data) async throws -&gt; DocumentObservation.Container.Table &#123; let request = RecognizeDocumentsRequest() let observations = try await request.perform(on: image) guard let document = observations.first?.document else &#123; throw AppError.noDocument &#125; guard let table = document.tables.first else &#123; throw AppError.noTable &#125; return table&#125; 文本内容处理方式文档内容提供多种查看方式： transcript: 将所有文本作为单个字符串 lines: 以文本行数组形式呈现 detectedData: 检测特殊字符串(邮箱、电话等) 1234567891011121314151617181920212223242526272829/// 从表格中提取姓名、邮箱和电话号码生成联系人列表private func parseTable(_ table: DocumentObservation.Container.Table) -&gt; [Contact] &#123; var contacts = [Contact]() for row in table.rows &#123; guard let firstCell = row.first else &#123; continue &#125; let name = firstCell.content.text.transcript var detectedPhone: String? = nil var detectedEmail: String? = nil for cell in row.dropFirst() &#123; let allDetectedData = cell.content.text.detectedData for data in allDetectedData &#123; switch data.match.details &#123; case .emailAddress(let email): detectedEmail = email.emailAddress case .phoneNumber(let phoneNumber): detectedPhone = phoneNumber.phoneNumber default: break &#125; &#125; &#125; if let email = detectedEmail &#123; let contact = Contact(name: name, email: email, phoneNumber: detectedPhone) contacts.append(contact) &#125; &#125; return contacts&#125; 相机镜头污渍检测DetectLensSmudgeRequest能够识别因镜头污渍导致的低质量照片。该API会生成一个0-1之间的置信度分数，开发者可以设置阈值来筛选可用图像。 12345let request = DetectLensSmudgeRequest()let observations = try await request.perform(on: image)if let observation = observations.first, observation.confidence &gt; 0.9 &#123; // 图像可能存在污渍&#125; 需要注意的是，某些特殊情况如运动模糊或云雾照片也可能被误判为污渍图像。建议结合其他Vision API如DetectFaceCaptureQualityRequest或CalculateImageAestheticScoresRequest共同评估图像质量。 手部姿态检测更新Vision对手部姿态检测模型进行了升级，新模型具有： 更高的精度 更小的内存占用 更低的延迟 虽然仍检测21个关节位置，但新模型的关节定位与旧模型有所不同。已训练手部姿态分类器的开发者建议重新训练模型以获得最佳准确性。 总结Vision框架的新功能为开发者提供了： 强大的文档结构解析能力(RecognizeDocumentsRequest) 图像质量控制工具(DetectLensSmudgeRequest) 更精确的手部姿态检测模型 这些更新将使开发者在处理文档扫描、图像质量控制和手势交互等场景时获得更出色的体验和效果。 相关视频探索 Apple 平台上的机器学习和 AI 框架探索 Vision 框架中的 Swift 增强功能在 Vision 中探索 3D 人体位姿和人像分隔在 Vision 中检测动物体态 文档资源Classifying Images with Vision and Core MLVision","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"探索 App Intents 中的最新改进","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_275/","text":"探索今年发布的 app intents 框架新推出的所有增强功能。了解助力日常开发工作的诸多改进 (如延迟属性)、一系列新功能 (如交互式 app intents 摘要片段、实体视图注释)，以及如何整合视觉智能等。我们将一起探索让 app intents 比以往更具表现力、更加流畅易用的各项更新。我们还将介绍今年 app intents 激动人心的新增支持 (如支持“聚焦”和视觉智能)，并讲解如何编写完美适配这些场景的 app intents。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com App Intents框架新特性解析：打造深度系统集成的应用体验引言App Intents框架作为苹果生态系统中的重要组成部分，为开发者提供了将应用功能深度整合到系统各处的能力。在今年的WWDC大会上，苹果工程师Jeff介绍了App Intents框架的一系列新特性和改进，包括交互式摘要卡片、增强的系统集成能力、用户体验优化以及开发者便利API等。 交互式摘要卡片：提升用户互动体验App Intents框架最大的亮点之一是新增的交互式摘要卡片功能。这种动态卡片允许开发者在系统级界面中展示定制化视图并实现用户交互。 功能特点 支持在卡片中嵌入按钮、开关等交互元素 可实时更新卡片状态反映应用最新数据 适用于操作确认、结果展示等多种场景 与SwiftUI的无缝集成，支持流畅的过渡动画 实现原理交互式卡片采用新型的SnippetIntent协议实现。系统通过以下流程处理卡片交互： Intent返回包含参数的Snippet Intent作为结果 系统刷新时自动填充参数值 执行Snippet Intent的perform方法渲染视图 用户交互触发关联Intent执行 系统再次渲染更新后的视图 代码示例开发者可以通过简洁的Swift代码实现这一功能：123456789struct ClosestLandmarkIntent: AppIntent &#123; func perform() async throws -&gt; some ReturnsValue&lt;LandmarkEntity&gt; &amp; ShowsSnippetIntent &amp; ProvidesDialog &#123; let landmark = await self.findClosestLandmark() return .result( value: landmark, snippetIntent: LandmarkSnippetIntent(landmark: landmark) ) &#125;&#125; 增强的系统集成能力App Intents框架新增了多项系统集成功能，让应用可以出现在更多系统界面中。 图像搜索集成iOS 16的图像搜索功能现在可以向第三方应用开放：123456struct LandmarkIntentValueQuery: IntentValueQuery &#123; func values(for input: SemanticContentDescriptor) async throws -&gt; [LandmarkEntity] &#123; guard let pixelBuffer = input.pixelBuffer else &#123; return [] &#125; return try await modelData.searchLandmarks(matching: pixelBuffer) &#125;&#125; 多实体类型支持开发者现在可以返回多种类型的实体：12345@UnionValueenum VisualSearchResult &#123; case landmark(LandmarkEntity) case collection(CollectionEntity)&#125; 用户体验优化支持撤销操作通过UndoableIntent协议，用户可以使用三指滑动撤销Intent操作：1234567struct DeleteCollectionIntent: UndoableIntent &#123; func perform() async throws -&gt; some IntentResult &#123; await undoManager?.registerUndo(withTarget: modelData) &#123; modelData in // 恢复集合 &#125; &#125;&#125; 多选项交互开发者可以提供多个操作选项供用户选择：1234let resultChoice = try await requestChoice( between: [.cancel, archive, delete], dialog: &quot;Do you want to archive or delete \\(collection.name)?&quot;) 开发者便利API视图控制分离新的API允许将UI代码从Intent中分离：123.onAppIntentExecution(OpenLandmarkIntent.self) &#123; intent in self.path.append(intent.landmark)&#125; 延迟属性加载优化性能的延迟属性加载功能：123456@DeferredPropertyvar crowdStatus: Int &#123; get async throws &#123; await modelData.getCrowdStatus(self) &#125;&#125; 结论App Intents框架的新特性为开发者提供了更强大的工具，让应用能够深度融入苹果生态系统。从交互式卡片到系统级集成，从用户体验优化到开发者便利性提升，这些改进将为用户带来更一致、更便捷的使用体验，同时降低开发者的实现难度。 相关资源开发者可以观看以下资源了解更多详情： “了解App Intents”专题演讲 TravelTracking示例应用代码 官方开发文档 查看完整视频列表和文档","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"设计交互式摘要卡片","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_281/","text":"摘要卡片是一种通过 app intents 调用的简洁视图，用于显示相应 app 内的信息。现在，你可以为摘要卡片添加增强意图交互性的按钮和状态信息，以便搭配 siri、“聚焦”以及“快捷指令”app 实现更多功能。在本次讲座中，你将了解设计摘要卡片的最佳实践，包括布局、字体、交互操作和意图类型方面的指导。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 设计交互式摘要卡片：提升应用便捷性的新方式摘要卡片的定义与价值在WWDC上，苹果介绍了”摘要卡片”这一创新功能，它是通过App Intents调用的紧凑视图，旨在为用户提供应用更新信息和快捷操作。这种设计巧妙地将应用功能延伸至系统各处，包括”聚焦”搜索、Siri智能助手和”快捷指令”应用，极大地提升了应用的可访问性和实用性。 摘要卡片的设计哲学体现”轻量不打扰”的理念：它们始终清晰地显示在屏幕顶部，覆盖其他内容但不会打断用户当前上下文。这种非模态交互方式允许用户自行决定何时关闭卡片——通过确认、取消或滑走操作。 设计原则解析视觉呈现优化文本可读性是摘要卡片设计的首要考虑因素。系统特意采用比默认更大的字体尺寸，以确保关键信息能够快速吸引用户注意力。设计时需要特别注意: 空间管理: 保持元素间充分间距以避免视觉混乱 布局一致性: 使用ContainerRelativeShape API确保边距在不同设备和屏幕尺寸上都能正确适应 内容精选: 高度限制在340点以内，避免滚动带来操作负担 视觉对比: 需考虑远距离观看时的可读性，必要时增强内容与背景的对比度 交互体验设计交互性使摘要卡片从静态展示升级为动态工具: 即时操作: 可集成如”添加水”这样的快捷按钮 状态反馈: 数据更新时伴随缩放和模糊效果提供视觉确认 多操作支持: 如音频均衡器卡片可同时展示多个预设选项 动态更新: 即使无交互也能实时显示应用最新数据 卡片类型与应用场景苹果定义了两种摘要卡片类型，分别适用于不同情境: 结果型卡片: 展示确认后的信息或无需进一步操作的内容 仅包含”完成”按钮 典型用例: 订单状态查询 确认型卡片: 需要用户先采取行动才能显示结果 包含明确的动作动词(如”下单”) 典型用例: 咖啡订购流程 多模态交互考量尽管摘要卡片主要面向视觉交互，设计时仍需考虑: 语音兼容性: 确保Siri对话能完整传达信息 独立可理解性: 卡片内容应不依赖对话即可被理解 信息精简: 避免冗余，保持直观性 开发资源开发者可以参考官方文档深入了解摘要卡片的实现细节: 显示静态和交互式摘要卡片 通过遵循这些设计原则，开发者能够创建出既美观又实用的摘要卡片，为用户提供轻量高效的日常交互体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"让你的 UIKit App 更加灵活","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_282/","text":"探究如何使用场景和容器视图控制器让你的 uikit app 在 iphone、ipad、mac 和 apple vision pro 上变得更加灵活。了解如何从以 app 为中心的生命周期过渡到基于场景的生命周期 (包括优化的窗口大小调整和改进的多任务处理)，以便解锁 app 的全部潜能。探索 uisplitviewcontroller 的增强功能，例如以交互方式调整列大小以及为检查器列提供一流支持；并通过采用新的布局 api 来增强视图和控制器的自适应性。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 让你的UIKit应用更具灵活性：全面适配多平台的实践指南在如今多样化的苹果设备生态系统中，如何确保UIKit应用能够在iPhone、iPad、Mac和Apple Vision Pro等不同平台上提供一致而优秀的用户体验？本文将从场景基础、容器视图控制器到自适应UI构建，全面解析UIKit应用灵活性提升的最佳实践。 场景：灵活应用的基石场景作为应用UI的独立实例，为灵活应用提供了坚实基础。每个场景包含应用视图控制器和视图，具有独立生命周期和状态恢复能力。在iOS 26中，开发者现在可以在单个应用中混合使用SwiftUI和UIKit场景类型。 场景实现的关键步骤包括： 在应用委托中处理场景配置，区分不同角色（如主场景和AirPlay到Apple TV的外部显示器场景） 通过UISceneDelegate管理单个场景生命周期，包括窗口创建和根视图控制器设置 实现状态恢复机制，使用UI状态活动保存和恢复场景的交互状态 值得注意的是，采用UIScene生命周期即将成为强制要求。开发者应参考技术说明”迁移到基于场景的UIKit生命周期”（TN3187）完成这一关键过渡。 容器视图控制器：灵活布局的核心UIKit提供的容器视图控制器是实现灵活布局的核心工具。 UISplitViewController的新特性UISplitViewController管理多列内容显示，并获得了多项增强： 交互式列调整：用户现在可通过拖动分隔符调整列宽，指针形状会相应变化指示调整方向 列宽自定义：开发者可设置minimumWidth、maximumWidth和preferredWidth属性优化列显示 分割视图控制器布局环境：新特征帮助UI根据展开/折叠状态自适应调整 检查器列支持：原生支持在尾随边缘显示元数据等附加信息，自动适应展开/折叠状态 1234// 示例：设置分割视图控制器的列宽偏好splitViewController.setMinimumWidth(200, for: .primary)splitViewController.setMaximumWidth(400, for: .primary)splitViewController.setPreferredWidth(300, for: .primary) UITabBarController的多平台适配UITabBarController在不同平台呈现差异化： iPhone：底部标签栏 Mac：工具栏或边栏 Apple Vision Pro：场景前缘装饰 iPad：顶部与导航控件结合或作为边栏 标签组管理是重要功能，开发者可通过UITabBarControllerDelegate自定义导航堆栈的视图控制器推送逻辑。 123456// 示例：自定义标签组视图控制器显示func tabBarController(_ tabBarController: UITabBarController, displayedViewControllersFor tab: UITabBarItem) -&gt; [UIViewController] &#123; guard tab == libraryTab else &#123; return [] &#125; return [libraryViewController]&#125; 构建真正自适应的UI安全区域与布局指南确保内容位于安全区域内是自适应UI的关键。开发者应： 使用layoutMarginsGuide为标准边距定位内容 在iPadOS 26中，注意窗口控制对布局的影响 使用水平角适应的布局边距指南处理窗口控制周边的布局 1234// 示例：安全区域布局实现let margins = view.layoutMarginsGuidecontentView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = truecontentView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = true 窗口控制与方向管理iPadOS 26引入了类似macOS的窗口控制。开发者应： 通过UIWindowSceneDelegate实现preferredWindowingControlStyle指定偏好样式 使用考虑窗口控制的布局指南防止UI遮挡 谨慎使用界面方向锁定，仅在必要时通过prefersInterfaceOrientationLocked实现 性能优化与未来兼容对于资源密集型UI（如游戏），应： 通过isInteractivelyResizing仅在交互完成后更新资源 移除已弃用的UIRequiresFullscreen键 注意iOS 26后系统将不再为新屏幕尺寸自动缩放应用UI 总结与下一步构建灵活UIKit应用的三部曲： 采用场景生命周期：为多平台适配奠定基础 善用容器视图控制器：UISplitViewController和UITabBarController是强大工具 实现自适应UI：通过安全区域、布局指南等API确保界面弹性 开发者应观看相关视频”UIKit的新功能”和”提升iPadOS中的标签页和边栏使用体验”，并参考技术文档完成迁移。通过这些实践，应用将能在苹果全平台生态中提供卓越的用户体验。 相关视频UIKit的新功能提升iPadOS中的标签页和边栏使用体验 文档TN3187:迁移到基于场景的UIKit生命周期UIKit更新","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"探索 visionOS 上的空间配件输入","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_289/","text":"了解如何将空间配件整合到你的 app 中。展示虚拟内容、与 app 进行交互、在空间中进行追踪，并获取有关交互效果的信息，进一步提升 visionos 上的虚拟体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 visionOS 上的空间配件输入：打造沉浸式雕刻体验Apple 在 visionOS 中引入了空间配件支持功能，为开发者提供了全新的交互方式。本文将通过一个空间雕刻应用的开发实例，详细介绍如何利用 PlayStation VR2 Sense 控制器和罗技 Muse 等空间配件，在 visionOS 应用中实现精确的追踪和交互。 空间配件概述visionOS 原本采用”眼手优先”的输入范式，而新加入的空间配件支持则扩展了这一体验。目前支持两款空间配件： PlayStation VR2 Sense 控制器：具有按钮、摇杆、扳机键和精准空间追踪，非常适合游戏场景 罗技 Muse：配备力传感器和触觉反馈，适用于生产力与创意应用 这些配件可以用于全空间和共享空间应用，通过结合 Vision Pro 的摄像头和配件自身的传感器实现位置与旋转追踪。 应用开发基础项目设置首先需要在 Xcode 项目中进行配置： 在 plist 中添加”Spatial Gamepad”支持 在”Accessory Tracking Usage”字段描述配件用途（如”追踪配件移动来雕刻虚拟粘土”） 配件连接管理使用 Game Controller 框架管理配件连接： 1234567NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidConnect, object: nil, queue: nil) &#123; notification in if let controller = notification.object as? GCController, controller.productCategory == GCProductCategorySpatialController &#123; &#125;&#125; 需要监听 GCControllerDidConnect 和 GCStylusDidConnect 通知来处理配件的连接和断开事件。 实现配件追踪与交互锚定虚拟内容在配件末端显示虚拟笔尖需要使用锚定技术。创建 AccessoryAnchoringSource 并锚定到配件的”aim”位置： 12345678func setupSpatialAccessory(device: GCDevice) async throws &#123; let source = try await AnchoringComponent.AccessoryAnchoringSource(device: device) guard let location = source.locationName(named: &quot;aim&quot;) else &#123; return &#125; let sculptingEntity = AnchorEntity(.accessory(from: source, location: location), trackingMode: .predicted)&#125; 追踪模式可选择： predicted（预测）：响应速度快，适合渲染和低延迟交互 continuous（连续）：精度高但延迟较高 获取变换矩阵使用 SpatialTrackingSession 获取配件 AnchorEntity 的变换： 123let session = SpatialTrackingSession()let configuration = SpatialTrackingSession.Configuration(tracking: [.accessory])await session.run(configuration) 添加触觉反馈为增强沉浸感，可以为配件添加触觉反馈： 12345678let stylus: GCStylus = ...guard let haptics = stylus.haptics else &#123; return&#125;guard let hapticsEngine: CHHapticEngine = haptics.createEngine(withLocality: .default) else &#123; return&#125;try? hapticsEngine.start() 高级功能实现响应式工具栏从 AnchorEntity 获取 ARKit 的 AccessoryAnchor 可实现响应式工具栏： 123456func getAccessoryAnchor(entity: AnchorEntity) -&gt; AccessoryAnchor? &#123; if let component = entity.components[ARKitAnchorComponent.self], return accessoryAnchor &#125; return nil&#125; 利用 handedness 属性决定工具栏显示位置： 左手握持时显示在正X轴方向 右手握持时显示在负X轴方向 纯 ARKit 实现对于自定义渲染的应用，可直接使用 ARKit API 追踪配件： 创建 Accessory 对象 使用 Accessory 追踪提供者 处理配件连接/断开事件 设计考量开发空间配件应用时需注意： 视图应同时接收手势和游戏控制器输入 全空间应用可使用 .persistentSystemOverlays 和 .upperLimbVisibility 增强沉浸感 应同时支持配件和手部输入 应用商店可展示”支持空间游戏控制器”或”需要空间游戏控制器”徽章 总结空间配件为 visionOS 应用带来了精细输入控制和触觉反馈的新维度。通过 GameController、RealityKit 和 ARKit 的组合，开发者可以创造高度沉浸的交互体验。从游戏到创意工具，空间配件的应用潜力才刚刚开始显现。 相关视频RealityKit 的新功能使用 ARKit 打造更出色的空间计算体验使用 RealityKit 构建空间绘画 App利用虚拟和物理游戏控制器游戏控制器的进展","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"了解 Foundation Models 框架","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_286/","text":"了解如何利用 apple 智能背后的设备端大语言模型！这个简介讲座涵盖了丰富的主题，从用于生成 swift 数据结构并结合流式传输实现灵敏响应体验的引导式生成功能，到用于整合数据源和会话以进行上下文管理的工具调用机制，应有尽有。这个讲座不设任何先决条件。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 Foundation Models 框架：设备端大语言模型的力量在2025年WWDC大会上，Apple推出了全新的Foundation Models框架，为开发者提供了访问设备端大语言模型的强大工具。本文将深入解析这个创新框架的关键功能和特性。 框架概述Foundation Models框架通过简洁强大的Swift API，让开发者能够在macOS、iOS、iPadOS和visionOS平台上访问驱动Apple智能的设备端大语言模型。该框架特别适用于内容生成、文本摘要和用户输入分析等任务。 所有数据处理都在设备端完成，确保了用户隐私安全，并支持离线运行。由于直接内置在操作系统中，该框架不会增加应用体积，为开发者提供了轻量级的AI解决方案。 核心功能解析模型能力与限制Foundation Models框架搭载的设备端模型是一个拥有30亿参数的大语言模型，每个参数量化到2比特。虽然比操作系统内其他模型规模大几个数量级，但它仍是专为设备优化的模型： 擅长摘要生成、信息提取、分类等任务 不适用于需要世界知识或复杂推理的任务 需要将复杂任务分解为更小单元处理 开发者可以通过Xcode Playground快速测试模型响应： 1234567import FoundationModelsimport Playgrounds#Playground &#123; let session = LanguageModelSession() let response = try await session.respond(to: &quot;What&#x27;s a good name for a trip to Japan? Respond only with a title&quot;)&#125; 引导式生成技术传统大语言模型输出非结构化内容，难以直接映射到应用界面。Foundation Models的引导式生成技术解决了这一问题： 12345678910@Generablestruct SearchSuggestions &#123; @Guide(description: &quot;建议搜索词列表&quot;, .count(4)) var searchTerms: [String]&#125;let response = try await session.respond( to: &quot;为一个关于游览著名地标的应用生成建议搜索词列表。&quot;, generating: SearchSuggestions.self) @Generable宏允许开发者定义期望的Swift数据结构，@Guide则通过自然语言描述属性。这种方法不仅简化了提示词设计，还通过约束解码技术保证了输出结构正确性。 快照流式传输不同于传统的增量流式传输，Foundation Models采用快照流式传输技术，特别适合结构化输出场景： 12345678let stream = session.streamResponse( to: &quot;制定3天富士山旅行计划。&quot;, generating: Itinerary.self)for try await partial in stream &#123; print(partial)&#125; 每个快照都表示部分生成的响应，所有属性都是可选的，随着模型生成更多内容而逐步填充。这种方法与SwiftUI等声明式框架完美配合，实现流畅的用户体验。 高级功能工具调用机制工具调用让模型能够执行开发者在应用中定义的代码，扩展了模型能力： 12345678910111213struct WeatherTool: Tool &#123; static let name = &quot;weather_tool&quot; static let description = &quot;获取指定城市的当前温度&quot; struct Parameters: Generable &#123; var city: String &#125; func call(_ parameters: Parameters) async throws -&gt; ToolOutput &#123; let temperature = try await getTemperature(for: parameters.city) return ToolOutput(.generated(Weather(temperature: temperature))) &#125;&#125; 定义工具后，只需将其传入会话初始化方法，模型就能自主决定何时调用这些工具。 有状态会话管理Foundation Models框架围绕有状态会话构建，支持多轮对话上下文跟踪： 1234let session = LanguageModelSession( model: .default, instructions: &quot;你是一个专业旅行规划助手，回答应简洁专业。&quot;) 会话对象的transcript属性记录所有交互历史，isResponding属性则指示模型是否正在生成响应，帮助开发者管理交互流程。 开发者工具与体验Apple为Foundation Models框架提供了完善的开发支持： Xcode Playground宏快速迭代提示词 Instruments应用分析模板优化模型请求延迟 Feedback Assistant反馈渠道帮助改进模型和API 适配器训练工具包支持高度专业化用例 123456#Playground &#123; let session = LanguageModelSession() for landmark in ModelData.shared.landmarks &#123; let response = try await session.respond(to: &quot;What&#x27;s a good name for a trip to \\(landmark.name)? Respond only with a title&quot;) &#125;&#125; 总结与展望Foundation Models框架代表了设备端AI技术的重大突破，通过Swift友好的API将大语言模型能力带给Apple平台开发者。其核心创新包括： 引导式生成确保结构化输出 快照流式传输优化用户体验 工具调用扩展模型能力 有状态会话支持复杂交互 随着开发者社区开始采用这一框架，预计将涌现大量创新应用场景，从个性化辅助到实时内容生成。Apple也承诺将持续优化模型性能，并通过开发者反馈改进框架功能。 相关视频探索 Apple 平台上的机器学习和 AI 框架探索设备端基础模型的提示设计和安全深入了解 Foundation Models 框架跟着视频学编程：使用 Foundation Models 框架将设备端 AI 引入你的 App 文档人机界面指南：生成式 AI","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"使用全新设计系统构建 UIKit App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_284/","text":"更新你的 uikit app，以便充分利用全新设计系统。我们将深入探索标签视图、分屏浏览、栏、演示文稿、搜索和控制项等方面的主要变化，并向你展示如何在自定 ui 中使用 liquid glass。为了充分从这个视频中获益，建议你先观看“了解全新设计系统”以获取一般性设计指导。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用全新设计系统构建 UIKit 应用iOS 26引入了名为Liquid Glass的全新设计系统，为UIKit应用带来了显著的视觉和交互体验提升。本文将详细介绍如何将现有UIKit应用适配到这一新设计系统，涵盖从基础控件到自定义UI的各个方面。 设计系统概览Liquid Glass是iOS 26的核心设计语言，其特征是半透明、灵动的玻璃质感效果。系统级UIKit组件如标签栏、导航栏等已全面更新为新设计风格，开发者仅需使用新SDK重新编译应用即可自动获得这些改进。 为获得最佳实践指导，建议先观看”了解Liquid Glass”和”使用Liquid Glass设计系统进行设计”等参考视频。 标签视图与分屏浏览的更新UITabBarController和UISplitViewController已全面采用Liquid Glass设计语言。iPhone上的标签栏现在悬浮在内容上方，并支持滚动最小化功能以优化内容浏览体验。 12// 设置标签栏滚动最小化行为tabBarController.tabBarMinimizeBehavior = .onScrollDown 标签栏上方可添加补充视图，如音乐应用的迷你播放器。这些补充视图会随着标签栏最小化而自动调整布局。 1234// 创建底部补充视图let nowPlayingView = NowPlayingView()let accessory = UITabAccessory(contentView: nowPlayingView)tabBarController.bottomAccessory = accessory iPad上的边栏设计也采用了类似风格，通过UIBackgroundExtensionView可以实现边栏下方显示内容的高级视觉效果。 导航栏与工具栏的改进导航栏和工具栏在新系统中采用透明玻璃质感设计，悬浮在内容上方。系统自动将工具栏按钮按视觉特征分组，每组共享玻璃背景。 12345678910// 自定义按钮分组navigationItem.rightBarButtonItems = [ doneButton, flagButton, folderButton, infoButton, .fixedSpace(0), shareButton, selectButton] 导航栏现在支持更丰富的标题显示选项，包括副标题和大标题副标题视图。 123// 设置标题和副标题navigationItem.title = &quot;收件箱&quot;navigationItem.subtitle = &quot;49 未读&quot; 呈现效果与搜索体验系统呈现效果也更新为Liquid Glass风格，包括动态缩放过渡动画。操作表单现在锚定在源视图上方，提供更自然的交互体验。 1234// 从工具栏按钮变形表单viewController.preferredTransition = .zoom &#123; _ in folderBarButtonItem&#125; 搜索功能得到显著改进，提供更紧凑的布局和更多放置选项。 123456// 将搜索栏放置在工具栏toolbarItems = [ navigationItem.searchBarPlacementBarButtonItem, .flexibleSpace(), addButton] 控件更新与自定义效果标准控件如按钮、滑块等都重新设计了外观。按钮现在支持玻璃质感样式配置。 12345// 标准玻璃质感button.configuration = .glass()// 突出显示玻璃质感tintedButton.configuration = .prominentGlass() 开发者还可以在自定义UI元素中应用Liquid Glass效果，创建与系统风格一致的视觉体验。 12345678// 为自定义视图应用玻璃效果let effectView = UIVisualEffectView()addSubview(effectView)let glassEffect = UIGlassEffect()UIView.animate &#123; effectView.effect = glassEffect&#125; 适配建议与总结UIKit提供了全面的工具支持新设计系统的适配。开发者应： 使用Xcode 26构建应用 逐屏审查界面元素 考虑用标准控件替代自定义实现 巧妙运用Liquid Glass突出特色功能 通过系统提供的API，开发者可以轻松为应用带来现代化的视觉体验，同时保持与iOS生态的一致性。 相关资源相关视频了解 Liquid Glass了解全新设计系统让你的 UIKit App 更加灵活UIKit 的新功能提升 iPadOS 中的标签页和边栏使用体验提升 UI 动画和过渡效果 文档采用 Liquid Glass人机界面指南","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"用于打造沉浸式 App 的 Metal 渲染的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_294/","text":"探索用于通过 compositor services 打造沉浸式 app 的 metal 渲染的最新改进。了解如何通过添加悬停效果来突出展示 app 的交互式元素，以及如何通过动态渲染质量实现更高保真度的渲染。了解新的 progressive 沉浸样式。探索如何通过将 mac 中的 metal 内容直接渲染至 vision pro，来为 macos app 提供沉浸式体验。 要充分利用好本次讲座，请先观看 wwdc23 讲座“探索 metal 技术打造沉浸式 app”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 用于打造沉浸式 App 的 Metal 渲染新功能苹果在 WWDC 上展示了通过 Compositor Services 打造沉浸式应用的 Metal 渲染最新改进。这些新功能包括悬停效果、动态渲染质量和渐进式沉浸风格，为开发者提供了更丰富的工具来提升应用交互性和视觉效果。 新渲染循环 APIMetal 沉浸式应用的渲染流程始于新的渲染循环 API。开发者需要创建包含合成器层的沉浸空间，该层提供用于渲染循环的层渲染器对象。今年的 Compositor Services 新增了返回数组的 queryDrawables 函数，根据系统上下文，该数组将包含 1 或 2 个 drawables。 12345678910111213141516171819// 场景渲染循环extension Renderer &#123; func renderFrame(with scene: MyScene) &#123; guard let frame = layerRenderer.queryNextFrame() else &#123; return &#125; frame.startUpdate() scene.performFrameIndependentUpdates() frame.endUpdate() let drawables = frame.queryDrawables() guard !drawables.isEmpty else &#123; return &#125; guard let timing = frame.predictTiming() else &#123; return &#125; LayerRenderer.Clock().wait(until: timing.optimalInputTime) frame.startSubmission() scene.render(to: drawable) frame.endSubmission() &#125;&#125; 悬停效果新的悬停效果功能让用户能直观看到哪些对象可交互。系统会动态高亮用户注视对象，为应用和游戏添加更丰富的交互细节。 开发者需要在层配置中设置追踪区域格式： 12345678910// 层配置struct MyConfiguration: CompositorLayerConfiguration &#123; func makeConfiguration(capabilities: LayerRenderer.Capabilities, configuration: inout LayerRenderer.Configuration) &#123; let trackingAreasFormat: MTLPixelFormat = .r8Uint if capabilities.supportedTrackingAreasFormats.contains(trackingAreasFormat) &#123; configuration.trackingAreasFormat = trackingAreasFormat &#125; &#125;&#125; 对象渲染时需要处理悬停效果： 1234567891011121314// 对象渲染函数extension MyObject &#123; func render(drawable: Drawable, renderEncoder: MTLRenderCommandEncoder) &#123; var renderValue: LayerRenderer.Drawable.TrackingArea.RenderValue? = nil if self.isInteractive &#123; let trackingArea = drawable.addTrackingArea(identifier: self.identifier) if self.usesHoverEffect &#123; trackingArea.addHoverEffect(.automatic) &#125; renderValue = trackingArea.renderValue &#125; self.draw(with: commandEncoder, trackingAreaRenderValue: renderValue) &#125;&#125; Metal 片段着色器需要同时输出颜色和追踪区域值： 1234567891011121314// Metal 片段着色器struct FragmentOut&#123; float4 color [[color(0)]]; uint16_t trackingAreaRenderValue [[color(1)]];&#125;;fragment FragmentOut fragmentShader( /* ... */ )&#123; return FragmentOut &#123; float4(outColor, 1.0), uniforms.trackingAreaRenderValue &#125;;&#125; 动态渲染质量动态渲染质量功能允许应用根据场景复杂度调整内容分辨率。开发者可以指定适合应用的最大渲染质量，并根据显示内容类型在运行时调整质量。 12345678// 质量常量extension MyScene &#123; struct Constants &#123; static let menuRenderQuality: LayerRenderer.RenderQuality = .init(0.8) static let worldRenderQuality: LayerRenderer.RenderQuality = .init(0.6) static var maxRenderQuality: LayerRenderer.RenderQuality &#123; menuRenderQuality &#125; &#125;&#125; 层配置中需要设置最大渲染质量： 123456789// 层配置struct MyConfiguration: CompositorLayerConfiguration &#123; func makeConfiguration(capabilities: LayerRenderer.Capabilities, configuration: inout LayerRenderer.Configuration) &#123; if configuration.isFoveationEnabled &#123; configuration.maxRenderQuality = MyScene.Constants.maxRenderQuality &#125; &#125;&#125; 运行时可以根据场景类型调整渲染质量： 12345678910111213141516// 设置运行时渲染质量extension MyScene &#123; var renderQuality: LayerRenderer.RenderQuality &#123; switch type &#123; case .world: Constants.worldRenderQuality case .menu: Constants.menuRenderQuality &#125; &#125;&#125;extension Renderer &#123; func adjustRenderQuality(for scene: MyScene) &#123; guard layerRenderer.configuration.isFoveationEnabled else &#123; return &#125; layerRenderer.renderQuality = scene.renderQuality &#125;&#125; 渐进式沉浸渐进式沉浸风格允许用户通过旋转 Digital Crown 控制沉浸程度。系统仅渲染当前沉浸级别内的内容，通过门户模板屏蔽外部内容，节省计算资源。 相关资源开发者可以通过以下资源深入了解这些新功能： 相关视频: 探索 Metal 技术打造沉浸式 App 探索 Metal 4 文档: 在 Metal 沉浸式应用中渲染悬停效果","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"将 SceneKit 项目移植到 RealityKit","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_288/","text":"了解为什么要弃用 scenekit，并探索如何将你的 3d 项目迁移至 realitykit 这一 apple 推荐的高级 3d 引擎。我们将阐明弃用 scenekit 对你的项目意味着什么，比较这两个引擎之间的关键概念，并向你展示如何将一个示例 scenekit 游戏移植到 realitykit。我们还将探讨 realitykit 在所有受支持平台上拥有的巨大潜力，以帮助你为 app 和游戏打造出精彩的 3d 体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 从 SceneKit 到 RealityKit：3D 项目的现代化迁移指南SceneKit 作为 Apple 平台上的原生 3D 引擎，曾为开发者提供了创建 3D 应用的便捷途径。随着技术演进和生态发展，Apple 现已正式在所有平台上弃用 SceneKit，并推荐开发者迁移至其现代化高级 3D 引擎 RealityKit。本文将深入解析这一过渡的技术细节和实践方法。 引言：SceneKit 的现状与未来SceneKit 的历史可以追溯到 13 年前的 OS X Mountain Lion 时代。多年来，它为开发者提供了可靠的 3D 渲染能力，包括著名的”Max the Panda”示例游戏。然而，随着 Apple 生态系统的发展变化，SceneKit 的架构已难以在不破坏现有应用的前提下持续更新。 此次弃用属于”软弃用”，意味着： 现有 SceneKit 应用仍可正常运行 不会强制要求立即重写代码 仅会修复关键错误，不再提供新功能 对于新开发项目，RealityKit 已成为 Apple 平台上的首选 3D 引擎，它被广泛应用于系统功能和第三方应用中，如 Quick Look 3D 预览、App Store 立体图标等，特别是在 visionOS 中扮演着核心角色。 核心架构对比节点式 vs 实体组件系统SceneKit 采用传统的节点式架构： 场景中的每个对象都是一个节点(SCNNode) 通过节点的预定义属性控制行为 功能集成在同一节点上(几何体、动画、音频等) 而 RealityKit 采用的是现代实体组件系统(ECS)： 每个场景对象都是实体(Entity) 通过附加组件(Component)定义行为 功能模块化，更加灵活 坐标系与资产格式两种引擎在坐标系上保持一致： x 轴向右 y 轴向上 z 轴朝向相机 但在资产格式上，SceneKit 使用专有的 SCN 格式，而 RealityKit 采用行业标准 USD(Universal Scene Description)格式，这有助于资产在不同工具间的交换和协作。 视图系统差异SceneKit 提供多种视图： SCNView SwiftUI 的 SceneView ARSCNView(用于 ARKit) RealityKit 则统一使用 RealityView： 专为 SwiftUI 设计 支持从纯虚拟场景到现实世界对象放置 自动适应所有 Apple 平台 资产转换与场景构建资产格式转换将现有 SceneKit 资产迁移到 RealityKit 有两种主要方法： Xcode 图形化导出：通过文件菜单将 SCN 资产导出为 USDZ 格式 命令行工具：使用 Xcode 26 中的 scntool 进行转换，特别是对于包含动画的资产： 1xcrun scntool --convert max.scn --format usdz --append-animation max_spin.scn 场景构建工具从 Xcode 的场景编辑器转向 Reality Composer Pro： 组合场景 添加/编辑组件 创建材质与着色器 准备最终场景 在 SwiftUI 中加载场景变得非常简单：1234567import RealityKitimport PyroPanda // 场景包RealityView &#123; content in let scene = try! await Entity(named: &quot;Scene&quot;, in: pyroPandaBundle) content.add(scene)&#125; 关键功能实现对比动画系统RealityKit 通过 AnimationLibraryComponent 管理动画，播放方式更加简洁：123456guard let max = scene.findEntity(named: &quot;Max&quot;), let library = max.components[AnimationLibraryComponent.self], let spin = library.animations[&quot;spin&quot;] else &#123; return &#125;max.playAnimation(spin) 光照系统RealityKit 提供更灵活的光照选项，包括带阴影的定向光：1234Entity(components: DirectionalLightComponent(), DirectionalLightComponent.Shadow()) 音频系统音频配置可以在 Reality Composer Pro 中预制，播放方式有两种：12345// 直接播放terrain.playAudio(audioResource)// 使用实体动作terrain.playAnimation(PlayAudioAction.targeted(...)) 视觉特效实现粒子系统和后处理特效在 RealityKit 中得到了显著增强：12345678final class BloomPostProcess: PostProcessEffect &#123; func postProcess(context: PostProcessEffectContext) &#123; // 实现自定义泛光效果 &#125;&#125;// 应用效果content.renderingEffects.customPostProcessing = .effect(BoomPostProcess()) 多平台适配与未来展望迁移后的 RealityKit 项目可以无缝运行于 iOS、iPadOS、macOS 和 tvOS 平台。特别在 visionOS 中，开发者可以利用渐进式沉浸视图创建独特的 3D 门户体验。 结论与学习资源虽然 SceneKit 被弃用，但现有应用仍能继续运行。RealityKit 作为 Apple 3D 技术的未来，提供了： 现代 ECS 架构 行业标准 USD 支持 跨平台一致性 强大的创作工具链 开发者可以通过以下资源进一步学习： RealityKit 的新功能利用 RealityKit 音频让空间计算 App 更加引人入胜在 Reality Composer Pro 中编写交互式 3D 内容认识 Reality Composer Pro","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"了解 Apple Projected Media Profile","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_297/","text":"深入了解 apple projected media profile (apmp)，并探索 apmp 如何通过视频扩展使用信号技术在 quicktime 和 mp4 文件中实现 180º/360º 和宽视角投影。我们将针对如何使用 os 提供的框架和工具对包含 apmp 的媒体进行转换、读/写、编辑和编码提供相关指导。我们还将介绍 apple positional 音频编解码器 (apac) 的功能，这些功能可用于创建和交付空间音频内容，从而打造出极具沉浸感的体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深入解析 Apple Projected Media Profile (APMP) 及 Apple Positional Audio Codec (APAC)随着沉浸式媒体技术的快速发展，Apple在WWDC上正式发布了Apple Projected Media Profile (APMP)和Apple Positional Audio Codec (APAC)两项重要技术标准。本文将详细介绍这两项技术的核心概念、技术实现和应用场景。 APMP概述Apple Projected Media Profile (APMP)是一套用于在QuickTime和MP4文件中存储180度、360度及宽视角视频内容的技术规范。该标准通过视频扩展使用信号技术，为沉浸式视频体验提供了标准化解决方案。 非线性视频投影类型APMP支持四种主要投影类型： 2D/3D/空间视频：采用线性投影方式 180度视频：使用半等距柱状投影 360度视频：采用等距柱状投影 宽视角视频：使用参数化投影（ParametricImmersive） 等距柱状投影（Equirectangular Projection）是目前编辑软件中广泛支持的格式，它将球体像素坐标表示为纬度和经度角度，并等比例映射到矩形视频帧中。其中水平轴代表经度（-180°至+180°），垂直轴代表纬度（-90°至+90°）。 技术实现细节文件格式与信号传递APMP内容通过QuickTime和MP4文件格式存储，利用ISO基本媒体文件格式(ISOBMFF)中的box结构组织数据。在visionOS 26中，Apple扩展了Video Extended Usage (vexu) box的功能，新增了以下关键box类型： 投影box：标识投影类型（等距柱状、半等距柱状或ParametricImmersive） 镜头集合box：包含ParametricImmersive投影的外部和镜头畸变参数 视图打包box：描述帧打包图像中的眼睛排列方式 参数化投影详解ParametricImmersive投影专门用于处理广角或鱼眼镜头的视频内容，包含了以下重要参数： 外部参数：通过3×3相机矩阵’K’表示，包含焦距、光学中心和镜头系统倾斜度等 镜头畸变参数： 径向畸变：校正桶形畸变现象 切向畸变 投影偏移 径向角度限制 镜头帧调整 工作流程与应用内容捕获与编辑目前市场上有多种支持APMP内容的捕获设备： 180度视频：Canon EOS VR系统等 360度视频：GoPro MAX、Insta360 X5等 宽视角视频：GoPro HERO 13、Insta360 Ace Pro 2等 编辑工作流程中，Final Cut Pro已支持360度APMP内容的读写，今年晚些时候Canon EOS VR Utility和GoPro Player等软件也将加入APMP支持。 典型的立体180工作流程包括： 使用HEVC、RAW或ProRes编解码器捕获内容 使用ProRes进行编辑 使用MV-HEVC编解码器编码和发布 开发者API支持Apple在CoreMedia和AVFoundation框架中新增了以下功能： 资源转换：识别Spherical Metadata V1/V2信号并转换为APMP格式 视频读取：通过AVAssetPlaybackAssistant识别APMP内容 视频编辑： 使用AVVideoComposition处理投影媒体 CMTaggedBuffers和CMTaggedDynamicBuffers处理立体内容 视频编写：通过AVAssetWriter输出APMP内容 发布规范与建议对于visionOS上的APMP内容发布，Apple推荐以下技术参数： 视频编解码器：HEVC Main或Main 10，4:2:0色度二次采样 色彩空间：Rec 709或P3-D65 分辨率： 单视10-bit：7680×3840 立体4K：每眼4320×4320 帧率：10-bit单视8K或立体4K推荐30fps 比特率：峰值不超过150Mbps HTTP Live Streaming (HLS)规范也已更新支持APMP流媒体传输，在EXT-X-STREAM-INFORMATION标签中新增了REQ-VIDEO-LAYOUT属性。 Apple Positional Audio Codec (APAC)为了完善沉浸式体验，Apple推出了空间音频编解码器APAC，其主要特点包括： 全息音频技术：使用球谐基函数数学编码声场 一阶全息：4个分量（1全向+3方向性） 二阶全息：9个分量 三阶全息：16个分量 编码支持： 支持平台：iOS、macOS、visionOS（watchOS除外） 比特率范围：一阶384kbps至三阶768kbps 流媒体传输：支持通过HLS分段传输APAC音频 总结Apple Projected Media Profile和Apple Positional Audio Codec为沉浸式媒体提供了完整的技术解决方案。APMP标准化了180度、360度和宽视角视频的存储和传输格式，而APAC则实现了高保真空间音频的编码和回放。开发者可以利用Apple提供的丰富API支持，在应用中集成这些先进技术，为用户创造更加真实、沉浸的视听体验。 随着更多硬件厂商和软件开发者采用这些标准，我们期待看到更丰富的沉浸式内容生态系统在Apple平台上蓬勃发展。 相关资源相关视频了解 Apple 沉浸视频技术探索 visionOS 的视频体验支持 visionOS App 播放沉浸视频空间网页的新功能AVQT 的新功能使用高级视频质量工具评估视频 文档Apple HEVC Stereo Video Interoperability ProfileAVFoundationCore MediaHTTP Live StreamingHTTP Live Streaming (HLS) authoring specification for Apple devicesQuickTime and ISO Base Media File Formats and Spatial and Immersive MediaUsing Apple’s HTTP Live Streaming (HLS) Tools","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"使用基于机器学习的视频效果增强你的 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_300/","text":"了解如何添加帧率转换、超高分辨率和噪声过滤等效果来改善视频编辑与直播体验。我们将探索 video toolbox 框架中专为 apple 芯片优化的基于 ml 的视频处理算法。了解如何将这些效果整合起来，以增强 app 在真实用例中的功能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用基于机器学习的视频效果增强你的 App：WWDC 技术解析引言在当今数字时代，视频内容已成为应用体验的重要组成部分。Apple 在最新的 Video Toolbox 框架中引入了一系列基于机器学习且针对 Apple 芯片优化的视频处理算法，为开发者提供了强大的工具来提升视频质量。这些创新技术包括帧率转换、超分辨率处理和降噪过滤等效果，能够显著改善视频编辑与直播体验。 视频效果概览专业级视频编辑效果VTFrameProcessor API 提供三种专业视频编辑效果： 帧率转换：调整视频的每秒帧数以匹配目标帧率或创建慢动作效果。示例展示了足球运动员庆祝进球的视频，慢动作版本更好地捕捉了庆祝的激情时刻。 超分辨率缩放：提升视频分辨率并修复老旧视频细节，特别适合照片增强和媒体修复应用。演示中船只的清晰度显著提升。 动态模糊：电影制作常用技术，创造自然运动效果。处理后的骑行者视频消除了卡顿感，看起来速度更快。 实时视频处理效果针对实时应用场景，API提供了： 时域降噪滤镜：基于运动估计技术，利用前后参考帧平滑时域噪声。树木视频中的彩色噪点，特别是交通标志部分明显减少。 低延迟帧插值：保持实时性能前提下提升帧率，可选择同时提升分辨率。女性讲话视频处理后播放更加流畅。 低延迟视频超分辨率：轻量级超缩放器，专为优化视频会议体验设计，减少编码伪影并锐化边缘。 技术集成指南基本处理流程使用 VTFrameProcessor API 包含两个主要步骤： 选择效果：通过配置参数创建处理会话 逐帧处理：应用发送带参数的输入视频帧，框架返回处理后的输出帧 开发者首先需要导入 Video Toolbox 框架，然后按照特定用例配置处理器。 帧率转换实现以下代码展示了创建帧率转换处理会话的核心实现： 12345678910let processor = VTFrameProcessor()guard let configuration = VTFrameRateConversionConfiguration(frameWidth: width, frameHeight: height, usePrecomputedFlow: false, qualityPrioritization: .normal, revision: .revision1)else &#123; throw Fault.failedToCreateFRCConfiguration&#125;try processor.startSession(configuration: configuration) 帧处理参数设置示例： 123456789101112131415sourceFrame = VTFrameProcessorFrame(buffer: curPixelBuffer, presentationTimeStamp: sourcePTS)nextFrame = VTFrameProcessorFrame(buffer: nextPixelBuffer, presentationTimeStamp: nextPTS)var interpolationPhase: [Float] = [0.25, 0.5, 0.75]guard let parameters = VTFrameRateConversionParameters(sourceFrame: sourceFrame, nextFrame: nextFrame, opticalFlow: nil, interpolationPhase: interpolationPhase, submissionMode: .sequential, destinationFrames: destinationFrames)else &#123; throw Fault.failedToCreateFRCParameters&#125;try await processor.process(parameters: parameters) 动态模糊效果实现动态模糊效果通过以下代码实现，其中模糊强度可通过API调节： 123456789101112guard let parameters = VTMotionBlurParameters(sourceFrame: currentFrame, nextFrame: nextFrame, previousFrame: previousFrame, nextOpticalFlow: nil, previousOpticalFlow: nil, motionBlurStrength: strength, submissionMode: .sequential, destinationFrame: destinationFrame) else &#123; throw Fault.failedToCreateMotionBlurParameters&#125;try await processor.process(parameters: parameters) 实时处理优化对于视频会议等实时场景，开发者可以使用： LowLatencySuperResolutionScalerConfiguration 实现超分辨率 低延迟帧插值提升网络不佳时的视频通话流畅度 这些优化特别适合需要即时处理的场景，如直播和视频会议应用。 结论Video Toolbox 框架通过 VTFrameProcessor API 为开发者提供了强大的视频处理能力。无论是为视频编辑添加专业效果，还是提升实时视频质量，这些基于机器学习的技术都能显著改善用户体验。随着这些技术在 iOS 26 和 macOS 15.4 中的可用性扩展，开发者现在有更多机会将这些先进功能集成到自己的应用中。 相关文档Frame processingVideo Toolbox","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"借助 MLX 在 Apple 芯片上探索大语言模型","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_298/","text":"了解 mlx lm，这款工具专为在 apple 芯片上轻松高效地处理大语言模型而设计。我们将介绍如何在 mac 上微调先进的大语言模型并以此运行推理，以及如何将这些模型无缝整合到基于 swift 的应用程序和项目中。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 借助 MLX 在 Apple 芯片上探索大语言模型在 WWDC 2025 的技术分享中，MLX 团队工程师 Angelos 详细介绍了如何利用 MLX 工具链在 Apple 芯片设备上高效运行和微调大语言模型。这一解决方案为开发者提供了从命令行工具到 Python/Swift API 的完整工作流，使得本地化部署大语言模型变得前所未有地简单。 MLX LM 工具链概览MLX 是一款专为 Apple Silicon 机器学习设计的开源框架，其核心优势在于充分利用了 Metal 框架的 GPU 加速能力以及 Apple 芯片的统一内存架构。这种架构允许 CPU 和 GPU 无缝共享相同数据，消除了传统异构计算中的数据迁移开销。 MLX LM 是构建在 MLX 之上的 Python 工具包，专门针对大语言模型的推理和训练进行了优化。该工具链提供三大核心功能： 命令行工具：无需编写代码即可完成模型推理和微调 Python API：提供完整的编程接口用于定制化模型操作 Swift 集成：原生支持在 Swift 应用中部署大语言模型 模型推理实战MLX LM 提供了极其简单的模型加载方式。开发者可以通过 Hugging Face 社区直接获取数千个预训练模型，也可以通过本地路径加载自定义模型。以下命令展示了如何加载一个 4-bit 量化版的 Mistral-7B 模型： 12mlx_lm.generate --model &quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot; \\ --prompt &quot;Write a quick sort in Swift&quot; 该工具会自动处理模型下载、提示词预处理和文本生成全流程。对于需要精细控制的场景，MLX LM 提供了完整的 Python API： 123456from mlx_lm import load, generatemodel, tokenizer = load(&quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot;)prompt = &quot;Write a quick sort in Swift&quot;messages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]prompt = tokenizer.apply_chat_template(messages, add_generation_prompt=True)text = generate(model, tokenizer, prompt=prompt, verbose=True) 高级特性：KV Cache 与量化对于需要维持对话上下文的场景，MLX LM 提供了键值缓存（KV Cache）机制。该技术通过存储历史计算的注意力键值对，显著提升了长文本生成的效率： 123from mlx_lm.models.cache import make_prompt_cachecache = make_prompt_cache(model)text = generate(model, tokenizer, prompt=prompt, prompt_cache=cache, verbose=True) 量化技术是另一个核心优势。MLX LM 内置的量化功能可以将模型压缩至 4-bit 甚至更低精度，同时保持可接受的精度损失。以下命令展示了如何将原始模型转换为 4-bit 量化版本： 1234mlx_lm.convert --hf-path &quot;mistralai/Mistral-7B-Instruct-v0.3&quot; \\ --mlx-path &quot;./mistral-7b-v0.3-4bit&quot; \\ --dtype float16 \\ --quantize --q-bits 4 --q-group-size 64 模型微调能力MLX LM 支持两种微调模式：全参数微调和低秩适配器（LoRA）微调。后者特别适合在消费级硬件上操作，因为它仅需训练少量新增参数： 12345mlx_lm.lora --model &quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot; --train --data /path/to/our/data/folder --iters 300 --batch-size 16 微调完成后，开发者可以将适配器融合回基础模型，创建独立的可部署版本： 123mlx_lm.fuse --model &quot;./mistral-7b-v0.3-4bit&quot; \\ --adapter-path &quot;adapters&quot; \\ --save-path &quot;fused-mistral-7b-v0.3-4bit&quot; Swift 原生支持MLX 的 Swift API 使得在原生应用中集成大语言模型变得异常简单。以下代码展示了如何在 Swift 应用中加载模型并生成文本： 1234567891011import MLXimport MLXLLMlet modelId = &quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot;let modelFactory = LLMModelModelFactory.sharedlet configuration = ModelConfiguration(id: modelId)let model = try await modelFactory.loadContainer(configuration: configuration)let prompt = &quot;Write a quicksort in Swift&quot;let input = try await context.processor.prepare(input: UserInput(prompt: prompt))let tokenStream = try generate(input: input, parameters: params, context: context) 生态资源与未来发展MLX 项目完全开源，开发者可以通过以下资源深入了解： 相关视频：开始使用适用于 Apple 芯片的 MLX 文档资源：MLXMLX LM - Python APIMLX Explore - Python APIMLX FrameworkMLX Llama InferenceMLX Swift 随着 Apple 芯片性能的持续提升和 MLX 生态的不断完善，在本地设备上部署和微调大语言模型正逐渐成为主流开发范式。这一技术方向不仅为隐私敏感应用提供了新可能，也为个性化AI体验开辟了道路。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"借助 SwiftUI 在 visionOS 中设置场景","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_290/","text":"探索精彩的全新 api，为你的 visionos app 打造更出色的窗口、空间容器和沉浸式空间。微调场景在重新启动或固定位置时的行为。通过裁剪边缘和对齐，根据周边环境来调整空间容器。将流媒体格式的沉浸式内容从 mac 传输到 apple vision pro。借助空间容器和沉浸式空间，让基于 uikit 的现有 app 更上一层楼。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com visionOS 26 中的 SwiftUI 场景构建新特性解析Apple 在 visionOS 26 中为开发者带来了一系列强大的场景构建新特性，这些改进为窗口、空间容器和沉浸式空间提供了更丰富的控制能力和更流畅的交互体验。本文将详细介绍这些新 API 的功能和应用场景。 生命周期管理增强visionOS 26 引入了多项实用的生命周期管理 API，让开发者能够更精细地控制场景的启动和锁定行为。新的 restorationBehavior 修饰符允许开发者禁用特定场景的恢复功能。这在处理欢迎界面、一次性登录提示或与特定应用状态绑定的工具窗口时尤为实用。 1234WindowGroup(&quot;工具&quot;, id: &quot;tools&quot;) &#123; ToolsView()&#125;.restorationBehavior(.disabled) defaultLaunchBehavior 修饰符提供了更灵活的启动控制选项。开发者可以根据应用状态决定是否优先显示特定场景，或使用 .suppressed 行为防止次要窗口在不当时候自动恢复。 1234567WindowGroup(&quot;欢迎页&quot;, id: &quot;welcome&quot;) &#123; WelcomeView() .onAppear &#123; isFirstLaunch = false &#125;&#125;.defaultLaunchBehavior(isFirstLaunch ? .presented : .automatic) 空间容器优化空间容器在 visionOS 26 中获得了多项增强功能。新的表面吸附特性允许窗口和空间容器智能地附着到物理环境表面，如墙面或桌面。通过 SurfaceSnappingInfo API，开发者可以获取吸附状态信息并做出相应调整。 123456789101112131415161718@Environment(\\.surfaceSnappingInfo) private var snappingInfo@State private var hidePlatform = falsevar body: some View &#123; RealityView &#123; /* ... */ &#125; .onChange(of: snappingInfo) &#123; if snappingInfo.isSnapped &amp;&amp; SurfaceSnappingInfo.authorizationStatus == .authorized &#123; switch snappingInfo.classification &#123; case .table: hidePlatform = true default: hidePlatform = false &#125; &#125; &#125;&#125; 新增的裁剪边距 API 允许开发者定义内容与容器边缘的安全距离，确保重要内容不会被遮挡。preferredWindowClippingMargins 和 windowClippingMargins 配合使用，可以创建既美观又实用的空间布局。 1234567891011RealityView &#123; content in // ... waterfall = createWaterfallEntity() content.add(waterfall)&#125; update: &#123; content in waterfall.scale.y = Float(min( windowMargins.bottom / pointsPerMeter, maxWaterfallHeight)) // ...&#125;.preferredWindowClippingMargins(.bottom, maxWaterfallHeight * pointsPerMeter) 沉浸式体验升级沉浸式空间在 visionOS 26 中获得了多项重要改进。onWorldRecenter 修饰符允许应用响应世界重新中心事件，确保虚拟内容始终保持在适当位置。 123456RealityView &#123; content in // ...&#125;.onWorldRecenter &#123; recomputePositions()&#125; 沉浸风格现在支持更多自定义选项。渐进式沉浸风格可以设置特定的宽高比，而混合沉浸风格新增了与系统环境共存的模式。 123456ImmersiveSpace(id: &quot;space&quot;) &#123; ImmersiveView()&#125;.immersionStyle( selection: $selectedStyle, in: .progressive(aspectRatio: .portrait)) 最引人注目的是新增的 RemoteImmersiveSpace，它允许直接从 macOS 应用预览 Vision Pro 沉浸场景，为跨平台开发带来了新的可能性。 场景桥接技术对于现有 UIKit 应用，visionOS 26 提供了场景桥接技术，使这些应用也能利用 SwiftUI 的空间容器和沉浸式空间功能。开发者可以通过继承 UIHostingSceneDelegate 来声明 SwiftUI 场景，并在 UIKit 环境中激活这些场景。 12345678class MyHostingSceneDelegate: NSObject, UIHostingSceneDelegate &#123; static var rootScene: some Scene &#123; WindowGroup(id: &quot;my-volume&quot;) &#123; ContentView() &#125; .windowStyle(.volumetric) &#125;&#125; 总结visionOS 26 为场景构建带来了大量创新功能，从精细的生命周期控制到智能的空间适配，再到跨平台沉浸式体验预览，这些改进显著提升了开发效率和用户体验。开发者现在可以创建更加智能、自然且与物理环境和谐共处的虚拟内容。 相关视频小组件的新功能搭配使用更出色：SwiftUI 和 RealityKit用于打造沉浸式 App 的 Metal 渲染的新功能 文档采用持久化 UI 的最佳实践","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"在你的 App 中提供适龄体验","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_299/","text":"了解如何使用全新的 declared age range api 在你的 app 中提供适龄体验。我们将介绍家长如何允许孩子与 app 共享年龄范围，以确保在保护隐私的情况下提供安全体验。我们还将探索此框架如何帮助你根据用户的年龄来定制你的 app 内容和功能，并展示如何实施年龄限制、理解缓存机制并尊重用户隐私，同时营造更安全、更有趣的体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 在你的应用中提供适龄体验：Declared Age Range API 详解引言随着数字世界日益复杂，如何为不同年龄段的用户提供安全、合适的应用体验成为开发者面临的重要课题。在 iOS 26 中，苹果推出了 Declared Age Range API，帮助开发者在保护用户隐私的前提下，根据年龄范围定制应用功能和内容。本文将详细介绍这一新框架的工作原理、实现方法以及相关隐私保护机制。 儿童上网安全的背景苹果始终致力于创造既能丰富用户生活又能保障安全的数字产品。2025年2月发布的《帮助保护儿童上网安全》白皮书强调了持续保护儿童免受网络威胁的重要性。2025年3月，苹果推出了简化的儿童设置流程，并在iOS 26中进一步优化： 儿童账户年龄错误可轻松更正 App Store全球年龄评级细化至五个类别（4+、9+、13+、16+、18+） 提供更详细的产品页面信息，帮助家长了解内容适合度 这些改进为Declared Age Range API的推出奠定了基础。 Declared Age Range框架解析Declared Age Range框架允许应用在不获取具体生日的前提下，了解用户的年龄区间范围。其核心特性包括： 隐私优先设计API仅返回由两个数字组成的年龄范围区间，而非具体生日。例如： 14岁用户可以声明”13-15岁”区间 9岁用户可以分享”12岁或以下” 42岁用户可以分享”16岁或以上” 框架针对儿童和青少年设计，设置了地区最高年龄限制（通常为该地区成人年龄）。 灵活的年龄区间设置应用可以根据自身需求： 指定最多三个不同年龄节点 产生四个不同区间（每个区间至少持续两年） 自定义适合应用的年龄划分标准 例如，照片分享应用可能关注13岁和16岁两个关键年龄节点。 家长控制选项家长可通过多种途径管理孩子的年龄分享设置： 家庭与设置 &gt; 选择孩子 &gt; Apple账户与密码 &gt; 应用年龄范围 孩子设备上的Apple账户与设置 &gt; 个人信息 &gt; 应用年龄范围 API提供三种分享模式： “始终分享”：自动返回年龄范围，有更新时显示通知 “询问首先”：每次请求时显示分享提示 “从不分享”：始终拒绝请求 隐私保护机制为防止生日信息泄露，框架采取了特殊措施： 在”询问首先”模式下，默认只在原始响应周年纪念日显示提示 在”始终分享”模式下，默认只在周年纪念日透露新年龄信息 例如，孩子年满13岁后，API在周年日前仍会返回”12岁或以下”，直到周年日才会更新。 用户也可手动清除缓存，在设置中选择特定应用并再次点击”分享年龄范围”，强制下次请求时获得更新后的响应。 代码实现示例以下是在SwiftUI应用中使用Declared Age Range API的完整步骤： 1. 添加框架能力在项目目标的Signing and Capabilities标签页添加Declared Age Range能力。 2. 请求年龄范围1234567891011121314151617181920212223242526272829303132333435363738import SwiftUIimport DeclaredAgeRangestruct LandmarkDetail: View &#123; @State var photoSharingEnabled = false @Environment(\\.requestAgeRange) var requestAgeRange var body: some View &#123; ScrollView &#123; Button(&quot;Share Photos&quot;) &#123;&#125; .disabled(!photoSharingEnabled) &#125; .task &#123; await requestAgeRangeHelper() &#125; &#125; func requestAgeRangeHelper() async &#123; do &#123; let ageRangeResponse = try await requestAgeRange(ageGates: 16) switch ageRangeResponse &#123; case let .sharing(range): if let lowerBound = range.lowerBound, lowerBound &gt;= 16 &#123; photoSharingEnabled = true &#125; print(range.ageRangeDeclaration) case .declinedSharing: print(&quot;拒绝分享&quot;) &#125; &#125; catch AgeRangeService.Error.invalidRequest &#123; print(&quot;处理无效请求错误&quot;) &#125; catch AgeRangeService.Error.notAvailable &#123; print(&quot;处理不可用错误&quot;) &#125; catch &#123; print(&quot;未处理错误: \\(error)&quot;) &#125; &#125;&#125; 3. 处理响应和错误API可能返回两种响应： .sharing(range)：包含年龄区间和声明类型（guardianDeclared或selfDeclared） .declinedSharing：用户拒绝分享 错误类型包括： invalidRequest：请求格式错误 notAvailable：设备配置不支持 4. 检查家长控制123if range.activeParentalControls.contains(.communicationLimits) &#123; print(&quot;通讯限制已启用&quot;)&#125; API还会返回家长配置的其他控制项信息。 其他儿童安全工具除了Declared Age Range API，开发者还可以利用以下工具增强儿童安全： Sensitive Content Analysis API：检测图片视频中的裸露内容 Screen Time框架：提供设备使用监管功能 Family Controls：为应用添加家长控制功能 结论Declared Age Range API为开发者提供了一种隐私友好的方式，在不获取具体生日的前提下，根据用户年龄范围定制应用体验。通过合理的年龄区间划分、灵活的家长控制选项和严格的隐私保护机制，该框架帮助开发者在保护儿童安全与尊重用户隐私之间取得平衡。开发者应结合应用实际需求，在适当位置添加适龄体验，为用户提供更安全、更有趣的数字产品。 相关资源相关视频使用 PermissionKit 增强儿童安全保护 文档DeclaredAgeRange","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"RealityKit 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_287/","text":"利用全新的 realitykit 功能尽情挥洒创意，这些功能可帮助你为 ios、ipados、macos、apple tvos 和 visionos 构建丰富的 3d 内容。了解如何直接通过 realitykit 来访问 arkit 数据。探究如何使用对象操作功能与 3d 内容进行更自然的交互。通过一个交互式示例，探索一些适用于场景理解、环境融合、实例化等方面的新 api。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com RealityKit 新特性：解锁虚实交互新可能引言在今年的WWDC大会上，RealityKit团队展示了该框架的一系列创新功能。作为Apple生态系统的核心3D内容开发框架，RealityKit此次更新带来了更强大的虚实融合能力，为开发者提供了更便捷的工具来创建沉浸式3D体验。本文将详细解析这些新特性及其应用场景。 跨平台支持扩展RealityKit现已全面支持最新版tvOS，这意味着开发者可以在所有Apple TV 4K机型上部署3D内容。这一扩展使RealityKit真正实现了”一次编写，多平台运行”的理想开发模式，为iOS、iPadOS、macOS、visionOS和tvOS提供一致的3D内容开发体验。 核心新功能解析增强的锚定系统RealityKit现在允许开发者直接访问ARKit数据，通过新的SpatialTrackingSession和AnchorStateEvents API，可以更精确地将虚拟内容锚定到现实环境中： 12345// 配置空间追踪会话的典型实现@State var spatialTrackingSession = SpatialTrackingSession()let configuration = SpatialTrackingSession.Configuration( tracking: [.plane]) 自然交互实现新增的ManipulationComponent极大简化了3D对象的抓取和旋转交互实现： 1234// 配置操控组件的标准流程var manipulationComponent = ManipulationComponent()manipulationComponent.releaseBehavior = .stayentity.components.set(manipulationComponent) 场景理解与物理通过SceneUnderstanding API，开发者可以让虚拟对象与现实环境产生真实的物理交互： 12345// 启用场景理解的碰撞检测let configuration = SpatialTrackingSession.Configuration( tracking: [.plane], sceneUnderstanding: [.collision, .physics]) 高效渲染技术MeshInstancesComponent允许开发者高效渲染大量重复模型： 1234// 创建网格实例的示例代码var meshInstancesComponent = MeshInstancesComponent()let instances = try LowLevelInstanceData(instanceCount: 20)meshInstancesComponent[partIndex: 0] = instances 沉浸式媒体支持新增的ImagePresentationComponent支持三类媒体展示方式： 传统2D图像 来自iPhone或Vision Pro的空间照片 由2D图像生成的3D立体影像 123// 加载空间场景的代码示例let spatial3DImage = try await ImagePresentationComponent.Spatial3DImage(contentsOf: url)var component = ImagePresentationComponent(spatial3DImage: spatial3DImage) 其他重要更新 空间配件支持：完整的六自由度追踪和触觉反馈 SwiftUI增强：新增ViewAttachmentComponent等组件 实体系统改进：新增关节附着方法和内存数据加载初始化器 视觉效果提升：支持AVIF纹理压缩和后处理特效 结语此次RealityKit的更新为开发者提供了更强大的工具来创建虚实融合的3D体验。从精确的环境锚定到自然的交互操作，从高效的渲染技术到丰富的媒体支持，这些新特性将大幅降低3D内容开发的门槛。随着Apple生态系统的扩展，RealityKit正在成为跨平台3D开发的重要选择。 相关视频探索 visionOS 上的空间配件输入搭配使用更出色：SwiftUI 和 RealityKit支持 visionOS App 播放沉浸视频","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"深入了解 Foundation Models 框架","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_301/","text":"使用 foundation models 框架提升性能。深入了解引导式生成的工作方式，并使用指南、正则表达式和生成方案来获取自定的结构化响应。我们将向你展示如何使用工具调用让模型自动访问外部信息并执行操作，从而实现个性化体验。 为了充分从这个视频中获益，建议你先观看“了解 foundation models 框架”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深入探索 Foundation Models 框架：从基础会话到工具调用Foundation Models 框架为开发者提供了直接在设备端运行大型语言模型的能力，支持 macOS、iPadOS、iOS 和 visionOS 平台。本文将系统介绍该框架的核心功能，包括会话机制、Generable 技术、动态模式以及工具调用。 基础会话机制Foundation Models 框架通过 LanguageModelSession 类提供简洁的会话接口。开发者只需导入框架并创建会话实例，即可开始生成文本内容。 1234567891011import FoundationModelsfunc respond(userInput: String) async throws -&gt; String &#123; let session = LanguageModelSession(instructions: &quot;&quot;&quot; 你是一位像素世界里的友善咖啡师。 请回答玩家的问题。 &quot;&quot;&quot; ) let response = try await session.respond(to: userInput) return response.content&#125; 会话具有状态性，每次响应调用都会记录在会话历史中。开发者需要注意上下文窗口限制问题，当超出限制时可选择创建新会话或保留部分历史记录。 12345678var session = LanguageModelSession()do &#123; let answer = try await session.respond(to: prompt) print(answer.content)&#125; catch LanguageModelSession.GenerationError.exceededContextWindowSize &#123; session = newSession(previousSession: session)&#125; Generable 技术：获取结构化输出@Generable 宏是获取结构化输出的关键工具。它允许开发者定义 Swift 结构体或枚举，模型将据此生成符合类型规范的数据。 12345@Generablestruct NPC &#123; let name: String let coffeeOrder: String&#125; 通过 Guide 宏可以进一步约束输出。开发者可以为数值类型指定范围，为数组指定数量，甚至使用正则表达式精确控制字符串格式。 123456789@Generablestruct NPC &#123; @Guide(description: &quot;全名&quot;) let name: String @Guide(.range(1...10)) let level: Int @Guide(.count(3)) let attributes: [Attribute]&#125; 动态模式：运行时定义结构对于需要在运行时动态定义结构的情况，Foundation Models 提供了 DynamicGenerationSchema。开发者可以在运行时构建模式，模型将据此生成符合规范的内容。 1234567let riddleSchema = DynamicGenerationSchema( name: &quot;Riddle&quot;, properties: [ .init(name: &quot;question&quot;, mode: .string), .init(name: &quot;answers&quot;, mode: .array(element: .reference(&quot;Answer&quot;))) ]) 动态模式特别适用于用户自定义内容的场景，如游戏关卡编辑器等应用。 工具调用：扩展模型能力工具调用功能使模型能够访问开发者定义的函数，极大地扩展了模型的能力。开发者需要定义符合 Tool 协议的结构体。 1234567891011121314struct FindContactTool: Tool &#123; let name = &quot;findContact&quot; let description = &quot;从指定年龄段查找联系人。&quot; @Generable struct Arguments &#123; let generation: Generation &#125; func call(arguments: Arguments) async throws -&gt; ToolOutput &#123; // 实现联系人查找逻辑 return ToolOutput(contactName) &#125;&#125; 工具特别适合访问隐私敏感数据，如通讯录或日历信息。由于 Foundation Models 在设备端运行，这些数据不会离开用户设备。 总结与最佳实践Foundation Models 框架为开发者提供了强大的设备端 AI 能力。以下是一些关键建议： 对于固定结构的内容，优先使用 @Generable 宏 需要运行时定义结构时，考虑使用动态模式 工具调用是实现个性化体验的强大工具 注意处理上下文窗口限制和语言支持问题 通过合理组合这些功能，开发者可以在保护用户隐私的同时，创造出丰富多样的 AI 体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"打造丝滑的多画面播放体验","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_302/","text":"了解如何在你的 app 中打造高级的多画面播放体验。我们将介绍如何跨多个播放器实现播放同步、通过隔空播放的无缝整合提升多画面播放效果，同时优化播放质量，以便提供引人入胜的多画面播放体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 打造流畅的多视角播放体验：WWDC技术解析引言随着多视角内容消费需求的增长，开发者面临如何实现流畅同步播放的技术挑战。苹果在WWDC上展示了如何利用AVFoundation和AVRouting框架构建专业级多视角播放体验，涵盖同步播放、AirPlay支持和质量优化三大核心能力。 多视角播放同步技术当应用需要同步播放多个关联音视频流时（如体育赛事多机位），AVPlaybackCoordinationMedium提供了完善的解决方案。该技术基于SharePlay的协调机制扩展而来，能自动处理播放控制、速率变化和时间跳跃等复杂场景。 关键实现仅需三个步骤： 创建AVPlaybackCoordinationMedium实例 为每个AVPlayer实例获取playbackCoordinator 调用coordinate方法连接协调媒介 123let coordinationMedium = AVPlaybackCoordinationMedium()try player1.playbackCoordinator.coordinate(using: coordinationMedium)try player2.playbackCoordinator.coordinate(using: coordinationMedium) 此方案支持任意数量播放器的同步，且在画中画模式和系统”正在播放”界面中仍保持同步效果。 AirPlay多视图路由管理AVRoutingPlaybackArbiter解决了多视图应用投屏时的路由选择问题，主要处理两类场景： 视频路由：当投屏至电视等单流设备时，自动选择主视图传输 音频路由：向HomePod等设备传输时管理不可混音的路由 开发者可通过设置preferredParticipant属性指定优先投屏的播放器： 1AVRoutingPlaybackArbiter.shared().preferredParticipantForExternalPlayback = mainPlayer 该机制与播放协调功能完美兼容，投屏时仍能保持多播放器的同步状态。 网络资源智能分配在多视角场景中，通过networkResourcePriority属性实现差异化的质量保障： .high：保障关键视角的高清质量（如赛事主视角） .low：允许次要视角适应网络状况（如观众特写） 12primaryPlayer.networkResourcePriority = .highsecondaryPlayer.networkResourcePriority = .low 系统会根据优先级、播放器数量、视频尺寸等综合因素自动优化带宽分配，在有限网络条件下提供最佳体验。 总结苹果提供的多视角播放技术栈包含： AVPlaybackCoordinationMedium实现播放同步 AVRoutingPlaybackArbiter管理AirPlay路由 网络优先级设置保障关键流质量 这些API组合为开发者提供了构建专业级多视角应用的全套工具，从体育直播到多机位演出等各种场景都能获得完美支持。 相关视频使用群组活动协调媒体体验 文档AVFoundationAVRouting","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"为 visionOS 设计悬停交互","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_303/","text":"了解如何为你的 visionos app 创建高级交互。我们将探索如何设计引人入胜的自定悬停效果和动画，如何避免常见错误，如何充分利用 look to scroll 等交互方式，以及如何使用持久化效果来构建直观的媒体控制项。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为 visionOS 设计悬停交互：打造自然流畅的沉浸式体验在 visionOS 生态系统中，悬停交互扮演着至关重要的角色，它让用户能够通过视线控制应用界面元素。本文将深入解析 WWDC 分享中关于 visionOS 悬停交互设计的核心要点，帮助开发者理解如何打造更加自然流畅的沉浸式体验。 眼动输入的基础原理visionOS 的交互基础建立在眼动追踪与手势配合之上。系统遵循几个关键设计准则： 核心内容前置：应将主要交互内容放置在用户视野正前方，便于查看和操作 形状优化：优先采用圆形、药丸形或圆角矩形等弧形轮廓，它们比尖锐形状更易吸引视线聚焦 尺寸规范：精密交互元素至少保留60点空间（约2.5度视角大小，相当于一米距离外4.4厘米物体） 高亮反馈：所有交互元素都应应用高亮效果，标准组件自动实现，自定义组件需手动添加 这些基础原则确保了visionOS应用能够提供一致且易用的交互体验。 自定义悬停效果设计标准高亮效果在多数场景表现良好，但开发者可以创建更具特色的自定义悬停效果。系统已广泛应用这种技术： 1234567891011// 自定义悬停效果示例Button(action: &#123;&#125;) &#123; Text(&quot;下载&quot;) .hoverEffect(.highlight) // 标准高亮效果 .customHoverEffect &#123; isHovering in if isHovering &#123; // 显示文件大小等附加信息 showFileSizeAnimation() &#125; &#125;&#125; 自定义效果主要有三种实现方式： 即时动画：视线接触视图立即触发，适合显示情境化补充信息 延迟动画：短暂延迟后显示，避免干扰快速视线移动 渐进动画：结合缓动曲线，先缓慢淡入再用弹性动画完成 设计自定义效果时需注意： 保持锚定元素位置稳定 效果必须源自可见元素 谨慎应用避免过度分散注意力 保持效果精炼适度 防止意外触发 视线滚动功能的实现视线滚动是一项让用户仅用眼睛就能浏览内容的创新功能，在阅读类应用中尤其实用。实现该功能时需要考虑： 12345// 启用视线滚动示例ScrollView &#123; // 内容区域&#125;.scrollHoverBehavior(.enabled) // 启用视线滚动 关键设计准则： 适合阅读/浏览为主的视图 通常只用于应用核心内容区 保持应用内部一致性 滚动视图应尽量充满窗口 避免在视差滚动或动画联动视图中使用 优化后的视线滚动体验应让用户感觉内容自然跟随视线移动，而非刻意操控。 持久化控件的最佳实践持久化控件设计解决了媒体播放场景中的常见痛点： 123// 视频控件持久化示例VideoPlayer(player: player) .persistentMediaControls(true) // 启用持久化 该特性适用于： 标准视频播放器（自动获得） 自定义视频控件（需手动启用） FaceTime通话界面 正念应用控制面板 设计原则是：当用户注视控件时保持显示，视线回到内容时再隐藏，实现无感的智能交互。 总结与资源visionOS的悬停交互设计提供了丰富的可能性，从自定义动画效果到视线滚动，再到智能持久的控件显示，开发者可以根据应用场景灵活组合这些技术。实现时需注意： 优先使用系统提供的标准组件和行为 自定义效果需在真实设备上充分测试 保持交互逻辑的一致性和可预测性 进一步学习资源： [相关视频]• Meet SwiftUI for visionOS• Build spatial experiences with RealityKit• Design for spatial user interfaces [文档]• Human Interface Guidelines for visionOS• SwiftUI documentation• RealityKit framework reference","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"针对 visionOS 优化你的自定环境","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_305/","text":"探索如何使用程序化工具为你的 visionos app 或游戏创建精美的沉浸式环境。我们将分享创建高质量环境的构建要素，然后深入探讨优化流程。了解如何使用 apple 针对 houdini 提供的一整套流程，减少场景的多边形数量、进行几何清理、打包 uv 贴图，并创建 usd 素材以便导入到 reality composer pro 或你选择的游戏引擎中。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 为 visionOS 优化你的自定义环境：打造沉浸式体验的技术解析在空间计算时代，为 Apple Vision Pro 创建沉浸式环境面临着独特的挑战与机遇。本文将深入解析如何通过程序化工具链构建高质量环境，实现电影级视觉效果与实时性能的完美平衡。 沉浸式环境的核心挑战Vision Pro 平台提供了超高分辨率、快速帧率和无缝实时交互能力，为开发者创造了打造真正临场感环境的绝佳机会。然而，高保真实时渲染往往伴随着高昂的性能代价——柔和的阴影、全局光照和复杂着色等效果都会消耗大量计算资源。 Alex 在 WWDC24 演讲中提出的解决方案并非依赖单一技术，而是采用一套灵活的工作流程： 从预渲染图像开始，捕捉电影级光照、丰富细节和高端材质 根据观看者实际体验优化几何体和纹理 将预渲染图像应用到优化后的环境 在实时编辑器（如 Reality Composer 或 Unity）中完成组装 环境优化的关键技术几何优化：从1亿到20万多边形面对如月球场景这样包含1亿多边形的复杂环境，演讲中展示了三项突破性的优化技术： 1. 自适应多边形缩减传统LOD系统简化单个资产的方案在这里被超越。通过基于沉浸边界内可能视点的优化方案： 使用增强版Houdini PolyReduce工具 通过属性驱动参数和边界采样点评估几何重要性 保持细节密度自然渐变，避免突兀变化 月球场景多边形从1亿降至35万 2. 几何广告牌技术对于1公里外的远景对象： 转化为朝向沉浸边界的平面几何体 通过Vista Billboard HDA工具生成简化剪影 避免使用透明材质的情况下大幅减少多边形 月球环境中选择1公里分界点以优化资源分配 3. 遮挡剔除双重剔除方案显著提升效率： 背面剔除：移除永远不可见的背面多边形（月球场景移除6万） 遮挡剔除：通过射线测试移除完全遮挡的三角形（额外移除11万） 合计移除约50%剩余三角形，最终控制在18万 UV与纹理优化：保留细节的艺术为在优化几何体上保留高精度PBR贴图细节，采用了创新的UV策略： 沉浸边界内（5米）：基于面积的UV映射，确保纹理密度一致 沉浸边界外：切换为基于屏幕空间的投影映射 使用Mesh Partition HDA分割网格为最小可见单元 Multi-Projection HDA从各分区最佳视角投射UV 最终压缩到两张纹理：边界内面积缩放，边界外屏幕空间缩放 纹理烘焙：从数十GB到200MB通过组合球形渲染和表面投影技术： 临时球形投影映射渲染到几何体 烘焙至最终UV布局 单视角缺失数据问题通过表面投影解决 实现数十GB高分辨率纹理压缩至不足200MB USD设置与最终优化精心设计的USD结构开启最终优化阶段： 层次划分实现高效视锥剔除 边界内使用Boundary Partition HDA 边界外使用Frustum Partition HDA分割为渐进式区块 导出前仅保留必要属性（名称属性、组分配） 最终成果令人印象深刻： 多边形：1亿→20万（实际每帧仅渲染约10万） 纹理内存：控制在250MB以内 实体数量：&lt;200个 单帧绘制调用：通常&lt;100次 应用场景与工具适配性这套工作流程经过精心设计，可适应多种场景需求： 门户体验：调整遮挡剔除参数 多沉浸边界场景：通过多组采样点优化 适用场景类型： 岩石地貌（月球、约书亚树） 大气景观（胡德山、哈雷阿卡拉） 硬表面室内（会议室、剧院） 对于不同场景需求，可灵活调整优化重点。例如复杂着色器场景可相应缩减几何体，而高效建模环境则无需重度优化。 开发者资源与核心启示随附的示例项目包含完整工作流程和工具，README文件提供详细说明。核心启示在于：高保真内容不必昂贵。将优化思维融入创作过程，借助强大工具链，开发者可以突破可能性边界，打造更具沉浸感的Vision Pro环境。 相关视频：为你的沉浸式 visionOS App 创建自定环境为空间计算优化 3D 素材资源在自定环境中提升媒体观赏体验的沉浸度探索 USD 生态系统","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"探索 visionOS 的视频体验","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_304/","text":"了解在你的 app 中创建和呈现沉浸视频体验的不同方式。我们将探索 visionos 26 中提供的多种媒体类型 (包括 180°、360°和宽视野视频的配置文件)、用来创建和播放 apple 沉浸视频的选项，以及适用于 2d、3d 和空间视频的扩展功能。探索哪些配置文件最适合你的 app 和内容。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 博客文章写作示例（基于WWDC演讲稿）标题：Vision Pro的空间视频拍摄技术解析引言苹果在WWDC大会上公布了Vision Pro头显的一项突破性功能——空间视频拍摄能力。这一技术革新允许用户通过设备内置的双摄像头系统捕捉具有深度信息的沉浸式视频内容。 空间视频技术原理双摄像头系统Vision Pro采用精密校准的双目摄像头阵列，两个镜头间距与人类瞳距相近。这种设计能够： 模拟人眼视差效应 实时计算深度信息 生成具有立体感的视频流 深度数据处理流程系统通过以下算法处理原始视频数据： 12345func processDepthData(leftImage: CGImage, rightImage: CGImage) -&gt; AVDepthData &#123; let disparityCalculator = DisparityCalculator() let depthData = disparityCalculator.compute(left: leftImage, right: rightImage) return depthData.applyTemporalSmoothing()&#125; 该Swift代码展示了深度计算的核心流程，包括视差图生成和时间域平滑处理。 技术特点实时编码技术空间视频采用HEVC格式的特殊扩展： 保持标准兼容性 新增深度元数据通道 码率控制在20-30 Mbps 回放兼容性拍摄的内容可在以下设备播放： Vision Pro头显（完全3D效果） 普通iOS设备（2D模式） Mac电脑（需安装最新解码器） 开发者支持API架构苹果提供了全新AVFoundation框架扩展： 123let spatialSession = AVSpatialVideoSession()spatialSession.delegate = selfspatialSession.startRecording(to: outputURL) 开发者可通过不超过10行代码实现基础拍摄功能。 应用场景专业领域 医疗手术记录 建筑设计预览 教育培训内容 消费领域 家庭纪念视频 旅行记录 现场活动直播 结语Vision Pro的空间视频技术标志着消费级3D内容创作的重要突破。这项技术不仅拓展了影像创作的维度，也为开发者提供了全新的内容创作工具链。 相关视频： WWDC23-10025: 拍摄和播放空间视频 WWDC23-10086: 空间视频编辑技术 文档： AVFoundation框架参考 空间视频技术白皮书","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"通过 Instruments 优化 CPU 性能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_308/","text":"了解如何借助 instruments 中的两个新硬件辅助工具，针对 apple 芯片来优化你的 app。我们将首先介绍如何分析你的 app，然后深入介绍通过 processor trace 调用的每个函数。此外，我们将讨论如何使用 cpu counters 的各个模式来分析代码中的 cpu 瓶颈问题。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 Instruments 优化 CPU 性能：Apple 芯片的终极指南在当今追求极致性能的移动计算时代，如何充分利用 Apple 芯片的强大处理能力成为开发者面临的重要课题。本文将详细介绍如何利用 Instruments 中的新型硬件辅助工具，为 Apple 芯片进行深度 CPU 优化。 性能优化的核心挑战性能优化工作面临两大固有难题：首先，Swift 源代码与最终执行的机器指令之间存在多层抽象转换；其次，现代 CPU 执行指令的方式高度不确定。操作系统内核工程师 Matt 指出，保持开放心态至关重要，因为性能瓶颈往往出现在意想不到的地方。 工具选择与基础优化Instruments 提供两种关键 CPU 分析工具： 传统 Time Profiler：基于定时采样 新型 CPU Profiler：基于时钟频率，避免了采样偏差 实际案例显示，使用新型 Span 容器替代 Collection 协议后，二分搜索性能提升达四倍之多。Span 专为内存连续存储的数据结构设计，还能有效防止内存引用泄漏问题。 革命性的处理器追踪技术Instruments 16.3 引入的 Processor Trace 技术具有以下优势： 完整记录用户空间所有指令执行 彻底消除采样偏差 性能影响仅约 1% 需要注意的是，该技术需要 Mac、M4 iPad Pro 或 A18 iPhone 的专用 CPU 功能支持。 瓶颈分析与优化策略Apple 芯片采用先进的流水线设计和指令级并行技术。新版 CPU Counters 工具提供预设模式，通过科学的瓶颈分析方法逐步定位性能问题。典型案例中，二分搜索的分支预测错误问题通过改写为无分支版本，实现了两倍的性能提升。 内存访问优化技巧CPU 多级缓存系统的特性： L1缓存：速度最快但容量最小 L2缓存：容量较大 主存访问：速度比缓存慢50倍 采用 Eytzinger 布局（广度优先遍历的树状结构）重组数据，使搜索过程的前几步能共享缓存行，再次获得两倍的性能提升。 综合优化成果通过系统性的优化方法，最终实现了约25倍的性能飞跃： CPU Profiler 发现从 Collection 到 Span 的转换 Processor Trace 揭示未特化泛型的开销 瓶颈分析指导下的微架构级优化 持续学习资源开发者可通过以下途径深化性能优化技能： 建立可靠的性能测试基准 参与开发者论坛的技术交流 观看 WWDC 相关专题视频 研读《Apple Silicon CPU Optimization Guide》技术文档 掌握这些工具和技术，开发者将能够充分发挥 Apple 芯片的计算潜力，打造极致流畅的用户体验。 相关视频优化 Swift 代码的内存使用和性能分析并优化 App 的功耗通过 Instrument 优化 SwiftUI 性能探索 Swift 性能使用 Instruments 分析挂起Swift 并发的可视化与优化 文档资源使用 Processor Trace 分析 CPU 使用率Apple 芯片 CPU 优化指南性能与指标为 Apple 芯片调整代码性能","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"开始使用适用于 Apple 芯片的 MLX","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_315/","text":"mlx 是一个灵活高效的阵列框架，适用于 apple 芯片上的数字计算和机器学习。我们将探索统一内存、懒性计算和函数转换等基本功能。我们还将了解一些有关使用 swift 和 python api 来构建和加速支持不同 apple 平台的机器学习模型的更高级技巧。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 开始使用适用于 Apple 芯片的 MLXMLX 是苹果公司专为 Apple 芯片设计的开源数组框架，旨在为数值计算和机器学习任务提供高效灵活的工具。本文将详细介绍 MLX 的核心功能、安装使用方法以及如何利用其特性加速机器学习工作负载。 MLX 简介MLX 是一个专门针对 Apple 芯片优化的数组框架，支持从基础数值运算到大规模机器学习模型的各类任务。该框架的特点包括： 支持 CPU 和 GPU 加速 提供 Python 和 Swift API 适用于 Mac、iPhone、iPad 和 Vision Pro 等苹果设备 采用 MIT 开源许可证 MLX 的核心 API 设计与 NumPy 高度相似，同时提供与 PyTorch 和 JAX 类似的高阶机器学习工具，使得熟悉这些框架的用户可以快速上手。 安装与基础使用安装 MLX Python 版非常简单，只需运行以下命令： 1pip3 install mlx 基础数组操作示例展示了 MLX 的使用方式： 123456789import mlx.core as mxa = mx.array([1, 2, 3])b = mx.array([4, 5, 6])c = a + bprint(f&quot;结果 c: &#123;c&#125;&quot;)print(f&quot;形状: &#123;c.shape&#125;&quot;)print(f&quot;数据类型: &#123;c.dtype&#125;&quot;) MLX 核心特性统一内存架构MLX 充分利用了 Apple 芯片的统一内存架构，CPU 和 GPU 共享相同物理内存： 12345a = mx.array([1, 2, 3])b = mx.array([4, 5, 6])c = mx.add(a, b, stream=mx.gpu)d = mx.multiply(a, b, stream=mx.cpu) 惰性计算MLX 采用惰性执行引擎，优化大型计算的性能： 123456a = mx.array([1, 2, 3])b = mx.array([4, 5, 6])c = a + b# 显式触发计算mx.eval(c) 函数变换MLX 提供自动微分等函数变换功能： 12345def sin(x): return mx.sin(x)dfdx = mx.grad(sin)d2fdx2 = mx.grad(mx.grad(mx.sin)) 神经网络构建MLX 提供 mlx.nn 和 mlx.optimizers 两个高阶包用于构建和训练神经网络： 12345678910111213class MLP(nn.Module): &quot;&quot;&quot;简单的多层感知机&quot;&quot;&quot; def __init__(self, dim, h_dim): super().__init__() self.linear1 = nn.Linear(dim, h_dim) self.linear2 = nn.Linear(h_dim, dim) def __call__(self, x): x = self.linear1(x) x = nn.relu(x) x = self.linear2(x) return x 性能优化技巧MLX 提供多种性能优化方法： 函数编译123@mx.compiledef compiled_gelu(x): return x * (1 + mx.erf(x / math.sqrt(2))) / 2 使用优化实现1mx.fast.rms_norm(x, weight, eps=1e-5) 添加自定义 Metal 内核12345678910source = &quot;&quot;&quot; uint elem = thread_position_in_grid.x; out[elem] = metal::exp(inp[elem]);&quot;&quot;&quot;kernel = mx.fast.metal_kernel( name=&quot;myexp&quot;, input_names=[&quot;inp&quot;], output_names=[&quot;out&quot;], source=source,) 模型量化123quantized_weight, scales, biases = mx.quantize( weight, bits=4, group_size=32,) MLX SwiftSwift 版本的 MLX 同样功能强大，使用方式与 Python 类似： 12345import MLXlet a = MLXArray([1, 2, 3])let b = MLXArray([1, 2, 3])let c = a + b 学习资源开发者可以通过以下资源进一步学习 MLX： 相关视频：借助 MLX 在 Apple 芯片上探索大语言模型 文档：MLXMLX LM - Python APIMLX Explore - Python APIMLX FrameworkMLX Llama InferenceMLX Swift MLX 为 Apple 芯片上的机器学习开发提供了强大而灵活的工具，开发者可以利用其特性构建高效的机器学习应用。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"包容性 App 设计的原则","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_316/","text":"探索了解残障人士的需求如何有助于你打造出人人都能方便使用的更出色 app。了解如何通过支持多种类型的交互、提供自定功能以及采用各种辅助功能 api，让你的 app 更具包容性。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 包容性应用设计原则：为所有人打造无障碍体验在当今数字化时代，应用开发者肩负着重要责任——确保每个人都能平等享受科技带来的便利。WWDC演讲中，无障碍设计专家克里斯和丽莎分享了如何通过包容性设计原则，打造适合残障人士使用的应用。这些原则不仅帮助扩大用户覆盖范围，更能激发创新灵感。 残障的多元视角残障并非单纯的个人特性，而是一种个人能力与社会预期之间的落差。全球大约每七个人中就有一位残障人士，这个数字远超许多人的想象。残障状态呈现为连续光谱而非二元对立——以视力为例，从全盲到视力完好之间存在各种不同程度的视力障碍，每个人的情况都独一无二。 这种理解至关重要，因为它打破了”非残即健”的刻板印象，提醒开发者需要考虑更广泛的用户需求。社会通常默认人都会经历”获得能力-逐渐丧失”的标准轨迹，但现实中的生命曲线充满多样性。正是个人实际能力与社会预期之间的差异，构成了”包容性缺口”。 从缺口到创新包容性缺口不仅是挑战，更是创新的源泉。历史上许多伟大发明都源于弥合这种缺口的尝试： 麦克风解决了人类嗓音不够洪亮的限制 眼镜帮助视力模糊者阅读小字 路缘坡道最初为轮椅设计，后来惠及骑行者、婴儿车等更多人群 这些例子证明，为残障人士设计的产品往往能产生广泛的外溢效益，让更多人受益。开发者应主动寻找应用中的包容性缺口，思考如何通过设计创新来缩小这些差距。 四大实用设计策略支持多感官通道最有效的包容性策略之一是提供多样化的信息获取方式。视频字幕就是典型案例——它不仅帮助听障人士，也让图书馆等安静环境的用户受益。开发者需要考虑： 视觉障碍用户是否有听觉替代方案？ 听障用户能否通过视觉获取完整信息？ 是否存在触觉反馈等替代交互方式？ “无障碍阅读器”功能展示了多感官通道的完美实现：支持纯视觉阅读、纯听觉播放，以及视听结合的跟读模式。第三方应用Crouton也提供了优秀范例，通过”从图片导入”、”相机拍摄”和”免提模式”等多元交互方式满足不同用户需求。 提供个性化定制标准化的界面无法满足所有用户，因此个性化定制至关重要。Accessibility Reader允许用户调整文字大小、更改颜色、选择高辨识度字体。气象应用Carrot Weather更是典范，支持从数据密集布局切换到极简界面，让用户按需定制信息展示方式。 开发者应考虑添加哪些定制选项来满足不同用户需求，实现”应用适应用户”而非相反的理念。 采用辅助技术API苹果提供了丰富的辅助技术API，开发者应充分利用： VoiceOver：支持盲人或低视力用户通过语音导航 切换控制：允许通过物理按钮操作设备 更大文字：将文字放大三倍并自动调整布局 Blackbox游戏展示了API整合的优秀案例——通过VoiceOver提供音频线索，让盲人玩家也能享受解谜乐趣。就像建设人行道时要考虑路缘坡道，采用辅助技术API才能确保使用辅助设备的用户也能操作应用。 追踪包容性债务包容性是持续旅程而非终点。开发者应将未解决的包容性问题视为”包容性债务”，定期评估并制定改进计划。主动寻找应用中的缺口，与残障人士协作测试，不断优化用户体验。 构建更包容的数字世界包容性设计不仅造福残障人士，也能提升所有用户的体验。正如路缘坡道最初为轮椅设计却惠及更多人，为特定人群优化的功能往往产生广泛效益。 开发者可通过以下资源深入学习： 观看WWDC视频《SwiftUI辅助功能最新进展》 阅读Human Interface Guidelines中的Accessibility和Inclusion章节 在App Store展示应用的无障碍特性 通过践行这些设计原则，开发者不仅能扩大用户基础，更能参与构建一个更灵活、包容的数字世界。正如演讲者所言：”关于我们的决策不能没有我们参与”——与残障社群协作，开发者将获得宝贵洞见，打造真正普惠的应用体验。 相关视频针对辅助功能标签评估你的 App包容性设计实践包容性设计过程 文档Human Interface Guidelines: AccessibilityHuman Interface Guidelines: Inclusion","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"开始使用量子安全加密技术","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_314/","text":"了解如何通过抵御量子计算这一新兴威胁来保护 app 的敏感用户数据，并了解如何保护用户隐私。我们将探索不同类型的量子攻击、它们对现有加密协议的影响，以及如何使用量子安全加密技术来抵御这些攻击。你将了解如何使用量子安全 tls 来保护网络数据，以及如何使用 cryptokit 的量子安全 api 来保护应用程序数据。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 采用量子安全加密技术抵御未来威胁随着量子计算技术的快速发展，传统加密系统正面临前所未有的安全挑战。本文将详细介绍量子计算对现有加密体系的威胁以及如何采用量子安全加密技术进行防御。 量子计算带来的加密挑战现代应用程序通常存储和传输大量用户敏感数据，包括健康记录、地理位置信息和私人照片等。这些数据主要通过加密技术进行保护，例如TLS协议保障数据传输安全。然而量子计算的崛起正在动摇这些传统加密手段的安全性。 密码学工程专家指出，量子计算机将对两大类加密技术产生重大影响： 公钥密码学（包括加密和签名）：当前广泛使用的RSA和椭圆曲线离散对数等算法在量子计算机面前将变得脆弱，量子计算机能够指数级加速破解这些数学难题。 对称密钥密码学：虽然量子计算机对其影响较小，但仍建议将密钥长度加倍（如从AES-128升级到AES-256）以确保安全性。 值得注意的是，一些量子攻击甚至不需要等待量子计算机问世。典型的”现在窃取，将来解密”攻击已经开始发生：攻击者现在就开始收集加密数据，等待未来获得量子计算能力后进行解密。 量子安全加密解决方案为应对这些威胁，密码学界已经开发出能够抵抗量子攻击的新算法。这些量子安全加密技术能够在现有经典计算机上运行，同时提供抵御量子计算机攻击的能力。 网络数据保护对于网络数据传输，量子安全TLS 1.3已成为标准解决方案。从iOS 26开始： URLSession和Network.framework等推荐网络API将默认启用量子安全TLS 开发者应逐步淘汰Secure Transport等旧API 服务器端需要相应配置支持量子安全密钥交换方案 苹果系统服务如iCloud数据同步、推送通知等正在逐步部署量子安全TLS。建议所有处理敏感数据的应用尽快跟进这一安全升级。 自定义协议保护对于需要端到端加密的自定义协议，CryptoKit提供了全新的量子安全API： 基于X-Wing的后量子混合公钥加密(Post-quantum HPKE) 支持ML-KEM后量子算法，性能媲美经典算法 安全隔区实现硬件级隔离防御 经过形式化验证的核心实现 这些API特别适合需要严格保护用户数据、防止服务器获知明文的场景。服务器端可以使用Swift Crypto库（与CryptoKit API兼容）或其他符合标准的实现。 行动建议量子安全加密升级不是遥远的未来需求，而是当前的迫切任务。开发者应采取以下行动： 评估应用中敏感数据的加密现状 优先升级网络层到量子安全TLS 自定义加密协议改用CryptoKit量子安全API 确保服务器端相应配置 正如苹果已在iMessage PQ3中实现的量子安全加密所展示的，提前部署这些防御措施能够有效保护用户数据免受未来量子攻击的威胁。 相关资源Apple CryptoKit文档iMessage PQ3量子安全消息技术详解","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"visionOS 26 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_317/","text":"探索 visionos 26 中精彩的新功能。了解增强版视体 api，以及如何综合利用 swiftui、realitykit、arkit 的强大功能。探索如何利用更快的手部跟踪和空间配件输入，构建更加引人入胜的 app 和游戏。抢先预览同播共享、compositor services、沉浸式媒体、空间网页、企业 api 等方面的更新。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com visionOS 26 新特性全面解析：构建下一代空间体验visionOS 26 为开发者带来了丰富的创新功能，从增强的容积 API 到游戏开发支持，再到共享体验和企业级功能，全方位提升了空间计算的可能性。本文将深入解析这些新特性，帮助开发者充分掌握 visionOS 26 的强大能力。 容积功能：SwiftUI 与 RealityKit 的深度整合SwiftUI 在 visionOS 26 中获得了全面的容积功能升级，为开发者提供了构建沉浸式 3D 界面的强大工具。深度对齐（DepthAlignment）和布局感知旋转（rotation3DLayout）等新特性，让 3D 内容布局变得更加直观和高效。 12345678struct LandmarkProfile: View &#123; var body: some View &#123; VStackLayout().depthAlignment(.front) &#123; ResizableLandmarkModel() LandmarkNameCard() &#125; &#125;&#125; 空间容器功能得到显著增强，包括瞬时内容展示和动态边界限制支持。新的对象操纵 API 允许用户像操作真实物体一样与虚拟内容交互，为应用增添了自然的物理感。 1234567891011121314struct RockView: View &#123; var body: some View &#123; RockLayout &#123; ForEach(rocks) &#123; rock in Model3D(named: rock.name, bundle: realityKitContentBundle) &#123; model in model.model? .resizable() .scaledToFit3D() &#125; .manipulable() &#125; &#125; &#125;&#125; 系统功能：智能化与持久化visionOS 26 引入了多项系统级创新： Foundation Models 框架：提供设备端大语言模型访问能力 SpeechAnalyzer：完全设备端运行的语音转文本 API 空间持久化：窗口和场景位置记忆功能 小组件增强：自动添加深度效果和自适应细节呈现 12345Window(&quot;Inspector&quot;, id: &quot;Inspector&quot;) &#123; InspectorView()&#125;.defaultLaunchBehavior(.suppressed).restorationBehavior(.disabled) 游戏开发与空间配件支持游戏开发者将受益于多项性能提升和新功能： 手部追踪速度提升高达 3 倍 PlayStation VR2 Sense 控制器和 Logitech Muse 手写笔支持 提高的内存限制和增强的 Metal 渲染引擎 macOS 空间渲染能力，将 Mac 性能与 Vision Pro 显示完美结合 共享体验与沉浸式媒体visionOS 26 大大增强了共享体验： 同播共享和空间自影像优化 Nearby Window Sharing 实现房间级共享 共享世界锚点确保内容精准定位 沉浸式媒体生态系统支持各种专业媒体格式 空间网页与企业功能Safari 新增的空间网页功能允许将传统网页转换为空间体验，而企业 API 则针对商业场景提供了： 主摄像头访问扩展 敏感数据保护机制 Window Follow 模式 设备共享和协作支持 总结visionOS 26 为开发者提供了前所未有的工具和能力，从基础的容积功能到高级的共享体验，再到专业的企业应用场景。这些创新不仅提升了现有应用的沉浸感，更为全新类别的空间体验开辟了道路。开发者可以充分利用这些新特性，在 Apple Vision Pro 平台上创造更加惊艳的内容。 相关视频与附近用户共享 visionOS 体验了解 Apple 沉浸视频技术了解 Apple Projected Media Profile了解 Foundation Models 框架 文档TabletopKit","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"在你的 App 中录制电影效果视频","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_319/","text":"了解如何使用 cinematic video api，让你的 app 轻松拍摄大片感满屏的精彩视频。我们将介绍如何配置电影效果拍摄会话，并讲解构建视频拍摄 ui 的基本知识。我们还将探索高级电影效果功能，例如应用景深效果来实现动态跟踪拍摄和巧妙的焦点切换。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 在应用中录制电影效果视频：全面解析 Cinematic Video API电影效果视频已成为现代移动设备的重要拍摄功能，通过专业的浅景深效果和智能对焦技术，让普通用户也能拍摄出电影质感的视频。苹果在 WWDC 上发布的 Cinematic Video API 为开发者提供了将这些专业功能集成到应用中的机会。 电影效果视频的核心价值电影效果视频的核心在于其模仿专业电影拍摄手法，特别是焦点转移和跟踪对焦技术的应用。通过浅景深效果，开发者可以将观众的注意力引导至场景中的关键主体，增强叙事感染力。传统上，这些对焦技术需要专业人员操作，而电影效果视频通过智能算法极大地简化了这一过程。 电影效果视频的智能特性包括： 自动识别进入画面的主体并跟踪对焦 主体移开视线时自动转移焦点 适时将焦点回归至原始主体 构建电影效果拍摄会话的完整流程使用 Cinematic Video API 构建电影效果视频拍摄功能需要遵循特定的设置流程： 设备与格式选择首先需要选择支持电影效果的设备。电影效果视频支持后置双广角摄像头和原深感摄像头，可以通过以下代码查找设备： 1let deviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInDualWideCamera], mediaType: .video, position: .back) 选择设备后，必须确保使用支持电影效果的格式： 12345678for format in camera.formats &#123; if format.isCinematicVideoCaptureSupported &#123; try! camera.lockForConfiguration() camera.activeFormat = format camera.unlockForConfiguration() break &#125;&#125; 音频输入配置专业的视频拍摄离不开高质量的音频录制： 1let audioDeviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes [.microphone], mediaType: .audio, position: .unspecified) 启用电影效果的关键步骤在输入配置中启用电影效果是核心步骤： 123if (videoInput.isCinematicVideoCaptureSupported) &#123; videoInput.isCinematicVideoCaptureEnabled = true&#125; 输出与预览配置配置输出时，可以考虑添加视频稳定功能： 1234if let connection = movieFileOutput.connection(with: .video), connection.isVideoStabilizationSupported &#123; connection.preferredVideoStabilizationMode = .cinematicExtendedEnhanced&#125; 预览层的设置可以使用 SwiftUI 实现： 12345struct CameraPreviewView: UIViewRepresentable &#123; func makeUIView(context: Context) -&gt; PreviewView &#123; return PreviewView() &#125;&#125; 高级控制功能详解Cinematic Video API 提供了丰富的高级控制功能，让开发者能够精细调整拍摄效果。 虚化强度调整通过 simulatedAperture 属性可以调整虚化强度： 123open class AVCaptureDeviceInput : AVCaptureInput &#123; open var simulatedAperture: Float&#125; 焦点控制方法API 提供了三种手动对焦方式： 按检测对象 ID 对焦 按视图点对焦 固定焦点对焦 示例代码展示了如何按视图点对焦： 1open func setCinematicVideoTrackingFocus(at point: CGPoint, focusMode: AVCaptureDevice.CinematicVideoFocusMode) 光线监测在低光环境下提供用户反馈十分重要： 1234567observation = camera.observe(\\.cinematicVideoCaptureSceneMonitoringStatuses) &#123; _, value in if let newStatuses = value.newValue &#123; if newStatuses.contains(.notEnoughLight) &#123; // 更新UI提示&quot;光线不足&quot; &#125; &#125;&#125; 应用场景与最佳实践开发者应考虑以下应用场景： 专业视频拍摄应用 社交媒体视频创作工具 教育类视频录制应用 企业视频会议增强功能 最佳实践包括： 提供虚化强度调整滑块 在低光条件下提示用户 实现多种对焦模式切换 保存元数据以供后期编辑 未来展望与资源随着 Cinematic Video API 的推出，开发者现在可以在应用中实现以往只有专业设备才能完成的电影效果视频拍摄。这一技术的开放将为移动视频创作带来更多可能性。 开发者可以参考以下资源深入学习和应用这一技术： 相关视频利用拍摄控件提升你的相机体验打造出色的锁定屏幕相机拍摄体验在 iPadOS App 中支持外部摄像头打造更流畅的相机体验探索 tvOS 连续互通相机 文档AVFoundationCinematic","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"与附近用户共享 visionOS 体验","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_318/","text":"了解如何为同一房间内佩戴 apple vision pro 的用户打造共享体验。我们将展示如何在你的 app 中整合同播共享并充分利用 arkit，介绍与附近 facetime 通话参与者共享窗口的流程有哪些更新，并介绍旨在实现流畅协作的全新 api。探索相关最佳实践，了解如何为身处同一空间的用户打造别具特色、易于发现且引人入胜的协作功能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 与附近用户共享 visionOS 体验：构建无缝协作的空间应用Apple 在 visionOS 26 中引入了一项革命性的同空间共享功能，让开发者能够为用户打造前所未有的协作体验。这项技术将 SharePlay 框架与 ARKit 深度融合，实现了物理空间中的虚拟内容共享。 近距离共享的核心机制visionOS 26 的近距离共享功能通过窗口栏右侧的共享按钮实现一键分享。选择附近联系人后，所有参与者都会在相同位置看到共享窗口，窗口栏变为绿色标识共享状态。系统确保所有用户看到的窗口位置和尺寸完全一致，并支持以下交互特性： 窗口移动同步给所有用户 自动朝向人群调整方向 共同调整应用尺寸或贴合环境 数码表冠重新定位功能 指向时内容淡出确保可见性 SharePlay 框架的深度整合建立互动式共享体验的关键在于集成 SharePlay 框架。开发者需要： 创建 GroupActivity 子类（如示例中的 BoardGameActivity） 在 SwiftUI 中添加 ShareLink 暴露活动 观察 GroupSession 处理会话状态 配置 supportsGroupImmersiveSpace 支持沉浸空间 12345678910struct BoardGameView: View &#123; @State private var activity = BoardGameActivity() var body: some View &#123; VStack &#123; // 游戏UI内容 ShareLink(item: activity) &#123; EmptyView() &#125;.hidden() &#125; &#125;&#125; 增强同空间体验的新APIvisionOS 26 为 SharePlay 引入了多项专为同空间用户设计的增强功能： 参与者检测通过 GroupSession 的 activeParticipants 发布者和 isNearbyWithLocalParticipant 属性，可以精确识别附近参与者。 内容定位从 GroupSession 的系统协调器获取 localParticipantState 的 pose 属性，实现基于用户实际位置的智能内容放置。 媒体同步AVPlayer 与 AVPlaybackCoordinator 的深度整合确保同空间用户的音视频播放完全同步。 12let coordinator = AVPlayerPlaybackCoordinator()coordinator.coordinateWithSession(groupSession) 多窗口支持使用 .groupActivityAssociation 视图修饰符指定与 SharePlay 关联的 WindowGroup： 12VideoPlayerView() .groupActivityAssociation(.primary) ARKit 共享世界锚点技术ARKit 在 visionOS 26 中新增了共享世界锚点功能，使虚拟内容能够固定在相同的物理位置： 检查 worldAnchorSharingAvailability 状态 创建 WorldAnchor 时设置 sharedWithNearbyParticipants: true 通过 anchorUpdates 序列接收共享锚点 12345let anchor = WorldAnchor( originFromAnchorTransform: transform, sharedWithNearbyParticipants: true)worldTracking.addAnchor(anchor) 设计最佳实践构建出色的近距离共享体验应考虑以下原则： 易发现性：确保共享功能在系统UI中直观可见 多平台兼容：支持附近和远程参与者的混合体验 空间感知：充分利用物理空间增强临场感 渐进式体验：从简单窗口到沉浸空间的平滑过渡 应用场景展望这项技术开启了丰富的应用可能性： 协作白板：实体墙上的虚拟协作空间 社交游戏：客厅中的沉浸式多人游戏 家庭影院：与朋友共享的电影之夜体验 室内设计：多人实时协作的家具布置方案 相关视频:了解面向空间商务 App 的增强功能自定支持同播共享的空间自影像模板打造出色的空间播放体验 文档:AVPlaybackCoordinatorConfigure your visionOS app for sharing with people nearby visionOS 26 的近距离共享功能代表了空间计算领域的重要进步，为开发者提供了构建下一代社交体验的强大工具。通过合理运用这些API，应用将能够创造更具沉浸感和连接性的用户体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"使用全新设计系统构建 SwiftUI App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_323/","text":"探索 liquid glass 为 app 的外观和风格带来了哪些颠覆性的改变。了解这个亮眼的新材质如何提升不同平台上工具栏、控制项和 app 结构的视觉效果，从而带来引人入胜的交互体验并将你的 app 与系统无缝整合在一起。了解如何采用新的 api 来帮助你充分利用 liquid glass。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用全新设计系统构建 SwiftUI 应用：Liquid Glass 带来视觉革命引言在 WWDC 2025 上，苹果发布了 iOS 26 和 macOS Tahoe 的重大视觉更新，核心亮点是名为 Liquid Glass 的全新自适应材质系统。这种创新材质为 SwiftUI 应用带来了革命性的视觉变革，从工具栏、控件到应用结构都焕然一新。本文将详细介绍如何利用这套新设计系统打造视觉惊艳的应用体验。 Liquid Glass 的核心概念Liquid Glass 材质巧妙融合了玻璃的光学特性和液体的流动性，创造出轻盈动态的视觉体验。随着用户滚动内容，这种材质能智能适应下方内容，实现从浅色到深色的自然过渡。系统控件如开关、分段选择器和滑块等，在交互时会转变为液态玻璃形态，带来赏心悦目的动态效果。 应用结构的革新NavigationSplitView 优化NavigationSplitView是构建层级导航的核心组件，现在拥有了悬浮在内容上方、具备 Liquid Glass 效果的侧边栏。新引入的backgroundExtensionEffect修饰符允许视图扩展到安全区域之外而不裁切内容，当侧边栏隐藏时，背景图像会被镜像并模糊处理，确保内容完整可见。 1234567NavigationSplitView &#123; // 侧边栏内容&#125;detail: &#123; // 详细内容&#125;.backgroundExtensionEffect() TabView 新特性iPhone 上的标签栏现在悬浮在内容上方，并可配置为滚动时最小化。通过tabBarMinimizeBehavior修饰符，开发者可以控制标签栏的折叠行为。例如，设置.onScrollDown行为会使标签栏在逆向滚动时重新展开。 1234TabView &#123; // 选项卡内容&#125;.tabBarMinimizeBehavior(.onScrollDown) 工具栏的全新设计新设计中的工具栏项目悬浮在 Liquid Glass 表面，自适应下方内容。系统自动分组工具栏项目，开发者可以使用ToolbarSpacer创建灵活的空间布局或固定间距的分组。 1234567891011.toolbar &#123; ToolbarItemGroup(placement: .primaryAction) &#123; Button(action: &#123;&#125;) &#123; Label(&quot;Favorite&quot;, systemImage: &quot;heart&quot;) &#125; ToolbarSpacer(fixed: true) // 固定间距分组 Button(action: &#123;&#125;) &#123; Label(&quot;Add&quot;, systemImage: &quot;plus&quot;) &#125; &#125;&#125; 对于需要显示状态指示的工具栏项目，简单的badge修饰符就能实现： 123456ToolbarItem &#123; Button(action: &#123;&#125;) &#123; Label(&quot;Notifications&quot;, systemImage: &quot;bell&quot;) &#125; .badge(5) // 显示5条未读通知&#125; 搜索体验升级全新搜索系统提供两种关键模式： 工具栏搜索：在iPad/Mac上显示于右上角，在iPhone上自动调整到底部 专用搜索页面：取代标签栏成为独立搜索界面 12345NavigationSplitView &#123; // 导航内容&#125;.searchable(text: $searchText) // 应用于整个视图.searchToolbarBehavior(.minimal) // 可选最小化行为 控件系统的全面更新按钮与滑块新特性 边框按钮默认采用胶囊形状 新增超大尺寸按钮选项 滑块支持刻度标记和自定义填充起点 123456Slider(value: $value, in: 0...100, step: 10) // 自动显示刻度 .ticks &#123; [60, 90] &#125; // 自定义刻度位置 .neutralValue(50) // 填充起点设为50%Button(&quot;Action&quot;) &#123; &#125; .controlSize(.extraLarge) // 超大尺寸按钮 同心性设计原则新设计强调”角同心性”，确保控件与容器的圆角完美对齐。使用containerConcentric配置可实现自动适应的形状： 12Rectangle() .corner(.containerConcentric) // 自动适应容器圆角 自定义 Liquid Glass 效果对于需要特殊视觉表现的自定义视图，glassEffect修饰符提供了强大的定制能力： 12345Text(&quot;Badge&quot;) .glassEffect() // 默认胶囊形状背景 .glassEffect(in: Circle()) // 自定义圆形形状 .tint(.accentColor) // 强调色 .interactive() // 添加交互动画 多个玻璃元素需要组合使用时，GlassEffectContainer确保视觉一致性： 123456GlassEffectContainer &#123; ForEach(badges) &#123; badge in BadgeView(badge) .glassEffectID(badge.id) // 关联过渡效果 &#125;&#125; 总结与行动指南采用全新设计系统时，建议开发者： 使用Xcode 26构建应用，自动获得大量视觉改进 检查并移除表单和工具栏背后的自定义背景 善用Liquid Glass打造独特视觉元素 遵循新的同心性设计原则 充分利用搜索和工具栏的新布局选项 通过这套全新的设计系统，开发者能够打造出更精美、更统一的应用体验，让应用视觉与苹果生态系统完美融合。 相关视频了解全新设计系统 文档Adopting Liquid GlassApplying Liquid Glass to custom views","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"watchOS 26 的新功能","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_334/","text":"了解 watchos 26 的新功能，以及如何将这些功能整合到你的 watchos 和 ios app 中。探索 arm64 架构，并深入了解全新设计系统。我们还将介绍小组件方面的更新，并就如何将控件引入 apple watch 提供一些建议。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com watchOS 26 新特性全面解析苹果在 watchOS 26 中带来了众多令人期待的新功能和技术革新，这些改进将极大地丰富 Apple Watch 用户的体验，同时也为开发者提供了更多展示应用价值的机会。 设计系统与架构革新watchOS 26 采用了全新的设计语言，整个操作系统的视觉呈现全面升级。这一变化包括材质与控件的更新、应用图标的全新设计，以及表盘、控制中心等系统界面的改进。值得注意的是，所有为 watchOS 10 及以上版本构建的应用将自动适配新样式，保持与系统整体风格的统一性。 在架构方面，Apple Watch Series 9、Ultra 2 及后续机型在 watchOS 26 中启用了 ARM64 架构。开发者需要在 Xcode 中为 Apple Watch 目标使用标准架构构建设置，以确保应用兼容所有 Apple Watch 架构。特别提醒开发者注意 ARM64 上的类型差异，尤其是 Float 和 Int 类型的使用以及指针计算。 控件与智能叠放的新机遇watchOS 26 引入了控件功能，允许用户将控件添加到控制中心和智能叠放，还能与 Apple Watch Ultra 的操作按钮配合使用。这些基于 WidgetKit 构建的控件，让用户无需打开应用就能快速执行操作或跳转到特定界面。 开发者需要根据应用的主要目的选择合适的内容呈现方式： 控件：适合执行操作（如更改应用设置） 小组件：适合持续显示信息（如天气预报） 实时活动：适合有明确起止时间的事件（如体育比分） 智能叠放现在支持控件、小组件和实时活动三种形式。对于健身类应用，系统可以根据用户的锻炼习惯在智能叠放中推荐应用，用户点击即可快速开始锻炼。开发者需要正确指定 HKWorkoutActivityType、记录准确的锻炼时间，并使用 HKWorkoutRouteBuilder 添加位置信息，以确保系统正确推荐。 增强的配置能力watchOS 26 允许用户自定义小组件和控件。开发者可以通过返回空建议数组的方式，让小组件变得可配置： 123func recommendations() -&gt; [AppIntentRecommendation&lt;BeachConfigurationIntent&gt;] &#123; return []&#125; 对于控件，开发者可以使用 AppIntentControlConfiguration 来提供额外的配置选项： 12345678910111213struct ConfigurableMeditationControl: ControlWidget &#123; var body: some ControlWidgetConfiguration &#123; AppIntentControlConfiguration( kind: WidgetKinds.configurableMeditationControl, provider: Provider() ) &#123; value in // 控件内容 &#125; .displayName(&quot;海洋冥想&quot;) .description(&quot;可选海浪声的冥想计时器&quot;) .promptsForUserConfiguration() &#125;&#125; MapKit 与位置相关体验watchOS 26 的 MapKit 新增了多项实用功能，包括搜索兴趣点、获取路线信息以及在 SwiftUI 地图上叠加路线。这些功能通过熟悉的 iOS API 实现，对于需要查找附近地点并显示路线的独立 Watch 应用特别有用。 通过全新框架 RelevanceKit，应用可以根据上下文线索（如日期、睡眠习惯、健身信息和位置）在最合适的时机显示相关内容。小组件还能与 MapKit 兴趣点类别关联，当用户身处特定地点类型时，对应小组件会自动变得相关。 开发者可以这样为 MapKit 兴趣点类别创建位置 RelevantContext： 123456func relevance() async -&gt; WidgetRelevance&lt;Void&gt; &#123; guard let context = RelevantContext.location(category: .beach) else &#123; return WidgetRelevance&lt;Void&gt;([]) &#125; return WidgetRelevance([WidgetRelevanceAttribute(context: context)])&#125; 相关小组件与推送更新watchOS 26 引入了专为智能叠放设计的相关小组件。与传统时间线小组件不同，相关小组件允许系统根据特定上下文建议多个视图，解决活动时间重叠导致的视图截断问题。 构建相关小组件需要创建 RelevanceEntry、实现 RelevanceEntriesProvider 的 relevance 方法，并使用 RelevanceConfiguration。为避免重复显示，开发者应在 RelevanceConfiguration 中添加 associatedKind 修饰符，关联时间线小组件的 kind。 另一个重要改进是推送更新功能。从 watchOS 26 开始，开发者可以使用 APNs 推送小组件更新，所有支持 WidgetKit 的 Apple 平台都支持此功能，为需要复杂推送的应用提供了更多可能性。 总结与展望watchOS 26 为开发者提供了丰富的新工具和机会，包括： 全新设计系统和 ARM64 架构支持 控件功能和智能叠放增强 可配置的小组件和控件 增强的 MapKit 功能和位置相关体验 相关小组件和推送更新功能 开发者应尽快在 watchOS 26 上测试应用，确保风格协调且完美支持新架构。尝试在 Apple Watch 上使用 iOS 控件，构建相关小组件，并用推送通知保持数据最新。这些新特性将帮助开发者在更多系统场景中创造价值，为用户提供更丰富、更贴心的 Apple Watch 体验。 相关视频了解 Liquid Glass使用 Icon Composer 构建图标小组件的新功能将 App 控制扩展到系统级别认识 SwiftUI 版 MapKit进一步了解 WidgetKit 中的复杂功能 文档创建跨系统执行操作的控件提升智能叠放中小组件的可见性制作可配置的小组件MapKit锻炼与活动圆环","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"健康与运动","slug":"健康与运动","permalink":"http://djs66256.github.io/tags/%E5%81%A5%E5%BA%B7%E4%B8%8E%E8%BF%90%E5%8A%A8/"}]},{"title":"探索 Apple 平台上的机器学习和 AI 框架","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_360/","text":"浏览 apple 平台上机器学习和 ai 框架的最新更新。无论你是准备利用 apple 智能功能的 app 开发者、希望为设备端部署优化模型的 ml 工程师，还是想要探索无限可能的 ai 爱好者，我们都会提供应你所需的指导，帮你选择适合自己的工具。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple平台机器学习与AI框架全解析在WWDC大会上，Apple工程经理Jaimin Upadhyay详细介绍了Apple平台上丰富的机器学习和AI工具生态系统。这些技术已被深度集成到Apple操作系统中，为开发者提供了从简单集成到底层开发的多层次解决方案。 平台智能功能集成Apple操作系统内置了大量基于机器学习的功能，包括Vision Pro的视控ID身份验证、iPad手写数学计算识别以及FaceTime的背景噪音消除等。这些功能都已针对设备端运行进行了专门优化。 最新引入的生成式AI功能包括： 自动写作工具 智绘表情 图乐园功能 开发者可通过以下方式集成这些功能： 使用标准UI控件自动获得支持 通过ImagePlayground框架的SwiftUI扩展 在自定义视图中添加少量代码 编程访问与API分类Apple提供了两类API供开发者使用： 核心系统实用工具API：访问基础功能 特定ML任务API：针对专门场景优化 典型API示例包括： ImageCreator类：用于图像生成 Smart Reply API：智能回复消息和邮件 Foundation Models框架：设备端语言模型访问 12345// Foundation Models基础调用示例import FoundationModelslet session = FMSession()let response = try await session.generate(with: &quot;写一篇关于AI的文章&quot;) Foundation Models框架支持结构化响应生成，开发者可使用@Generatable标记应用类型，为属性添加自然语言描述。该框架还支持工具调用(Tool Use)功能，允许模型访问实时数据和执行应用动作。 机器学习API套件Apple提供了丰富的专业API： Vision：图像视频分析 Natural Language：文本语言识别 Translation：多语言翻译 Sound Analysis：声音分类 Speech：语音识别转录 Vision框架新增功能： 文档结构识别API 镜头污渍检测模式 Speech框架在iOS 26引入： 全新SpeechAnalyzer API 更高效的语音转文本模型 自定义模型部署对于需要部署自定义模型的开发者，Core ML是主要解决方案。工作流程包括： 获取Core ML格式模型 使用coremltools进行转换和优化 Xcode提供模型检查工具，今年新增了架构可视化功能。Core ML运行时能智能分配计算资源。 对于高级场景，开发者可以组合使用： MPS Graph + Metal（图形工作负载） BNNS Graph（CPU实时处理） 123456// BNNS Graph使用示例import Acceleratelet graph = BNNSGraph()let input = graph.placeholder(...)let output = graph.convolution2D(input, ...) 前沿开发工具Apple为研究型开发者提供了强大工具： MLX：开源阵列框架，支持在Apple芯片上高效运行最新模型 传统框架支持：PyTorch/JAX通过Metal加速 MLX特点包括： 统一内存架构优化 多设备并行操作支持 多语言支持（Python/Swift/C++等） 工具选择指南开发者可以根据需求选择不同层级的工具： 直接使用平台智能功能（最简单） 调用ML驱动API（中等复杂度） 部署优化Core ML模型（较高级） 使用MLX探索前沿研究（最灵活） 所有工具都针对Apple芯片进行了深度优化，确保最佳性能表现。 相关视频Human Interface Guidelines: Generative AIHuman Interface Guidelines: Machine learning","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"了解 Containerization","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_346/","text":"认识一下 containerization，它是一个用 swift 编写的开源项目，用于在 mac 上创建和运行 linux 容器。了解 containerization 如何安全私密地对 linux 容器进行管理。探索开源 container cli 工具如何利用 containerization 软件包提供简单而强大的功能，以在 mac 上构建、运行和部署 linux 容器。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索Containerization：在macOS上运行Linux容器的Swift框架引言Linux容器已经成为现代软件开发中不可或缺的一部分，而苹果最新开源的Containerization框架为macOS用户带来了全新的容器体验。这个基于Swift编写的开源项目不仅提供了高效安全的容器运行环境，还通过创新的架构设计解决了传统虚拟化方案的多项痛点。 容器技术概述Linux容器已成为构建、测试和部署服务器端应用程序的标准解决方案。容器技术通过隔离机制，允许开发者将应用程序及其所有依赖项打包到一个可部署单元中。这种打包方式使得容器可以拥有与主机机器完全不同的依赖版本，同时提供了运行时隔离环境： 网络隔离：每个容器拥有独立的网络栈 进程隔离：容器间无法相互查看进程信息 资源隔离：CPU、内存和磁盘资源可独立分配 传统macOS运行Linux容器的方式是通过启动大型虚拟机来托管多个容器，这种方案存在资源分配不灵活、共享目录权限控制粗糙等问题。 Containerization框架设计Containerization框架针对macOS环境特别优化，实现了三个核心设计目标： 安全性：通过轻量级虚拟机为每个容器提供与传统大型虚拟机相同的隔离级别，同时减少了核心工具和动态库的需求，显著降低了攻击面。 隐私性：实现了基于容器的精细目录访问控制，只有请求目录的容器才能访问相应内容。 性能：在保证安全隔离的同时，实现了亚秒级启动时间，并优化了资源使用效率。 镜像管理机制Containerization提供了完整的镜像管理API，镜像作为容器模板包含文件系统内容和默认配置。框架采用创新的块设备方式提供高性能镜像访问： 123// 从Registry获取镜像示例let registry = ContainerRegistry()try await registry.pullImage(named: &quot;alpine:latest&quot;) 镜像内容被格式化为EXT4文件系统，Containerization包含专门的Swift软件包来处理EXT4文件系统的格式化、目录创建和内容填充操作。 轻量级虚拟化架构与传统方案不同，Containerization为每个容器启动独立的轻量级虚拟机，这种架构带来了多重优势： 每个容器获得专用IP地址，无需端口映射 精细的资源控制，不运行时零资源占用 更严格的目录共享权限控制 虚拟机启动后，会运行一个名为vminitd的特殊初始化进程，这个用Swift编写的进程负责网络配置、文件系统挂载和进程监督。 创新初始化系统vminitd作为容器环境的核心组件，具有多项创新特点： 采用Swift Static Linux SDK交叉编译为静态可执行文件 基于musl libc实现，优化静态链接支持 运行在高度精简的环境中，不包含传统Linux核心工具 提供API用于从主机管理和控制容器进程 这种设计大幅减少了容器运行时的攻击面，同时保持了高度可靠性。 容器命令行工具Containerization配套提供了一个功能完整的命令行工具，下面展示基本使用流程： 12345# 拉取镜像container image pull alpine:latest# 运行容器container run -t -i alpine:latest sh 该工具构建在Containerization API之上，包含多个组件： CLI前端 XPC服务层 存储管理系统 镜像管理服务 网络服务（IP分配和DNS） 应用前景与资源Containerization为macOS上的容器开发打开了新可能，适用于： 本地开发环境搭建 持续集成测试 微服务架构部署 教学与研究环境 开发者可以通过GitHub获取项目源码、提交问题或参与贡献。框架文档中包含多个示例项目，展示了如何集成Containerization构建定制化容器解决方案。 相关视频: WWDC Containerization 介绍视频 文档: Containerization GitHub仓库 Swift Static Linux SDK文档","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"了解 Apple 沉浸视频技术","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_403/","text":"探索 apple 沉浸视频和 apple 空间音频格式技术的功能，以打造真正的沉浸式体验。了解新的 immersivemediasupport 框架，该框架可读取和写入必要的元数据来实现 apple 沉浸视频。了解在单独的文件中编码和发布 apple 沉浸视频内容以通过 hls 进行播放或流媒体播放时应遵循的准则。 为了充分从这个讲座中获益，建议你先观看“探索 visionos 的视频体验”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple 沉浸式视频技术深度解析：从元数据到空间音频在 WWDC26 上，Apple 展示了其最新的沉浸式视频技术，为开发者提供了打造深度沉浸体验的全新工具。本文将详细介绍这些技术的核心要素，包括视频元数据处理、文件格式规范以及创新的空间音频系统。 技术概览Apple 沉浸式视频代表了 Apple Vision Pro 上的终极视频体验，结合了高保真视频与全沉浸音频，创造出令人叹为观止的临场感。这项技术要求使用特殊校准的专业摄像机（如 Blackmagic URSA Cine Immersive）来捕捉内容，这些摄像机出厂时已经过精确校准，能够记录每个立体镜头的曲率数据。 macOS 和 visionOS 26 引入了全新的 Immersive Media Support 框架，为开发者提供了读写必要元数据、创建自定义工作流以及在编辑过程中预览内容的能力。 沉浸式视频元数据架构实现沉浸体验的核心在于元数据系统。整个架构包含两个关键组成部分： VenueDescriptor：描述拍摄场景中的摄像机组合信息，包括： 摄像机引用和视图模型 AIMEData（Apple Immersive Media Embedded）引用 边缘遮罩和原点位置等校准数据 自定义背景环境添加功能 PresentationCommand：表示定时动态元数据命令，用于处理： 镜头翻转（shot flop）自动镜像 动态渲染的淡入淡出效果 其他帧级调整 这些元数据会被混流到最终 QuickTime 文件中，确保每帧都能获得正确的投影处理。 AIVU 文件处理Apple 推出了专用的 Apple Immersive Video Universal（AIVU）文件格式，作为沉浸式内容的容器。开发者可以通过以下方式处理这些文件： 读取流程： 使用 AVAsset 读取元数据 通过 quickTimeMetadataAIMEData 标识符过滤出 AIMEData 转换为 VenueDescriptor 对象 使用 quickTimeMetadataPresentationImmersiveMedia 标识符获取同步元数据组 解码为 PresentationDescriptor 写入流程： 确保视频资产使用 AppleImmersiveVideo 投影类型 通过 AVAssetWriter 写入 VenueDescriptor 和 PresentationCommand 使用 AIVUValidator 验证文件完整性 内容发布规范通过 HLS 流式传输沉浸式内容时，开发者需注意以下技术规格： 视频：支持 4320×4320 单眼分辨率，90 帧/秒 MV-HEVC 格式 色彩空间：P3-D65-PQ 码率建议：平均 25-100 Mbps，峰值 50-150 Mbps HLS 要求： 版本 12+ 指向 AIME 文件的 venue description data ID 内容类型标记为 fully immersive 使用 APAC 音频编码 空间音频创新Apple 推出了两套音频技术来增强沉浸感： ASAF（Apple Spatial Audio Format）： 基于广播 Wave 文件格式 结合线性 PCM 与空间元数据 支持多点源和高阶 Ambisonics APAC（Apple Positional Audio Codec）： 流媒体专用编码格式 最低仅需 64 kbps 即可实现沉浸音频 支持各种音频特性（对象、Ambisonics、对话等） 这些音频技术能与视频完美同步，根据观众位置和方向实时调整，创造真正的3D音频体验。 开发资源开发者可以通过以下资源深入了解这些技术： 相关视频： 了解 Apple Projected Media Profile 探索 visionOS 的视频体验 支持 visionOS App 播放沉浸视频 文档： Immersive Media Support HTTP Live Streaming (HLS) authoring specification 随着这些技术的推出，开发者现在拥有了打造真正沉浸式体验所需的全部工具，期待看到创意社区利用这些技术创造出令人惊叹的作品。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"Welcome to WWDC25","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_364/","text":"there’s so much to dive into at wwdc25. here’s a quick guide to help get you started. 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com WWDC25全面启航：开发者盛宴的亮点解析年度开发者盛会揭开帷幕WWDC25作为苹果年度开发者大会，为全球开发者带来了前所未有的技术盛宴。本次大会包含超过100场专业技术讲座，内容涵盖了Apple生态系统的方方面面，从设计革新到核心技术框架，再到开发工具优化，为开发者提供了全方位的技术支持。 设计革新：液态玻璃美学WWDC25推出了苹果有史以来最全面的设计革新。这套全新的设计系统能够在不同应用和平台间灵活缩放，同时保持用户熟悉的操作体验。设计采用了创新的”液态玻璃(Liquid Glass)”材料理念，这种设计语言巧妙融合了玻璃的光学特性与流体的动态质感，创造出更具表现力的用户体验。 液态玻璃设计不仅提升了视觉美感，更实现了内容聚焦的效果，让应用的核心内容能够自然地吸引用户注意力。苹果表示，这种设计革新将为开发者提供更丰富的表现手段，期待开发者的应用能够在新设计语言下焕发新生。 Apple Intelligence：隐私优先的智能系统WWDC25宣布了一项重要突破——任何应用现在都可以调用苹果强大且注重隐私的智能系统。这一系统最显著的特点是即使在离线状态下，用户仍可通过设备端的大语言模型直接访问Apple Intelligence的核心功能。 值得强调的是，所有智能生成的内容都完全在设备端完成处理，确保了用户隐私和数据安全。这种本地化处理方式不仅保护了用户数据，还提供了快速响应的体验，展现了苹果在隐私保护和人工智能领域的平衡艺术。 开发者支持与学习资源WWDC25为开发者提供了前所未有的学习支持系统。今年每一场技术讲座都配备了文字摘要，突出关键要点，方便开发者快速获取核心信息、相关文档和示例代码。开发者甚至可以直接从讲座内容中复制代码到Xcode中立即使用。 对于需要个性化支持的开发者，苹果提供了一对一实验室咨询服务，开发者可以与苹果专家直接讨论项目细节。此外，今年新增了线上团体实验室，由苹果工程师和设计师主持，深入探讨重大技术发布。在这些活动中，开发者既可以积极提问，也可以选择旁听学习。 持续的开发者支持还包括Apple开发者论坛和全球性的”Meet with Apple”开发者活动，这些资源将为开发者提供会后的长期技术交流平台。 实践导向的技术学习WWDC25特别强调实践性学习，推出了CodeAlong实践课程。在这些课程中，开发者能够与苹果工程师一起逐行编写代码，通过实际操作掌握技术要点。课程内容从基础场景出发，逐步验证解决方案的适用性。 Foundation系列课程则是另一个亮点，它们专注于巩固关键设计与技术原理，为开发者构建坚实的技术基础。其中，全新的Foundation Models框架将成为今年技术讲座的重点内容之一。 展望未来WWDC25的丰富内容只是开始，更多开发者相关的详细公告将在平台国情咨文中陆续揭晓。从设计革新到智能系统，从开发工具到学习资源，苹果为开发者打造了一个全方位的生态系统支持平台。 开发者可以通过多种方式参与这场技术盛会，无论是现场参加还是线上学习，都能获得宝贵的技术洞见和实践经验。随着活动的进行，全球开发者社区将共同探索这些创新技术如何塑造苹果生态的未来。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"设计基础：从创意到界面","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_359/","text":"清晰、直观、易用，是每款优秀 app 的必备要素。在本讲座中，你将了解如何通过 app 设计来加强功能效果、充分展现 app 的用途、引导用户浏览你的内容，并合理使用组件打造简洁明了又打动人心的出色体验。本次讲座适合各种技能水平的设计师和开发者，也欢迎希望了解设计知识的其他人员参加。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 设计基础：从创意到界面本文将详细介绍WWDC演讲中分享的应用设计基础理念，涵盖从结构设计到视觉呈现的完整流程，帮助开发者打造清晰、直观且易用的优秀应用。 引言在数字产品领域，优秀应用的核心特征在于其清晰度、直观性和易用性。本次WWDC演讲由设计布道团队的Majo主持，系统性地讲解了如何通过科学的设计方法强化应用功能、有效传达应用价值、优化用户导航体验，并合理运用组件创建简洁动人的界面交互。 结构设计：应用的基础框架应用结构决定了用户如何使用应用，影响着导航路径、内容优先级和整体体验呈现。一个良好的结构能让用户操作行云流水，而混乱的结构则会导致困惑和放弃使用。 设计评估的关键问题在评估应用设计时，需要关注三个核心问题： 用户是否能清楚知道自己当前所处位置 可执行的操作是否明确可见 是否有清晰的下一步行动指引 这些问题的解决程度直接决定了应用的使用流畅度。 信息架构优化方法优化信息架构的流程包括： 列出所有功能（包括核心功能和辅助功能） 设计用户使用场景和使用环境 精简内容：移除非核心功能、重命名模糊项、合理归类相关项 这种精简过程有助于明确应用的核心价值主张，为用户提供清晰的路径。 导航设计：用户移动方式导航设计的目标是让用户在应用中能够明确方位、自信操作。iOS的Tab bar组件是实现主要功能导航的理想选择，但需要注意： 控制选项卡数量（过多会增加用户决策负担） 确保每个选项卡都有清晰的目的 遵循《人机界面指南》原则（Tab bar用于导航而非执行操作） 导航优化技巧 优化选项卡标签和图标：使用直观的标签和标准化的SF Symbols图标 合理使用工具栏：放置屏幕相关操作和标题，保持方位感 迭代设计：通过多次调整使导航更具支持性、可预测性和易操作性 内容呈现：引导用户关注内容组织应引导用户关注重点信息和预期内容。核心策略包括： 渐进式呈现(progressive disclosure)这种技术只展示必要的前置内容，通过交互逐步展示更多细节。实现方式包括： 初始界面保持简洁 高级选项隐藏在展开控件中 新屏幕与前屏保持布局一致性 内容组织方法针对大量内容，可采用以下分组方式： 时间分组（如”最近文件”） 季节性/时效性分组 进度分组（如草稿、进行中的任务） 模式分组（展示关联项） 对于视觉性内容，集合视图(Collection)是最佳选择，它能： 保持项间间距一致 避免过多文本干扰 呈现动态浏览体验 视觉设计：个性与可用性的平衡视觉设计通过层次、排版、图像和色彩的协调运用，在支持功能的同时传递情感。关键要素包括： 视觉层次创建 使用系统文本样式(System text styles)创建清晰层次 支持动态类型(Dynamic Type)适配不同文字大小需求 图像上叠加文本时，添加渐变或模糊背景提升可读性 色彩与图像运用 建立统一的调色板和使用规则 合理使用语义颜色(Semantic colors)自动适应不同模式 在集合视图中添加代表性图像提升扫描效率 结论优秀的设计是一个系统工程，需要从结构、导航、内容到视觉的全面考量。核心要点包括： 精简信息架构明确应用核心价值 使用标准组件创建可预测的导航 采用渐进式呈现优化内容组织 平衡个性与可用性的视觉表达 设计过程本质上是迭代的，没有标准答案。开发者可以通过持续学习和实践，结合平台设计资源，创造出更优秀的应用体验。 文档Human Interface Guidelines","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"通过小小文字改动让 App 变得大不同","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_404/","text":"随着新的设计系统在各平台之间实现统一，现在是时候重新审视一下 ui 中的文字表述了。了解一些小的改动 (例如移除重复内容并突出优势) 如何快速提升 app 的可用性和清晰度。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 通过微调文字提升 App 体验：WWDC 文案优化指南在苹果全新设计系统统一各平台的背景下，应用文案的优化同样值得开发者关注。本文根据WWDC演讲稿，详细解析四个能显著提升用户体验的文案技巧。 文案优化的必要性用户体验文案师Liv Huntley和Jennifer Bush指出，当开发者思考新设计系统对应用视觉效果的影响时，应同步考虑文案优化。精简文案是提升应用可用性与清晰度的关键。 四大文案优化技巧1. 删除填充词最常见的问题是在文案中过度使用不必要的修饰词，主要包括： 副词：如”轻松地”、”快速地” 形容词：如”高速”、”简单” 感叹词：如”哎呀”、”糟糕” 客套话：如”抱歉”、”谢谢” 案例分析：停车应用原提示：”只需输入车牌号即可快速支付停车费”。优化后：”输入车牌号支付停车费”。删除”只需”和”快速”后，信息更客观准确。 例外情况：宠物喂食器应用：”外出时喂养宠物”可优化为”外出时自动定时喂养宠物”，此时”自动”一词突出了产品核心优势。 另一案例：快递延误通知原文案：”糟糕！我们迟到了。非常抱歉，送货司机无法准时到达，还有短短的10分钟！请查看应用获取司机位置”优化后：”送货延迟10分钟。请查看应用获取司机位置”删除情绪化表达后，信息更专业可信。 2. 避免重复表达重复表达是另一种常见冗余问题。 案例分析：优化前的送货通知：标题”我们迟到了”与正文”司机无法准时到达，10分钟后抵达”存在语义重复。优化方案：合并为”送货延迟10分钟”，既说明问题又量化延迟时长，保持其余提示：”请查看应用获取司机位置”。 3. 价值先行原则最有效的文案应先阐明用户价值，再说明操作方式。 案例1：Apple News+谜题通知优化前：”解答 crossword 保持连胜”优化后：”保持连胜记录：立即解答今日 crossword” 案例2：餐厅订座应用初稿：”输入电话号码获取预订更新”优化后：”获取预订更新：请输入电话号码”将利益点前置后，用户行动意愿显著提升。 4. 建立术语表术语表虽在应用之外创建，但对维持内部一致性至关重要。建议采用表格形式： 使用术语 禁用术语 定义 别名 用户名/称号 玩家在游戏中显示的名称（非登录用） 生命值 爱心/体力 玩家存活时长指标 实际应用示例： “设置您的别名”（对应：玩家显示名称） “查找别名”（避免使用”用户名”） “玩家’示例别名’发起对战” 术语一致性帮助用户建立准确心智模型。苹果风格指南是优秀的参考资源。 综合案例分析：AirPods Pro 听力测试该应用完美体现了四大优化原则： 无填充词：标题”测试听力”而非”快速简单的听力测试” 价值先行：段落首句即阐明：”听力损失普遍存在且可能恶化”、”AirPods Pro 可提供听力辅助” 一致性：全程使用”下一步”按钮 无重复：标题”寻找安静环境”与正文”背景噪音会导致测试不准”互为补充 实践建议与资源实践方法： 预留1-2小时集中优化应用文案 朗读文案以识别冗余表达 延伸学习： 往期用户体验文案分享 苹果人机界面指南文案规范 通过上述微小调整，开发者可以显著提升应用体验，让文案与全新设计系统相得益彰。 相关文档Human Interface Guidelines: Writing","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"借助 SpeechAnalyzer 将先进的语音转文本功能引入 App","date":"2025-06-10T13:46:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_277/","text":"探索带来语音转文本功能的全新 speechanalyzer api。我们将了解这一 swift api 及其丰富的功能，这些功能为“备忘录”“语音备忘录”“手记”等 app 提供了支持。我们将深入探讨相关细节，了解语音转文本功能的运作方式，以及 speechanalyzer 和 speechtranscriber 如何助你构建精彩、实用的功能。你还将跟着视频学习如何通过编程将 speechanalyzer 和实时转录功能整合到 app 中。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 通过 SpeechAnalyzer 为 App 引入先进的语音转文本功能引言在 iOS 18 中，苹果推出了全新的 SpeechAnalyzer API，这是一个强大的语音转文本解决方案，为开发者提供了与系统应用（如备忘录、语音备忘录和手记）相同的核心技术。这项创新技术不仅提升了转录速度和准确性，还支持本地端处理，确保了用户隐私。 SpeechAnalyzer API 概述与传统技术的比较SpeechAnalyzer 取代了 iOS 10 引入的 SFSpeechRecognizer，提供了更先进的语音识别能力。传统技术主要用于短文本听写，而新 API 专为处理长距离音频场景（如讲座、会议和对话）优化，具有以下显著优势： 更快的处理速度 更强的适应性 更好的长音频处理能力 本地端处理确保隐私安全 API 架构设计SpeechAnalyzer 采用模块化设计，核心类是 SpeechAnalyzer 和 SpeechTranscriber。其工作流程如下： 创建分析器实例 添加转录模块 接收音频缓冲区 异步返回处理结果 这种设计充分利用了 Swift 的异步序列机制，将音频输入和结果输出解耦，所有操作都基于精确的音频时间线执行。 核心功能与使用方式转录结果类型SpeechAnalyzer 提供两种转录结果： 易变结果(volatile results)：近乎实时呈现但准确性较低 确定性结果：随着获取更多上下文音频，模型会逐步优化并最终输出 开发者可以通过简单的代码实现基本转录功能： 123456789101112let transcriber = SpeechTranscriber(locale: locale, preset: .offlineTranscription)async let transcriptionFuture = try transcriber.results .reduce(&quot;&quot;) &#123; str, result in str + result.text &#125;let analyzer = SpeechAnalyzer(modules: [transcriber])if let lastSample = try await analyzer.analyzeSequence(from: file) &#123; try await analyzer.finalizeAndFinish(through: lastSample)&#125; else &#123; await analyzer.cancelAndFinishNow()&#125; return try await transcriptionFuture SpeechTranscriber 模式SpeechTranscriber 由苹果全新研发的模型驱动，具有以下特点： 支持多语言（持续增加中） 适用于除 watchOS 外的所有平台 模型自动更新机制 不增加应用下载大小或存储占用 对于不支持的语言或设备，API 还提供了 DictationTranscriber 作为备用方案。 实战应用：构建实时转录功能实现步骤 配置 SpeechTranscriber 123456func setUpTranscriber() async throws &#123; transcriber = SpeechTranscriber(locale: Locale.current, transcriptionOptions: [], reportingOptions: [.volatileResults], attributeOptions: [.audioTimeRange])&#125; 设置 SpeechAnalyzer 和音频格式 12analyzer = SpeechAnalyzer(modules: [transcriber])self.analyzerFormat = await SpeechAnalyzer.bestAvailableAudioFormat(compatibleWith: [transcriber]) 处理转录结果 123456789101112131415161718recognizerTask = Task &#123; do &#123; for try await case let result in transcriber.results &#123; let text = result.text if result.isFinal &#123; finalizedTranscript += text volatileTranscript = &quot;&quot; updateStoryWithNewText(withFinal: text) print(text.audioTimeRange) &#125; else &#123; volatileTranscript = text volatileTranscript.foregroundColor = .purple.opacity(0.4) &#125; &#125; &#125; catch &#123; print(&quot;语音识别失败&quot;) &#125;&#125; 音频处理音频输入处理包括权限请求和 AVAudioSession 配置： 123456789101112131415func record() async throws &#123; self.story.url.wrappedValue = url guard await isAuthorized() else &#123; print(&quot;用户拒绝麦克风权限&quot;) return &#125;#if os(iOS) try setUpAudioSession()#endif try await transcriber.setUpTranscriber() for await input in try await audioStream() &#123; try await self.transcriber.streamAudioToTranscriber(input) &#125;&#125; 与 Apple Intelligence 结合SpeechTranscriber 的高准确性使其成为 Apple Intelligence 处理的理想输入源。开发者可以利用 FoundationModels API 进行后续处理，如自动生成内容摘要或标题。 结论SpeechAnalyzer API 为开发者提供了强大而灵活的语音转文本解决方案，使得构建类似备忘录这样功能丰富的应用变得简单高效。新模型的速度、准确性和隐私保护特性，加上 Swift 的现代异步编程模型，为开发者创造了绝佳的开发体验。 更多技术细节和示例应用代码，开发者可以参考官方文档和示例项目。 相关视频使用个人和自定义声音扩展语音合成 文档Speech","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"“钱包”的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_202/","text":"了解“钱包”中的最新功能和改进。我们将介绍如何以惊艳的全新设计更新你的登机牌，并探索适用于多场次活动门票的新功能。我们还将讨论有助于你将凭证无缝添加到“钱包”中的 api 更新。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 钱包新功能：全面升级的活动票证与登机牌体验苹果钱包应用在WWDC24上迎来多项重要更新，包括增强型活动票证、全新设计的登机牌以及更便捷的凭证添加API。这些改进将为用户带来更丰富的使用体验，同时为开发者提供更强大的工具。 活动票证的后续活动功能今年钱包应用对活动票证进行了重大升级，引入了”后续活动”特性。这一功能允许用户通过单张票证访问多场关联活动，解决了以往需要多张独立票证的痛点。 技术实现细节后续活动功能通过pass.json文件中的新数组upcomingPassInformation实现配置。开发者需要在数组中为每场活动定义对象，包含类型(event)、唯一标识符、显示名称和日期等必要字段。该功能充分利用了iOS 18引入的海报活动票证语义机制。 12345678&quot;upcomingPassInformation&quot;: [ &#123; &quot;type&quot;: &quot;event&quot;, &quot;identifier&quot;: &quot;unique_id_123&quot;, &quot;displayName&quot;: &quot;Summer Concert Series - Night 2&quot;, &quot;date&quot;: &quot;2024-07-15T20:00:00&quot; &#125;] 每个后续活动对象支持完整的票证语义结构，包括： semantics对象：描述活动的语义信息 additionalInfoFields/backFields：未被语义覆盖的自定义属性 URLs对象：分组所有活动相关操作 images对象：配置活动关联图像 值得注意的是，后续活动不会自动复用主票证的属性。开发者需要为每个活动单独配置相关内容，包括自定义横幅图像(headerImage)、场地信息(venueName、venuePlaceID、venueLocation)和活动指南等。 登机牌的全面升级钱包中的登机牌体验今年迎来重大革新，新设计更具动态性和可配置性，并与苹果生态系统深度集成。 核心改进特性 实时航班追踪：与苹果航班服务自动同步，更新登机口变更、延误等信息 系统深度集成：地图提供机场路线指引，”查找”功能追踪行李 航空公司服务版块：显示旅客全程可采取的操作及相关信息摘要 智能徽章系统：自动显示最重要的信息，如舱位等级、行李资格等 技术配置要点升级版登机牌通过语义识别航班信息，核心语义包括： airlineCode：航空公司代码 flightNumber：航班号 originalDepartureDate：原始出发日期 currentBoardingDate：当前登机时间 徽章功能支持IATA特殊服务请求代码，通过passengerServiceSSRs语义实现。开发者还可使用自定义语义控制航空公司特有信息的标签。 12345&quot;semantics&quot;: &#123; &quot;passengerServiceSSRs&quot;: [&quot;SVAN&quot;, &quot;WCHR&quot;], &quot;seatClass&quot;: &quot;Business&quot;, &quot;airlineStatus&quot;: &quot;Gold&quot;&#125; 自动添加凭证API针对频繁添加凭证的用户，今年推出了新的PKPassLibrary API，支持后台自动添加功能。 实现步骤 请求权限：使用requestAuthorization(for: .backgroundAddPasses)请求后台添加权限 检查状态：通过authorizationStatus(for:)检查当前授权状态 添加凭证：授权后使用addPasses方法自动添加凭证 123Task &#123; await PKPassLibrary.shared.requestAuthorization(for: .backgroundAddPasses)&#125; 兼容性与最佳实践虽然新功能强大，开发者仍需考虑以下兼容性要点： 升级版登机牌功能仅支持最新iOS和watchOS设备 应继续在现有登机牌中添加语义和URL，确保旧系统用户也能获得良好体验 后续活动功能需要iOS 18及以上版本支持 对于活动票证，建议定期更新isActive属性，及时移除已取消或不相关的活动，确保列表信息的准确性。 开发资源开发者可以访问以下资源获取更多详细信息： 人机界面指南：钱包 PassKit(Apple Pay和Wallet)文档 相关WWDC视频讲解 这些钱包新功能将为用户带来更加无缝、智能的体验，同时也为开发者提供了更丰富的工具来创建出色的凭证解决方案。通过合理利用这些新特性，应用可以显著提升用户满意度和参与度。 相关视频Apple Pay 的新功能“钱包”和 Apple Pay 的新功能 文档人机界面指南：钱包PassKit (Apple Pay 和 Wallet)","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"Apple Pay 的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_201/","text":"探索 apple pay 中的最新改进和新 api。你将探索 apple pay ecommerce 体验有哪些优化 (例如新增的动态支付按钮)，并了解如何充分利用增强后的预授权付款支持。我们将介绍“钱包”中的订单跟踪将迎来哪些全新功能，并了解一些有助于让订单呈现精美外观的建议。我们还将深入了解 financekit 的新背景交付 api，这些 api 让财务管理 app 即使在非活跃状态下也能获取最新数据。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple Pay 新功能：电子商务体验与FinanceKit深度解析Apple Pay作为苹果生态系统的核心支付解决方案，在WWDC上公布了多项重要更新。这些改进覆盖了支付全流程体验、订单管理以及FinanceKit API的扩展功能，为开发者和商户提供了更强大的工具来优化用户交互与后台数据处理。 支付体验全面升级今年Apple Pay的改进首先体现在支付按钮的动态显示功能上。该系统会根据用户默认支付方式自动调整按钮显示内容，展示卡片图像和相关信息。为实现这一功能，开发者需要在支付请求中提供商户类别代码(Merchant Category Code)和支持的支付网络信息。 12// 设置商户类别代码示例paymentRequest.merchantCategoryCode = .retail 值得注意的是，苹果仍严格保护用户隐私，应用无法直接访问卡片详细信息。SwiftUI和UIKit应用将自动获得新按钮支持，同时开发者也可选择继续使用传统样式。 预授权支付功能获得了显著增强，新增的统一视图让用户可以集中管理所有预授权交易。商户现在可以通过提供丰富的品牌信息来定制界面体验，这需要从bundle分发端点提供包含特定信息的bundle： 123456// 商户令牌信息架构示例&#123; &quot;merchantTokenIdentifier&quot;: &quot;com.example.merchant&quot;, &quot;merchantName&quot;: &quot;Example Store&quot;, &quot;merchantLogoName&quot;: &quot;logo.png&quot;&#125; 智能订单跟踪系统自iOS 16引入订单跟踪功能以来，今年苹果进一步整合了智能技术实现自动订单检测。钱包应用现在能够安全地扫描邮件中的订单信息，自动创建跟踪条目。 为确保最佳自动跟踪效果，商户邮件需要包含三个关键要素： 邮件正文中的商户名称 每封邮件独有的订单编号 用于关联承运商信息的跟踪编号 商户还可以通过Apple Business Connect设置品牌logo和其他详细信息，这些内容将应用于所有相关邮件订单。 FinanceKit API的重大扩展FinanceKit API自iOS 17.4发布以来首次迎来重大更新。最引人注目的是新增的后台交付功能，它允许金融类应用在非活跃状态下仍能获取最新数据。 后台交付扩展需要实现两个核心端点： 12345678// 后台交付扩展实现示例func didReceiveData(_ data: [BackgroundDataType]) &#123; // 处理数据变更&#125;func willTerminate() &#123; // 清理资源&#125; 开发者可以配置三种数据更新频率（每小时、每日、每周），系统会根据实际数据变化情况智能触发扩展。同时，FinanceKit API现已扩展至英国市场，支持Connected Cards功能。 开发者资源与后续步骤苹果为开发者提供了全面的资源支持： 商户品牌展示：通过Apple Business Connect统一管理 订单体验优化：注册订单确认邮件地址或集成订单跟踪bundle FinanceKit集成：Xcode直接支持后台交付功能开发 相关技术文档和WWDC视频资源已全面更新，帮助开发者快速掌握这些新功能。 相关视频“钱包”的新功能了解FinanceKit“钱包”和Apple Pay的新功能钱包与Apple Pay的新功能 文档Apple PayHuman Interface Guidelines: Apple Pay","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"提升 iPad App 设计","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_208/","text":"让你的 app 在 ipados 上呈现出色观感。了解设计响应式布局的最佳实践，轻松创建可调整大小的窗口。熟悉窗口控件，并探索适配不同窗口控件的最佳方式。了解出色菜单栏的构建要素。此外，探索全新指针及其效果更新。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 提升 iPad 应用设计：WWDC 26 最新指南概述iPadOS 26 带来了一系列创新功能，旨在帮助开发者打造更强大、更流畅的 iPad 应用体验。本次 WWDC 演讲详细介绍了如何利用这些新特性优化应用设计，包括导航模式选择、窗口管理改进、指针增强以及菜单栏设计。 导航设计新范式在 iPadOS 26 中，应用的导航设计获得了全新可能性。设计师 Rene Lee 展示了两种主要导航模式： 侧边栏导航非常适合内容层级复杂的应用，如邮件应用展示的示例。邮件应用利用侧边栏扁平化导航结构，将所有邮箱和账户一目了然地展示给用户。音乐应用则展示了侧边栏与选项卡栏之间的流畅转换：点击侧边栏中的按钮，导航可以无缝变形为更紧凑的选项卡栏。 选项卡栏导航作为更紧凑的选择，能够最大化内容展示空间，提供更沉浸式的体验。开发者可以从选项卡栏开始设计，因为它能轻松扩展为侧边栏，为应用未来的发展预留空间。 演讲特别强调了导航在尺寸变化时的适应性表现： 竖屏模式下，侧边栏可变形为选项卡栏 布局变化应保持非破坏性 尽可能恢复到初始状态 Rene 还建议开发者充分利用”滚动边缘效果”，在工具栏下方扩展内容，创造更沉浸式的体验，这对于浮动窗口尤为重要。 窗口系统革新iPadOS 26 引入了更简单强大的窗口系统： 每个支持多任务处理的应用右下角新增了调整手柄，用户可轻松拖动调整窗口大小 左上角的窗口控件点击时会放大显示功能，长按则提供快速创建各种窗口布局的快捷方式 窗口控件的放置也有新规范： 应环绕在工具栏前导边缘 避免使用兼容性放置方式（在工具栏上方增加安全区域） 正确放置可回收额外内容空间 文档打开行为也有重要变化： 每个新文档应在独立窗口中打开（而非”就地打开”） 应用菜单新增窗口列表功能 为每个窗口提供描述性名称至关重要 指针交互升级iPadOS 26 对指针系统进行了显著改进： 新指针形状更精确，直接一对一跟踪输入 悬停效果更新为”液态玻璃托盘”视觉反馈 高亮效果会弯曲折射底层元素，清晰指示选中状态 指针不再磁吸或橡皮筋式粘附，响应更直接 开发者被建议全面测试应用与新指针的交互，确保体验流畅。 菜单栏设计规范iPad 菜单栏设计需要特别注意： 自定义菜单设计准则： 按使用频率而非字母顺序排列操作 相关操作分组到独立部分 次要操作可放入子菜单 为项目分配匹配应用的符号 常用操作设置键盘快捷键 视图菜单优化建议： 包含应用选项卡作为菜单项 为选项卡切换分配快捷键 添加侧边栏切换器功能 重要注意事项： 避免根据上下文隐藏菜单或项目 非活动项目应变暗而非隐藏 保持菜单内容静态以确保可预测性 即使没有可操作项，也应显示完整菜单 总结与资源iPadOS 26 为应用设计提供了丰富的新工具：从流畅的导航转换、优化的窗口管理，到精确的指针交互和结构化的菜单栏设计。开发者可以通过合理运用这些构建模块，显著提升 iPad 应用体验。 更多详细信息可参考以下设计指南： Human Interface Guidelines: MultitaskingHuman Interface Guidelines: The menu barHuman Interface Guidelines: Windows","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"了解焕然一新的 App 图标","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_220/","text":"简要了解 ios、ipados 和 macos 的全新 app 图标外观，包括浅色调和深色调以及透明选项。了解如何使用霜冻质感和半透明效果使 app 图标更生动鲜活、更富表现力，并了解如何确保你的图标与镜面高光效果相得益彰。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 苹果WWDC揭秘：全面重构的App图标设计语言在2025年苹果全球开发者大会上，苹果设计师Marie详细介绍了全新重构的App图标视觉系统。这项革新将为iOS、iPadOS和macOS等平台带来焕然一新的视觉体验。 液态玻璃材质：图标设计的革命性突破作为今年最具突破性的重新设计，苹果团队从visionOS的分层图标中汲取灵感，结合真实玻璃材质特性，创造出名为”液态玻璃（Liquid Glass）”的全新材质。这种材质通过巧妙的分层技术呈现边缘高光、磨砂纹理和半透明效果： 立体感增强：边缘光线会随设备陀螺仪移动而流转 内部发光效果：营造出独特的视觉深度 多模式支持：完美适配浅色、深色及全新的半透明外观模式 特别值得注意的是，苹果开发了两类色调模式：深色色调为前景着色，浅色色调则将色彩注入玻璃本身，使图标在锁屏配色搭配时效果尤为惊艳。 跨平台统一的设计体系过去不同设备平台采用差异化设计的问题得到了彻底解决。新系统带来了多项重大改进： 网格更新：采用更简洁均匀的间距布局，增大圆角半径 圆形图案优化：为圆形图标提供专属框架和更多留白空间 自动适配机制：系统能自动应用蒙版或扩展适配模板，赋予旧图标新材质外观 对于开发者特别关注的macOS图标适配问题，苹果展示了”通讯录”图标的具体改造案例。新系统会智能处理不规则轮廓，同时建议开发者重新绘制图标以充分利用画布空间。 图标绘制专业技巧Marie分享了多项实用设计技巧，帮助开发者充分利用新材质特性： 分层结构：背景层+前景层的组合是设计核心 半透明与模糊：比以往更优雅简单的实现方式 简约设计：遵循”少即是多”原则，让材质本身说话 背景处理：推荐使用System Light/Dark渐变而非纯色 值得注意的是，由于材质本身已包含丰富动态效果，苹果建议减少源图案中的静态效果。此外，设计时还需注意避免尖锐边缘和细线，采用圆角更利于光线传播。 新时代的图标设计理念这项革新不仅是视觉美学的改变，更标志着图标设计新时代的到来。苹果鼓励开发者： 拥抱变革，探索新的设计可能性 让图标成为最能体现应用价值的视觉载体 在叙事与品牌塑造中发挥更关键作用 对于希望深入了解新设计系统的开发者，苹果提供了配套讲座和设计模板资源。这项全面的图标设计革新预计将随新版操作系统一同推出，为苹果生态系统带来更加统一、精致的视觉体验。 相关视频了解 Liquid Glass了解全新设计系统使用 Icon Composer 构建图标 文档资料人机界面指南：App图标","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"了解 Liquid Glass","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_219/","text":"liquid glass 统一了 apple 平台的设计语言，同时提供更生动、更富表达力的用户体验。了解 liquid glass 的设计原则，探索它核心的光学和物理特性，并了解相关用途和原理。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple液态玻璃设计系统：革新数字体验的超材料液态玻璃作为Apple最新的设计系统，正在重新定义其平台上的视觉体验。这一创新材质不仅统一了Apple生态系统的设计语言，还带来了前所未有的表现力和动态交互能力。 液态玻璃的核心概念液态玻璃代表了Apple软件视觉设计的重大革新，它创造性地融合了历代界面的精华元素。该系统并非简单模仿现实材质，而是构建了一种新型数字超材料，具备动态折射光线和自然流动的特性。 这种设计语言延续了从macOS X的Aqua界面到visionOS沉浸式界面的演进脉络，其核心在于”透镜效应”——通过模拟自然界的透明物体折射光线的方式，实现了界面层级的清晰区分。 动态特性与交互体验液态玻璃的视觉表现建立在三个关键特性上： 光学特性：与传统散射材质不同，液态玻璃能实时动态地折射、塑造和聚焦光线，让控件显得轻盈透明却不失辨识度。 物理特性：借鉴了液体的流畅特性，界面响应符合人类对物理世界的直觉认知。交互时，元素会即时反射和增强光线，营造灵敏的反馈感。 状态转换：控件形状在不同情境下动态变化，但始终悬浮于同一平面，使得过渡流畅自然。例如菜单展开时，气泡会直接变形显示内容。 这些特性共同创造了全新的交互维度，通过光线折射与动态反射的创新组合，让用户体验更加自然流畅。 自适应机制液态玻璃具备强大的环境适应能力，其多层结构会根据不同场景自动调整： 文本滚动时阴影加深确保可读性 着色度动态变化平衡透明度与辨识度 展开菜单时材质模拟更厚重的光学特性 在不同设备上，液态玻璃控件会完美契合窗口圆角，保持视觉一致性。边栏等大型元素会吸收周围环境的光色，通过光线反射与阴影增强立体感。 系统还智能调节滚动边缘效果的透明度与亮度，确保标题等悬浮元素始终清晰可见。这些自适应机制既维持了界面的清晰层级，又确保内容始终是视觉焦点。 设计准则与应用液态玻璃的设计结构分为三个层次： 高光层：模拟真实环境光源，产生动态边缘光效 阴影层：智能调节不透明度以适应不同背景 反馈光晕：触控时从接触点扩散，与弹性特性融合 应用液态玻璃时需注意以下准则： 适用场景：优先用于悬浮导航层，避免用于内容层 层级规范：禁止重叠使用，上层元素应采用填充/透明度 变体选择：常规变体适合大多数场景，透明变体仅限媒体内容上方 系统还提供了完善的可读性优化策略和辅助功能支持，包括自动切换深浅模式、动态调整色相/饱和度，以及针对特殊需求的降低透明度、提高对比度等选项。 液态玻璃标志着Apple视觉设计的新纪元，为开发者提供了创造惊艳体验的强大工具。通过合理运用这一创新材质，开发者可以为用户带来更自然、更流畅的数字交互体验。 相关视频和文档资源可帮助开发者深入了解和掌握液态玻璃设计系统的应用方法。 相关视频了解全新设计系统了解焕然一新的 App 图标使用 Icon Composer 构建图标 文档资源采用液态玻璃人机界面指南人机界面指南：材质","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"AdAttributionKit 的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_221/","text":"了解 adattributionkit 的新功能，包括如何衡量重叠的重新吸引转化，以及如何为你的 app 自定广告归因规则。深入了解一个新的回传属性，你可以使用这个属性来衡量广告系列在各个国家和地区的实际效果。我们还将展示新的功能，以及用于测试 adattributionkit 实现情况的最佳做法。为了充分从这个讲座中获益，建议你先观看“了解 adattributionkit”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com AdAttributionKit 新特性：全面解析广告归因增强功能Apple在WWDC24上为开发者带来了AdAttributionKit的一系列创新功能，旨在提升广告转化测量精度与灵活性，同时坚守隐私保护的核心理念。本文将深入解析这些新特性的技术实现与应用场景。 引言AdAttributionKit作为Apple隐私优先的广告归因解决方案，自iOS 17.4推出以来不断完善。在iOS 18系列更新中，该系统新增了多项关键功能，包括重叠转化窗口测量、自定义归因规则配置、地理数据回传以及开发者测试工具增强。 重叠转化窗口测量iOS 18.4引入的突破性功能允许应用同时追踪多个再互动转化窗口，解决了以往只能有一个活跃窗口的限制。这项改进特别适用于同时运行多个促销活动的场景。 技术实现要点： 需在Info.plist中设置EligibleForAdAttributionKitOverlappingConversions为YES 通过URL参数解析转化标签：1234567func retrieveConversionTag(fromURL url: URL) -&gt; String? &#123; guard let components = URLComponents(url: url, resolvingAgainstBaseURL: true) else &#123; print(&quot;无法解析URL组件&quot;) return nil &#125; // 其余解析代码...&#125; 更新特定转化值时调用专用API：123456func updateConversionValue(_ conversionValue: Int, conversionTag: String) async &#123; let update = PostbackUpdate(fineConversionValue: conversionValue, lockPostback: false, conversionTag: conversionTag) // 执行更新...&#125; 自定义归因规则配置开发者现在可以针对不同广告网络和互动类型灵活配置归因参数： 归因窗口定制：按网络和互动类型(点击/浏览)设置不同窗口时长 冷却期设置：避免安装后的短时互动覆盖原始转化价值 配置示例：123456789&#123; &quot;com.example.adNetwork&quot;: &#123; &quot;click&quot;: 2, &quot;view&quot;: 1 &#125;, &quot;global&quot;: &#123; &quot;view&quot;: 3 &#125;&#125; 回传地理数据增强新增的国家代码字段为广告主提供了地域维度的数据分析能力： App Store安装：采用用户账户的商店地区 再互动转化：沿用安装时的地区 替代市场：需在JWS令牌中提供已验证的国家代码 隐私保护：遵循群体匿名算法，仅当转化量达标时才会包含该字段 开发者测试工具iOS 18.4的设置应用新增了直接创建测试回传的功能： 路径：开发者选项→”Ad Attribution Testing”→”Development Postbacks” 可配置属性：包括测试国家代码、数据粒度等 特殊标识：网络ID为”development.adattributionkit”，使用新签名密钥 总结与建议AdAttributionKit的新特性为开发者提供了更精细的广告效果测量工具，同时保持了Apple对用户隐私的承诺。开发者应采取以下行动： 在Info.plist中添加归因规则配置 尽早利用测试功能验证实现 从SKAdNetwork迁移至AdAttributionKit以获得完整功能 这些增强功能体现了Apple在平衡广告效果测量与用户隐私保护方面的持续创新，为应用开发者提供了更强大的商业化工具。 相关资源将隐私保护融入开发流程了解 AdAttributionKitAdAttributionKit 文档","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"提升 App 的多语言体验","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_222/","text":"为使用多种语言的用户打造顺畅体验。了解语言发现功能如何以用户偏好的语言优化你的 app。探索为从右至左显示的语言提供支持的最新进展，包括用来在双向文本中选择多个范围的自然选择。我们还将介绍在你的 app 中支持多语言场景的最佳实践。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com iOS 26中的多语言体验全面升级苹果在WWDC上展示了iOS 26中一系列针对多语言体验的重要改进，这些新功能将帮助开发者构建更具包容性和全球化的应用。 语言发现与个性化体验iOS 26引入了革命性的语言发现功能，能够自动识别用户的多语言使用习惯。系统通过设备端智能分析用户在不同场景下的语言使用情况，如消息、音乐和新闻浏览等。开发者现在可以通过Locale.preferredLocalesAPI获取包含丰富信息的Locale对象数组，取代原有的Locale.preferredLanguages字符串数组。 12let preferredLocales = Locale.preferredLocaleslet preferredLanguages = Locale.preferredLanguages 新API提供了更全面的语言和地区信息，包括数字系统、本地化名称等，使开发者能够更精确地匹配用户偏好。苹果已在翻译应用、日历和Apple Music等场景中应用了这一技术，显著提升了多语言用户的体验。 备选日历支持扩展iOS 26新增了11种备选日历选项，包括古吉拉特语、马拉地语和韩语等。这些新日历在所有苹果平台上可用，开发者可以通过Foundation框架中的Calendar.Identifier访问。这一扩展为不同文化背景的用户提供了更符合其传统的日期显示方式。 双向文本的重大革新iOS 26对双向文本处理进行了重大改进，其中最引人注目的是”自然选择”功能。新系统解决了在混合LTR(左至右)和RTL(右至左)文本中选择时的显示问题。开发者现在需要使用selectedRanges属性取代原有的selectedRange，以准确反映用户在双向文本中的多段选择。 1234let ranges = textView.selectedRanges.reversed()for range in ranges &#123; textView.textStorage.deleteCharacters(in: range)&#125; UITextViewDelegate协议也相应更新，新增了支持范围数组的方法。值得注意的是，要充分利用这些新功能，开发者必须使用TextKit2作为文本引擎。苹果还优化了书写方向的动态确定机制，使文本流向能够根据内容自动调整。 键盘与输入体验优化iOS 26为多语言用户提供了多项键盘改进： 新增Arabizi音译键盘，支持拉丁字母输入阿拉伯语 为印地语键盘加入双语建议功能 推出阿拉伯语-英语双语多文字键盘 为泰语用户新增24键布局键盘 这些改进显著提升了多语言用户的输入体验，特别是经常需要在不同语言间切换的用户。 开发建议与最佳实践苹果建议开发者： 及时迁移到Locale.preferredLocalesAPI 在文本处理中使用TextKit2而非TextKit1 适配新的selectedRanges和代理方法 利用新的备选日历选项 遵循苹果的人机界面指南中的RTL规范 这些改进共同构成了iOS 26强大的多语言支持体系，帮助开发者构建真正全球化的应用，为不同语言和文化背景的用户提供更自然、更贴心的体验。 相关视频跟着视频学编程：使用 SwiftUI 和 AttributedString 精心打造富文本体验构建支持多语言的 App向左语言 文档Human Interface Guidelines: Right to left","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"了解面向空间商务 App 的增强功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_223/","text":"在去年发布的访问和企业级功能基础上，visionos 26 中最新的增强功能和 api 实现了进一步扩展，快来一探究竟吧！了解这些全新功能如何助你轻松构建模型训练工作流程、增强视频影像，并在本地网络上统一坐标系，从而为企业内部 app 打造协作体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 visionOS 26 企业级应用新功能在 WWDC 最新演讲中，visionOS 团队展示了针对企业级应用的多个重要增强功能。本文将详细解析这些新功能和技术实现，帮助开发者了解如何构建更强大的空间商务应用。 企业级 API 访问优化visionOS 26 首先对现有企业级 API 进行了开放性调整。其中两项关键功能——UVC 视频设备访问和神经引擎（Neural Engine）使用权现已向所有开发者开放，不再需要企业许可证或特殊权限。这意味着开发者可以更方便地利用外部摄像头进行视频会议或专业成像，以及使用设备端机器学习能力。 命令行对象追踪训练对象追踪功能获得了重大改进，新增了通过命令行直接训练模型的能力： 1xcrun createml objecttracker -s my.usdz -o my.referenceobject 这一变化使得模型训练流程可以完全自动化，开发者能够将其整合到现有工作流中，大幅提升效率。 简化的许可证管理全新的 Vision Entitlement Services 框架简化了企业许可证管理流程。开发者现在可以： 直接从 Apple 开发者账户获取许可证文件 自动接收无线推送的许可证更新 通过代码检查特定功能的访问权限 123456import VisionEntitlementServiceslet license = EnterpriseLicenseDetails.sharedif license.isApproved(for: .mainCameraAccess) &#123; // 启用摄像头功能&#125; 用户体验增强功能窗口跟随模式新引入的窗口跟随模式(Window Follow Mode)解决了用户在移动过程中与窗口交互的痛点。通过简单的操作，用户可以让特定窗口随移动而移动，特别适合需要持续监控信息的场景。 共享坐标空间SharedCoordinateSpaceProvider API 允许企业应用创建自定义的共享体验。多个用户可以在同一物理空间中看到对齐的数字内容，支持协作工作场景。 123let sharedCoordinateSpace = SharedCoordinateSpaceProvider()let worldTracking = WorldTrackingProvider()try await arkitSession.run([sharedCoordinateSpace, worldTracking]) 内容安全保护新的 contentCaptureProtected 视图修饰符为企业敏感数据提供保护： 12SensitiveDataView() .contentCaptureProtected() 被标记的内容在屏幕录制或共享时会被自动模糊，但对佩戴者保持完全可见。 环境可视化增强摄像头访问扩展visionOS 26 扩展了摄像头访问权限，现在支持： 单独访问左/右摄像头 立体处理和分析 沉浸空间和共享空间环境 摄像头区域技术CameraRegionView 和 CameraRegionProvider API 提供了强大的环境细节可视化能力： 123CameraRegionView(isContrastAndVibrancyEnhancementEnabled: true) &#123; result in // 处理每帧图像&#125; 该技术可实现： 特定区域的独立视频馈送 图像稳定化 对比度和鲜艳度增强 与3D对象关联的锚点定位 最佳实践与注意事项开发者在使用这些新功能时需要注意： 确保用户环境安全 透明处理数据收集 仅申请必要的权限 优化资源使用，特别是大型摄像头区域 符合企业API的使用资格要求 总结visionOS 26 的企业级功能增强为空间商务应用开发带来了更多可能性。从开发流程优化到用户体验提升，再到环境可视化能力，这些新特性将助力开发者构建更专业、更高效的企业解决方案。 相关视频与附近用户共享 visionOS 体验为你介绍适用于 visionOS 的企业 API使用 ARKit 打造更出色的空间计算体验探索适用于 visionOS 的对象追踪 文档使用 visionOS 企业 API 构建商务空间体验在 visionOS 应用中实现对象追踪","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 AlarmKit API 实现唤醒功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_230/","text":"铃-铃-铃！从你食谱 app 中的倒计时器到你旅行规划 app 中的闹钟，ios 和 ipados 26 中的 alarmkit 框架可将计时器和闹钟引入到锁定屏幕、灵动岛等其他地方。了解如何使用 app intents 框架来创建和管理你 app 的闹钟，自定闹钟的实时活动，并提供自定提醒操作。为了充分从这个视频中获益，建议你先观看 wwdc23 讲座“了解 activitykit”。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 全面解析 iOS AlarmKit 框架：从基础应用到高级定制iOS 和 iPadOS 26 中引入的 AlarmKit 框架为开发者提供了一套完整的闹钟功能实现方案。该框架不仅支持基础闹钟功能，还能与系统深度整合，在锁定屏幕、灵动岛等界面展示丰富的交互体验。本文将系统性地介绍 AlarmKit 的各项功能特性、实现方式以及最佳实践。 AlarmKit 框架概述AlarmKit 是 iOS 系统提供的一个专业闹钟管理框架，它能够实现以下核心功能： 创建基于固定时间或重复模式的闹钟提醒 支持倒计时功能，包括预警倒计时和后续倒计时间隔 突破系统静音模式和专注模式的显著提醒 与实时活动(Live Activities)深度整合，在锁定屏幕、灵动岛和待机模式下展示自定义界面 提供可定制的提示音和交互按钮 闹钟触发时会显示包含自定义标题和应用名称的提醒界面，用户可选择关闭或使用小睡功能延迟处理。此外，闹钟还支持在配对的 Apple Watch 上同步展示。 授权与权限配置在使用 AlarmKit 前，应用必须获取用户授权。授权配置包含以下关键步骤： 在 Info.plist 中添加 NSAlarmKitUsageDescription 键，说明闹钟的使用场景 使用 AlarmManager 的 requestAuthorization API 手动请求授权 在调度闹钟前检查 authorizationState 状态 授权状态检查示例 123456789101112import AlarmKitfunc checkAuthorization() &#123; switch AlarmManager.shared.authorizationState &#123; case .notDetermined: // 手动请求授权 case .authorized: // 继续调度闹钟 case .denied: // 提示用户未获授权 &#125;&#125; 用户授权状态分为三种：未决定(notDetermined)、已授权(authorized)和被拒绝(denied)。开发者应在应用界面清晰处理各种状态，特别是被拒绝状态时应明确告知用户无法设置闹钟。 闹钟创建与配置创建闹钟需要配置多个核心要素，包括倒计时时长、日程设置、界面定制等。 倒计时配置AlarmKit 支持设置预警倒计时和后续倒计时两个阶段： 倒计时配置示例 12345import AlarmKitfunc scheduleAlarm() &#123; let countdownDuration = Alarm.CountdownDuration(preAlert: (10 * 60), postAlert: (5 * 60))&#125; 此配置表示10分钟预警倒计时和5分钟后续倒计时。首次调度时会显示预警倒计时界面，结束后触发提醒界面。若用户选择小睡，则会再次显示后续倒计时界面。 日程设置AlarmKit 提供两种日程设置模式： 固定日程：指定未来某个绝对时间，不受时区变化影响 固定日程示例 12345678910111213import AlarmKitfunc scheduleAlarm() &#123; let keynoteDateComponents = DateComponents( calendar: .current, year: 2025, month: 6, day: 9, hour: 9, minute: 41) let keynoteDate = Calendar.current.date(from: keynoteDateComponents)! let scheduleFixed = Alarm.Schedule.fixed(keynoteDate)&#125; 相对日程：包含每日时间和周重复模式，自动适应时区变化 相对日程示例 1234567import AlarmKitfunc scheduleAlarm() &#123; let time = Alarm.Schedule.Relative.Time(hour: 7, minute: 0) let recurrence = Alarm.Schedule.Relative.Recurrence.weekly([.monday, .wednesday, .friday]) let schedule = Alarm.Schedule.Relative(time: time, repeats: recurrence)&#125; 界面定制与实时活动AlarmKit 支持高度自定义的界面展示，包括提醒界面和倒计时界面。开发者可以通过实时活动(Live Activities)在锁定屏幕、灵动岛和待机模式下展示丰富内容。 实时活动配置示例 1234567891011121314151617181920import AlarmKitimport ActivityKitimport WidgetKitstruct AlarmLiveActivity: Widget &#123; var body: some WidgetConfiguration &#123; ActivityConfiguration(for: AlarmAttributes&lt;CookingData&gt;.self) &#123; context in switch context.state.mode &#123; case .countdown: countdownView(context) case .paused: pausedView(context) case .alert: alertView(context) &#125; &#125; dynamicIsland: &#123; context in DynamicIsland &#123; // 展开区域视图 &#125; compactLeading: &#123; compactLeadingView(context) &#125; // 其他紧凑视图 &#125; &#125;&#125; 高级功能与最佳实践自定义动作处理通过 App Intent 框架，开发者可以为闹钟按钮添加自定义动作： 自定义按钮动作示例 12345678910111213import AlarmKitimport AppIntentsfunc scheduleAlarm() async throws &#123; let openButton = AlarmButton(text: &quot;打开&quot;, textColor: .white, systemImageName: &quot;arrow.right.circle.fill&quot;) let alertPresentation = AlarmPresentation.Alert(..., secondaryButtonBehavior: .custom) let secondaryIntent = OpenInApp(alarmID: id.uuidString)&#125;public struct OpenInApp: LiveActivityIntent &#123; public static var openAppWhenRun = true @Parameter public var alarmID: String&#125; 提示音定制AlarmKit 支持使用系统预置或自定义的提示音： 提示音配置示例 12let sound = AlertConfiguration.AlertSound.named(&quot;Chime&quot;)let alarmConfiguration = AlarmConfiguration(..., sound: sound) 生命周期管理AlarmManager 提供完整的闹钟生命周期管理API，包括： 调度新闹钟 取消已有闹钟 暂停/恢复闹钟 查询当前闹钟状态 应用场景与限制AlarmKit 最适合以下场景： 精确倒计时应用（如烹饪计时器） 规律性提醒（如起床闹钟） 需要突破静音模式的紧急提醒 但不建议用于替代关键通知或时效性通知。开发者应保持提醒界面简洁明了，实时活动应包含剩余时间、关闭和暂停/继续按钮等核心元素。 总结AlarmKit 框架为 iOS 应用提供了强大的闹钟功能实现方案。通过合理配置授权、精心设计界面和充分利用实时活动，开发者可以为用户创造丰富而实用的闹钟体验。建议结合 App Intents 和 ActivityKit 框架，实现更高级的定制功能。 相关视频和文档资源可帮助开发者更深入地了解和应用 AlarmKit 框架。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"了解适用于 SwiftUI 的 WebKit","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_231/","text":"了解如何使用 webkit 将网页内容轻松整合到你的 swiftui app 中。了解如何载入和显示网页内容、与网页进行通信等。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索适用于 SwiftUI 的 WebKit苹果在 WWDC 2025 上发布了 WebKit for SwiftUI，这是一个全新的 SwiftUI API，旨在帮助开发者更轻松地将网页内容集成到 SwiftUI 应用中。该 API 结合了 WebKit 的强大网络能力与 SwiftUI 的简洁特性，为开发者提供了前所未有的便捷开发体验。 WebKit for SwiftUI 简介WebKit 是 Safari、Mail 以及众多苹果平台应用的核心浏览器引擎。全新的 WebKit for SwiftUI API 让开发者能够以极简的方式调用 WebKit 的功能，只需创建 WebView 并提供一个 URL 即可显示网页内容。该 API 支持所有 WebKit 兼容平台，包括 iOS、iPadOS、VisionOS 和 macOS。 加载与显示网页内容WebKit for SwiftUI 提供了 WebView 视图，这是专门为展示网页内容而设计的新 SwiftUI 视图。开发者只需简单地将 URL 传递给 WebView，它就会自动加载并显示内容。不仅如此，WebView 还支持动态切换 URL，当 URL 变化时，WebView 会自动导航至新的 URL。 使用 WebPage 观察网页内容除了基本的 URL 加载，开发者还可以创建 WebPage 并将其连接到 WebView。WebPage 是一个全新的 Observable 类，代表网页内容，能够完美适配 Swift 和 SwiftUI。通过 WebPage，开发者可以观察网页内容的各种属性变化，如页面标题、URL 等。 WebPage 提供了多种加载网页内容的方式： 加载远程 URL： 1webPage.load(URLRequest(url: url)) 直接加载 HTML 字符串： 1webPage.loadHTMLString(htmlString, baseURL: baseURL) 加载 web archive 数据： 1webPage.load(data: data, mimeType: mimeType, characterEncodingName: encoding, baseURL: baseURL) 自定义 URL Scheme 处理WebKit for SwiftUI 还支持自定义 URL scheme 处理，允许开发者处理特定 scheme 的资源加载。开发者可以创建遵循 URLSchemeHandler 协议的类型，并通过实现 reply 函数来提供自定义数据。 12345struct LakesSchemeHandler: URLSchemeHandler &#123; func reply(to request: URLRequest) async -&gt; AsyncSequence&lt;URLSchemeTaskResult&gt; &#123; // 实现自定义资源加载逻辑 &#125;&#125; 与页面通信观察导航事件WebPage 提供了 currentNavigationEvent 属性，允许开发者观察网页的导航状态变化。导航事件包括： startedProvisionalNavigation：导航开始 receivedServerRedirect：服务器重定向 committed：开始接收主框架内容 finish：导航完成 failed/failedProvisionalNavigation：导航失败 开发者可以使用 Swift 6.2 的 Observations API 来观察这些事件的变化： 123for await event in webPage.currentNavigationEvent.values &#123; // 处理导航事件&#125; JavaScript 通信WebPage 提供了 callJavaScript API，允许开发者评估 JavaScript 代码并与页面通信。该 API 支持传递参数，并将 JavaScript 返回值转换为 Swift 类型。 123let result = try await webPage.callJavaScript(&quot;&quot;&quot; document.getElementById(&#x27;\\(sectionID)&#x27;).getBoundingClientRect().top&quot;&quot;&quot;) 定制内容交互WebKit for SwiftUI 提供了丰富的视图修饰符，用于定制用户与网页内容的交互方式： 滚动行为定制 scrollBounceBehavior：定制滚动弹跳行为 webViewScrollPosition：关联 WebView 的滚动位置 onScrollGeometryChange：响应滚动几何变化 123456WebView(webPage: webPage) .scrollBounceBehavior(.vertical, axes: .vertical) .webViewScrollPosition($scrollPosition) .onScrollGeometryChange &#123; geometry in // 处理滚动变化 &#125; 查找功能开发者可以使用现有的 findNavigator 修饰符为 WebView 添加查找功能： 12WebView(webPage: webPage) .findNavigator(isPresented: $isFindNavigatorPresented) VisionOS 特定功能在 visionOS 上，WebView 支持 look to scroll 功能，可以通过 webViewScrollInputBehavior 修饰符启用： 12WebView(webPage: webPage) .webViewScrollInputBehavior(.look) 总结WebKit for SwiftUI 提供了一个简单而功能强大的 API，将网页内容无缝集成到 SwiftUI 应用中。它支持： 多种网页内容加载方式 自定义 URL scheme 处理 丰富的网页交互观察能力 JavaScript 通信 灵活的滚动和查找功能定制 开发者可以参考官方文档了解更多细节，并尝试将现有应用迁移到这一新 API 上。 相关视频使用 WebGPU 解锁 GPU 计算能力空间网页的新功能Safari 浏览器和 WebKit 的新功能Swift 的新功能SwiftUI 的新功能 文档SwiftUI","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"safari-浏览器和网页","slug":"safari-浏览器和网页","permalink":"http://djs66256.github.io/tags/safari-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E9%A1%B5/"}]},{"title":"在网页上验证身份证件","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_232/","text":"了解 digital credentials 如何增强在线身份验证流程。我们将介绍网站如何整合 digital credentials api，以便请求访问“钱包”中的身份证件所包含的信息。我们还将探讨 app 如何利用新的 identitydocumentservices 框架提供 app 内的身份证件进行在线验证。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 在网页上验证身份证件：数字凭证API与IdentityDocumentServices框架详解引言在当今数字化时代，身份验证流程的便捷性与安全性成为用户体验的关键环节。传统的实体证件验证方式存在诸多不便，而基于移动证件(mdoc)格式的数字身份证件正逐渐成为解决方案。苹果在WWDC演讲中展示了如何利用数字凭证API和IdentityDocumentServices框架优化在线身份验证流程，为开发者和用户带来更高效、安全的体验。 数字身份证件的优势传统的实体证件在线验证方式要求用户拍摄证件照片上传，这种方式对用户体验和机构验证都带来挑战。相比之下，数字身份证件(mdoc)基于ISO 18013-5标准，具有三大核心优势： 跨平台互操作性：遵循国际标准确保在不同系统和平台间无缝工作 精准信息共享：用户仅需分享验证方必需的信息，而非全部证件内容 增强安全性：通过发行机构加密签名确保验证方收到的信息真实可靠 苹果钱包中的身份证件功能正是基于mdoc格式构建的实例，目前已经在美国特定机场、商户和Apple Store等场景得到应用。 Web集成：数字凭证API详解工作原理网站集成数字凭证API进行身份验证包含三个关键步骤： 请求构建：服务器生成并签署文档请求 浏览器传递：通过W3C数字凭证API将请求传递给浏览器 验证响应：服务器接收并解密加密响应 以太空船租赁网站为例，请求包含设备请求和加密信息两部分： 12345678910111213141516const request = &#123; challenge: crypto.getRandomValues(new Uint8Array(32)), documentRequest: &#123; documents: [ &#123; docType: &quot;org.iso.18013.5.1.mDL&quot;, elements: [ &quot;org.iso.18013.5.1.given_name&quot;, &quot;org.iso.18013.5.1.family_name&quot;, &quot;org.iso.18013.5.1.birth_date&quot; ] &#125; ] &#125;, encryption: &#123; scheme: &quot;HPKE&quot;, encapsulatedPublicKey: new Uint8Array([...]), recipientPublicKey: new Uint8Array([...]) &#125;&#125; 安全机制数字凭证API构建了四层安全防护体系： 请求认证：通过证书签名明确标识请求方身份 响应加密：采用HPKE标准(RFC-9180)实现端到端加密 发行方认证：验证数据签发者的可信度 mdoc认证：防止文档跨设备复制 验证过程中需执行以下关键检查： 12345678// 验证文档签名证书链verifyCertificateChain(documentSigningCertificate, trustedRoots);// 通过移动安全对象验证返回要素哈希摘要verifyMobileSecurityObject(returnedElements, mso);// 使用设备公钥验证文档来源verifyDeviceKeySignature(document, devicePublicKey); 应用集成：IdentityDocumentServices框架对于希望提供身份证件验证服务的应用开发者，苹果引入了IdentityDocumentServices框架。主要实施步骤包括： 注册扩展：通过IdentityDocumentProviderRegistrationStore注册文档类型和信任证书机构 构建UI：在扩展中创建授权界面展示请求方信息和所需要素 处理请求：验证原始请求签名并构建加密响应 提供取消选项：确保用户随时可以中止验证流程 关键创新是”部分请求”机制，该系统先验证请求签名后才向应用扩展提供部分请求用于UI构建，用户授权后才会释放完整ISO 18013设备请求，有效防范未经用户交互的原始数据解析风险。 实施建议与资源网站开发者建议 注册Apple Business Connect获取必要证书 遵循W3C数字凭证API标准实现请求流程 对接不同证件提供应用时需满足各自特定要求 应用开发者建议 实现Identity Document Provider扩展目标 深入研读ISO 18013系列相关标准文档 正确实施请求验证和响应加密机制 总结数字凭证API和IdentityDocumentServices框架为在线身份验证提供了标准化、安全的解决方案。通过采用mdoc格式和ISO标准，这些技术既提升了用户体验，又增强了安全性。随着数字身份证件的普及，这些API将为各类身份验证场景提供更灵活的解决方案。 相关资源开发者可进一步参考以下资源深入了解相关技术： 相关视频 进一步了解声明式网页推送Safari 浏览器和 WebKit 的新功能钱包与 Apple Pay 的新功能 文档资源 作为身份文档提供者实施指南在网页上请求移动文档","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"Safari 浏览器和 WebKit 的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_233/","text":"了解 safari 浏览器和 webkit 中最新的网页技术如何助你打造妙不可言的体验。我们将重点介绍不同的 css 功能及其工作原理，包括滚动驱动动画、跨文档视图转换和锚点定位。我们还将探讨针对音频、视频、图像以及图标的新增媒体支持。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Safari浏览器与WebKit新特性解析：CSS动画、布局与媒体支持2025年WWDC大会上，Safari与WebKit团队宣布了一系列令人振奋的新网页技术，涵盖动画、布局、视觉效果和媒体支持四大领域。这些创新将显著提升开发者的创作能力，同时确保卓越的用户体验。 四大技术亮点概述Safari 19和WebKit的最新更新主要聚焦于以下技术方向： 动画增强：滚动驱动动画和跨文档视图转换 布局革新：精准的锚点定位系统 视觉特效：背景裁剪扩展、新型形状函数和智能文本换行 媒体支持：SVG图标、HDR图像和扩展的媒体格式 这些技术的共同特点是减少对JavaScript的依赖，提升性能表现，同时保持对可访问性的深度考量。 动画技术的突破滚动驱动动画实现原理滚动驱动动画(Scroll-driven animations)通过引入两种新型时间轴彻底改变了CSS动画的实现方式： 滚动时间轴(scroll timeline)：将动画进度与文档滚动位置绑定 视图时间轴(view timeline)：根据元素在视口中的可见性触发动画 核心优势在于无需JavaScript即可创建复杂的滚动交互效果。典型应用包括阅读进度指示器和视差效果。 关键技术实现：123456789.progress-bar &#123; animation: progress linear; animation-timeline: scroll();&#125;@keyframes progress &#123; from &#123; width: 0%; &#125; to &#123; width: 100%; &#125;&#125; 跨文档视图转换技术跨文档视图转换(Cross-document view transitions)扩展了单页面视图转换的能力，允许在不同文档间实现平滑过渡。这项技术特别适合多页面网站的场景，只需简单CSS声明即可启用： 123@view-transition &#123; navigation: auto;&#125; 开发注意事项： 过渡效果仅限于同源页面 必须考虑用户运动偏好设置 本质上属于渐进增强特性 布局系统的革新锚点定位工作机制锚点定位(Anchor positioning)与popover API协同工作，提供了一套完整的定位解决方案。该系统包含三个核心概念： 锚点定义：通过anchor-name标识参考元素 定位策略：使用position-area或anchor()函数 响应式处理：position-try提供备用方案 典型工具提示实现：12&lt;button popovertarget=&quot;tooltip&quot; anchor=&quot;trigger&quot;&gt;悬停我&lt;/button&gt;&lt;div id=&quot;tooltip&quot; popover anchor=&quot;trigger&quot;&gt;提示内容&lt;/div&gt; 12345#tooltip &#123; position-anchor: --trigger; position-area: right; position-try: flip-inline;&#125; 视觉呈现的进化背景裁剪的边界突破新增的background-clip: border-area值允许开发者为透明边框应用背景效果，开启了创意设计的新可能： 12345.card &#123; border: 10px solid transparent; background-image: linear-gradient(45deg, #f06, #f90); background-clip: border-area;&#125; 形状函数的响应式能力shape()函数引入容器查询单位，使复杂形状能够响应容器尺寸变化： 123.fluid-shape &#123; clip-path: shape(&#x27;M0 0 L100% 0 L100% 75cqh L50% 100% L0 75cqh Z&#x27;);&#125; 智能文本排版的进步text-wrap: pretty算法自动优化文本换行，消除孤行并减少连字符使用，显著提升阅读体验： 1234article &#123; text-wrap: pretty; max-width: 65ch;&#125; 多媒体支持的扩展SVG图标的全场景支持SVG图标现已扩展至以下应用场景： 书签图标 启动页面图标 Dock图标 PWA应用图标 技术优势包括： 矢量清晰度 多分辨率适配 文件体积优化 HDR图像工作流HDR支持带来以下技术特性： 10-16位色深支持 广色域显示(P3) 动态范围自动适配 实现方案：123.hdr-image &#123; dynamic-range-limit: constrained;&#125; 媒体格式矩阵Safari 19新增支持的格式包括： 音频：Ogg Opus、Ogg Vorbis 视频：WebM(MediaRecorder API) 图像：HEIC、AVIF、JPEG XL 现有支持已达15种主流媒体格式，满足各类开发需求。 开发资源与后续规划开发者可通过以下渠道深入探索这些新技术： 官方文档：WebKit.org发布说明 测试工具：Safari Technology Preview 反馈渠道：Feedback Assistant和WebKit Bugzilla 团队将持续关注互操作性改进和隐私保护，推动Web平台向前发展。这些新特性现已逐步推出，开发者可以开始适配和测试，为用户提供更丰富、更高效的网络体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"进一步了解声明式网页推送","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_235/","text":"了解声明式网页推送如何帮助你更可靠地发送通知。了解如何借鉴现有标准实现更高效、更透明的设计，同时保证与原始网页推送的向后兼容性。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 声明式网页推送：更高效可靠的通知解决方案引言推送通知已成为现代网页和移动应用不可或缺的功能。从2009年iPhone OS 3首次引入推送通知以来，这项技术已发展成为各平台的标配功能。WebKit架构团队工程师Brady Eidson在WWDC上详细介绍了网页推送通知的最新进展——声明式网页推送（Declarative Web Push），这一创新旨在提供更高效、更透明且更可靠的通知解决方案。 原始Web Push的局限性传统的Web Push完全依赖JavaScript驱动，具体流程包括： 需要安装Service Worker处理推送事件 获取推送订阅后将信息发送到服务器 服务器使用订阅URL发送推送消息 浏览器启动Service Worker处理push事件 Service Worker调用showNotification API显示通知 用户点击通知后再次启动Service Worker处理点击事件 这种设计的灵活性虽然高，但也带来诸多问题： 性能开销：每次推送都需要运行JavaScript代码 隐私风险：网站数据可能成为用户追踪的媒介 可靠性问题：复杂代码链增加了出错概率 声明式网页推送的工作原理声明式网页推送借鉴了iOS和macOS原生推送的设计理念，通过标准化JSON格式描述通知，大幅减少了JavaScript代码的需求。其核心优势包括： 简化的订阅获取：PushManager可直接在window对象上使用，无需先安装Service Worker 自动化的通知处理：浏览器直接解析JSON格式的推送消息并自动显示通知 渐进式增强：与现有Web Push标准保持兼容 声明式JSON格式详解有效的声明式推送消息必须包含： 12345678910&#123; &quot;web_push&quot;: &quot;8-0-3-0&quot;, &quot;notification&quot;: &#123; &quot;title&quot;: &quot;通知标题&quot;, &quot;body&quot;: &quot;通知内容&quot;, &quot;data&quot;: &#123; &quot;url&quot;: &quot;https://example.com&quot; &#125; &#125;&#125; 其中web_push: &quot;8-0-3-0&quot;是识别声明式推送的”魔法键”。该格式支持完整的NotificationOptions选项，包括： 标题和正文文本 通知标签 默认提示音 应用徽章更新 点击导航URL 高级功能：可变通知处理对于需要客户端处理的特殊场景（如端到端加密消息），声明式推送支持mutable: true标记： 123456789101112&#123; &quot;web_push&quot;: &quot;8-0-3-0&quot;, &quot;notification&quot;: &#123; &quot;title&quot;: &quot;加密消息&quot;, &quot;body&quot;: &quot;需要解密的内容&quot;, &quot;data&quot;: &#123; &quot;encrypted&quot;: true, &quot;payload&quot;: &quot;...&quot; &#125; &#125;, &quot;mutable&quot;: true&#125; 当Service Worker接收到这类推送时，可以解密内容并替换原始通知： 123456789101112self.addEventListener(&#x27;push&#x27;, event =&gt; &#123; if (event.data.json().mutable) &#123; const original = event.data.json().notification; const decrypted = decryptMessage(original.body); event.waitUntil( self.registration.showNotification(decrypted.title, &#123; body: decrypted.content, data: &#123; url: original.data.url &#125; &#125;) ); &#125;&#125;); 向后兼容性设计声明式网页推送完美兼容现有Web Push系统： 不支持声明式的浏览器会回退到原始Web Push处理流程 已使用原始Web Push的网站可以逐步迁移 JSON格式可以同时满足新旧两种处理方式 迁移步骤建议： 重构推送消息为声明式标准格式 简化Service Worker代码仅处理必要逻辑 逐步添加声明式特定功能 可用性与资源声明式网页推送已在以下版本中提供支持： macOS Safari 18.5+ iOS 18.4+ iPadOS 18.4+ 开发者可以利用相关资源进一步学习： 在网页上验证身份证件 Safari浏览器和WebKit的新功能 Safari浏览器网页推送功能简介 结论声明式网页推送代表了Web通知技术的重大进步，它结合了原生推送的高效性和Web的开放性。通过减少JavaScript依赖、标准化消息格式和保持向后兼容，它为开发者提供了更可靠的解决方案，同时为用户带来更好的隐私保护和性能体验。无论是新建项目还是现有系统迁移，现在都是采用声明式推送的理想时机。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"safari-浏览器和网页","slug":"safari-浏览器和网页","permalink":"http://djs66256.github.io/tags/safari-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E9%A1%B5/"}]},{"title":"使用 WebGPU 解锁 GPU 计算能力","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_236/","text":"了解 webgpu api 如何为图形和通用计算提供安全访问 gpu 设备的权限。我们还将探讨用来编写 gpu 程序的 wgsl 着色语言。此外，我们将深入探索在台式机和移动设备上实现最优性能同时尽可能降低能耗的最佳实践。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com WebGPU：解锁网页GPU计算与图形新纪元在WWDC技术分享中，Safari团队工程师Mike详细介绍了WebGPU这一革命性技术，它为网页开发者提供了安全访问GPU设备的全新方式，不仅能够实现高性能图形渲染，还能进行通用GPU计算。 WebGPU技术概览WebGPU作为WebGL的继任者，在3D图形领域实现了全面超越，具备更高性能和更强灵活性。值得注意的是，WebGPU目前是唯一能在浏览器中直接运行通用GPU计算的解决方案。其API设计与苹果Metal框架高度相似，在Mac、iPhone、iPad和Vision Pro等支持Metal的平台上都能完美运行。 WebGPU的跨平台特性使其成为网页图形处理的理想选择。开发者可以直接使用WebGPU API，也可以借助threeJS等图形库来享受WebGPU带来的性能优势。一个典型的案例是实时渲染的3D水母动画，在Safari中展现出流畅的视觉效果。 WebGPU API架构解析WebGPU的图形管线可以分为几个关键阶段：内容加载、WebKit预处理、Metal资源创建和GPU硬件执行。在这个过程中，WebGPU通过Metal生成三类核心资源： 缓冲区(buffers)：存储各类数据 纹理(textures)：处理图像数据 采样器(samplers)：控制纹理采样方式 这些资源被组织为GPU绑定组，底层实现则通过Metal的参数缓冲区完成。WebGPU程序由代码字符串编译而来，分为三种类型： 计算程序(compute) 顶点程序(vertex) 片段程序(fragment) WebGPU API采用扁平化设计，主要接口包括： GPU和GPU适配器接口 GPUCanvasContext（与Canvas配合使用） GPUDevice（API主要入口） 这些接口可以简化为五大类： 资源类（纹理、缓冲区、采样器） 编码器（操作资源） 管线（指导资源使用） 绑定组（资源分组关联） 着色器模块（GPU计算指令） 实践WebGPU开发创建基本的WebGPU应用需要经历几个关键步骤： 123456789// 创建GPUDevice并配置GPUCanvasContextconst canvas = document.querySelector(&#x27;canvas&#x27;);const adapter = await navigator.gpu.requestAdapter();const f16Supported = adapter?.features.has(&#x27;shader-f16&#x27;);const device = await adapter?.requestDevice( requiredFeatures: f16Supported ? [&#x27;shader-f16&#x27;] : []);const context = canvas.getContext(&#x27;webgpu&#x27;);context.configure(&#123; device, format, alphaMode &#125;); 这段代码展示了如何初始化WebGPU环境。值得注意的是，WebGPU支持shader-f16等扩展功能，能够使用半精度浮点数来提升性能并降低内存占用。 创建资源方面，WebGPU提供了灵活的缓冲区和纹理系统。缓冲区能够存储各种数据类型，而纹理则专门处理图像数据： 123456789101112// 创建缓冲区示例device.createBuffer(&#123; size: bufferSize, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST&#125;);// 创建纹理示例device.createTexture(&#123; size: [image.width, image.height], format: &#x27;rgba8unorm&#x27;, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST&#125;); WGSL着色语言详解WebGPU采用WGSL(WebGPU Shading Language)作为着色语言，这种语言专为网页安全设计，支持三类程序： 顶点程序：处理几何体位置计算 片段程序：计算像素颜色和深度 计算程序：执行通用GPU计算 计算着色器是WebGPU独有的强大功能，能够进行物理模拟等复杂计算，这是WebGL无法实现的。计算程序需要定义工作组尺寸(workgroup size)，并使用global_invocation_id等内置变量。 性能优化关键策略在苹果平台上优化WebGPU性能需要注意几个关键点： 内存管理：使用半精度浮点数(f16)可以显著降低内存占用。在iOS和visionOS上，数据压缩格式也能有效避免内存问题。 1234// 启用f16示例const device = await adapter?.requestDevice( requiredFeatures: [&#x27;shader-f16&#x27;]); 命令复用：使用渲染包(render bundles)可以避免重复验证，只需编码一次命令即可多次执行。 资源精简：尽量减少命令缓冲区、渲染/计算通道、绑定组的数量。动态偏移技术可以帮助减少绑定组的创建。 WebGPU为网页带来了前所未有的GPU计算能力，开发者现在可以在网页上实现以往需要原生应用才能完成的高性能计算和图形渲染。随着WebGPU的普及，网页应用的性能边界将被重新定义。 相关资源开发者可以通过以下资源深入了解WebGPU： 相关视频： 了解适用于 SwiftUI 的 WebKit Safari 浏览器和 WebKit 的新功能 为 Apple 芯片 Mac 优化 Metal 性能 使用Metal技术驾驭Apple图形处理器 文档： Metal Performance Shaders Transformers.js - Huggingface WebGPU - W3C WebGPU Samples - github.io","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"StoreKit 和 App 内购买项目的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_241/","text":"了解最新的 storekit api 增强功能，它们有助于你为顾客提供出色的 app 内购买项目体验。我们将介绍 apptransaction、transaction 和 renewalinfo 中新增的字段，以及针对 app 内购买项目优惠代码所做的更新。我们还将介绍如何使用 app store server library 创建已签名的 app 内购买项目请求，以及如何使用 swiftui 来更新陈列订阅项。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com StoreKit 与应用内购买新特性解析苹果在最新的 WWDC 上公布了多项 StoreKit 与应用内购买的更新，这些改进将帮助开发者更好地管理应用内购买体验。本文将详细介绍这些新功能及其实现方式。 核心框架更新StoreKit 框架中的三个关键类型获得了重要升级，为开发者提供了更丰富的购买信息和管理能力。 AppTransaction 增强AppTransaction 类型现在包含两个新字段： appTransactionID: 这是一个全局唯一标识符，从 iOS 18.4 开始可用(支持回溯至 iOS 15)，每个下载应用的 Apple ID 账户都会获得独立 ID originalPlatform: 表示用户原始购买设备的平台类型(AppStore.Platform)，包括 iOS、macOS、tvOS 和 visionOS 这些字段特别适用于商业模式变更的场景，例如从付费应用转为含内购的免费应用时识别老用户权益。 Transaction 改进Transaction 类型代表了成功的应用内购买，iOS 18.4 带来以下变化： 废弃了 Transaction.currentEntitlement for productID API，改用新的 Transaction.currentEntitlements API 新增三个字段：appTransactionID、Offer Period(关联订阅周期)和 advancedCommerceInfo(仅适用于高级商务 API 用户) RenewalInfo 扩展RenewalInfo 类型专用于管理自动续订订阅，新增内容包括： 通过 Transaction ID 查询订阅状态的新 API 四个新字段：appTransactionID、Offer Period、advancedCommerceInfo 和 appAccountToken(用于关联开发者服务中的用户账户) 优惠码功能扩展优惠码支持范围得到了显著扩大： 现已支持消耗型商品、非消耗型商品和非续订订阅的兑换(回溯至 iOS 16.3) 自动续订订阅的优惠码支持可回溯至 iOS 14.2 新增 Transaction.Offer.PaymentMode 类型来区分不同优惠的支付模式 请求签名新方法从 iOS 18.2 开始，StoreKit 引入了需要 UI 上下文的购买方法。不同平台需要提供不同的上下文对象： iOS/macCatalyst/tvOS/visionOS：需要提供 UIViewController macOS：需要提供 NSWindow watchOS：不需要提供上下文 在 SwiftUI 视图中，可以通过 purchase 环境值获取 PurchaseAction 实例 SwiftUI 订阅展示新推出的 SubscriptionOfferView 是 StoreKit 视图家族的新成员，专门用于展示自动续订订阅选项。开发者可以通过五种关系类型配置展示逻辑： 1234567891011121314// 升级选项展示SubscriptionOfferView(relation: .upgrade)// 降级选项展示 SubscriptionOfferView(relation: .downgrade)// 同级最佳选项展示SubscriptionOfferView(relation: .crossgrade)// 当前方案展示(需配合优惠码)SubscriptionOfferView(relation: .current) // 展示组内全部方案SubscriptionOfferView(relation: .all) 总结与最佳实践这些 StoreKit 的增强功能为开发者提供了更强大的工具来构建优质的应用内购买体验。苹果建议开发者： 全面采用 StoreKit 2 API 利用 StoreKit 视图构建应用商店界面 集成 App Store Server Library 简化请求签名流程 通过合理运用这些新特性，开发者可以更高效地管理应用内购买流程，为用户提供更流畅的购买体验。 相关视频和文档请参考以下资源。 相关视频App Store Connect 的新功能探索适用于 App 内购买项目的 App Store Server API认识 StoreKit 与 SwiftUI认识 StoreKit 2 文档Advanced Commerce APIHuman Interface Guidelines: In-app purchaseSet up offer codesSimplifying your implementation by using the App Store Server LibraryStoreKit","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"深入探索适用于 App 内购买项目的 App Store Server API","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_249/","text":"了解 app store server api、app store 服务器通知以及 app store server 资源库如何帮助你直接在服务器上管理顾客购买数据，并提供卓越的 app 内购买项目体验。我们将介绍 appaccounttoken 和签名流程的最新更新、签名交易和续订信息的新字段，以及一些全新 api。然后，我们将展示如何在服务器上生成促销优惠签名，以及如何使用 send consumption information 端点。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com App 内购买项目的 App Store 服务器 API 深度解析引言每年 WWDC 都为我们带来 Apple 生态系统中各类技术的更新与改进。在 2025 年的 WWDC 上，App Store 服务器团队展示了关于 App 内购买项目 API 的一系列重要更新。这些改进将帮助开发者更高效地管理应用内购买，优化服务器端流程，并提升用户体验。 核心职责概述应用服务器在 App 内购买生态系统中扮演着关键角色，主要有三大核心职责： 管理 App 内购买项目：包括将交易数据与客户账户关联，确保应用能够无缝提供内容和服务。 签名请求：生成签名以授权服务器向 App Store 发起的请求。 参与退款决策流程：通过分享消费数据帮助 App Store 做出明智的退款决策。 管理 App 内购买项目客户账户关联有效处理客户账户是管理 App 内购买项目的首要任务。开发者通常会在系统中为每个客户分配唯一的账户 ID，从而在其账户与 App Store 交易之间建立明确关联。这种关联对于提供正确内容或个性化用户体验至关重要。 数据结构解析App Store 通过三种关键数据结构提供 App 内购买数据： AppTransaction：包含应用级别的交易信息 JWSTransaction：代表已签名的交易对象 JWSRenewalInfo：包含订阅续订相关信息 其中，JWSTransaction 是处理单个购买的核心数据结构。当客户完成 App 内购买时，App Store 会提供已签名的交易对象，服务器端可以使用 App Store 服务器库对其进行验证和解码。 JWSTransaction 字段解析解码后的 signedTransactionInfo 包含以下重要信息： 基础信息： 应用相关信息 App 内产品类型 购买元数据： 购买数量 价格信息 货币类型 优惠信息（如果客户兑换了优惠）： offerType：优惠类型 offerIdentifier：优惠标识符 offerDiscountType：优惠折扣类型 新增字段： offerPeriod：采用 ISO 8601 持续时间格式表示兑换优惠的有效期（该字段也存在于 JWSRenewalInfo 中） 交易标识符： transactionId：交易的唯一标识符，适用于 App 内购买、恢复或订阅续订 相关资源视频资源StoreKit 和 App 内购买项目的新功能探索适用于 App 内购买项目的 App Store Server API 文档资源高级商业 APIApp Store 服务器 APIApp Store 服务器通知设置应用账户令牌使用 App Store 服务器库简化实现提交反馈 总结本次 WWDC 介绍的 App Store 服务器 API 更新为开发者提供了更强大的工具来管理应用内购买。通过优化交易标识符、简化签名流程以及增强退款决策参与机制，开发者将能够构建更加可靠和高效的应用内购买系统。建议开发者仔细研究相关文档和视频资源，充分利用这些新特性来提升用户体验和业务运营效率。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用“App 分析”优化盈利策略","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_252/","text":"探索“app 分析”中新推出的盈利、订阅和优惠分析指标。我们将介绍强大的新数据可视化功能和自动报告如何帮助你做出基于数据的决策，从而推动收入增长。我们还将探讨如何将这些指标与自定产品页面等用户获取功能相结合，以优化并改进你的盈利策略。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 利用“App 分析”优化盈利策略：WWDC 2025 深度解析引言在应用生态中，数据驱动的决策已成为提升盈利表现的关键。苹果在 WWDC 2025 上宣布了 App Analytics 的一系列创新功能，旨在帮助开发者更精准地衡量和优化应用盈利策略。这些新工具涵盖了付费用户分析、订阅表现追踪、促销活动效果评估等多个维度，为开发者提供了前所未有的洞察力。 全新入口与增强筛选功能App Analytics 现已迁移至 Apps 标签页下的专属入口，使数据分析与应用管理更紧密地结合。新版界面经过重新设计，将关键板块整合至侧边栏，提升了浏览效率。 其中最具突破性的改进是扩展筛选功能，开发者现在可以为任何指标添加多达七个不同的筛选条件，每个条件还支持多选操作。例如，开发者可以同时分析特定地区、设备型号和操作系统版本组合下，不同自定产品页面的转化率表现。 1234567// 示例：多条件筛选分析let filters = [ &quot;region&quot;: [&quot;US&quot;, &quot;CA&quot;], &quot;device&quot;: [&quot;iPhone&quot;, &quot;iPad&quot;], &quot;osVersion&quot;: &quot;iOS 18&quot;, &quot;sourceType&quot;: [&quot;App Store Search&quot;, &quot;App Referral&quot;]] 付费用户指标与基准数据新引入的 Monetization 板块为应用收入分析提供了全面视角。其中两项关键群体指标尤为值得关注： 下载到付费转化率：追踪新用户的购买速度 平均每下载收入：衡量用户全生命周期价值 与以往不同的是，这些指标现在都配备了同类应用基准数据，开发者可以直观了解自身表现所处的百分位区间。例如，某健身应用35天后3%的转化率处于第25-50百分位之间，表明还有提升空间。 通过全新的 Cohorts Analysis 页面，开发者能够深入分析不同用户群体的行为差异。数据显示，尽管跑步者的初期转化率低于平均水平，但一旦订阅，他们的留存表现反而优于其他用户群体。 订阅分析深度洞察针对订阅模式的应用，App Analytics 新增了专门的 Subscriptions 板块，提供50多项精细指标，分为两大类： 状态指标：特定时间点的订阅业务快照 事件指标：方案状态间的流转情况 订阅留存率分析揭示了一个有趣现象：从”跑步”主题页面进入的用户虽然初期转化率较低，但6个月后的留存率高达73%，远超平均水平。这种洞察帮助开发者精准定位用户漏斗中的薄弱环节。 促销活动效果追踪新推出的 Offers 板块让开发者能够量化评估促销活动的真实效果。数据显示，采用”一个月免费试用”策略后，跑步者群体的付费转化率显著提升： 67%的试用用户转化为全价订阅 78%的用户在三个月后仍保持订阅 73%的用户在六个月后继续订阅 这些指标证实了促销活动在用户获取和留存方面的双重价值。 数据分析报告扩展从2025年6月起，Analytics Reports API将新增两份订阅分析报告： 订阅状态报告：提供订阅业务的全景视图 订阅事件报告：追踪订阅状态的变化轨迹 这些报告以隐私保护的方式关联下载与订阅数据，支持开发者进行大规模的离线分析。 结语WWDC 2025带来的App Analytics革新为开发者提供了全方位的盈利策略优化工具。从精准的群体分析到客观的基准对比，从订阅深度洞察到促销效果追踪，这些功能共同构成了一个完整的数据分析生态系统。开发者现在能够基于可靠数据，针对不同用户群体制定差异化的盈利策略，最终实现收入的最大化。 相关视频App Store Connect 的新功能StoreKit 和 App 内购买项目的新功能探索”App 分析”中的基准App Analytics 中的新功能 文档Analytics Reports通过 Analytics 获取洞察在应用中实施 introductory offer衡量应用表现StoreKit针对同类基准采取行动","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"深入了解写作工具","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_265/","text":"借助写作工具，用户可以直接在你的 app 内进行文本校对、改写和转换。了解为你的 app 自定写作工具的高级技巧。探索众多格式选项，以及如何在富文本编辑中加以利用。如果你使用自定文本引擎，欢迎了解如何无缝整合完整的写作工具体验，以便用户直接在文本视图中进行修改。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深入探索写作工具：从原生集成到自定义文本引擎的高级应用引言在WWDC 2024的”深入探索写作工具”课程中，Apple详细介绍了写作工具的高级集成方案。作为文本输入和国际化研发专家，董源系统性地展示了写作工具的最新功能、原生文本视图定制技巧、富文本格式支持方案，以及针对完全自定义文本引擎的完整集成方案。这些技术将帮助开发者在其应用中实现更智能的文本处理能力。 新功能概览写作工具的最新迭代带来了多项重要更新。首先是通过ChatGPT集成实现的指令式内容生成功能，用户现在可以使用简单指令创建各类文本内容甚至生成图像。这套工具已全面支持visionOS平台，覆盖邮件、备忘录及第三方应用等多种场景。 iOS/iPadOS/macOS 26版本中新增的”后续调整”功能尤为亮眼，它允许用户在完成初始文本改写后追加风格要求，如”更温暖”、”更口语化”或”更鼓舞人心”等。写作工具现已无缝集成快捷指令功能，借助Apple Intelligence实现自动化的校对、改写和摘要流程。 在API层面，开发者现在可以获取标准工具栏按钮、支持富文本的表达意图返回，以及全新的协调器API。特别是专为自定义文本引擎设计的协调器API，为高级集成提供了强大支持。 原生文本视图的深度定制对于采用系统原生文本视图的开发者，写作工具提供了开箱即用的支持。通过精心设计的生命周期方法，应用可以响应写作工具的各种操作，如同步暂停事件。开发者可以灵活配置功能范围，设置禁止改写的文本区间，或使用重命名后的”Writing Tools Result Options”管理富文本、列表和表格支持。 尽管文本选中时会自动启用写作工具，但对于文字密集型应用（如备忘录和邮件），建议主动添加工具栏按钮以提升用户体验。UIKit中使用UIBarButtonItem，AppKit则使用NSToolbarItem。系统会自动在上下文菜单中插入写作工具项，若需自定义菜单布局，可将automaticallyInsertsWritingToolsItems设为false，并通过writingToolsItems API获取标准菜单项。 富文本格式的高级处理方案现实应用中的文本视图类型多样，从Finder搜索框等纯文本视图，到TextEdit等支持基础富文本的视图，再到备忘录等支持语义化样式（标题、副标题、引用块等）的高级视图。写作工具通过结果选项声明文本视图的处理能力： 纯文本视图使用.plainText选项 基础富文本视图使用.richText选项（可选配.list和.table） 支持语义化格式的应用需使用新增的.presentationIntent选项 值得注意的是，即使在表达意图模式下，写作工具仍可能添加某些显示属性（如删除线），因为部分样式无法通过意图完全表达。开发者应重写textView的requestContexts方法，尽可能提供含表达意图的上下文以增强语义理解。 自定义文本引擎的完整集成方案对于采用完全自定义文本引擎的应用，Apple提供了完整的写作工具集成路径。基础支持只需实现通用文本编辑协议，而通过新增的WritingToolsCoordinator API可获得原地改写、动画效果和行内校对标记等高级功能。 具体实施分为几个关键步骤：首先在DocumentView中添加会话所需属性，然后初始化NSWritingToolsCoordinator并设置委托关联视图。核心委托方法包括文本上下文提供、替换操作处理、动画预览生成以及校对标记边界返回等。 UIKit中通过UIInteraction机制附加协调器：12345func configureWritingTools() &#123; guard UIWritingToolsCoordinator.isWritingToolsAvailable else &#123; return &#125; let coordinator = UIWritingToolsCoordinator(delegate: self) addInteraction(coordinator)&#125; AppKit中则作为视图属性配置：1234567func configureWritingTools() &#123; guard NSWritingToolsCoordinator.isWritingToolsAvailable else &#123; return &#125; let coordinator = NSWritingToolsCoordinator(delegate: self) coordinator.preferredBehavior = .complete coordinator.preferredResultOptions = [.richText, .list] writingToolsCoordinator = coordinator&#125; 开发者需特别注意外部文本变更时的同步处理，主动调用协调器的updateRange:withText方法保持状态一致，布局变化时则调用updateForReflowedText请求新预览。 结语与行动建议写作工具的强大功能为应用文本处理带来了质的飞跃。开发者应当立即体验Vision Pro的写作工具、快捷指令集成和改写后调整功能。对于文字密集型应用，建议添加专用工具栏按钮；支持富文本的应用应尝试格式选项实现语义样式；而拥有自定义文本引擎的应用则可通过协调器API获得完整功能。 Apple已发布包含TextKit 2示例的演示项目，结合《写作工具入门》课程和官方文档，开发者可以快速掌握这些高级集成技术，为用户提供更智能、更流畅的文本编辑体验。 相关视频开始使用 Writing Tools 文档Writing Tools","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"小组件的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_278/","text":"widgetkit 带来小组件、实时活动以及控制方面的众多更新，助你提升 app 性能。了解如何将小组件引入 visionos，如何利用 carplay 车载让小组件在驾驶途中也能顺畅使用，以及如何使用强调渲染模式优化小组件的视觉效果。此外，探索如何让相关小组件呈现在 watchos 的智能叠放中，以及如何使用推送通知确保小组件保持最新。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 小组件新特性全面解析：WidgetKit 的跨平台进化引言WidgetKit 作为苹果生态系统中的重要组件，在 WWDC 2024 上迎来了一系列令人振奋的更新。这些改进不仅增强了小组件的功能性，更将其应用场景扩展到了 visionOS、CarPlay 车载等新平台。系统体验团队工程师 Tanner Oakes 以咖啡因记录应用为例，详细展示了如何充分利用这些新特性提升用户体验。 一、传统平台的小组件视觉升级在 iOS 26 和 macOS Tahoe 中，小组件迎来了全新的视觉呈现方式。用户可将主屏幕配置为透明玻璃效果来展示图标和小组件，并选择特定色调进行深度自定义。这种新呈现方式采用了强调渲染模式技术，该技术会先生成白色调内容，再移除背景替换为符合主题的玻璃或着色效果。 开发者在适配过程中需要注意，像咖啡因追踪这样显示最常饮用饮料的小组件，在强调模式下可能会出现图像辨认困难的问题。解决方案是观察 .widgetRenderingMode 并添加条件渲染逻辑，使用 .widgetAccentedRenderingMode 修饰符提供的五种图像处理选项（包括去饱和、强调色等）来优化显示效果。 123// 强调渲染模式的优化实现示例Image(&quot;coffee-cup&quot;) .widgetAccentedRenderingMode(.selectiveColor) 二、visionOS 的小组件革命visionOS 26 的重大突破在于允许应用包含小组件，这标志着小组件正式进入空间计算领域。兼容 iPhone/iPad 的小组件可以自动移植到 visionOS，并支持交互和动画功能。用户可以将小组件添加到空间环境中，选择悬浮或嵌入式两种呈现方式。 开发者为 visionOS 适配小组件时，可通过 .supportedMountingStyles 和 .widgetTexture 修饰符配置悬挂样式和材质（如纸质纹理）。新引入的 systemExtraLargePortrait 系列完善了海报风格的视觉效果，而 LevelOfDetail API 则能根据观看距离自动调整内容密度，确保远距离观看时的可读性。 1234// visionOS 小组件配置示例WidgetConfiguration() .supportedMountingStyles([.floating, .embedded]) .widgetTexture(.paper) 三、CarPlay 车载与 watchOS 的新整合CarPlay 车载现在支持显示小组件和实时活动，这对驾驶场景下的应用体验提升显著。小组件显示在仪表板左侧的堆叠中，采用 StandBy 样式以确保清晰度。实时活动默认显示灵动岛视图，但开发者可以通过配置 .supplementalActivityFamilies 和 .activityFamily 来优化显示效果。 watchOS 26 引入了关联性小组件（Relevance Widgets）这一创新概念，它们仅在相关内容出现时才会显示在智能堆叠中。通过 RelevanceConfiguration 和 RelevanceEntriesProvider 的实现，可以创建根据时间区间等条件动态显示的小组件。 12345// 关联性小组件配置示例RelevanceConfiguration( provider: CoffeeDealsProvider(), placeholder: Text(&quot;No current offers&quot;)) 四、全面的更新机制为确保跨设备数据同步，WidgetKit 提供了三种互补的更新机制： 定时重新加载：适合定期更新内容 App 主动触发：通过 WidgetCenter API 实现 服务器推送通知：针对外部数据变更 实现推送通知需要创建符合 WidgetPushHandler 的类型，并在小组件配置中添加 .pushHandler 修饰符。值得注意的是，系统会对推送更新实施预算管理以保障性能，开发期间可使用 WidgetKit 开发者模式暂时忽略这一限制。 123456// 推送通知处理示例struct CoffeeWidgetPushHandler: WidgetPushHandler &#123; func handle(_ notification: UNNotification) async &#123; // 处理推送内容 &#125;&#125; 结论与最佳实践WidgetKit 的这些新特性为开发者提供了更广阔的创新空间和更丰富的交互可能性。从 visionOS 的空间体验到 CarPlay 的车载整合，从 watchOS 的智能堆叠到跨平台推送更新，每个改进都值得开发者深入研究。 建议开发者根据具体场景组合使用不同的更新机制：紧急通知采用用户通知，限时更新使用实时活动，保持最新状态则选择推送更新。同时，充分利用新的视觉渲染模式和平台特定特性，为用户创造更自然、更智能的小组件体验。 相关资源建议观看以下视频深入了解： CarPlay 车载优化 visionOS 小组件设计 watchOS 26 新功能 实时活动设计 系统级控制扩展 推送通知专题 文档资源包括： 智能堆叠可见性优化 强调渲染模式指南 RelevanceKit 文档 推送通知实现 visionOS 适配指南","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"跟着视频学编程：使用 SwiftUI 和 AttributedString 精心打造富文本体验","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_280/","text":"了解如何使用 swiftui 的 texteditor api 和 attributedstring 构建富文本体验。探索如何启用富文本编辑功能、构建用来操控编辑器内容的自定控件，并对提供的众多格式选项进行自定。了解 attributedstring 的高级功能，以便精心打造超棒的文本编辑体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 SwiftUI 和 AttributedString 构建精美富文本编辑器在 WWDC 的技术演讲中，SwiftUI 团队的 Max 和 Swift 标准库团队的 Jeremy 共同介绍了如何利用 SwiftUI 的 TextEditor API 和 AttributedString 创建功能丰富的富文本编辑器。以下是本次演讲的技术要点解析。 从纯文本到富文本编辑器基础 TextEditor 实现纯文本编辑器可以通过 SwiftUI 的 TextEditor API 轻松实现： 123456789import SwiftUIstruct RecipeEditor: View &#123; @Binding var text: String var body: some View &#123; TextEditor(text: $text) &#125;&#125; 这种实现仅支持基本的字符串编辑功能，适用于简单的文本输入场景。 升级为富文本支持将 String 替换为 AttributedString 即可实现富文本支持： 123456789import SwiftUIstruct RecipeEditor: View &#123; @Binding var text: AttributedString var body: some View &#123; TextEditor(text: $text) &#125;&#125; 升级后的编辑器支持以下丰富的文本格式功能： 基本样式：加粗、斜体、下划线、删除线 字体调整：自定义字体、字号 颜色设置：前景色、背景色 排版细节：字距调整、基线偏移 特殊内容：Genmoji 段落样式：行高、对齐方式、书写方向 特别值得注意的是，这些属性与 SwiftUI 的非可编辑 Text 视图完全兼容，可以实现无缝的内容展示转换。 编辑器功能扩展选区处理与自定义控件在实际应用中，开发者常需要处理文本选区并添加自定义功能。演讲中展示了如何实现通过选中文本一键添加配料的功能： 123456789101112131415161718import SwiftUIstruct RecipeEditor: View &#123; @Binding var text: AttributedString @State private var selection = AttributedTextSelection() var body: some View &#123; TextEditor(text: $text, selection: $selection) .preference(key: NewIngredientPreferenceKey.self, value: newIngredientSuggestion) &#125; private var newIngredientSuggestion: IngredientSuggestion &#123; let name = text[selection] return IngredientSuggestion( suggestedName: AttributedString(name)) &#125;&#125; 关键技术点： 使用 AttributedTextSelection 处理文本选区 通过选区下标直接获取选定内容 结合 PreferenceKey 实现自定义功能 文本格式的精细控制演讲还介绍了如何通过 AttributedTextFormattingDefinition 协议定制编辑器支持的属性范围： 1234567891011struct RecipeFormattingDefinition: AttributedTextFormattingDefinition &#123; struct Scope: AttributeScope &#123; let foregroundColor: AttributeScopes.SwiftUIAttributes.ForegroundColorAttribute let adaptiveImageGlyph: AttributeScopes.SwiftUIAttributes.AdaptiveImageGlyphAttribute let ingredient: IngredientAttribute &#125; var body: some AttributedTextFormattingDefinition&lt;Scope&gt; &#123; // 具体实现 &#125;&#125; 开发者可以添加约束条件来确保特定的格式规则，例如强制配料名称显示为绿色： 123456789101112struct IngredientsAreGreen: AttributedTextValueConstraint &#123; typealias Scope = RecipeFormattingDefinition.Scope typealias AttributeKey = AttributeScopes.SwiftUIAttributes.ForegroundColorAttribute func constrain(_ container: inout Attributes) &#123; if container.ingredient != nil &#123; container.foregroundColor = .green &#125; else &#123; container.foregroundColor = nil &#125; &#125;&#125; 高级属性控制通过 AttributedStringKey 协议可以对属性行为进行精细控制： 12345678struct IngredientAttribute: CodableAttributedStringKey &#123; typealias Value = Ingredient.ID static let name = &quot;SampleRecipeEditor.IngredientAttribute&quot; static let inheritedByAddedText: Bool = false // 新增文本不继承属性 static let invalidationConditions: Set&lt;AttributedString.AttributeInvalidationCondition&gt;? = [.textChanged] // 文本变化时失效&#125; 这些控制选项让开发者能够： 决定属性是否会被新增文本继承 设置属性失效条件 实现更复杂的文本交互行为 总结与资源SwiftUI 的 TextEditor 配合 AttributedString 提供了强大的富文本编辑能力，开发者可以在此基础上： 构建自定义控件增强编辑体验 实施精细的格式控制规则 创建独特的文本交互模式 AttributedString 作为 Swift 开源项目的一部分，欢迎开发者通过 GitHub 参与贡献或在 Swift 论坛交流经验。 相关视频提升 App 的多语言体验向左语言Foundation 中的新功能 文档参考AttributedTextFormattingAttributedTextSelectionCharacter","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"}]},{"title":"了解 PaperKit","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_285/","text":"了解如何将 paperkit 引入你的 ios、ipados、macos 以及 visionos app。我们将介绍如何将 pencilkit 绘画与标记功能 (如形状和图像) 无缝整合，以及如何自定用户界面。了解向前兼容性的最佳实践，并探索高级自定选项，以便为你的 app 打造真正与众不同的标记体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 了解 PaperKit：苹果全系统标注框架解析在今年的 WWDC 上，苹果推出了一个强大的新框架——PaperKit，它为 iOS、iPadOS、macOS 和 visionOS 应用提供了统一的标注体验。本文将详细介绍 PaperKit 的核心功能、集成方法以及自定义选项。 PaperKit 简介PaperKit 是支撑苹果全系统标注体验的基础框架，被广泛应用于备忘录、屏幕截图、快速查看和日记等原生应用中。作为一个多功能画布框架，它允许开发者轻松地在应用中添加丰富的标注功能，包括： PencilKit 绘画功能 各种标注元素（形状、图像、文本框等） 绘画与标注元素的组合交互 跨平台一致体验（包括最新的 macOS Tahoe） 核心组件PaperKit 包含三个主要组件： PaperMarkupViewController：交互式创建和展示标注内容的控制器 PaperMarkup：数据模型容器，负责保存/加载标注数据和渲染 插入菜单： iOS/iPadOS/visionOS：MarkupEditViewController macOS：MarkupToolbarViewController（新工具栏） 快速集成iOS 平台集成在 iOS 应用中集成 PaperKit 只需几个简单步骤： 123456789101112131415161718override func viewDidLoad() &#123; super.viewDidLoad() let markupModel = PaperMarkup(bounds: view.bounds) let paperViewController = PaperMarkupViewController(markup: markupModel, supportedFeatureSet: .latest) view.addSubview(paperViewController.view) addChild(paperViewController) paperViewController.didMove(toParent: self) becomeFirstResponder() let toolPicker = PKToolPicker() toolPicker.addObserver(paperViewController) pencilKitResponderState.activeToolPicker = toolPicker pencilKitResponderState.toolPickerVisibility = .visible toolPicker.accessoryItem = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(plusButtonPressed(_:)))&#125; macOS 平台集成macOS 上的集成方式类似，但提供了专门的工具栏选项： 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() let markupModel = PaperMarkup(bounds: view.bounds) let paperViewController = PaperMarkupViewController(markup: markupModel, supportedFeatureSet: .latest) view.addSubview(paperViewController.view) addChild(paperViewController) let toolbarViewController = MarkupToolbarViewController(supportedFeatureSet: .latest) toolbarViewController.delegate = paperViewController view.addSubview(toolbarViewController.view) setupLayoutConstraints()&#125; 高级功能与最佳实践自动保存机制PaperKit 提供了方便的代理方法来处理标注内容的自动保存： 1234567func paperMarkupViewControllerDidChangeMarkup(_ paperMarkupViewController: PaperMarkupViewController) &#123; let markupModel = paperMarkupViewController.markup Task &#123; let data = try await markupModel.dataRepresentation() try data.write(toFile: paperKitDataURL) &#125;&#125; 向前兼容性处理对于版本兼容性问题，建议显示预渲染缩略图： 12345678910func updateThumbnail(_ markupModel: PaperMarkup) async throws &#123; let thumbnailSize = CGSize(width: 200, height: 200) let context = makeCGContext(size: thumbnailSize) context.setFillColor(gray: 1, alpha: 1) context.fill(renderer.format.bounds) await markupModel.draw(in: context, frame: CGRect(origin: .zero, size: thumbnailSize)) thumbnail = context.makeImage()&#125; 自定义功能集PaperKit 允许开发者通过 FeatureSet 自定义可用的标注功能： 12345678910var featureSet: FeatureSet = .latestfeatureSet.remove(.text)featureSet.insert(.stickers)// HDR 支持featureSet.colorMaximumLinearExposure = 4toolPicker.colorMaximumLinearExposure = 4let paperViewController = PaperMarkupViewController(supportedFeatureSet: featureSet) 自定义背景开发者可以设置任意 UIView 作为标注背景： 123let template = UIImage(named: &quot;MyTemplate.jpg&quot;)let templateView = UIImageView(image: template)paperViewController.contentView = templateView 总结PaperKit 为苹果生态应用提供了一套完整、灵活的标注解决方案。通过简单的集成步骤和丰富的自定义选项，开发者可以轻松地为应用添加专业级的标注功能。无论是简单的笔记应用还是复杂的创意工具，PaperKit 都能满足不同场景的需求。 相关视频充分利用 Apple Pencil 的强大功能PencilKit 的新功能SwiftUI 新功能 文档PaperKit","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 PermissionKit 增强儿童安全保护","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_293/","text":"了解 permissionkit 如何帮助你的 app 增强儿童通信安全。我们将向你展示如何使用这一全新框架来创建适龄通信体验，并利用“家人共享”请求获得家长批准。你将了解如何构建与“信息”无缝整合的权限请求、处理家长答复，并为儿童用户量身定制 ui。为了充分从这个讲座中获益，我们建议你先观看 wwdc25 讲座“在你的 app 中提供适龄体验”视频。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 PermissionKit 强化儿童安全保护引言在数字时代，儿童网络安全成为家长和开发者共同关注的焦点。苹果在 iOS、iPadOS 和 macOS 26 系统中推出的 PermissionKit 框架，为开发者提供了一套完整的解决方案，让应用能够更好地保护儿童通信安全。本文将详细介绍 PermissionKit 的核心功能、技术实现方式以及最佳实践。 PermissionKit 概述PermissionKit 是苹果最新推出的框架，旨在为请求者与权限管理者之间创造快速、一致且一流的权限体验。该框架特别适合用于儿童与父母间的通信权限管理，通过”信息”应用作为沟通桥梁，让儿童能够安全地向家长申请与新联系人的交流权限。 前提条件使用 PermissionKit 前需注意以下几点： 用户必须加入”家人共享”群组 家长或监护人需为儿童启用”通信限制”功能 应用需具备判断用户年龄或年龄段的能力 为儿童定制安全界面对于儿童用户，应用应谨慎展示未知联系人的内容。通过 CommunicationLimits 单例的 knownHandles(in:) 方法，可以高效查询系统已知的联系人： 123456789import PermissionKitlet knownHandles = await CommunicationLimits.current.knownHandles(in: conversation.participants)if knownHandles.isSuperset(of: conversation.participants) &#123; // 显示内容&#125; else &#123; // 隐藏内容&#125; 该方法对输入的句柄集合执行优化查询，返回系统已知的子集，开发者无需重复构建已有数据。 构建权限请求流程PermissionKit 使用”问题”抽象层封装权限请求的细节。开发者需要构建 PermissionQuestion 对象，包含通信主题和相关信息。 创建基本问题123456import PermissionKitvar question = PermissionQuestion(handles: [ CommunicationHandle(value: &quot;dragonslayer42&quot;, kind: .custom), CommunicationHandle(value: &quot;progamer67&quot;, kind: .custom)]) 添加元数据增强决策信息为帮助家长做出更明智的决定，可以为问题添加更多元数据： 1234567891011121314151617import PermissionKitlet people = [ PersonInformation( handle: CommunicationHandle(value: &quot;dragonslayer42&quot;, kind: .custom), nameComponents: nameComponents, avatarImage: profilePic ), PersonInformation( handle: CommunicationHandle(value: &quot;progamer67&quot;, kind: .custom) )]var topic = CommunicationTopic(personInformation: people)topic.actions = [.message]var question = PermissionQuestion(communicationTopic: topic) 在不同框架中发起请求在 SwiftUI 中使用 CommunicationLimitsButton： 12345678910111213import PermissionKitimport SwiftUIstruct ContentView: View &#123; let question: PermissionQuestion&lt;CommunicationTopic&gt; var body: some View &#123; // ... CommunicationLimitsButton(question: question) &#123; Label(&quot;请求权限&quot;, systemImage: &quot;paperplane&quot;) &#125; &#125;&#125; 在 UIKit 中： 1234import PermissionKitimport UIKittry await CommunicationLimits.current.ask(question, in: viewController) 在 AppKit 中： 1234import PermissionKitimport AppKittry await CommunicationLimits.current.ask(question, in: window) 处理家长反馈家长在”信息”中做出回应后，应用需要在后台处理这些反馈： 12345678910111213141516171819import PermissionKitimport SwiftUIstruct ChatsView: View &#123; @State var isShowingResponseAlert = false var body: some View &#123; List &#123; // ... &#125; .task &#123; let updates = CommunicationLimits.current.updates for await update in updates &#123; // 收到反馈！ self.isShowingResponseAlert = true &#125; &#125; &#125;&#125; 完整工作流程 儿童在应用中尝试与未知联系人通信 应用隐藏敏感内容并显示权限请求按钮 儿童发起请求，系统生成”信息”对话 家长在”信息”中查看请求详情并做出决策 决策结果自动同步回应用，更新儿童界面 其他儿童保护方案除 PermissionKit 外，苹果还提供多种儿童保护技术： Sensitive Content Analysis API：检测视频通话中的裸露内容 Declared Age Range API：获取用户年龄段信息 Screen Time 框架：家长监管工具 Family Controls 框架：应用级家长控制 结论PermissionKit 为开发者提供了一套完整的儿童通信安全解决方案，通过系统级集成简化了复杂的权限管理流程。开发者只需遵循框架提供的API，就能轻松构建符合儿童安全标准的通信功能。随着数字安全意识的提升，集成此类保护机制将成为儿童友好型应用的必备功能。 相关视频在你的 App 中提供适龄体验 文档DeclaredAgeRangePermissionKit","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"SwiftData：深入了解继承和架构迁移","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_291/","text":"了解如何使用类继承对数据进行建模。了解如何优化查询，并无缝迁移你的 app 数据以便使用继承。探索如何通过子类归类来构建模型图形、编写高效的数据获取和查询，并实现顺畅平稳的架构迁移。了解如何使用可观测持久性历史记录来有效进行更改跟踪。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com SwiftData：深入探索继承与架构迁移SwiftData作为iOS 17推出的数据建模和持久化框架，为开发者提供了强大的工具来管理应用数据。本文将深入探讨如何利用类继承构建数据模型、优化数据查询以及实现平滑的架构迁移。 类继承的应用类继承是SwiftData中一项强大的功能，尤其适用于具有自然层级关系的模型场景。在示例应用SampleTrips中，所有行程共享基础属性（如目的地、日期等），但又有商务行程和个人行程等特殊类型。 12345678910111213141516171819202122232425262728@Modelclass Trip &#123; var name: String var destination: String var startDate: Date var endDate: Date var bucketList: [BucketListItem] = [] var livingAccommodation: LivingAccommodation?&#125;@available(iOS 26, *)@Modelclass BusinessTrip: Trip &#123; var perdiem: Double = 0.0&#125;@available(iOS 26, *)@Modelclass PersonalTrip: Trip &#123; enum Reason: String, CaseIterable, Codable &#123; case family case reunion case wellness &#125; var reason: Reason&#125; 使用继承需注意两点核心原则：首先，模型间应存在自然的”is-a”关系；其次，应用既需要查询所有类型（如所有行程），也需要查询特定子类（仅商务行程）。如果不满足这两个条件，应考虑使用属性或扁平化模型结构。 数据迁移策略随着应用迭代，数据模型可能需要调整。SwiftData提供了完善的迁移方案： 定义每个版本的Schema 创建迁移阶段（轻量级或自定义） 构建完整的迁移计划 123456789enum SampleTripsMigrationPlan: SchemaMigrationPlan &#123; static var schemas: [any VersionedSchema.Type] &#123; [SampleTripsSchemaV1.self, SampleTripsSchemaV2.self, SampleTripsSchemaV3.self, SampleTripsSchemaV4.self] &#125; static var stages: [MigrationStage] &#123; [migrateV1toV2, migrateV2toV3, migrateV3toV4] &#125;&#125; 自定义迁移阶段允许开发者介入迁移过程，处理如数据去重等复杂场景： 1234567891011static let migrateV1toV2 = MigrationStage.custom( fromVersion: SampleTripsSchemaV1.self, toVersion: SampleTripsSchemaV2.self, willMigrate: &#123; context in let fetchDesc = FetchDescriptor&lt;SampleTripsSchemaV1.Trip&gt;() let trips = try? context.fetch(fetchDesc) // 去重逻辑... try? context.save() &#125;, didMigrate: nil) 查询优化技巧SwiftData提供了多种优化查询性能的方法： 使用谓词精确过滤数据 指定需要预加载的关系 限制返回结果数量 1234let fetchDesc = FetchDescriptor&lt;SampleTripsSchemaV1.Trip&gt;()fetchDesc.propertiesToFetch = [\\.name]fetchDesc.relationshipKeyPathsForPrefetching = [\\.livingAccommodation]fetchDesc.fetchLimit = 1 复合谓词可以组合多种过滤条件： 12345let searchPredicate = #Predicate&lt;Trip&gt; &#123; searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)&#125; 数据变更追踪SwiftData提供了多种追踪数据变更的方式： 使用withObservationTracking观察单个对象属性变化 通过持久化历史记录追踪跨进程变更 123var historyDesc = HistoryDescriptor&lt;DefaultHistoryTransaction&gt;()historyDesc.sortBy = [.init(\\.transactionIdentifier, order: .reverse)]historyDesc.fetchLimit = 1 可以构建谓词来筛选特定类型的变更： 12345let changesPredicate = #Predicate &#123; $0.changes.contains &#123; change in [Trip.self, LivingAccommodation.self].contains(change.changedPersistentIdentifier.entityName) &#125;&#125; 总结SwiftData的继承功能为构建复杂数据模型提供了新思路，但需要谨慎评估适用场景。合理的迁移策略和查询优化可以显著提升应用性能。通过结合Observable和持久化历史记录，开发者可以实现高效的数据变更追踪。 相关视频： SwiftUI 的新功能 使用 SwiftData 历史记录 API 跟踪模型更改 文档： SwiftData","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"通过 Instrument 优化 SwiftUI 性能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_306/","text":"探索全新的 swiftui instrument。我们将介绍 swiftui 如何更新视图、app 数据的变化对这些更新会产生什么影响，以及新的 instrument 如何帮助你以可视化方式了解相应的原因和效果。 为了充分从这个讲座中获益，建议你先熟悉一下如何用 swiftui 编写 app。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 Instrument 优化 SwiftUI 性能概述在 WWDC 的主题演讲中，来自 Instruments 团队的 Jed 和 Apple Music 团队的 Steven 共同介绍了全新的 SwiftUI Instrument 工具，该工具旨在帮助开发者识别并解决 SwiftUI 应用中的性能瓶颈问题。性能问题通常表现为应用响应迟缓、卡顿、动画跳帧或滚动延迟等现象，这些都会严重影响用户体验。 全新 SwiftUI Instrument 介绍Instruments 26 中引入了专为 SwiftUI 设计的分析工具，包含三个主要组成部分： SwiftUI Instrument：核心工具，提供 SwiftUI 工作时段的可视化分析 Time Profiler：显示 CPU 工作负载情况 Hangs 和 Hitches 工具：追踪应用响应性问题 SwiftUI Instrument 提供了多层级的性能分析视图： “Update Groups”显示 SwiftUI 的工作时段 “Long View Body Updates”标记耗时过长的视图 body 更新 “Long Representable Updates”标识视图控制器更新 “Other Long Updates”显示其他长耗时工作 其中，橙色和红色标记分别表示可能造成卡顿和严重性能问题的区域。 诊断长耗时视图 body 更新在 Landmarks 应用的案例研究中，Steven 展示了如何使用 SwiftUI Instrument 诊断滚动卡顿问题。通过分析发现，LandmarkListItemView中的distance计算属性频繁创建MeasurementFormatter和NumberFormatter实例，导致视图 body 更新耗时过长。 Jed 解释了 SwiftUI 的渲染循环机制：每帧处理事件后更新 UI，所有工作必须在帧截止前完成。长耗时视图 body 可能导致错过截止时间，造成卡顿。 优化方案是将距离字符串计算移至LocationFinder类中预计算并缓存： 1234567891011// 在 LocationFinder 中预计算距离private let formatter = MeasurementFormatter()private let numberFormatter = NumberFormatter()private var distanceCache: [Landmark.ID: String] = [:]func updateDistances() &#123; for landmark in landmarks &#123; let distance = calculateDistance(to: landmark) distanceCache[landmark.id] = formatter.string(from: distance) &#125;&#125; 修改后，视图只需通过distance(from:)方法获取缓存值，显著提高了滚动流畅度。 理解更新的因果关系Steven 在添加收藏功能时发现，点击单个收藏按钮会导致多个列表项视图更新。通过 Cause &amp; Effect Graph 分析，发现原因是所有LandmarkListItemView都依赖完整的favorites数组。 解决方案是为每个地标创建独立的 ViewModel 管理收藏状态： 1234567891011class LandmarkViewModel: ObservableObject &#123; @Published var isFavorite: Bool init(isFavorite: Bool) &#123; self.isFavorite = isFavorite &#125; func toggleFavorite() &#123; isFavorite.toggle() &#125;&#125; 每个视图拥有专属 ViewModel 实例，直接切换 ViewModel 状态而非操作全局数组。追踪数据显示优化后只有被点击的视图会更新。 Jed 进一步解释了环境依赖的传播机制，强调环境值更新会通知所有依赖视图，但只有实际使用该值的视图需要重新运行 body。 性能优化要点总结 保持视图 body 快速执行：避免复杂计算和频繁对象创建 设计数据流仅触发必要更新：使用细粒度数据依赖 慎用高频变更的依赖项：考虑使用 ViewModel 或中间层 频繁使用 Instruments 分析：开发过程中持续监控性能 相关资源相关视频通过 Instruments 优化 CPU 性能使用 Instruments 分析挂起探索 SwiftUI 动画解密 SwiftUI 性能使用 SwiftUI 构建自定布局揭开 SwiftUI 的神秘面纱探索 UI 动画阻碍与渲染循环 文档Analyzing the performance of your visionOS appImproving app responsivenessMeasuring your app’s power use with Power ProfilerPerformance and metricsUnderstanding and improving SwiftUI performance 全新 SwiftUI Instrument 为开发者提供了强大的性能分析工具，结合这些优化原则和实践，可以帮助构建更加高效流畅的 SwiftUI 应用。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"探索 Swift 和 Java 互操作性","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_307/","text":"了解如何在一个代码库中混合使用 swift 和 java。我们将介绍 swift-java 互操作性项目，该项目让你可以在 java 程序中使用 swift，反之亦然。我们将向你展示如何使用 swift-java 提供的工具和库来编写可在这两个运行时之间进行互操作的安全高效代码。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 探索 Swift 与 Java 的互操作性在现代软件开发中，跨语言互操作性变得越来越重要。Swift 语言团队推出的 Swift-Java 互操作性项目，为开发者提供了在单一代码库中混合使用 Swift 和 Java 的能力，无需进行大规模重写即可逐步引入新技术。 项目背景与意义Swift-Java 互操作性项目旨在消除语言壁垒，允许开发者： 在 Java 程序中调用 Swift 代码 在 Swift 程序中调用 Java 代码 重用现有 Java 库 将 Swift 库提供给 Java 项目使用 这种互操作性支持渐进式迁移策略，开发者可以在不影响现有代码库的情况下，逐步用 Swift 替换或添加新功能。 技术基础：运行时比较尽管 Java 和 Swift 运行时有显著差异，但两者也存在诸多相似之处： 面向对象特性：都提供类和支持继承的面向对象模型 内存管理：均采用自动内存管理机制 泛型系统：具有相似的泛型系统（尽管运行时表现不同） 错误处理：Swift 错误和 Java 异常都可抛出处理 这些相似点为互操作性奠定了良好基础。 Java 原生方法 (JNI) 集成Java 原生接口 (JNI) 是 Java 与原生代码互操作的传统方式。典型的 JNI 工作流程包括： 在 Java 中定义原生方法 使用 Java 编译器生成 C 头文件 使用原生语言（如 Swift）实现函数 然而，原始 JNI 存在诸多痛点： 大量样板代码 方法签名匹配容易出错 对象生命周期管理复杂 需要额外的构建步骤 SwiftJava 解决方案SwiftJava 项目提供了一套完整的工具链来简化互操作： 主要组件 JavaKit：Swift 库，提供 JNI 处理宏和工具 SwiftKit：Java 库，帮助处理 Swift 对象 Swift-Java 命令行工具：自动化代码生成 构建系统集成：支持 SwiftPM 插件和 Gradle 集成 改进的 JNI 工作流使用 SwiftJava 后，JNI 实现变得简洁高效： 1234567@JavaImplementationextension JNIExample: JNIExampleNativeMethods &#123; @JavaMethod func compute(_ value: JavaInteger) -&gt; JavaInteger &#123; // 业务逻辑实现 &#125;&#125; SwiftJava 带来的优势： 消除手动头文件生成 自动处理方法签名 改进的对象生命周期管理 减少错误可能性 从 Swift 调用 Java 库SwiftJava 支持导入完整的 Java 库而无需修改源代码。以 Apache Commons CSV 为例： 依赖管理：通过 Gradle 解析 Java 依赖 配置方式： 使用 SwiftPM 插件（需关闭安全沙箱） 或使用命令行工具手动解析 123456789import JavaKitimport JavaApacheCommonsCSV// 在 Swift 中启动 JVM 并直接使用 Java 库let fileReader = FileReader(&quot;data.csv&quot;)let parser = CSVParser(fileReader)for record in parser &#123; // 处理 CSV 记录&#125; 关键特性： 无缝处理 Java 集合（支持 Swift for-each） 自动管理 Java 对象生命周期 支持复杂的传递依赖解析 从 Java 调用 Swift 库SwiftJava 还支持将整个 Swift 库包装为 Java 可用的形式： 使用 Foreign Function &amp; Memory API（Java 22+） 生成 Java 包装类： 实现 Swift 值类型接口 包含原生内存指针 映射所有公共方法和属性 12345// Java 中使用 Swift 结构体try (var arena = ConfinedArena.open()) &#123; var business = new SwiftyBusiness(arena, 42); business.doSomething();&#125; // 自动清理 内存管理最佳实践： 优先使用 ConfinedArena 替代依赖 GC 确保明确的生命周期管理 避免大量对象终结带来的性能问题 项目现状与未来SwiftJava 目前已经提供了： 安全的互操作代码生成 高效的内存管理 与主流构建工具集成 该项目完全开源，欢迎开发者参与贡献或通过 Swift 论坛提供反馈。 总结Swift-Java 互操作性为开发者提供了灵活的选择： 在现有 Java 应用中逐步引入 Swift 在 Swift 项目中复用 Java 生态 将 Swift 库分享给 Java 团队使用 随着项目发展，Swift 和 Java 之间的互操作将变得更加无缝和安全。 相关视频优化 Swift 代码的内存使用和性能安全地混合使用 C、C ++ 和 SwiftSwift 的新功能融合 Swift 和 C++ 文档The Swift website","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"安全地混合使用 C、C ++ 和 Swift","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_311/","text":"了解如何混合使用 c、c++ 和 swift，同时提高 app 的安全性。我们将介绍如何在 swift 代码中找到不安全的 c 和 c++ api 调用位置、如何更安全地调用这些 api，以及如何使 app 中的现有 c 和 c++ 代码默认处于更安全的状态。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 安全混合使用 C、C++ 与 Swift：实现跨语言安全互操作在现代应用开发中，混合使用 Swift 与 C/C++ 代码的情况十分常见。本文将详细介绍如何在保证安全性的前提下实现跨语言调用，帮助开发者避免常见的安全隐患。 引言随着 Swift 在应用开发中的普及，许多开发者都会面临与现有 C/C++ 代码库互操作的需求。然而，这种混合编程方式可能带来严重的安全隐患，特别是当涉及到指针操作时。苹果安全语言扩展团队经理 Yeoul 在 WWDC 演讲中详细介绍了如何解决这些问题。 定位不安全调用Swift 6.2 引入的”严格内存安全”编译模式可以帮助开发者识别潜在的 unsafe 调用。例如： 12var imageData = [UInt8](repeating: 0, count: imageDataSize)filterImage(&amp;imageData, imageData.count) 在启用该模式后，编译器会明确警告这种不安全构造，提示开发者需要标记为”unsafe”。 要在项目中启用严格内存安全模式，开发者需要在 Xcode 项目设置中进行手动配置。这种模式能够标记所有不安全代码并解释其原因，是发现混合编程安全问题的第一道防线。 安全调用 C/C++ 代码指针安全问题原始指针最大的安全挑战在于缺乏边界保护和生命周期管理。Swift 6.2 引入了新型安全指针 Span 和 MutableSpan，既保留了指针的高效性，又内置了安全防护。 添加安全注解开发者可以通过添加特定注解来提升指针安全性： 边界保护：使用 __counted_by 注解显式关联指针与元素数量 1void invertImage(uint8_t *__counted_by(imageSize) imagePtr __noescape, size_t imageSize); 生命周期管理：使用 __noescape 声明参数不逃逸函数范围 1void applyGrayscale(CxxSpanOfByte imageView __noescape); 返回值安全：使用 __lifetimebound 确保返回值的生命周期正确 1CxxSpanOfByte scanImageRow(CxxSpanOfByte imageView __lifetimebound, size_t width, size_t rowIndex); 安全导入自定义 C++ 类型对于自定义的 C++ 类型，开发者可以通过特定的注解实现安全导入： 视图类型：使用 SWIFT_NONESCAPABLE 注解确保不超越所指内存的生命周期 12345struct ImageView &#123; std::span&lt;uint8_t&gt; pixelBytes; int width; int height;&#125; SWIFT_NONESCAPABLE; 引用计数类型：使用 SWIFT_SHARED_REFERENCE 指定引用计数函数 123456struct ImageBuffer &#123; std::vector&lt;uint8_t&gt; data; std::atomic&lt;unsigned&gt; refCount;&#125; SWIFT_SHARED_REFERENCE(retain_image_buffer, release_image_buffer);ImageBuffer* createImage() SWIFT_RETURNS_RETAINED; 提升 C/C++ 代码安全性虽然无法完全消除 C/C++ 的安全隐患，但开发者可以采取以下措施提升安全性： 启用 C++标准库强化功能，对 std::span 等标准容器进行边界检查 启用 C++不安全缓冲区错误检查，强制使用 std::span 代替原始指针 使用 C边界安全扩展，通过 __counted_by 等注解为指针添加边界信息 这些安全特性可以在 Xcode 的项目设置中统一启用。 总结与最佳实践为确保混合语言编程的安全性，开发者应当遵循以下最佳实践： 在 Swift 项目中启用严格内存安全模式 为所有 C/C++ API 添加适当的安全注解 开启 C/C++ 的边界安全特性 苹果正在与开源社区合作完善语言间的安全互操作机制，开发者可以参考以下资源了解更多信息： 相关视频优化 Swift 代码的内存使用和性能 文档资料-fbounds-safety: Enforcing bounds safety for CSafely Mixing Swift and C++","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"使用全新设计系统构建 AppKit App","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_310/","text":"更新你的 appkit app，以便充分利用全新设计系统。我们将深入探索标签视图、分屏浏览、栏、演示文稿、搜索和控制项等方面的主要变化，并向你展示如何在自定 ui 中使用 liquid glass。为了充分从这个视频中获益，建议你先观看“了解全新设计系统”以获取一般性设计指导。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用全新设计系统构建 AppKit 应用引言macOS 迎来了一次重大的视觉系统革新，全新设计系统为 Mac 应用带来了崭新的外观标准。Apple 框架工程经理 Jeff Nadeau 在 WWDC 2025 的演讲中详细介绍了如何利用这个新设计系统更新 AppKit 应用。此次变革的核心在于 Liquid Glass 材质的引入，它为界面元素带来了立体感和动态效果。 设计系统概述新设计系统带来了全方位的视觉更新，主要包括以下特点： 采用 Liquid Glass 材质，具有半透明特性 能够反射和折射光线，创造立体效果 AppKit 提供了完整的工具支持 涵盖了窗口结构、控件样式等多个方面 应用结构设计窗口外观更新新设计系统对 Mac 窗口的外观进行了重新设计： 窗口形状变化：采用了全新的几何形状设计 材质应用：主要结构区域使用玻璃材质 层级增强：工具栏元素悬浮于玻璃材质上，增强视觉层次 工具栏设计技巧工具栏控件的分组逻辑也得到了改进： AppKit 会自动将同类工具栏按钮组合到同一玻璃块中 不同类型控件(如分段控件、弹出按钮)会自动分隔显示 开发者可以使用 NSToolbarItemGroup 手动分组或插入留白器进行分隔 Liquid Glass 具有自适应特性： 智能调整以匹配下层内容亮度 工具栏玻璃会自动在深浅色外观间切换 通过 NSAppearance 系统实现内容适配 12345678// 移除工具栏项玻璃材质toolbarItem.isBordered = false// 使用强调色为玻璃着色toolbarItem.style = .prominent// 使用特定颜色为玻璃着色toolbarItem.backgroundTintColor = .systemGreen 工具栏徽章系统新设计系统引入了丰富的徽章样式： 12345678// 数字徽章NSItemBadge.count(4)// 文字徽章NSItemBadge.text(&quot;New&quot;)// 指示器徽章NSItemBadge.indicator 分屏浏览布局优化边栏和检查器区域的设计有了显著变化： 边栏显示为悬浮玻璃窗格 检查器为无边玻璃区域 使用 NSSplitViewController 自动获得玻璃材质 适合悬浮显示的内容类型包括： 水平滚动内容 支持轻扫操作的列表 地图/电影海报等丰富内容 12// 允许内容扩展到边栏下方splitViewItem.automaticallyAdjustsSafeAreaInsets = true 窗口圆角处理窗口圆角半径也有了调整： 带工具栏的窗口使用更大圆角半径 仅标题栏的窗口保持较小圆角半径 使用 NSView.LayoutRegion 避免内容被圆角裁剪 12345678910111213// 避开窗口角落func updateConstraints() &#123; guard !installedButtonConstraints else &#123; return &#125; let safeArea = layoutGuide(for: .safeArea(cornerAdaptation: .horizontal)) NSLayoutConstraint.activate([ safeArea.leadingAnchor.constraint(equalTo: button.leadingAnchor), safeArea.trailingAnchor.constraint(greaterThanOrEqualTo: button.trailingAnchor), safeArea.bottomAnchor.constraint(equalTo: button.bottomAnchor) ]) installedButtonConstraints = true&#125; 滚动边缘效果新系统鼓励无边滚动内容设计： 软边缘样式：渐变透明+内容虚化 硬边缘样式：不透明背景+明显区分 分屏浏览项目补充视图： 类似标题栏补充视图，但局限于单个分屏 可置于分屏顶部或底部边缘 添加方法： addTopAlignedAccessoryViewController addBottomAlignedAccessoryViewController 控件更新与改进macOS Tahoe 为控件带来了多项新特性： 尺寸变化： 新增超大尺寸(强调主要操作) 调整各尺寸高度(增大点击区域) prefersCompactControlSizeMetrics 兼容旧版布局 形状变化： 迷你至中号：圆角矩形 大号和超大号：胶囊形状 使用 borderShaped 属性自定义形状 玻璃边框样式： 使用 Liquid Glass 替代标准按钮背景 兼容 bezelColor 着色属性 突出等级系统： none：不着色/最浅 secondary：柔和着色 primary：最醒目着色 automatic：自动选择 123456// 为随机播放和排队按钮设置次级突出shuffleButton.tintProminence = .secondaryplayNextButton.tintProminence = .secondary// 默认按钮自动使用主要突出playButton.keyEquivalent = &quot;\\r&quot; 其他控件改进： 滑块增加 neutralValue 设置填充锚点 支持轨道强调色填充 菜单全面更新外观，增加图标使用 Liquid Glass 材质应用设计意图Liquid Glass 材质的设计原则： 悬浮在 UI 顶层 仅用于最重要的元素 提升控件和导航层级 实现方法使用 NSGlassEffectView 的要点： 设置 contentView 显示内容 避免作为子视图置于内容下方 使用 cornerRadius 和 tintColor 自定义外观 12345678910111213// 采用 NSGlassEffectViewlet userInfoView = UserInfoView()let activityPickerView = ActivityPickerView()let userInfoGlass = NSGlassEffectView()userInfoGlass.contentView = userInfoViewlet activityPickerGlass = NSGlassEffectView()activityPickerGlass.contentView = activityPickerViewlet stack = NSStackView(views: [userInfoGlass, activityPickerGlass])stack.orientation = .horizontal NSGlassEffectContainerView 的优势： 统一组内元素视觉效果 支持液体融合效果 确保采样区域一致 提升渲染性能 123456789101112131415161718// 采用玻璃效果容器视图let userInfoView = UserInfoView()let activityPickerView = ActivityPickerView()let userInfoGlass = NSGlassEffectView()userInfoGlass.contentView = userInfoViewuserInfoGlass.cornerRadius = 999let activityPickerGlass = NSGlassEffectView()activityPickerGlass.contentView = activityPickerViewactivityPickerGlass.cornerRadius = 999let stack = NSStackView(views: [userInfoGlass, activityPickerGlass])stack.orientation = .horizontallet glassContainer = NSGlassEffectContainerView()glassContainer.contentView = stack 实施建议与总结为了帮助开发者顺利过渡到新设计系统，演讲中提出了以下实施步骤： 使用 Xcode 26 构建应用 采用悬浮玻璃工具栏和边栏 转向无边内容展示风格 适配新控件尺寸 检查硬编码高度问题 使用符号图标优化菜单 为重要元素应用 Liquid Glass 新设计系统为 macOS 应用带来了全新的视觉体验，通过 Liquid Glass 材质和各种优化设计，开发者可以为用户创造更加精美、现代的界面效果。遵循这些设计原则和技术指导，将使应用完美融入 macOS 的视觉生态系统。 相关视频了解 Liquid Glass了解全新设计系统 文档采用 Liquid Glass人机界面指南：macOS 设计","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"将 Swift Charts 扩展成三维图表","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_313/","text":"了解如何使用 chart3d 将你的 2d swift charts 转换为三维图表，从全新角度直观呈现你的数据集。绘制 3d 数据图表，以可视化方式显示数学表面，并对摄像头、材质等各种因素进行自定，让你的 3d 图表更加清晰直观、赏心悦目。 为了充分从这个讲座中获益，我们建议你先熟悉一下如何创建 2d swift charts。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 将 Swift Charts 扩展为三维图表：数据可视化新维度引言Apple 在 iOS、macOS 和 visionOS 26 中为 Swift Charts 框架引入了令人振奋的三维图表功能。这项突破性扩展让开发者能够通过 Chart3D 将二维图表转换为三维可视化，为用户提供探索和理解数据集的全新视角。本文将详细介绍如何利用三维图表呈现数据、绘制数学曲面以及自定义图表样式，助您掌握这项强大的可视化工具。 三维图表基础与应用场景Swift Charts 三维图表特别适合呈现数据形态比精确值更重要的情况，尤其是本身具有三维空间属性的数据。以企鹅数据集为例，通过三维散点图可以同时展示鳍肢长度、体重和喙长三个维度的数据，比传统的二维图表更能直观呈现不同企鹅物种间的整体差异。 创建三维图表非常简单，开发者只需将原来的 Chart 替换为 Chart3D，并为现有的标记(如 PointMark)提供 Z 轴值即可。Chart3D 支持 PointMark、RuleMark 和 RectangleMark 等常用标记类型，用户可以通过手势旋转图表从多个角度观察数据。 值得注意的是，三维图表依赖交互操作来理解数据，因此在选择使用三维图表时，应考虑交互是否能真正提升应用体验。当需要同时展示多个变量关系或数据本身具有三维属性时，三维图表会是理想选择。 SurfacePlot：三维曲面绘制功能SurfacePlot 是 Chart3D 独有的强大功能，作为 LinePlot 的三维扩展，它能够绘制包含最多两个变量的数学曲面。其 API 设计与 LinePlot 类似，接收一个将两个 Double 参数转换为 Double 输出的闭包： 123SurfacePlot &#123; x, z in x * z&#125; 开发者可以轻松绘制从简单乘法曲面到复杂三角函数曲面等各种数学图形。此外，SurfacePlot 还支持将机器学习模型预测结果可视化。例如，使用 CreateML 框架训练企鹅数据的回归模型后，可以将预测结果作为灰色曲面绘制在图表中，清晰展示变量间的关联程度。 丰富的自定义选项Chart3D 提供了多种自定义功能，让图表更具表现力： 视角设置：通过 Chart3DPose 修饰符可以预设初始视角，包括内置的 .front 视角或自定义方位角(azimuth)和倾角(inclination)。 投影模式： 正交投影(orthographic)：保持远近物体大小一致，适合侧面观察 透视投影(perspective)：增强深度感知，营造沉浸体验 曲面样式： 应用 LinearGradient 或 EllipticalGradient 等渐变 heightBased 模式根据曲面高度着色 normalBased 模式根据曲面法线角度着色 1234SurfacePlot &#123; x, z in sinc(sqrt(x*x + z*z))&#125;.gradient(.ellipticalGradient(.white, center: .center, startRadiusFraction: 0, endRadiusFraction: 1)) 这些自定义选项在 Vision Pro 上尤其出色，为三维数据提供了自然的展示平台。 结论Swift Charts 的三维功能为数据可视化开启了全新维度。当数据集适合三维呈现时，Chart3D 能够通过其直观的 API 和丰富的定制选项，帮助开发者创建具有深度和表现力的可视化效果。无论是展示生物统计数据、数学曲面，还是机器学习模型预测，三维图表都能提供传统二维图表无法比拟的数据洞察能力。 相关资源相关视频Swift Charts：矢量图与函数图利用图表设计 App 体验设计实用高效的图表 文档资源Swift ChartsSwift Charts 更新日志","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"优化 Swift 代码的内存使用和性能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_312/","text":"了解如何提升 swift 代码的性能和内存管理。我们将探索优化代码的多种方法，包括进行高级算法更改，以及采用新的 inlinearray 和 span 类型对内存和分配进行更精细的控制。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 优化 Swift 代码的内存使用和性能Swift 作为现代编程语言，其性能和内存管理一直是开发者关注的重点。在 WWDC 的技术分享中，Nate Cook 从 Swift 标准库团队的视角，详细介绍了如何通过多种方法提升 Swift 代码的性能和内存效率。 性能优化的多维度方法性能优化需要从多个维度着手。首先需要定位性能瓶颈，然后针对性地采取优化措施。Swift 6.2 引入的新特性为开发者提供了更精细的控制手段，包括： 高级算法优化 内存分配控制 独占性检查消除 堆栈分配转换 引用计数减少 这些技术手段可以组合使用，以达到最佳的优化效果。 QOI 格式解析器案例分析QOI 格式作为一种简单的无损图像格式，其解析器是展示性能优化过程的理想案例。通过分析这个解析器的性能问题，可以清晰地看到不同优化技术带来的效果提升。 算法层面优化分析显示解析器存在明显的性能问题，处理一张鸟类图片需要数秒时间。使用 Instruments 的 Time Profiler 工具进行分析后，发现平台级 memmove 调用占据了绝大部分时间。这表明解析器主要在复制数据而非读取。 问题根源在于 readByte 方法中调用 Data 初始化器导致了数据复制。改用集合方法 popFirst() 后，解析器的时间复杂度从二次方优化为线性，带来了显著的性能提升。 内存分配优化Allocations 工具显示解析单张图片时进行了近百万次分配。通过调用树追踪，发现问题源自 RGBAPixel.data 方法——每次调用都新建包含 3-4 个元素的数组。 优化方案改为预先计算总字节数并一次性分配存储空间，然后逐个解析像素直接写入目标位置。这一改变使分配次数大幅下降，仅保留必要的图像数据存储。 独占性检查优化Swift 数组的动态特性和值语义带来了便利，但也需要付出性能代价。分析发现解析器的 State 类属性触发了运行时独占性检查。 解决方案是将这些属性移出类直接放入解析器类型中。这样调整后，运行时独占性检查完全消失。为进一步优化，可以使用 Swift 6.2 的新特性 InlineArray 来替代像素缓存数组。 创新特性 InlineArray 和 SpanSwift 6.2 引入的 InlineArray 和 Span 类型为性能优化提供了新的可能性。 InlineArray 的优势InlineArray 是固定大小的连续内存容器，其特点包括： 大小通过值泛型在编译时确定 不支持增减元素 存储总是内联（栈上）而非单独分配 不共享存储也不使用写时复制 赋值时即完全复制，无需引用计数和唯一性检查 Span 类型的作用标准库新增的 Span 类型能够消除解析时的引用计数。Span 系列类型通过非逃逸语言特性保证内存安全访问，无需手动管理指针。使用 RawSpan 重构 readByte 方法后，swift_retain 和 swift_release 调用完全消失。 进一步优化是采用 OutputSpan 逐步填充未初始化数据，替代预置零的 Data。最终实现使解析速度提升六倍，且完全无需不安全代码，较最初版本提速超 700 倍。 Swift 二进制解析库基于这些特性构建的 Swift Binary Parsing 库现已公开。该库提供全套安全高效的二进制解析工具，包括： 防止整数溢出 指定字节序等安全特性 已在苹果内部使用 鼓励开发者尝试并参与社区贡献 优化实践建议开发者可以按照以下步骤优化自己的 Swift 代码： 使用 Xcode 和 Instruments 分析应用关键路径性能 探索新版文档中的 InlineArray 和 Span 类型 针对不同性能问题选择合适优化方法 组合使用多种优化技术以达到最佳效果 通过系统地应用这些优化方法，开发者可以显著提升 Swift 代码的性能和内存效率。 相关视频分析并优化 App 的功耗通过 Instruments 优化 CPU 性能Swift 的新功能探索 Swift 性能 文档性能与指标Swift 官网","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"了解 HealthKit Medications API","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_321/","text":"了解 healthkit 中的全新 medications api。探索一个使用此全新 api 的示例 app，了解如何访问药品和剂量，并了解你的 app 如何管理此类新数据的授权。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 深度解析 HealthKit 药物 API：创新医疗数据管理方案引言苹果在 WWDC 上发布了 HealthKit 药物 API，为开发者提供了访问和管理药物数据的新工具。这一创新扩展了健康应用的开发边界，使开发者能够创建更全面、更个性化的健康管理体验。本文将详细解析药物 API 的技术实现、数据模型及其在实际应用中的表现。 药物数据存储机制数据录入流程药物数据通过 iOS 健康应用的”药物”功能录入系统。用户可在”搜索”标签页中找到”药物”选项，通过”添加药物”流程完成数据录入。该系统具有三个关键特性： 药物识别：支持相同名称不同规格药物的精确识别 定制化设置：允许设置服药提醒时间和个性化备注 服药记录：提供多种记录选项（已服用、跳过、延后） 所有录入的数据都将安全存储在 HealthKit 中，为第三方应用提供数据基础。 API 核心架构数据模型设计药物 API 引入了两种核心数据类型： HKUserAnnotatedMedication：代表用户自定义的药物对象 包含四个关键属性 isArchived 表示药物停用状态 hasSchedule 显示提醒设置状态 nickname 提供用户友好别名 关联具体药物引用 HKMedicationDoseEvent：新型 HKSample 子类 记录服药的实际剂量和时间 包含剂量状态（服用/跳过） 区分计划剂量与实际剂量 药物概念模型HKMedicationConcept 提供标准化药物描述： 唯一标识符保证数据准确性 显示名称提供用户友好视图 剂型分类（胶囊/片剂等） 临床编码（如 RxNorm）确保系统互操作性 实际应用案例数据查询示例以下展示了阿莫西林抗生素的典型数据结构：12345678910111213141516// 药物概念示例concept = HKMedicationConcept( identifier: &quot;308192&quot;, displayName: &quot;阿莫西林三水合物 500mg 口服片剂&quot;, dosageForm: .tablet, codingSystem: .rxNorm)// 剂量事件示例doseEvent = HKMedicationDoseEvent( medicationConcept: concept, status: .skipped, dose: HKQuantity(unit: .count(), doubleValue: 0), scheduledDose: HKQuantity(unit: .count(), doubleValue: 1), scheduledTime: Date()) 示例应用实现Srishti 开发的示范应用展示了 API 的典型用法： 药物列表视图：显示已授权药物 剂量详情：展示最近服药记录 副作用追踪：通过表情符号记录症状严重度 授权流程采用对象级权限管理，确保数据访问的安全性。副作用数据通过 RxNorm 编码系统与药物关联，实现智能匹配。 高级查询技术锚定对象查询实现对于时间序列数据展示，推荐使用 HKAnchoredObjectQuery：123456789let query = HKAnchoredObjectQuery( type: HKMedicationDoseEvent.sampleType, predicate: predicate, anchor: anchor, limit: HKObjectQueryNoLimit) &#123; (query, samples, deletedObjects, newAnchor, error) in // 处理新增和删除的样本 // 更新界面展示&#125; 关键实现要点： 精确设置查询谓词限定范围 正确处理删除的样本数据 保持与健康应用数据同步 充分利用 Swift 异步接口优势 权限管理系统新增药物授权流程健康应用提供简化的共享授权： 用户添加新药物时自动触发共享选项 开发者无需额外实现授权逻辑 系统自动管理权限边界 这种设计既保证了用户隐私控制权，又简化了开发者的权限管理负担。 开发建议与资源实践指导 数据关联：利用药物概念与其他临床数据建立关联 编码系统：深入研究 RxNorm 等标准化系统 状态处理：全面理解不同记录状态的含义 学习资源相关视频：使用 iOS 和 iPadOS 上的 HealthKit 跟踪体能训练HealthKit 入门讲座 文档资源：健康数据访问授权HKAnchoredObjectQueryHKSampleQueryrequiresPerObjectAuthorization()) 结语HealthKit 药物 API 为健康应用开发开辟了新维度。通过标准化的数据模型和灵活的查询接口，开发者可以构建从服药提醒到长期疗效追踪的各类创新应用。随着医疗健康领域的数字化发展，这类 API 将成为连接专业医疗数据与日常健康管理的重要桥梁。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"借助 App Store Connect API 实现开发流程自动化","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_324/","text":"了解新的 webhook api 如何为你提供 app store connect 中的实时通知。我们还将介绍一些可帮助你管理用户反馈和构建版本交付的 apl，并讨论如何将这些工具整合到你的开发工作流程中，以提高效率并简化流程。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com App Store Connect API新特性解析：Webhook通知与自动化开发流程在2025年WWDC大会上，App Store Connect团队工程师Dajinsol Jeon详细介绍了API功能的重要更新，这些更新旨在帮助开发者实现开发流程的自动化。本文将全面解析这些新特性，包括Webhook通知、构建上传API和反馈API等关键技术。 引言：自动化开发流程的重要性现代应用开发是一个持续迭代的过程，涉及构建上传、测试反馈和版本更新等多个环节。App Store Connect提供的API扩展让开发者能够自动化这些流程，从而专注于核心功能的开发。2025年的更新主要集中在三方面：Webhooks API、BuildUpload API和Feedback API，这些都为加速开发周期提供了强大支持。 Webhook通知：事件驱动的自动化Webhook技术改变了传统的轮询模式，实现了服务器间的推送通信。当应用相关事件发生时，App Store Connect会主动通过HTTP回调通知开发者的服务器。 Webhook配置流程配置Webhook监听器需要以下步骤： 在App Store Connect网站的”用户与权限”版块中进入”集成”→”Webhooks” 填写描述性名称和监听器URL（接收通知的端点） 设置密钥用于验证通知真实性 选择订阅的事件类型（构建上传、测试版状态和TestFlight反馈等） 开发者也可以通过API注册Webhook，这种方式特别适合管理多款应用或需要自动注册的场景。成功创建后将收到201 CREATED响应，其中包含后续管理所需的Webhook ID。 构建上传API：标准化的自动上传流程新的构建上传API采用标准化设计，支持任何编程语言/平台，并提供格式良好的错误消息便于自动化处理。上传流程分为四个清晰步骤： 创建包含版本号和目标平台的BuildUpload 通过BuildUploadFiles提供构建文件详情 按指示上传二进制文件 发送PATCH请求标记上传完成 上传完成后，Webhook会在处理完成时通知开发者（状态从PROCESSING变为COMPLETE）。通知包含X-Apple-SIGNATURE头，开发者可通过预设密钥验证消息真实性。 测试反馈自动化管理测试阶段的反馈处理直接影响用户体验，新的API和Webhook组合提供了完善的解决方案。 测试版构建分发构建处理完成后，TestFlight API可自动化以下流程： 将构建分配给特定测试组 为外部测试者提交Beta应用审核 通知测试者新版本可用 新增的构建测试版状态Webhook事件会在测试版审核完成时立即通知开发者。 反馈APITestFlight反馈包含截图反馈（建议/UI问题）和崩溃反馈，快速响应对于优化用户体验至关重要。新增的反馈API配合Webhook事件可实现： 即时接收新反馈通知 通过反馈ID获取详细信息 下载崩溃日志和截图 其他开发API扩展本次更新还包括多项重要扩展： 自动化管理Apple-Hosted Background Assets的新API 应用版本状态Webhook事件（追踪应用商店状态变更） 现有API的增强，可自动化开发流程各阶段 总结与最佳实践为实现高效的自动化开发流程，App Store Connect团队建议开发者： 搭建Webhook监听器接收实时通知 基于Webhook事件实现自动化响应工作流 全面探索App Store Connect API以加速整个开发周期 开发者可参考以下相关资源获取更多技术细节： 相关视频探索 Apple 托管的 Background AssetsApp Store Connect 的新功能 文档Beta 反馈崩溃提交Beta 反馈截图提交预发布版本与测试人员上传和版本化 Apple 托管的背景资源Webhook 通知","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"使用 iOS 和 iPadOS 上的 HealthKit 跟踪体能训练","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_322/","text":"了解有关为 ios 打造出色体能训练体验的最佳做法。探究体能训练会话的生命周期，探索 apple watch 上和 iphone 上体能训练的不同之处，并了解如何使用实时活动和 siri 来提升 app 的锁屏体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 在 iOS 和 iPadOS 上使用 HealthKit 追踪体能训练HealthKit 作为苹果健康数据管理的核心框架，为开发者提供了追踪体能训练的丰富 API。本文将详细介绍如何在 iOS 和 iPadOS 设备上实现完整的训练追踪体验。 训练会话基础实现建立完整的训练会话流程包含几个关键步骤： 会话配置与启动开发首先需要创建训练配置对象，设置活动类型（如跑步）和位置类型（如户外）。配置完成后，通过 HKWorkoutSession 初始化会话实例，并关联训练构建器与数据源： 12345678let configuration = HKWorkoutConfiguration()configuration.activityType = .runningconfiguration.locationType = .outdoorlet session = try HKWorkoutSession(healthStore: healthStore, configuration: configuration)let builder = session.associatedWorkoutBuilder()builder.dataSource = HKLiveWorkoutDataSource(healthStore: healthStore, workoutConfiguration: configuration) 启动前调用 prepare 方法让设备传感器预热，随后显示3秒倒计时，确保训练开始时就能获取准确数据： 123session.prepare()session.startActivity(with: startDate)try await builder.beginCollection(at: startDate) 数据处理与会话结束训练构建器委托方法负责处理实时收集的数据： 12345678func workoutBuilder(_ workoutBuilder: HKLiveWorkoutBuilder, didCollectDataOf collectedTypes: Set&lt;HKSampleType&gt;) &#123; for type in collectedTypes &#123; guard let quantityType = type as? HKQuantityType else &#123; return &#125; let statistics = workoutBuilder.statistics(for: quantityType) updateForStatistics(statistics) &#125;&#125; 结束训练时需要依次调用停止、结束收集和完成训练的方法： 1234session.stopActivity(with: .now)try await builder.endCollection(at: change.date)let finishedWorkout = try await builder.finishWorkout()session.end() 设备差异性处理iOS/iPadOS 与 Apple Watch 在训练追踪方面存在几个重要区别： 传感器可用性iPhone 和 iPad 本身不配备心率传感器，但可以配对支持心率 GAT 配置文件的外设。系统会自动处理这些设备的数据，将其存入健康数据库。 数据类型差异训练数据分为两类： 系统生成类型：如卡路里和距离等基础指标 收集类型：应用自定义收集的指标（如饮水量） 开发者可以通过数据源的 enable/disable collection 方法动态调整收集的数据类型。 锁屏状态处理iOS 设备在训练时可能锁屏，系统会显示特殊权限提示，允许应用在锁屏时继续访问训练数据。这是展示实时活动的理想场景： 设备锁定时若无数据访问权限，应仅显示训练时长 可以结合实时活动和 Siri 意图提升锁屏体验 增强训练体验锁屏 Siri 支持通过实现特定意图处理器，应用可以支持锁屏状态下的语音控制： 12345public class IntentHandler: INExtension &#123;&#125;extension IntentHandler: INStartWorkoutIntentHandlingextension IntentHandler: INPauseWorkoutIntentHandlingextension IntentHandler: INResumeWorkoutIntentHandlingextension IntentHandler: INEndWorkoutIntentHandling 处理逻辑需要检查当前训练状态并做出相应响应： 123456789101112public func handle(intent: INStartWorkoutIntent) async -&gt; INStartWorkoutIntentResponse &#123; let state = await WorkoutManager.shared.state switch state &#123; case .running, .paused, .prepared, .stopped: return INStartWorkoutIntentResponse(code: .failureOngoingWorkout, userActivity: nil) default: WorkoutManager.shared.setWorkoutConfiguration(activityType: .running, location: .outdoor) return INStartWorkoutIntentResponse(code: .success, userActivity: nil) &#125;&#125; 崩溃恢复机制iOS 新增了场景委托来处理训练恢复： 12345678910111213func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123; if options.shouldHandleActiveWorkoutRecovery &#123; let store = HKHealthStore() store.recoverActiveWorkoutSession(completion: &#123; (workoutSession, error) in Task &#123; await WorkoutManager.shared.recoverWorkout(recoveredSession: workoutSession) &#125; &#125;) &#125; // 返回场景配置&#125; 恢复时只需重建数据源即可继续之前的会话： 1234567func recoverWorkout(recoveredSession: HKWorkoutSession) &#123; session = recoveredSession builder = recoveredSession.associatedWorkoutBuilder() let dataSource = HKLiveWorkoutDataSource(healthStore: healthStore, workoutConfiguration: workoutConfiguration) builder?.dataSource = dataSource&#125; 开发最佳实践 优先在 Apple Watch 上启动训练以获得完整指标 仅请求必要数据类型的健康权限 始终使用训练构建器 API 保存训练数据 已有 Apple Watch 应用可以轻松扩展到 iOS/iPadOS 平台 及时同步训练数据到 iPhone（参考多设备训练专题） 相关资源开发者可以参考以下资源获取更多信息： 相关视频了解 HealthKit Medications API利用 App Intents 为用户奉上 App 的核心功能了解 ActivityKit构建多设备训练 App 文档HKWorkoutSessionRunning workout sessions","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"App Store Connect 的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_328/","text":"了解 app store connect 的最新更新，包括适用于构建版本交付的新网页 ui 以及 testflight 通知的增强功能。我们还将探讨新的 app 发现功能和增强功能，例如适用于自定产品页面的关键词、辅助功能标签以及年龄分级方面的更新等。此外，你还将了解 app 内购买项目优惠代码以及评论总结工具等新功能。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com App Store Connect新功能全面解析：提升应用开发与管理效率引言在WWDC的最新发布会上，Apple详细介绍了App Store Connect的一系列创新功能改进。这些更新覆盖了从应用构建管理到用户发现、从测试流程优化到变现策略增强等多个维度，为开发者提供了更强大的工具链。 核心功能优化构建版本管理升级构建版本交付流程获得了三项关键性改进： 可视化构建上传状态：开发者现在可以实时追踪所有应用版本的交付进度，包括处理失败的构建版本。新增的”构建上传”专区提供了完整的处理记录和详细错误信息，团队成员能够快速定位问题根源。 API集成构建上传：App Store Connect API将支持构建上传功能，配合Webhooks实时通知系统，开发者能够建立完全自动化的构建管理流程。 大容量资源分发：新增的Apple-Hosted Background Assets支持最大200GB的资产分发，并可独立于应用更新进行管理，这对Apple Vision Pro等设备上的高规格应用尤为重要。 TestFlight测试增强TestFlight反馈机制实现了质的飞跃： 测试人员提交的反馈（含截图）和崩溃日志会实时推送到开发者的移动设备 智能摘要功能有效管理通知频率 团队成员可以直接在iPhone/iPad上共享测试反馈 应用发现与用户获取精准触达目标用户应用商店标签系统通过大语言模型分析生成精准标签，开发者可以在”应用信息”页面管理这些标签，控制应用在不同标签专题页的曝光。 自定产品页面关键词功能允许为特定场景创建定制化展示页面，系统会在用户搜索匹配词条时自动展示对应的定制页面而非默认页面。开发者还能在应用分析中追踪各定制页面的搜索表现。 变现策略扩展优惠码功能适用范围已扩展到所有应用内购买类型，包括： 消耗型项目 非消耗型项目 非续订订阅 每季度每应用可生成最多100万条优惠码，支持基于用户消费历史的兑换条件设置。沙箱测试环境现已同步支持优惠码生成功能。 用户体验与合规管理决策辅助工具AI生成的评论摘要整合用户评价的核心观点，开发者可以查看当前展示的摘要内容，对不准确的摘要提交修正请求。 年龄分级系统升级为5级阈值，新增针对青少年群体的细分评级，开发者可以声明应用内置的家长控制功能，并标注可能涉及年龄限制内容的功能模块（如聊天、广告等）。 无障碍访问创新革命性的辅助功能营养标签系统允许开发者： 按设备声明对VoiceOver等功能的支持程度 添加详细指导说明 提供辅助功能支持说明的网页链接 支持分设备发布和后续编辑 其他重要改进平台还包含多项值得关注的增强： App Analytics新增100+指标，重点加强订阅变现数据分析 Game Center推出全新游戏应用，增强社交互动功能 审核提交流程优化，支持背景资源等新项目单独提交 开发者可以创建包含多种项目类型的草稿提交组合 技术支持与学习资源开发者遇到技术问题时，可通过Apple开发者官网联系全天候支持团队，建议提供详细的问题描述、截图和HAR日志以加速解决过程。 总结这一系列App Store Connect新功能为开发者提供了从应用构建到发布、从用户获得到变现的全流程优化工具。特别是可视化构建管理、AI生成标签和评论摘要、大容量背景资源分发等创新，将显著提升开发效率和用户体验。 相关视频使用”App 分析”优化盈利策略借助 App Store Connect API 实现开发流程自动化探索 Apple 托管的 Background Assets通过 Apple Games App 吸引玩家针对辅助功能标签评估你的 AppStoreKit 和 App 内购买项目的新功能实现 App Store Offers 文档资源年龄分级App Store Connect 帮助中心Apple 开发者支持配置多版本产品页面辅助功能营养标签概述评分与评论管理促销代码申请与管理","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"SF Symbols 7 的新功能","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_337/","text":"探索 apple 图标资料库 sf symbols 的最新更新。了解全新动画系统 draw，让符号模仿手写笔画自然的流畅性；还有用来表示强度或进度的 variable draw。探索为符号增添立体感和视觉吸引力的 gradients，以及在相关符号间增强连贯性的魔术替换增强功能。此外，了解如何预览并将这些功能整合到自己的 app 中。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com SF Symbols 7 新功能详解：Draw动画、渐变与魔术替换增强引言Apple 设计团队的 Kelsey 在 WWDC 上分享了 SF Symbols 7 的最新更新。作为苹果生态系统中的重要设计资源，SF Symbols 持续进化，本次更新带来了全新的动画系统、渐变效果以及魔术替换功能的增强。这些改进将使开发者能够为应用界面创造更加生动和富有表现力的视觉体验。 符号设计与构建基础在深入了解新功能之前，理解符号的基本设计原理至关重要。每个 SF Symbol 都是从单个矢量点开始精心设计的连续路径： 符号由矢量点和曲线构建，而非简单的可见轮廓 通过精确控制比例、负空间和视觉比重来确保清晰度 某些形状由两条方向相反的路径创建，这对动画实现有重要影响 以箭头符号为例，其尖端形状由两条路径精心构建，这种设计方法为后续的 Draw 动画功能奠定了基础。 Draw：手写风格的动画系统核心概念Draw 是 SF Symbols 7 引入的全新动画系统，其灵感来源于手写笔画的自然流畅性： Draw On：符号在屏幕上绘制显现的动画预设 Draw Off：符号从屏幕绘制消失的动画预设 利用符号的图层结构，可在关键时刻增强用户体验 播放选项Draw 动画提供三种播放方式： By Layer（按图层）：默认选项，每个路径错开开始绘制 Whole Symbol（整体符号）：所有图层同时绘制，适合快速即时效果 Individually（逐个）：新版选项，等前一个图层完成再绘制下一个，适合突出个体动作 灵活应用Draw 功能展现出强大的适应性： 风向符号从左到右绘制表现运动 阿拉伯字符从右到左绘制符合书写方向 对称符号从中心向外绘制 复杂符号如箭头，其尖端会随路径移动，强化含义表达 渐变效果与视觉深度SF Symbols 7 新增了渐变功能： 通过单一源色生成平滑线性渐变 兼容所有渲染模式和系统/自定义颜色 在大尺寸显示时效果尤为突出 为符号增添深度和维度感 渐变效果特别适用于需要强调符号立体感的场景，为界面元素带来更强的视觉吸引力。 魔术替换功能增强魔术替换（Magic Replace）功能获得显著改进： 现在能识别并匹配符号的外框（enclosures） 共享外框的符号间可实现无缝过渡 结合 Draw Off 和 Draw On 动画效果 可在动画检查器中预览魔术替换预设 自定义符号标注指南要为自定义符号添加 Draw 功能支持，需要正确标注符号： 引导点系统Draw 动画依赖路径上的引导点（guide points）： 基本引导点：开放圆（起点）和实心圆（终点） 角落点：菱形标示，用于处理锐角转折 附着点：用于箭头等非绘制元素与路径关联 标注流程 从常规字重开始标注（作为基础） 系统自动将引导点插值到其他字重模板 开启引导点编号检查顺序一致性 可通过右键菜单调整引导点 完成后，可通过设置中的变量渲染开关让符号支持 Variable Draw。 API集成与使用开发者可通过以下API使用新功能： SwiftUI示例1234567// 应用Draw动画Image(systemName: &quot;arrow.right&quot;) .symbolEffect(.draw)// 应用渐变渲染Image(systemName: &quot;cloud&quot;) .symbolRenderingMode(.gradient) UIKit/AppKit12345// 配置Draw动画let config = UIImage.SymbolConfiguration(preset: .drawOn)// 设置渐变渲染let gradientConfig = UIImage.SymbolConfiguration(renderingMode: .gradient) 总结与下一步建议SF Symbols 7 通过 Draw 动画系统、渐变效果和魔术替换增强，为开发者提供了更丰富的视觉表达工具。建议开发者： 下载 SF Symbols 7 测试版预览新功能 检查自定义符号的标注兼容性 查阅框架文档了解详细集成方法 这些创新功能将为应用界面带来前所未有的生动表现力和一致性。 相关视频SF Symbols 6 的新功能","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"探索 Apple 托管的 Background Assets","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_325/","text":"本次讲座将以 background assets 为基础，介绍用于为游戏和其他应用程序下载内容素材包的新功能。了解 apple 如何为你托管这些素材包，或如何管理自托管选项。我们将深入探索原生 api 整合及相应的 app store 实现，并为你提供工具来提升 app 的内容交付体验和用户体验。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple 托管的 Background Assets 全面解析引言Apple 在 WWDC 上正式推出 Background Assets 这一全新的资源分发机制，旨在优化应用资源交付体验，特别是针对游戏开发者和其他需要管理大型资源包的场景。这项技术允许开发者将资源与主应用分离，由 Apple 托管这些资源包，从而提供更流畅的首次启动体验和灵活的更新机制。 Background Assets 新特性背景与现状传统资源交付方式存在明显局限：主应用包集成方案会导致用户被迫下载全部资源；URLSession 需要开发者自行管理复杂的下载流程；而 On-Demand Resources 即将退役。Background Assets 作为新一代解决方案，提供了系统级的资源管理能力。 核心优势托管式 Background Assets 提供三大关键改进： 自动管理：系统处理下载、更新、压缩等流程 灵活策略：三种下载策略（必需型、预载型、按需型）满足不同场景 托管服务：Apple 提供的 200GB 存储空间，免除自托管负担 技术实现细节资源包与应用构建的匹配Apple 托管资源包采用灵活的版本匹配机制： 资源包版本与应用构建版本解耦 不同分发渠道（App Store/TestFlight）可对应不同资源包版本 兼容性管理成为关键考虑因素 版本匹配示例展示了当多个资源包版本并存时，系统如何自动选择正确的版本供不同渠道的用户使用。 开发流程实施托管式 Background Assets 需完成三个主要步骤： 创建资源包 使用跨平台打包工具（macOS/Linux/Windows） JSON 清单配置资源包属性 支持文件级和目录级选择 API 集成 通过 AssetPackManager 类管理资源包 Swift 的 async/await 接口简化异步操作 Objective-C 采用 delegate 模式 本地测试 新 Background Assets 模拟服务器支持 开发者设置配置测试环境 最佳实践与优化建议配置注意事项开发者需特别注意： 应用组配置确保主应用与扩展通信 Info.plist 关键字段设置（BAAppGroupID、BAHasManagedAssetPacks等） 资源包版本更新时的向后兼容性 测试与分发流程完整的发布流程包括： 通过 Transporter 或 API 上传资源包 在 App Store Connect 创建资源包记录 测试验证（内部测试→外部测试） 最终提交至 App Store 审核 结论与展望托管式 Background Assets 代表了 Apple 资源分发技术的重大进步，特别是对游戏和媒体类应用开发者而言。通过将资源管理与分发流程系统化，开发者可以更专注于创造优质内容而非基础设施维护。随着 On-Demand Resources 的逐步退役，迁移至 Background Assets 将成为必要选择。 开发者可通过提供的打包工具和 API 快速上手，利用 Apple 提供的托管服务和自动化测试工具优化资源交付体验。这项技术的广泛应用有望显著提升用户首次启动应用的满意度，降低因等待下载导致的用户流失。 相关视频借助 App Store Connect API 实现开发流程自动化App Store Connect 的新功能Background Assets 的新动向 文档配置 Background Assets 项目最大构建文件大小Apple 托管资源包概述","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"录制、重播和查看：使用 Xcode 实现 UI 自动化","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_344/","text":"了解如何在 xcode 中录制、运行和维护 xcuiautomation 测试。利用测试计划配置，在数十个语言、设备类型和系统条件下重播 xctest ui 测试。使用 xcode 测试报告来查看测试结果，并下载运行情况的截图和视频。我们还将介绍有关通过辅助功能为 app 做好自动化准备以及编写稳定、高质量自动化代码的最佳做法。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 Xcode 实现 UI 自动化：从录制到审查的完整指南UI 自动化是确保应用质量的重要手段，Xcode 提供了一套完整的工具链，帮助开发者轻松实现应用交互的自动化测试。本文将从 UI 自动化的基本原理出发，详细介绍如何在 Xcode 中录制、运行和维护 XCUIAutomation 测试，并通过测试计划在多配置环境下回放测试，最后查看测试报告和视频录像。 UI 自动化基础Xcode 提供了两个主要的测试框架：Swift Testing 和 XCTest。当导入 XCTest 时，系统会自动包含 XCUIAutomation 框架，这个框架能够模拟用户操作来自动化运行应用。这两个框架共同构成了完整的应用测试套件。 完整的应用测试通常包含两种类型： 单元测试：验证应用逻辑和模型，可在没有用户界面的框架和 Swift 包上运行 UI 自动化测试：验证用户体验、与 Apple 硬件的集成以及常见工作流程的行为 UI 自动化测试的优势在于它能直观展示应用的外观表现、行为方式以及与操作系统的集成效果。具体应用场景包括： 模拟用户操作（点击、滑动和按压） 测试辅助技术（如 VoiceOver、语音控制和动态类型）下的用户体验 验证应用在所有支持语言和地区的表现 测试与 Apple 硬件功能的集成 评估应用的启动性能 UI 自动化支持所有 Apple 平台：iOS、iPadOS、macOS、watchOS、tvOS 和 visionOS。同一套自动化脚本甚至可以在多个平台上运行，实现”一次编写，多平台测试”的效果。 为自动化做准备虽然 UI 自动化可以开箱即用，但为了获得更好的测试质量，建议进行以下准备工作： 添加辅助功能标识符辅助功能标识符（accessibilityIdentifier）是自动化中唯一识别应用元素的最佳方式。优秀的标识符应具备以下特点： 在整个应用中具有唯一性 描述性强，能详细说明所属元素 保持静态，不随内容变化而改变 在 SwiftUI 中，可以为任何 UI 元素添加 accessibilityIdentifier 修饰符： 12LandmarkRow(landmark: landmark) .accessibilityIdentifier(&quot;landmark_\\(landmark.id)&quot;) 在 UIKit 中，可以直接设置 accessibilityIdentifier 属性： 1button.accessibilityIdentifier = &quot;addButton&quot; 审查辅助功能Xcode 自带的”辅助功能检查器”可以帮助查找、诊断和修复辅助功能问题。该工具可从 Xcode 顶层菜单的”Open Developer Tool”启动，也能通过 Spotlight 打开。检查器会列出应用视图的辅助功能值，其中”Basic”部分的属性对 UI 自动化特别有用。 添加 UI 测试目标在 Xcode 的项目设置视图中，点击目标列表下方的”+”按钮，选择”UI Testing Bundle”添加新目标。完成后，新的 UI 测试文件夹和模板将添加到项目中，为自动化测试提供基础结构。 录制交互操作录制 UI 测试的基本流程如下： 打开 UI 测试源文件，使用侧边栏的按钮开始 UI 录制 Xcode 会自动构建并在模拟器中重新启动应用 与应用交互时，操作会被实时记录为代码 停止录制后检查代码，添加验证逻辑 运行测试验证录制是否正确 在录制过程中，Xcode 会为每个操作提供多个 UI 元素定位选项。选择推荐方案： 对于包含本地化字符串的视图，优先选用辅助功能标识符 对于深度嵌套的视图，选择尽可能简洁的查询 对于动态内容，使用通用查询或现有的辅助功能标识符 录制完成后，可以添加验证代码检查预期行为： 123let app = XCUIApplication()let element = app.buttons[&quot;Max的澳洲冒险&quot;]XCTAssert(element.waitForExistence(timeout: 5)) 在多配置环境下回放测试计划是管理多环境测试的强大工具，允许您： 包含或排除单个测试 设置测试运行的系统配置 管理超时、重复、并行化等属性 关联特定构建设置 在测试计划的”Configurations”标签页中，可以： 设置多语言配置运行应用 控制是否在运行期间捕获视频或截图 选择保留哪些运行的媒体（失败或全部） Xcode Cloud 是运行多配置测试的理想平台，它支持： 在云端构建应用和运行测试 使用相同的测试计划在多种设备上运行 查看完整的运行历史和结果 审查视频与结果Xcode 测试报告提供了丰富的工具来分析和诊断测试结果。主要功能包括： 查看失败测试的视频录像和错误描述 切换不同配置的测试视频 下载视频和截图用于进一步分析 在失败时刻查看存在的 UI 元素 获取代码建议来定位元素 通过右键点击测试报告中的元素，可以获得如何在自动化代码中定位该元素的建议，这对于快速修复测试失败非常有帮助。 最佳实践与总结为了构建稳定高效的 UI 自动化测试，建议遵循以下最佳实践： 优先使用辅助功能标识符定位元素 为关键工作流程添加验证逻辑 在多语言和设备配置下运行测试 利用测试计划管理复杂的测试场景 定期审查测试视频和报告，持续优化测试 UI 自动化、辅助功能、本地化、Xcode Cloud 和测试报告的协同工作，共同提升了应用质量，让全球用户都能获得更好的体验。将这些技术整合为统一的工作流程，将显著提高开发效率和产品质量。 相关视频了解 Swift Testing使用 Xcode 测试报告更快修复故障在 SwiftUI 和 UIKit 中创建易于访问的 App在 Xcode Cloud 中创建实用的工作流程对你的 App 进行辅助功能审核为 Xcode Cloud 创建快速而可靠的测试SwiftUI 辅助功能：超越基础功能 文档Improving code assessment by organizing tests into test plansPerforming accessibility testing for your app","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"了解全新设计系统","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_356/","text":"深入了解全新设计系统，探索视觉设计、信息架构及核心系统组件方面的关键变化。了解如何借此重塑界面与内容之间的关系，打造动态、和谐且一致的设计，完美适配各种设备、屏幕尺寸和输入模式。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com Apple设计系统革新：Liquid Glass全面解析在WWDC2025上，Apple设计团队的Maria详细介绍了全新的设计系统Liquid Glass，这一系统标志着Apple迄今为止最全面的软件设计革新。该系统通过一套全新的启发式方法重塑了界面与内容的关系，打造出更加协调、自适应且富有表现力的统一设计语言。 设计语言：构建协调性的基础Liquid Glass在不同平台间建立了熟悉感，同时为每个体验提供精准定制。这一系统化的设计方法体现在从最小控件到最大界面的所有层级： 色彩系统：对浅色、深色和高对比度外观进行了微妙调整，提升色相区分度同时保持Apple特有的乐观精神 排版系统：采用更粗体且左对齐的方式，强化关键场景的可读性 形状系统：引入了三种形状类型： 固定形状（恒定圆角半径） 胶囊形状（容器高度一半的半径） 同心形状（从父级减去间距计算的半径） 这些形状遵循同心性驱动的几何学，通过围绕共享中心对齐半径和边距实现自然嵌套。在macOS上，Mini、Small和Medium控件继续使用圆角矩形，Large控件采用胶囊形状，配合新的X-Large尺寸创造层次与平衡。 结构体系：引导导航与内容互动Liquid Glass在UI中定义了新的功能层，悬浮于内容上方提供结构而不喧宾夺主： Action Sheet革新：现在从操作本身弹出，而非固定出现在屏幕底部 材质变化：反映导航焦点，随导航深入或转移而强化意图 bars设计优化：不再需要自定义背景或边框，层次通过布局和分组表达 tab bar改进：iOS新增底部专用搜索标签，支持持久功能如媒体播放控件 滚动边缘效果采用微妙模糊替代硬分隔线，系统提供两种样式：柔和（默认）与强硬（主要用于macOS）。边栏现在采用内嵌设计，允许内容在其后方流动，实现更沉浸的体验。 连续性：跨设备统一体验Liquid Glass确保了用户在不同设备间切换时的流畅体验： 设备上下文适应：iPhone专注垂直布局，Mac展开为宽阔画布，iPad作为中间层 共享内容策略：有意分组的内容应保持在一起，跨设备使用相同符号建立熟悉感 菜单设计：更多依赖符号而非文本，相关操作使用一个符号引入分组 组件设计原则：构建可扩展的结构组件，将平台差异视为共享框架的表达而非例外 开发者行动指南Maria建议开发者： 更新应用时检查过尖或过宽的圆角 清理自定义bars，改用系统提供的分组API 根据功能和频率合理组织bar items 确保tab bar只包含持久功能而非上下文操作 正确使用滚动边缘效果（避免混合或叠加） 利用边栏的背景延伸效果创造沉浸体验 跨平台保持符号和组件行为的一致性 相关资源开发者可以深入探索以下资源： 《人机交互指南》更新内容 Apple设计资源中的新UI工具包 配套演讲视频《认识Liquid Glass》 图标设计指南和材质使用规范 Liquid Glass代表了Apple设计语言的新篇章，为开发者提供了打造协调、自适应且富有表现力应用的强大工具。通过遵循这些设计原则和最佳实践，开发者可以为用户创造更统一、更流畅的跨设备体验。","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"使用 Icon Composer 构建图标","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_361/","text":"了解如何使用 icon composer 为 ios、ipados、macos 和 watchos 构建最新 app 图标。探索如何从你选择的设计工具中导出素材，将它们添加到 icon composer 中，应用实时玻璃属性和其他效果，以及预览不同平台和外观模式下的显示效果并进行调整。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com 使用 Icon Composer 构建图标：Apple 平台图标设计新方式在 WWDC 2025 上，Apple 发布了全新的 Icon Composer 工具，这款工具彻底革新了为 Apple 平台设计 App 图标的方式。作为一名科技领域的专业博客作者，本文将深入解析这项新工具的功能与优势。 Icon Composer 带来的变革Icon Composer 解决了多平台图标适配的长期痛点。以往开发者需要为不同平台和设备创建多个版本的图标，而现在只需一个设计就能为 iPhone、iPad、Mac 和 Apple Watch 等所有 Apple 设备生成适配图标。 这款工具特别值得关注的是其对六种全新外观模式的支持：默认、深色、透明浅色、透明深色、着色浅色和着色深色。Icon Composer 让开发者能够实时预览这些不同模式下的显示效果，确保图标在各种环境下都能保持最佳视觉效果。 设计流程优化Icon Composer 的工作流程分为四个简单步骤： 在设计工具中创建图标 导出分层设计 导入 Icon Composer 进行调整 保存并导入 Xcode Apple 设计团队已在今年使用这个工具更新了所有原生 App 的图标，显著提高了工作效率。对于开发者而言，这意味着可以节省大量原本用于多平台图标适配的时间。 设计技巧与规范在使用 Icon Composer 前，设计阶段需要注意以下要点： 使用矢量绘图工具（如 Figma、Sketch、Photoshop 或 Illustrator） 设置合适的画布尺寸（1024px 用于 iPhone/iPad/Mac，1088px 用于 Watch） 采用分层设计结构，底层作为背景，其他元素沿 Z 轴堆叠 保持设计简洁，避免在原始设计中添加后期可通过 Icon Composer 实现的效果 分层设计是 Icon Composer 发挥最大效用的关键。简单图标可能只需要前景和背景两层，复杂图标最多可达四层。恰当的颜色分层能为 Icon Composer 提供更大的控制空间。 导出与导入注意事项将设计导入 Icon Composer 前，需要注意以下导出规范： 按 Z 轴顺序编号图层 确保所有文字已转为轮廓 避免在导出文件中添加圆角或圆形蒙版 自定义渐变或复杂效果需导出为 PNG 格式 支持 SVG 或 PNG 导出格式 Icon Composer 功能详解导入 Icon Composer 后，开发者将面对三个主要工作区： 左侧边栏：管理画布、分组和图层 中间区域：实时预览面板 右侧检查器：调整外观属性 Icon Composer 的核心功能包括自动应用 Liquid Glass 效果（可在图层级别控制），以及强大的颜色和构图控制功能。这些工具特别适合为不同外观模式创建变体，并处理平台特定的适配需求。 使用 Icon Composer 时，有几个实用技巧值得注意： 关闭镜面效果可以解决图标在狭窄空间的显示问题 色彩阴影能有效增强材质感 深色模式需要特别注意填充效果 单色外观应保证至少包含一个白色元素 圆形平台（如 watchOS）需特别关注边缘构图 交付与未来展望完成图标调整后，开发者只需保存 .icon 文件并导入 Xcode 即可。Icon Composer 代表了图标设计从静态图像向动态设计的转变，使图标能够响应不同输入并完美适配各种外观。 Icon Composer 目前提供测试版，Apple 鼓励开发者下载试用并通过 Feedback Assistant 提交使用反馈。这项工具的推出标志着 Apple 在设计工具生态上的重要进步，为开发者提供了更高效的图标创作流程。 对于希望深入了解 Icon Composer 及相关技术的开发者，Apple 提供了丰富的学习资源： 相关视频了解 Liquid Glass了解全新设计系统了解焕然一新的 App 图标 文档资源使用 Icon Composer 创建应用图标人机界面指南：应用图标","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"探索 SwiftUI 中的并发机制","date":"2025-06-10T13:46:47.000Z","path":"2025/06/10/2025-06-10-wwdc2025_266/","text":"探究 swiftui 如何利用 swift 并发机制来构建安全且响应灵敏的 app。探索 swiftui 如何默认使用主 actor，并将工作转移给其他 actor。了解如何解释并发注解并使用 swiftui 的事件循环来管理异步任务，以实现流畅的动画和 ui 更新。你还将了解如何避免数据争用并放心地编写代码。 视频地址 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com SwiftUI 中的并发机制解析：构建安全高效的应用程序SwiftUI 通过 Swift 并发机制为开发者提供了构建安全且响应迅速应用程序的强大工具。本文将深入探讨 SwiftUI 如何利用主 Actor 作为默认设置，如何安全地将工作转移到后台线程，以及如何组织并发代码以实现最佳用户体验。 主 Actor 的默认隔离机制SwiftUI 将 @MainActor 作为编译时和运行时的默认选择，为开发者提供了天然的线程安全保障。在 SwiftUI 中，View 协议本身就隔离于 @MainActor，这意味着所有遵循 View 协议的结构体及其成员都自动获得 @MainActor 隔离。 这种隔离机制确保了视图中的所有状态访问都在主线程上安全进行。例如在颜色提取应用中，ColorExtractorView 结构体自动获得了 @MainActor 隔离，其 body 属性和 @State 变量等成员都隐式隔离于主线程。 这种设计不仅简化了开发者的工作流程，也确保了与 AppKit 和 UIKit 框架的无缝协作。例如，UIViewRepresentable 协议继承自 View 协议，同样获得了 @MainActor 隔离，使得在 makeUIView 方法中创建 UIKit 组件完全符合框架要求。 后台线程优化策略为了保持界面流畅，SwiftUI 会将部分计算密集型工作转移到后台线程执行。这种优化特别适用于需要大量计算的场景，如动画中间状态计算和高频几何运算。 在颜色提取应用中，圆形元素的 scaleEffect 动画和自定义 WedgeShape 的 path 计算方法都会在后台线程执行。SwiftUI 通过 Sendable 注解向开发者明确这些 API 的并发行为，帮助避免潜在的数据竞争问题。 当需要在并发任务中访问外部变量时，开发者可以采用捕获列表制作变量副本的策略。例如，在 visualEffect 修饰符中，通过 [pulse] 捕获列表创建 pulse 变量的副本，避免了跨线程访问主 Actor 隔离变量的风险。 同步与异步代码的组织原则良好的用户体验往往依赖于及时的界面反馈。SwiftUI 的多数 API（如按钮的 action 回调）都采用同步设计，这确保了 UI 状态能够立即响应。 在组织并发代码时，开发者应遵循以下原则： 在启动异步任务前同步更新 UI 指示状态 将异步工作逻辑与视图逻辑分离 使用状态作为 UI 代码与异步代码的桥梁 保持视图逻辑主要为同步代码 这种方法不仅提升了应用性能，也简化了测试流程。异步代码可以独立于 UI 逻辑进行测试，而视图则专注于同步响应和状态管理。 最佳实践与后续步骤随着 Swift 6.2 的推出，开发者可以尝试启用默认 Actor 隔离设置，减少显式的 @MainActor 注解。同时，深入了解 Mutex 等同步工具将有助于构建更安全的并发代码。 开发者还可以挑战为应用的异步代码编写独立于 SwiftUI 的单元测试，这将有助于构建更清晰的应用架构。 相关视频跟着视频学编程：使用 Swift 并发机制提升 App 性能采用 Swift 并发探索 SwiftUI 动画 文档ConcurrencyMutex","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"采用 Swift 并发","date":"2025-06-10T07:33:32.000Z","path":"2025/06/10/2025-06-10-wwdc2025_268/","text":"与我们一起了解 swift 并发方面的核心概念。并发可帮助你提高 app 的响应速度和性能，而 swift 旨在让正确编写异步和并发代码变得更加简单。我们会介绍将 app 编程从单线程转换为并发流程所需的步骤。无论你想让代码更加异步化、将代码移到后台，还是在并发任务中共享数据，我们都将帮助你确定充分利用 swift 并发功能的恰当方式和时机。 视频地址 掌握 Swift 并发编程：从单线程到高效并发的演进之路引言在当今移动应用开发中，响应速度和性能表现至关重要。Swift 并发模型为开发者提供了强大的工具，使异步与并发代码的编写变得简单可靠。本文将带您了解如何从单线程应用逐步演进到高效的并发架构，并介绍 Swift 并发模型的各种特性和最佳实践。 单线程基础所有 Swift 程序默认在主线程运行，这是最简单的开发模式： 1234567var greeting = &quot;Hello, World!&quot;func greet() &#123; print(greeting)&#125;greet() 这种单线程模式具有以下优势： 简单性：同一时间只执行一个操作 安全性：无需担心并发访问问题 维护性：代码逻辑更直观易懂 Swift 默认使用 @MainActor 保护主线程代码，这意味着编译器会自动确保这些内容只在主线程访问。 异步任务处理当需要处理网络请求等耗时操作时，异步编程可以显著提升用户体验： 12345func fetchAndDisplayImage(url: URL) async throws &#123; let (data, _) = try await URLSession.shared.data(from: url) let image = decodeImage(data) view.displayImage(image)&#125; 使用 async/await 语法时： async 标记可能暂停的函数 await 标识潜在的暂停点 系统会在等待时自动释放线程资源 任务交错与并发多个任务可以交错执行，充分利用系统资源： 123456789func onTapEvent() &#123; Task &#123; do &#123; try await fetchAndDisplayImage(url: url) &#125; catch let error &#123; displayError(error) &#125; &#125;&#125; Swift 的并发模型特点： 每个 Task 独立执行特定操作 系统自动管理任务调度 暂停的任务会让出线程给其他就绪任务 后台执行与数据安全当主线程负载过高时，可以将工作移至后台： 1234@concurrentfunc decodeImage(_ data: Data) async -&gt; Image &#123; Image()&#125; 处理数据安全的关键点： 使用 Sendable 协议确保线程安全 值类型(URL, Data)天然线程安全 引用类型需要特别注意并发访问 Actor 模型对于复杂的并发需求，可以使用 Actor 隔离共享状态： 1234567actor NetworkManager &#123; var openConnections: [URL: Connection] = [:] func openConnection(for url: URL) -&gt; Connection &#123; // 线程安全的连接管理 &#125;&#125; Actor 的特性： 内部数据自动隔离保护 不绑定特定线程 可以创建多个实例 适合非UI子系统 总结与最佳实践Swift 并发编程的演进路径： 从单线程开始，保持简单 引入异步任务处理高延迟操作 使用并发减轻主线程负担 采用 Actor 管理后台数据 推荐做法： 先用性能分析工具定位瓶颈 逐步引入并发特性 启用”Approachable Concurrency”构建选项 主模块默认使用 MainActor 隔离 Swift 并发是提升应用性能的强大工具，但并非所有应用都需要复杂的并发架构。明智的做法是根据实际需求逐步引入适当的并发特性。 相关视频 跟着视频学编程：使用 Swift 并发机制提升 App 性能 超越结构化并发的基础 文档 Swift Migration Guide 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"给面试者的一些建议","date":"2021-12-22T14:02:29.000Z","path":"2021/12/22/2021-12-22-给面试者的一些建议/","text":"前言从一个面试者到面试官，然后再到考虑团队建设，很多看法都发生了很大的改变。但是在自己上百场的面试过程中，也看到了很多自己以前的影子。很多时候并不是自己不够优秀，而是在某些方面没有做好。所以这里来聊聊这些问题。 本文并不想传授什么面试技巧，或者刷提指南，个人认为知识永远是无法短时间内补齐的，只要是有经验的面试官，其实很容易拆穿这种小把戏。我更希望能给大家了解招聘和面试中的一些标准和要求，让大家把最好的一面表现出来。当然在这方面我也还没达到特别高的程度，只能聊聊招聘技术开发的角色的一些问题。 面试官与团队角度很多人，包括我自己，以及刚开始做面试官的时候，都很难去思考我们的招聘标准以及对人的一个要求是什么。但这的确是招人最重要的一个环节。 如何考察一个人考察一个面试者，一般会从下面3个方面进行： 知识 对知识的应用 软实力 知识毫无疑问，作为一个技术人员，知识是最基本的，知识的深度和体量直接决定了上层建筑，这也是最容易区分人和进行量化的部分。 相信大厂的职级系统应该大部分都是直接对标的知识这个维度来设计的。 对知识的应用其实这一点并不太好衡量，这里包括业务经验，过往工作经验，同时作为编程能力的一部分，抽象、总结能力也是非常重要的一部分。所以这点往往会从过往的项目中去考察。 但也存在着一定的问题，一个是不同的业务方向会有不同的经验，另一个是不同的面试官对这个标准都不太一样，很难形成一致的标准。这也是为什么有些面试官会被吐槽，往往都是拿着自己业务的东西，代入到他人的项目中去问。 至于为什么有些大厂会考察算法题，我个人感觉还是有一定道理的。算法除了能看出个人的编码习惯，也能看出一定的抽象逻辑思维能力。单纯从能力角度去量化衡量太难了，而变成算法就容易多了。 软实力作为技术人员，软实力这部分是最不重要的。但是会作为你最终职位和定位的一个参考。这个会在下一点讨论。 所以，只要你技术方面足够厉害，作为技术开发这个职位来说，就不会有任何问题。从Google的招聘思路上，宁缺毋滥，也是类似的。我们可以花大价钱找一个不听话的技术达人（当然不是指破坏者），也不会找一个处事圆滑的老油条。 从招人角度看我们招到的人不可能从一个模子里刻出来的，也不可能在各个方面都达到要求，而如何发挥每个人最大的作用这就属于管理范畴的内容了，团队人才培养与梯度建设不在这里讨论。所以从团队管理的角度看一个人的部分缺点是完全可以用团队来弥补的，这也是我为什么说软实力在技术开发的角色中并不是特别重要，只要你不是害群之马，都不存在问题。 所以，关键的是每个人都要有自己的特色，自己突出的能力，这才是团队比较喜欢的一点。阿里曾经的招聘要求是，必须招到比团队平均线以上的人。我个人的理解应该是，招到在某个方向，或者某个领域，能够超过目前团队能力的人，这样团队才能不停的变的更优秀。 说了这么多，你应该知道企业都想要找到什么样的人了吧？时刻问问自己，自己的优势是什么？不要相信木桶原理，不停的在自己不擅长的领域做无用功。当然基础知识这一点不算在内，因为这是基础的基础。 面试者角度在做面试官后，遇到过各式各样的面试者，这里说一说大家普遍性的几个问题吧。 简历简历是我们给面试官的第一印象，但是从我的角度看来，我几乎没有遇到过一份简历是写的很好的。 从我个人的角度看，我并不想了解你的毕业，四六级成绩，考过什么证书，只会关注你的最近2年左右的工作内容，以及你对技术领域方面的能力。当然这里不是指这些信息没用，而是说对于技术面的面试官来说不是重点。 有些人可能觉得简历应该足够精简，控制在一页以内。其实我想说的是这个完全是误导人，如果你几年的工作经历能够凝练在十行以内，那么我想说的是完全看不出来你所做的事情。精简是对的，但是必须能够说明白你做的事情，你做这件事情的前后缘由，自己的思考和思路，以及最终产生的收益和结果，如果有后续的一些反思是最好的。你需要找到你最亮眼的工作内容，在其中体现出你对于技术的应用，对于问题的探索和思考，这才是一份有亮点的简历。同时，这也能引导面试官在这个方向上来提问题，而不是基于面试官的个人经验。 其中比较典型的问题是流水账，大部分简历都是写的是 1234XXX公司：1. 负责xxxx2. 负责xxx3. 性能优化 当然不是说这样写存在问题，而是在这种描述中完全看不出你个人在这些工作中所做的贡献与价值，这些描述都过于泛泛而谈了，面试官也不知道改怎么询问你在这个业务中的贡献。 与其让面试官去挖掘你的亮点，为什么不直接展示出来呢？所以我的建议是不要被篇幅局限了，找到你自己觉得最优秀的几个方面，用最精炼的语言说明白你在这件事情中的贡献。当然这个要基于你真正做过的事情，不能凭空捏造，被发现了反而是件非常不好的事情。 至于怎么展示你的亮点，可以参考下Star法则。亮点贵在精，而不在多。 准备些什么很多人都会问，我要面试了，需要准备些什么，可以刷哪些题。而我想说的是，临时抱佛脚都是没用的，特别是在知识这一块。 知识只能通过平时的日积月累，以及平时遇到的困难中去总结，任何临阵磨枪其实在优秀的面试官面前都会原形毕露，只要随便换种方式问一问就能知道你是不是真正的掌握了。刷题能骗过的也就是在这一块也不懂的面试官。 那么我们需要准备什么呢？其实很简单，把自己之前做过的事情重新梳理一遍，把自己以前对其中的各种问题的思考都再总结一遍。确保自己能够在讲述自己做的事情的时候，是完整的，条理清晰的。如果有条件可以找别人听一听你的描述，在这个基础上可以进行改进下就好了。其实我们最忌讳问到面试者怎么做或怎么思考的时候，说这个东西其实也没做什么，这个东西是老板派的任务，这个时间有点久了，记不清了。 只要做好平时的积累，以及对自己做的事情的梳理，剩下的就交给机遇吧。 面试中面试中的问题只要你做好前几个，一般问题不大，但是必须要注意几个点。 不要不懂装懂如果被问到知识盲区的时候，千万不要自以为是的回答，不知道就是不知道，没有人是完美的，面试官并不会因为一个盲点而否定一个人的能力，可以大方的承认自己在这块的能力不足。 如果你有自己的理解和推断，可以先承认自己的盲区，然后再说明自己的推断和思路。哪怕这种推断和实际情况不符，但是合理也不会有什么问题。 描述要精炼有部分面试者会出现这类问题，觉得自己回答的东西越多，总有一个点答到了面试官的点。 可以说这种思路完全是错误的，首先不说你说的内容是否有面试官关心的点，你的长篇大论可能面试官根本没有耐心听完。因为面试官要从回答中提炼出重点，然后思考和组织你的知识体系，并且记录，本身就是一件非常耗精力的事情，可能只能专注你的回答前半分钟。所以切记不要有这种想法。 回答一定要精炼，有重点，最好能够做到结构化的去描述。 同时不要夸夸而谈，技术出身的人大部分都是非常务实的，避免天马行空而没有办法实际落地的东西。 技术人员一般对沟通能力不会做太大的要求，只要能精炼的描述清楚一件事情就好了。 总结机遇总是给有准备的人的，所以只要在平时做好积累，总有一天会降临到你的头上的。 欢迎大家给我投简历 djs66256@163.com","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"微前端笔记","date":"2021-06-06T12:26:43.000Z","path":"2021/06/06/2021-06-06-微前端笔记/","text":"目前很多大型业务随着业务的飞速膨胀，单体结构(monolithic)已经远不能符合当前开发模式了，所以后端有微服务，前端有微前端，客户端有组件化，其主要目标都是一致的，都是为了解决单体结构的问题，但是各端也有各自的一些特色，其中后端的拆分最为复杂，而客户端拆分最难以彻底，而微前端则介于这两者之间。 一般来说，都是后端先进行的微服务拆分，而组织架构的调整最好是前后端保持一致，才能确保最低的沟通成本，而从康威定律来看，相应的架构也需要进行同样的调整。 同时服务拆分也给我们带来了异构系统的可能性，不仅仅是后端服务的异构实现，甚至前端也可以采用不同的框架进行搭建，这给予了团队不同的技术选型空间。 服务拆分的最大一个好处就是功能发版不再相互依赖了，减少了团队间的沟通成本与增加了迭代速度。 而对于微前端来说，比较重要的几个方面就是： 页面路由 跨组件通信 页面组合 路由的事情相对比较容易解决，对于多页应用来说，通过配置反向代理即可，只需要定义好各个团队之间的域即可，避免出现冲突等问题。 通信的问题对前端来说也比较容易解决，通过事件冒泡的形式向上传递事件，接收方可以通过在window上加入监听实现。 其中组合的方式较为复杂，有多种形式进行，但是需要保证的是各个团队的职责足够的清晰。 页面合成可以通过： iframe ajax web component 从渲染发生的时间可以分为： CSR SSR 两者混合渲染 可以看到两种渲染方式的明显区别。这种特点在加载时间上也带来了不一样的体验。 下面是技术选型的一个指导。 总结可以看出来微前端既有一部分微服务在后台拆分思路一致的地方，也有和客户端一样单体页面拆分问题。","categories":[],"tags":[{"name":"micro-frontend","slug":"micro-frontend","permalink":"http://djs66256.github.io/tags/micro-frontend/"}]},{"title":"wakeup in XNU","date":"2021-04-03T07:04:51.000Z","path":"2021/04/03/2021-04-03-wakeup-in-XNU/","text":"苹果在iOS13的时候，在内核中加入了一个新的性能衡量指标wakeup，同时由于这个指标而被系统杀死的应用数不胜数，其中也包括我们常用的微信淘宝等。而这个指标完全是由XNU内核统计的，所以我们很难通过日志等普通手段去准确的定位问题，所以这里通过另一种思路去解决这个问题。 为什么要统计 wakeup要定位这个问题，首先我们需要知道这个指标的目的是什么。 XNU中，对性能的指标有CPU、内存、IO，而wakeup属于CPU的性能指标，同时属于CPU指标的还有CPU使用率，下面是XNU中对其限制的定义。 1234567/* * Default parameters for CPU usage monitor. * * Default setting is 50% over 3 minutes. */#define DEFAULT_CPUMON_PERCENTAGE 50#define DEFAULT_CPUMON_INTERVAL (3 * 60) 12345678910#define TASK_WAKEUPS_MONITOR_DEFAULT_LIMIT 150 /* wakeups per second */#define TASK_WAKEUPS_MONITOR_DEFAULT_INTERVAL 300 /* in seconds. *//* * Level (in terms of percentage of the limit) at which the wakeups monitor triggers telemetry. * * (ie when the task&#x27;s wakeups rate exceeds 70% of the limit, start taking user * stacktraces, aka micro-stackshots) */#define TASK_WAKEUPS_MONITOR_DEFAULT_USTACKSHOTS_TRIGGER 70 总结来说，当CPU使用率在3分钟内均值超过50%，就认为过度使用CPU，当wakeup在300秒内均值超过150次，则认为唤起次数过多，同时在阈值的70%水位内核会开启监控。 CPU使用率我们很容易理解，使用率越高，电池寿命越低，而且并不是线性增加的。那么wakeup又是如何影响电池寿命的呢？ 首先我们需要看看ARM架构中对于CPU功耗问题的描述： 1Many ARM systems are mobile devices and powered by batteries. In such systems, optimization of power use, and total energy use, is a key design constraint. Programmers often spend significant amounts of time trying to save battery life in such systems. 由于ARM被大量使用与低功耗设备，而这些设备往往会由电池来作为驱动，所以ARM在硬件层面就对功耗这个问题进行了优化设计。 1234567Energy use can be divided into two components: - Static Static power consumption, also often called leakage, occurs whenever the core logic or RAM blocks have power applied to them. In general terms, the leakage currents are proportional to the total silicon area, meaning that the bigger the chip, the higher the leakage. The proportion of power consumption from leakage gets significantly higher as you move to smaller fabrication geometries. - Dynamic Dynamic power consumption occurs because of transistor switching and is a function of the core clock speed and the numbers of transistors that change state per cycle. Clearly, higher clock speeds and more complex cores consume more power. 功耗可以分为2种类型，即静态功耗与动态功耗。 静态功耗指的是只要CPU通上电，由于芯片无法保证绝对绝缘，所以会存在“漏电”的情况，而且越大的芯片这种问题越严重，这也是芯片厂家为什么拼命的研究更小尺寸芯片的原因。这部分功耗由于是硬件本身决定的，所以我们无法去控制，而这种类型功耗占比不大。 动态功耗指的是CPU运行期间，接通时钟后，执行指令所带来的额外开销，而这个开销会和时钟周期频率相关，频率越高，耗电量越大。这也就说明了苹果为什么会控制CPU使用率，而相关研究（Facebook也做过）也表明，CPU在20以下和20以上的能耗几乎是成倍的增加。 CPU使用率已经能够从一定程度上限制电池损耗问题了，那么wakeup又是什么指标呢？ wakeup 是什么要了解wakeup是什么，首先要知道ARM低功耗模式的2个重要指令WFI和WFE。 1ARM assembly language includes instructions that can be used to place the core in a low-power state. The architecture defines these instructions as hints, meaning that the core is not required to take any specific action when it executes them. In the Cortex-A processor family, however, these instructions are implemented in a way that shuts down the clock to almost all parts of the core. This means that the power consumption of the core is significantly reduced so that only static leakage currents are drawn, and there is no dynamic power consumption. 通过这2个指令进入低功耗模式后，时钟将会被关闭，这个CPU将不会再执行任何指令，这样这个CPU的动态能耗就没有了。这个能力的实现是由和CPU核心强绑定的空转线程idle thread实现的，有意思的是XNU中的实现较为复杂，而Zircon中则非常直接暴力： 12345__NO_RETURN int arch_idle_thread_routine(void*) &#123; for (;;) &#123; __asm__ volatile(“wfi”); &#125;&#125; 在XNU中，一个CPU核心的工作流程被概括为如下状态机： 12345678/* * -------------------- SHUTDOWN * / ^ ^ * _/ | \\ * OFF_LINE ---&gt; START ---&gt; RUNNING ---&gt; IDLE ---&gt; DISPATCHING * \\_________________^ ^ ^______/ / * \\__________________/ */ 而wakeup则表示的是，从低功耗模式唤起进入运行模式的次数。 wakeup 如何统计的ARM异常系统CPU时钟被关闭了，那么又要怎么唤起呢？这就涉及到CPU的异常系统。 在ARM中，异常和中断的概念比较模糊，他把所有会引起CPU执行状态变更的事件都称为异常，其中包括软中断，debug中断，硬件中断等。 从触发时机上可以区分为同步异常与异步异常。这里指的同步异步并不是应用程序的概念，这里同步指的是拥有明确的触发时机，比如系统调用，缺页中断等，都会发生在明确的时机，而异步中断，则完全无视指令的逻辑，会强行打断指令执行，比如FIQ和IRQ，这里比较典型的是定时器中断。 异常系统有很多能力，其中一个重要的能力就是内核态与用户态切换。ARM的执行权限分为4个等级，EL0，EL1，EL2，EL3。其中EL0代表用户态，而EL1代表内核态，当用户态想要切换至内核态的时候，必须通过异常系统进行切换，而且异常系统只能向同等或更高等级权限进行切换。 那么这么多类型的异常，又是如何响应的呢？这里就涉及到一个异常处理表（exception table），在系统启动的时候，需要首先就去注册这个表，在XNU中，这个表如下： 12345678910111213141516171819 .section __DATA_CONST,__const .align 3 .globl EXT(exc_vectors_table)LEXT(exc_vectors_table) /* Table of exception handlers. * These handlers sometimes contain deadloops. * It&#x27;s nice to have symbols for them when debugging. */ .quad el1_sp0_synchronous_vector_long .quad el1_sp0_irq_vector_long .quad el1_sp0_fiq_vector_long .quad el1_sp0_serror_vector_long .quad el1_sp1_synchronous_vector_long .quad el1_sp1_irq_vector_long .quad el1_sp1_fiq_vector_long .quad el1_sp1_serror_vector_long .quad el0_synchronous_vector_64_long .quad el0_irq_vector_64_long .quad el0_fiq_vector_64_long .quad el0_serror_vector_64_long wakeup 计数那么我们回过头来看看wakeup计数的地方： 1234567891011121314151617181920212223242526272829/* * thread_unblock: * * Unblock thread on wake up. * Returns TRUE if the thread should now be placed on the runqueue. * Thread must be locked. * Called at splsched(). */boolean_tthread_unblock( thread_t thread, wait_result_t wresult)&#123; // . . . boolean_t aticontext, pidle; ml_get_power_state(&amp;aticontext, &amp;pidle); /* Obtain power-relevant interrupt and “platform-idle exit&quot; statistics. * We also account for “double hop” thread signaling via * the thread callout infrastructure. * DRK: consider removing the callout wakeup counters in the future * they’re present for verification at the moment. */ if (__improbable(aticontext /* . . . */)) &#123; // wakeup ++ &#125; // . . .&#125; 而这里的aticontext则是通过ml_at_interrupt_context获取的，其含义则是是否处于中断上下文中。 123456789101112131415161718/* * Routine: ml_at_interrupt_context * Function: Check if running at interrupt context */boolean_tml_at_interrupt_context(void)&#123; /* Do not use a stack-based check here, as the top-level exception handler * is free to use some other stack besides the per-CPU interrupt stack. * Interrupts should always be disabled if we’re at interrupt context. * Check that first, as we may be in a preemptible non-interrupt context, in * which case we could be migrated to a different CPU between obtaining * the per-cpu data pointer and loading cpu_int_state. We then might end * up checking the interrupt state of a different CPU, resulting in a false * positive. But if interrupts are disabled, we also know we cannot be * preempted. */ return !ml_get_interrupts_enabled() &amp;&amp; (getCpuDatap()-&gt;cpu_int_state != NULL);&#125; 那么cpu_int_state标记又是在什么时候设置上去的呢？只有在locore.S中，才会更新该标记：1str x0, [x23, CPU_INT_STATE] // Saved context in cpu_int_state 同时发现如下几个方法会配置这个标记： 12345el1_sp0_irq_vector_longel1_sp1_irq_vector_longel0_irq_vector_64_longel1_sp0_fiq_vector_longel0_fiq_vector_64_long 结合上述的异常处理表的注册位置，与ARM官方文档的位置进行对比，可以发现： 这几个中断类型均为FIQ或者IRQ，也就是硬中断。由此我们可以判断，wakeup必然是由硬中断引起的，而像系统调用，线程切换，缺页中断这种并不会引起wakeup。 进程统计由上可以看出，wakeup其实是对CPU核心唤起次数的统计，和应用层的线程与进程似乎毫不相干。但从程序执行的角度思考，如果一个程序一直在运行，就不会进入等待状态，而从等待状态唤醒，肯定是因为某些异常中断，比如网络，vsync等。 在CPU核心被唤醒后，在当前CPU核心执行的线程会进行wakeup++，而系统统计维度是应用维度，也就是进程维度，所以会累计该进程下面的所有线程的wakeup计数。 1234queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) &#123; info-&gt;task_timer_wakeups_bin_1 += thread-&gt;thread_timer_wakeups_bin_1; info-&gt;task_timer_wakeups_bin_2 += thread-&gt;thread_timer_wakeups_bin_2;&#125; 所以在我们代码中，如果在2个不同线程启用用同样的定时器，wakeup是同一个线程起2个定时器的2倍（同样的定时器在底层其实是一颗树，注册同样的定时器实际只注册了一个）。 用户层获取该统计值则可以通过如下方式： 1234567891011121314151617181920212223242526#include &lt;mach/task.h&gt;#include &lt;mach/mach.h&gt;BOOL GetSystemWakeup(NSInteger *interrupt_wakeup, NSInteger *timer_wakeup) &#123; struct task_power_info info = &#123;0&#125;; mach_msg_type_number_t count = TASK_POWER_INFO_COUNT; kern_return_t ret = task_info(current_task(), TASK_POWER_INFO, (task_info_t)&amp;info, &amp;count); if (ret == KERN_SUCCESS) &#123; if (interrupt_wakeup) &#123; *interrupt_wakeup = info.task_interrupt_wakeups; &#125; if (timer_wakeup) &#123; *timer_wakeup = info.task_timer_wakeups_bin_1 + info.task_timer_wakeups_bin_2; &#125; return true; &#125; else &#123; if (interrupt_wakeup) &#123; *interrupt_wakeup = 0; &#125; if (timer_wakeup) &#123; *timer_wakeup = 0; &#125; return false; &#125;&#125; wakeup 治理从以上分析来看，我们只需要排查各种硬件相关事件即可。 从实际排查结果来看，目前只有定时器或者拥有定时能力的类型是最普遍的场景。 比如NSTimer，CADisplayLink，dispatch_semaphore_wait，pthread_cond_timedwait等。 关于定时器，我们尽量复用其能力，避免在不同线程去创建同样的定时能力，同时在回到后台的时候，关闭不需要的定时器，因为大部分定时器都是UI相关的，关闭定时器也是一种标准的做法。 关于wait类型的能力，从方案选择上避免轮询的方案，或者增加轮询间隔时间，比如可以通过try_wait，runloop或者EventKit等能力进行优化。 监控与防劣化一旦我们知道了问题原因，那么对问题的治理比较简单，而后续我们需要建立持续的管控等长效措施才可以。 在此我们可以简单的定义一些规则，并且嵌入线下监控能力中： 定时器时间周期小于1s的，在进入后台需要进行暂停 wait类型延迟小于1s，并且持续使用10次以上的情况需要进行优化 总结wakeup由于是XNU内核统计数据，所以在问题定位排查方面特别困难，所以从另一个角度去解决这个问题反而是一种更好的方式。 同时从XNU中对CPU功耗的控制粒度可以看出，苹果在极致的优化方面做的很好，在自身的软件生态中要求也比价高。电量问题在短时间内应该不会有技术上的突破，所以我们自身也需要多思考如何减少电池损耗。 附录armv8 armv8 program guide","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"},{"name":"wakeup","slug":"wakeup","permalink":"http://djs66256.github.io/tags/wakeup/"},{"name":"XNU","slug":"XNU","permalink":"http://djs66256.github.io/tags/XNU/"}]},{"title":"Flutter 图片控件适配之路","date":"2020-12-10T15:33:36.000Z","path":"2020/12/10/2020-12-10-Flutter图片组件踩坑/","text":"背景目前大部分应用都会使用大量的图片，图片成为当前应用带宽占比最大的一种资源。在我们接入 Flutter 的时候，发现 Flutter 的图片控件缓存完全由自己管理，同时还没有提供磁盘缓存（1.22版本），所以在性能以及体验上均比较差，所以必须对其进一步优化。 图片缓存在目前很多 CDN 实现上，所有资源都是拥有唯一 uri 的，所以很多的客户端实现，是忽略了 HTTP 协议中的 Caches 能力，而是直接将 uri 作为唯一标识符来判断图片资源是否唯一的。这样大大节省了向服务端确认 304 的时间与请求。 而在客户端，一般都会存在至少内存和磁盘这两级缓存，而我们在接入 Flutter 图片库的时候，就希望能够将客户端的缓存与 Flutter 中的缓存进行打通，从而减少内存和网络的消耗。 而目前复用缓存的方向大致有如下3种： 复用视图，完全由客户端来提供 Flutter 的图片能力，就像 React Native 一样。 复用磁盘缓存，不复用内存缓存，这种方案实现相对简单，但会导致内存中存在两份图片数据。 复用内存缓存，由客户端从磁盘加载到内存，并由客户端来管理整个缓存的生命周期，比如和 SDWebImage 进行深度融合。该方案看似是最完美的复用，而且客户端有能力对整个应用的图片缓存大小进行精确的控制。 那么下面我们来看看这几种方案的实现，哪些看似美好的方案，我们都踩了哪些坑。 复用视图Flutter 提供了一种和客户端原生视图进行无缝拼接的方案，原始的动机其实是为了像地图、WebView 这种场景，Flutter 不可能再去实现一套如此复杂的控件。那么如果我们用这个来做客户端图片桥接方案会怎么样呢？ 首先，我们要明白 PlatformView 是如何进行桥接的（以下讨论的都是iOS实现）。在 Widget 中插入一层客户端 View，此时并不是我们想的那样，将此 View 简单的draw到 Flutter Root Layer 上。因为 Flutter 的draw call并不是发生在主线程上的，而是发生在raster线程上的，如果我们想要将客户端的 View 绘制到 Flutter 上，则必须先光栅化为一张图片，然后再进行绘制，这中间的性能开销与延迟显而易见是不可接受的，同时每帧都需要这么做也是不现实的。 所以，Flutter 采用了一种拆分 Flutter Layer 的形式。在插入一个客户端 View 后，Flutter 会自动将自己拆为2层： 123|-----| Flutter Overlay View 2|-----| Native View|-----| Flutter Root View 1 客户端 View 就像夹心饼干一样被2个 Flutter view 夹住，此时位于 Platform View 上层以及后续的兄弟 Widget 都会被绘制到上层的 View 上，其他的依旧绘制在底层。这样虽然解决了客户端视图的接入，但也会导致一个问题，当上层视图发生位置等变更的时候，需要重新创建对应的 Overlay View，为了减少这种开销，Flutter 采用了一种比较 trick 的做法，即 Overlay View 会铺满屏幕，而通过移动上面的 mask 来进行控制展示区域。 1234567891011121314// The overlay view wrapper masks the overlay view.// This is required to keep the backing surface size unchanged between frames.//// Otherwise, changing the size of the overlay would require a new surface,// which can be very expensive.//// This is the case of an animation in which the overlay size is changing in every frame.//// +------------------------+// | overlay_view |// | +--------------+ | +--------------+// | | wrapper | | == mask =&gt; | overlay_view |// | +--------------+ | +--------------+// +------------------------+ 目前已经解决了客户端视图接入 Flutter 的能力，但可以看到，当插入一张客户端 View，Flutter 需要额外创建2个 View 进行分区域绘制。当一个页面存在多张图片的时候，此时额外产生的开销显然也是不可接受的，性能更是不可接受。 下面是 Flutter 官方在 Platform View 上描述的关于性能的考虑。 123456789Platform views in Flutter come with performance trade-offs.For example, in a typical Flutter app, the Flutter UI is composed on a dedicated raster thread. This allows Flutter apps to be fast, as the main platform thread is rarely blocked.While a platform view is rendered with Hybrid composition, the Flutter UI is composed from the platform thread, which competes with other tasks like handling OS or plugin messages, etc.Prior to Android 10, Hybrid composition copies each Flutter frame out of the graphic memory into main memory, and then copies it back to a GPU texture. In Android 10 or above, the graphics memory is copied twice. As this copy happens per frame, the performance of the entire Flutter UI may be impacted.Virtual display, on the other hand, makes each pixel of the native view flow through additional intermediate graphic buffers, which cost graphic memory and drawing performance. 复用磁盘缓存让我们都退一步，我们首先解决网络带宽的问题，那么一个简单的方案便是复用磁盘缓存。 复用磁盘缓存的方案相对可以做的非常简单，并且拥有极低的倾入性。我们只需要设计一套 channel 接口，来同步双方缓存的状态和缓存的地址。 1234567getCacheInfo(&#123; String url, double width, double height, double scale, BoxFit fit&#125;) -&gt; &#123;String path, bool exists&#125; 那么在使用的时候，我们仅需要定制一套新的 ImageProvider，将网络、本地两种 Provider 统一起来即可。 123456789101112131415161718192021222324252627282930313233343536_CompositeImageStreamCompleter(&#123; String url, double width, double height&#125;) &#123; getCacheInfo(&#123;url: url, width: width, height:height&#125;) .then((info) &#123; if (info != null &amp;&amp; info.path != null &amp;&amp; info.path.length &gt; 0) &#123; var imageProvider; var decode = this.decode; if (info.exists) &#123; final imageFile = File(info.path); imageProvider = FileImage(imageFile, scale: this.scale); &#125; else &#123; imageProvider = NetworkImage(info.fixUrl ?? this.url, scale: this.scale, headers: this.headers); decode = (Uint8List bytes, &#123;int cacheWidth, int cacheHeight, bool allowUpscaling&#125;) &#123; final cacheFile = File(info.path); // 缓存到磁盘 cacheFile.writeAsBytes(bytes).then((value) =&gt; &#123; &#125;); return this.decode(bytes, cacheWidth: cacheWidth, cacheHeight: cacheHeight, allowUpscaling: allowUpscaling); &#125;; &#125; _childCompleter = imageProvider.load(imageProvider, decode); final listener = ImageStreamListener(_onImage, onChunk: _onChunk, onError: _onError); _childCompleter.addListener(listener); &#125; &#125;).catchError((err, stack) &#123; print(err); &#125;);&#125; 这里需要注意的是，当不存在磁盘缓存的时候，这里采用了 Flutter 来下载图片，此时需要我们手动将其保存到磁盘上，以保证磁盘缓存的一致性。 复用内存缓存复用磁盘缓存是风险较低的一种改动，但是代价是无法复用内存缓存，不仅仅需要分别读取，同时会保存多份内存缓存，因为双方的内存缓存部分是完全独立存在的。 那么如果我们想进一步优化，则需要采用复用内存缓存的方案，目前同步内存缓存大致有如下几种方案： 利用 channel 通信，将内存传输给 Flutter 利用新特性 ffi 通道，将内存直接传递给 Flutter 利用 Texture 控件，从纹理层面进行复用 ChannelFlutter 官方稳定的消息通信方案，兼容性和稳定性都非常高。当我们需要展示缓存图片的时候，只需要将图片数据通过 BinaryMessenger 形式传递到 Flutter 即可。 由于 Channel 本身就必须是异步过程，所以该方式通信会有一定开销。 同时由于 Channel 在客户端是在主线程进行处理，所以也需要注意避免在主线程直接做加载与解码等耗时操作。 而 Channel 在数据传递过程中，由于机制（从安全角度来看也必须这么做）原因，二进制数据必然会被拷贝一份，这样导致的结果是 Flutter 这边维护的内存缓存和客户端自身的缓存依然是两份，并没有完美的达到我们上述的复用效果。 ffi从消息通信开销以及消息的内存拷贝问题来看，ffi 的出现似乎能够完美解决 Channel 中所有的问题。 原理和实现过程与 Channel 完全一致，此时只需要替换为 ffi 通道即可。ffi 并没有像 Channel 那么长的通信过程，不需要进行消息序列化与解析，也不需要切换线程处理，就像一个 HTTP 请求和一个简单的 API 调用的区别一样。 这里我们需要注意的是 ffi 接口是同步执行的，也就是说客户端执行的时候是处于 flutter.ui 线程，我们必须注意线程安全问题。而对于 Flutter 来说，由于是在 UI 线程执行，所以该方法必须尽量快的返回，不能执行一些耗时比较长的操作。 但是我们采用 ffi 就真的能够解决上述问题吗？仔细研究发现，其实还是不能解决内存复用的根本性问题，下面可以看下 ffi 转换的过程。 当我们把客户端图片加载到内存的时候，是通过 Buffer 的形式传递给 Flutter 的，比如是这样一个结构： 1234struct Buffer &#123; int8 *ptr; size_t length;&#125; 而 Flutter 中图片解码过程会在 engine 层的 io 线程中执行，此时会进行一次图片数据拷贝。 所以，从最终结果来看，并不比 Channel 有更高的缓存复用能力。 Texture另一种是共享 PixelBuffer，也就是解码后的图片数据，在 Flutter 这里可以采用 Texture 来实现复用。 具体实现方案阿里已经研究的非常透彻，这里就不再复述了，我们主要分析下其性能与复用能力。 Texture 复用采用的是 TextureId，这是一个 int 值，所以在两端通信上不存在数据量上的性能开销。其主要过程是： 客户端将纹理注册到 Flutter，同时会返回一个 id 作为唯一标识符（i++）。这个过程发生在 Platform 线程，也就是客户端主线程，而真正注册到 TextureRegistry 中则是在 raster 线程中完成的。 在 flutter.ui 线程处理 paint 事件的时候，会将该 id 传递给 TextureLayer。 并在 raster 线程，从 TextureRegistry 中取出并生成 draw call。 从整体流程来看，Flutter 在中间流转过程全程只使用了 TextureId，并不会操作内存与纹理，并不存在多份缓存的问题。所以这种方案比较完美的解决了上述两个问题。 内存优化虽然从上述分析中，缓存利用率最高的是 Texture，但是从内存上来分析，则出现了一个意想不到的结果。 上图是使用 Flutter Image 控件，加载几张大图的一个内存图，总共增加了 10M 内存消耗。 上图是使用 Texture 方案，加载同样图片所产生的内存消耗，达到了 37M，相差巨大。 同时可以看到原生 Flutter 图片在初始阶段有一个比较大的波峰，同样纹理也有，但相对平缓一些。 产生这样大的区别主要还是要从 Flutter Image 控件的渲染流程中说起。 ImageProvider 将图片加载到内存后，首先会进行解码，而这个事情实在 flutter.io 线程完成的。 图片数据解码之后，会造成一个非常大的内存消耗，因为此时的图片数据是以 pixel buffer 的形式存储的。而 Flutter 在这一过程会进行一个优化，此时解码的数据将不是 100% 大小的，而是会当前 widget size进行调整，计算出一个最优的大小，然后在这一大小上进行解码，所以原生的 Image 反而在内存占用这个方面会比客户端更优秀。 在图片移除后，Flutter 会立刻回收解码后的内存，即 Flutter 仅对图片的原始压缩数据进行存储，并不缓存 pixel buffer。而我们客户端（SDWebImage）则会缓存解码后的全部数据，这也是另一个 Flutter 内存表现比客户端要优的地方。 那么 Flutter 这种策略在内存占用上完胜客户端，是否就必然是好的呢？ 其实从渲染流程中看，Flutter 仅仅是用解码时间换取了内存空间。在实际 Demo 中，列表快速滑动时，Flutter Image 控件的图片展示会有明显的延迟，而采用 Texture 方案，肉眼几乎无法分辨。所以从整体的表现上来说，Texture 方案并不是没有优点。 Size从上述中可以看出来，Texture 方案在内存的表现上比较差，那么我们如何去进一步优化呢？ 对于很多场景，比如用户头像等，都是有一个固定大小的，那么我们可以将该大小作为参数，传给 CDN，在 CDN 上就进行裁剪成我们需要的大小，这样也会节省大量流量。 但是同样有很多场景，我们是无法得到其控件大小的，比如充满容器大小这种场景。我们如何自动在所有图片上加上 Size 参数呢？ 从渲染过程中，Layout之后会触发Paint，而此时该控件的大小必然已经是完全确定的了，那么我们可以在这里做一个假的占位控件，在计算出大小后，再替换为真正的图片。 123456789101112131415161718192021222324252627282930313233343536373839404142typedef ImageSizeResolve = void Function(Size size);class ImageSizeProxyWidget extends SingleChildRenderObjectWidget &#123; const ImageSizeProxyWidget(&#123;Key key, Widget child, this.onResolve&#125;) : super(key: key, child: child); final ImageSizeResolve onResolve; @override ImageSizeProxyElement createElement() =&gt; ImageSizeProxyElement(this); @override ImageSizeRenderBox createRenderObject(BuildContext context) =&gt; ImageSizeRenderBox(onResolve); @override void updateRenderObject( BuildContext context, covariant ImageSizeRenderBox renderObject) &#123; super.updateRenderObject(context, renderObject); renderObject.onResolve = onResolve; &#125;&#125;class ImageSizeProxyElement extends SingleChildRenderObjectElement &#123; ImageSizeProxyElement(RenderObjectWidget widget) : super(widget);&#125;class ImageSizeRenderBox extends RenderProxyBox with RenderProxyBoxMixin &#123; ImageSizeRenderBox(ImageSizeResolve onResolve, [RenderBox child]) : onResolve = onResolve, super(child); ImageSizeResolve onResolve; @override void paint(PaintingContext context, ui.Offset offset) &#123; if (hasSize) &#123; if (onResolve != null) onResolve(size); &#125; super.paint(context, offset); &#125;&#125; 这样，我们就能强制所有图片都必须带上 Size 参数了。 经过这样的优化处理后，内存占用下降到了 2M 左右（由于我用的测试图都是高清图，所以效果看上去会比较明显）。 总结Flutter 的很多思路和策略和客户端有着明显的区别，从图片这一个能力来看，就可以从各个方面进行适配与优化，如果需要达到完美可用的一个状态，看来还是需要不断的投入与探索。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/tags/Flutter/"},{"name":"Image","slug":"Image","permalink":"http://djs66256.github.io/tags/Image/"},{"name":"Texture","slug":"Texture","permalink":"http://djs66256.github.io/tags/Texture/"}]},{"title":"谈谈 Flutter、客户端、React 组件的几个区别","date":"2020-12-01T15:37:30.000Z","path":"2020/12/01/2020-12-1-谈谈Flutter与React的几个区别/","text":"Flutter 是 Google 新的一种跨端方案，大家都非常的看好他的上限。但是实际和大家了解下来，却处于一种比较尴尬的地位。客户端开发觉得这个和原生开发相差很大，学习成本陡峭，而前端又觉得这是一个客户端的技术，同时 dart 语言也远没有 js 灵活好用。但技术总是万变不离其宗，很多思想其实都是殊途同归。这里我们就简单讨论一下 Flutter 与 React 之间的一些区别与联系，有 React 开发经验的同学会更容易理解。 Widget 与 Component 与 ViewFlutter 的 Widget 是页面的最基础组成部分，这个很类似与 React 中的 Component 和客户端中 View 的概念，但却又有本质上的区别。 首先不同的点是 mutable，Widget 是不可修改的，一旦创建就无法进行修改，因为一旦修改了其内容，就无法正确的对其进行 diff。这一点其实和 Component 很相似，虽然 Component 可以直接修改，但本质上还是需要通过状态机进行更新。而 View 则是完全开放其修改的能力的。 其次，概念本身会有区别，大致可以这么认为： 1RenderWidget + RenderElement + RenderObject == Component + &lt;div&gt; == View Widget 不一定会承载视图，即可能承载的是纯粹的业务逻辑或者消息通信能力，不像 Component，即使是个桥接能力的组件，也会生成一个 div 标签。粒度比 Component 更细，这可能也是前端同学觉得不够灵活的一个原因吧。 当 Widget 承载视图的时候，也不是直接承载的，而是通过 RenderElement 进行管理状态，RenderObject 管理布局与绘制。从客户端的角度看，可能这样的对应关系更为贴切： 12RenderElement -&gt; ViewRenderObject &gt;= Layer 从绘制角度看，一个 Widget 未必就代表一个图层，而对客户端来说，一个 View 则必然代表一个或多个图层。Flutter 会对其进行优化，将多个 Widget 合并到一个图层上进行绘制，也有可能一个 Widget 会拆分为多个图层。虽然业务开发过程中不会接触到这个概念，但是必须了解其不同点。其中 RepaintBoundary 就是强制进行拆分图层的一个组件。 Stateful 与 StatelessFlutter 和 React 进行界面更新，都是通过状态机进行的，个人认为这种思路非常的优秀，而客户端则很少基于这种思路进行开发。从性能来看状态机流程所需要处理的流程会多的多，而目前来说，基本不存在这种瓶颈，但在开发过程中却需要一定的技巧，减少状态变更导致的视图树重建开销。 在 React 中，并没有严格的 Stateful 和 Stateless 的区分，只有 class component 和 function component 的区别，Flutter 将这两个概念进行了严格的区分，不允许混用，同时 Flutter 将很多不同类型的能力都进行了特化，目的就是为了进一步的优化性能。 在 Flutter 中 Stateless 仅仅是对于 Widget 层的逻辑而言，并不是代表了这个组件是完全不会有状态更新的，这个在下面的依赖绑定中可以看到。 Dependency依赖绑定是 Flutter 中的一个优化特性，React 也可以做到同样的能力，但似乎并不是官方提供的能力。 依赖绑定让我们拥有了一种控制局部更新的能力，最典型的就是系统的 Theme 组件。如果没有这种能力，那么我们必须在每个使用该能力的地方，都注册监听来更新当前状态机，或者直接重建整棵树。前者会大大增加代码复杂度，而后者则会大大增加性能开销。 个人觉得依赖绑定特别适合应用于数据类型状态机与组件之间的关系绑定。比如当前用户信息状态，不同页面信息状态同步等，这种范围相对较大，同时又需要在多个地方进行数据同步。甚至我们可以实现自定义规则的依赖绑定，这些都可以根据我们的需要进行。 举个例子，当前用户头像中 VIP 状态同步，可以思考下直接使用 instance 和使用 of 之间的区别： 123456789Widget build(Context context) &#123; return AvatarImage(&#123; url: CurrentUser.instance.avatarUrl, childBuilder: (ctx) &#123; final currentUser = CurrentUser.of(ctx) return currentUser.isVIP ? VIP() : null; &#125; &#125;&#125; 依赖绑定\b的发挥空间很大，很多功能都可以考虑下这种能力。 LayoutFlutter 中的布局方案和前端基本保持一致，都是 Flex 布局。但是在 Flutter 中，布局模式被切分为各个子项进行特化，并且是与渲染组件是分离的，而不像网页那样，单个组件可以添加各种属性。这种改变让我感觉特别不适应，更不要说前端开发了，但这对于第一次接触的人来说，学习成本似乎会低一些。 前端写法类似于： 1234567Foo( style: &#123; padding: xxx, width: xxx, height: xxx, &#125;) 而在 Flutter 则需要改为如下结构，似乎变得更加啰嗦了。 12345Padding ( SizedBox ( Foo() )) 布局拆分特化同时也减少了代码复杂度，以及自己新增布局能力的灵活性。 总结可以看到，这几种技术的基本元素依然可以关联起来，只是各自有各自的一些独特能力，相信了解 React 或者 SwiftUI 这种框架的人应该能够很快适应这种开发。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/tags/Flutter/"},{"name":"React","slug":"React","permalink":"http://djs66256.github.io/tags/React/"}]},{"title":"RN优化实践之拆包与预热","date":"2020-10-17T09:24:08.000Z","path":"2020/10/17/2020-10-17-RN优化实践之拆包与预热/","text":"随着RN技术在业务中广泛的应用，一些比较重要的功能也开始采用RN的方案来进行了，这就给RN页面的打开速度提出了更高的要求，因为打开速度是影响用户跳出率的重要原因之一。 拆包对于RN打开速度优化，业界比较通用的方案也就是预热+拆分基础包，减少容器初始化时间和基础库加载时间。 对RN进行拆包可以依赖于官方提供的工具进行，但是官方提供的能力是JS内部的一个拆分加载，如果我们需要做容器预热，则无法使用官方的加载方案，而需要我们从客户端原本的逻辑中进行，进行多步加载。 我们需要对RN的逻辑进行改造，就需要对RN初始化逻辑有所了解。 上图是一个大致的过程，这里我们对比较关键的几个步骤进行简单的说明。 RNBridge在实例化之后，会首先准备好JS运行线程和原生模块。 然后会创建一个JSExcutor，这个执行器决定了JS执行环境是客户端还是远程调试（安卓可以是自己定制的执行器，比如v8）。 加载源码（bundle），这个根据来源不同可能是从本地加载，也可能通过url从远端加载。 由于初始化JS执行器和代码是并行触发的，这里需要一个栅栏同步两者结果，之后开始将代码放入执行器执行（JS代码运行）。 在此之后，客户端会监听垂直同步信号（该信号的作用是在页面发生变更的时候，需要重新刷新页面）。 此时RootView收到JS加载完成的通知，开始触发RunApp逻辑，该逻辑就是启动前端的app注册表中对应的应用。 整个流程比较长，但是分工还是相当明确的，此次拆包改造的地方也非常明确。 上图中绿色框内就是我们此次改造的点，这里为了逻辑简单与实际需求，将加载代码设计了串行加载，如果有需要，加载过程也可以进行并发。 这里我们对加载能力进行一次抽象，加载一段代码定义为一个SourceLoader，那么一个拆包bridge就相当于有一个加载器列表，对应于bridge上的属性就非常简单。 1234567@property (nonatomic, strong) NSArray&lt;id&lt;RCTBridgeSourceLoaderProtocol&gt;&gt; *preloadSourceLoaders; // 预加载的加载器- (void)preloadSourceWithCompletion:(void(^)(NSError *error))completion; // 触发预加载加载器@property (nonatomic, strong) NSArray&lt;id&lt;RCTBridgeSourceLoaderProtocol&gt;&gt; *sourceLoaders; // 非预加载加载器- (void)loadSourceWithCompletion:(void(^)(NSError *error))completion; // 触发非预加载器- (void)loadAllSourcesWithCompletion:(void(^)(NSError *error))completion; // 先加载预加载代码，再加载非预加载代码 这里有一个需要注意的点是，我们需要启动一个垂直同步信号监听，为了性能考虑，需要在预热容器加载到真正视图的时候才能开启，所以这里对加载器增加一个标记，只有加载到该加载器之后才能开启监听。 经过这样的改造，我们的RN就已经支持了多包分布加载了。我们就可以把一些基础功能的js代码打包进app内部，也减少一些包大小。 容器预热以上的分包加载并不能对加载速度有太大的影响，而真正的优化点是容器的预热，可以将很多准备工作先做了，在业务加载的时候只会触发加载业务代码与渲染页面。 受限于手机性能的局限，以及一些苹果官方的策略，我们不太可能无限制的去使用该能力，所以这里按3个方面来看预热。 预热触发时机 目前预热触发的时机主要有下面3个点 冷启动 热启动 容器复用之后 在这些时机触发之后，再延迟一定时间（几秒），进行创建预热实例。延迟一会的原因是这些时机大概率都是在做一些CPU密集型任务，如果此时再加入创建预热容器这种非必须的任务，反而可能影响主业务的一些性能。 预热容器销毁 目前销毁的时机主要有下面2个 内存警告 进入后台 进入后台销毁的目的主要是为了降低后台运行的内存，虽然影响不是很大，但是目前苹果对后台app策略还是比较严格的，减少一点是一点。 预热的场景化 由于RN这种业务在我们的业务中并不是主流业务，可能大部分用户都不会使用到RN，而我们对全量用户进行无差别的开启预热功能，也不是一种最优的方式。目前我们还没有能力对用户场景进行机器学习这样的智能化分析，那么这次就对一些场景做一下简单的归类： 3天内没有使用过RN，则认为该用户 3天内没有由于内存警告而销毁的记录 当前应用启动周期内： 预加载失败3次，则该周期内不再启用预加载 容器预热的关键点是在不影响用户其他体验的时候，尽可能的提高预热的命中率，目前做的一些策略都比较简单，后续如果要优化，就需要深入业务场景中。 总结此次RN的优化分为拆包和预热两部分，各自能力独立，并分别进行AB控制，最大可能保证稳定性。后续优化将会深入业务场景去做一些优化策略。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"}]},{"title":"跨端能力平台化建设","date":"2020-10-05T14:12:59.000Z","path":"2020/10/05/2020-10-05-跨端能力平台化建设/","text":"跨端能力一直是近些年来的大热门，我们对跨端能力也一直抱有非常高的期望，我从2016年开始就一直关注着跨端能力的发展，经历了其中各个发展阶段，而目前我们团队也将建设整个跨端平台化能力，这里就来讨论下跨端的一些东西，以及我们的平台化会如何建设整个生态。 我们真的需要跨端能力吗跨端的发展基本经历了这么几个阶段，h5-&gt;RN/weex-&gt;小程序-&gt;flutter，而最近flutter成了最火爆的弄潮儿，但是我们可以看到，每种跨端方案在提出之初，都被吹捧为将会颠覆整个客户端开发，而现实却是原生开发依然占据着无法撼动的地位。 我在早期也非常的看好跨端方案，因为这是唯一一种能够同时大量降低业务开发工作量的方案，而且跨端的很多技术方案也是领先原生开发一个世代的，无论从学习成本，开发效率以及一些前后端融合的趋势都有着非常优秀的设计，以至于我一直认为跨端将是原生开发的未来，原生开发模式的终结者。然而后续的现实却深深的打了我的脸，从facebook放弃h5以及RN，阿里放弃weex，说明当时的跨端方案几乎是失败的。为什么我会认为当时的方案几乎是失败的，我们又将如何对待跨端这项技术呢，接下来我们可以简单的分析一下。 早期的跨端方案是失败的早期的跨端方案基本都是打着消灭原生开发的口号而进行的，从Facebook对h5的各种优化来看，认为当前的网页早已经能够承担所有能力了，而且随着手机摩尔定律的发展，不用几年，手机就会和电脑一样，能够很好的承载网页了。而现实却是Facebook最终还是没有等来那个美好的未来。 随着前端技术的快速发展，衍生出了react和vue这样的技术，这项技术给前端的开发模式带来了巨大的变革，从此前端不需要再依赖jQuery这样去操作具体节点了，所有DOM节点都被抽象化，这给也给一批跨端先驱者们带来了曙光。既然DOM节点可以被抽象化，同样的原生View也可以被抽象化，并通过映射关系，组建原生视图。可以说，这种思路是一个跨时代的想法，第一次前端与原生应用进行了一次激烈的碰撞。这种碰撞也催生了众多的新的思路与设计理念（比如swiftUI，个人也将部分理念贯彻到了原生开发之中，来解决原生开发的一些问题），在跨端方面也催生了RN和weex这两种方案，这两种方案都以write once, run anywhere这样的主旨努力，想要统一前端、iOS、安卓这几个平台。 但这些技术的最终结果却是很悲惨，Facebook放弃了h5和RN，目前RN也只是开源爱好者在用爱发电了，而阿里也逐步淘汰了weex，可能国内某些厂在内部还在维护一些魔改版。两大创时代的技术创造者最后却放弃了，这让我陷入深深的怀疑，跨端的方向是否是正确的。 大家可能会说，现在还是有大量的公司在使用这种方案，并不代表这项技术是失败的。但我个人认为它的失败在于它并没有完成最早所承诺的能力与效果。 实行这种方案对人员素质要求非常高，需要开发仅对前端、移动端都有所涉猎，在出现一些兼容问题的时候能够自主解决该问题。而现实是这种人才真的太少了，特别是在国内的这种环境，要找到并留住这种人才是非常困难的，而如果人员素质没有达到如此高的程度，那么会大大增加多端的沟通成本，甚至比原生开发需要更多的人力成本（以个人经验来看，一旦涉及到跨端能力接入，那么至少需要1iOS+1安卓+1前端人力，包括接口设计、调试等沟通时间，未必会比原生开发减少太多的人力）。 如果缺乏一个能够掌控全局的人，那么每次需要一个原生能力的时候，便会新增一个接口，而这些接口能力并没有经过良好设计，从而导致这些能力的复用性极差，以至于后期这类接口能力的爆炸，无法维护。这类问题虽然看似比较少见，但在一个业务快速膨胀的团队，仅需要1年时间就可以让沟通成本急剧增加。（不要说文档，如果文档能够解决这类问题，也就不存在前后端接口爆炸的问题了，而且文档也是一种大大增加沟通成本的东西，并且我不相信目前国内有哪个团队在文档这块做到及格的。） 双端有着这种不一致的体验与设计语言，write once, run anywhere这个理念本身就是一个无法达到的乌托邦，并且react-native自身也认识到这个问题，并没有把run anywhere作为自己的目标，而是区分对待两端的特殊性，而在上层进行整合这种特殊性，所以依然无法逃避在不同平台实现不同逻辑。而weex则更激进一些，甚至将原生View给映射为div这种前端标签，想要一次性整合3端，然而这种巨大的不一致性所导致的结果是彻底的失败，最终还是仅仅在移动端进行了部分整合。 当然这些跨端方案还有另一个问题就是通信成本特别高，特别是一些实时性、流畅性要求高的场景，往往是达不到要求的。 综上所述，早期的跨端方案在多个维度都没有兑现自己的想法，所以我认为是失败的，但是这些方案却给我们带了一个意料之外的惊喜，那就是动态化，这个之后再说。 特定领域跨端化实践在经历了早期跨端实践的失败后，大家都开始思考跨端的未来，如果还是想要统一各端的开发，那么很有可能将会经历一样的失败。此时微信找到了一个极好的应用场景，那便是小程序。 小程序这种场景有着这么几个特点： 对动态性要求特别高，因为苹果不允许执行下发动态库，所以必须采用动态化特性 对性能要求一般，但对功能要求较高，需要能够满足大量现有能力 要求较好的隔离性，由于子应用是可以由3方提供服务，那么主应用与子应用之间必须是单向管理的关系，需要严格限制子应用的能力特性，以防被3方软件滥用 要求较高的鲁棒性，主应用就相当于操作系统，能够保持每次升级与优化的兼容性与一致性 那么从以上几个特点来看，设计一套简化版的DSL是必须的，同时需要设计自己的通用能力与权限系统，以及OAuth2认证等。而目前最为符合，同时也是最小开发量的就是h5技术，所以目前常见的小程序基本还是以h5容器为主。 小程序的出现，不仅仅是跨端领域的一次新的尝试，同时也是业务领域的一个创举。小程序的出现，将一个普通的应用，演化成一个完整的平台系统，不仅仅给其他公司提供了一个发展的平台，同时也帮助自己巩固自身的平台地位。将一个巨应用，逐步转化为微应用集合，减少各类成本的同时，也极大的丰富了这种功能服务。可以说小程序就是大平台应用的一次战略性布局，当然现在已经展示出了它的价值。 这次，小程序给跨端指明了一个方向，那就是在特定领域创造价值。 统一移动端思潮的亡者归来flutter的出现，大家又掀起一次跨端思潮的崛起，但这次的崛起，似乎减少了对双端的统一要求（安卓的material与iOS的cupertino），大家似乎已经从狂热的思潮中冷静下来，认识到了各端不一致性的必然性，以及用户对各自平台的接受程度，这次的革新，似乎已经不是write once, run anywhere这样的呐喊，而更多的是对所有“大前端”的开发模式的一次统一。（有很多人认为write once, run anywhere就是flutter的目的，并且是跨端的终极模式，个人认为并不是，这个口号官方从来没有喊过，而且flutter的野心比单纯的实现跨端方案要大的多） flutter的目的并不是单纯的实现一个跨端方案，所以就决定了所采用的技术就不会依赖于各个平台的UI层，它从最基础的GPU绘制开始，完全使用自己的能力，这是一套非常完整的UI框架。由于flutter完全抛弃了各平台的UI层，那么便不存在各个平台的差异性了（这其实也是个坑），理论上可以做到不需要做任何兼容性实现。但现实却是，平台的差异性目前已经深入人心，粗暴的提供一种效果和习惯并不能收获用户最好回应。但是如果你是想要拿着flutter去实现安卓的效果，或者实现iOS的效果，那么你可以打消这个念头了，他能做到的最多是“模拟”，而非“实现”。 那么flutter的应用场景就比较固定了，我们依然只能在一些重业务与展示的场景去使用，而在个性非常突出的场景，以及涉及到大量原生能力的地方，就显得不那么适合了。 为什么我会认为flutter想要打造一个完善的统一的UI开发平台才是其真正的目的。由于目前移动端的开发人员依然比较割裂，而未来的趋势必然是整个前端的大融合，甚至是与部分后端的融合，让业务方去关注整个业务而不是业务的一个点，这样的融合就必须首先统一各端的开发模式以增加效率和人员的流通性，可以说flutter的出现对于移动端未来发展也有深刻的影响。 所以在此看来flutter依旧不能完全实现跨端统一这一乌托邦，但是其引入的很多前端思路将会给目前的客户端开发模式带来足够的冲击。由于flutter这个项目还在快速发展中，所以我会进行持续关注。 跨端能力总结在进入跨端平台化建设之前，我们花了大量的篇幅来回顾各个时间段的跨端发展历程，我这里更多的采用了批判性的角度去看待这些技术，目的是为了找到各个技术的局限性与应用场景。各种技术都有自己的优势与局限性，我们无法将其单纯的判定为成功与失败。 跨端的思路也给我们带来了一些业务上的创新力与未来开发模式的一次变革机会。我们可以看看如何做所有跨端能力平台化整合。 平台化目前业务的发展导致当前项目中引入了多种跨端方案，而在如此多的方案中，我们又该如何选择，如何去有效的利用各个能力，这是我们希望完成跨端平台化的初衷。 跨端方案想要解决的问题无非是两大类： 动态性（快速迭代） 开发效率（成本） 由于客户端应用更新的特性，导致我们的新功能、新特性永远无法第一时间到达用户手上，从安卓碎片化程度来看，就知道想让用户保持更新的习惯是多么困难的了。那么在一些场景，比如活动、微应用等，会非常依赖于实时性调整，就会有强烈的动态能力要求。 而效率问题一直是我们所探讨的，虽然有很多种解决效率问题的方案，但跨端给我们提供的一种思路似乎就是一种万能且直接有效的方案，能够大量缩减客户端的人力，毕竟前端人员比客户端人员会好招的多。 但是跨端方案毕竟不是万能的，在诸多方案上还是拥有大量限制，而理想化的一些优势也需要在特定场景才会有明显的发挥。我们想要组建的平台化，也将会从各个方面去帮助业务与开发人员去正确的选择方案，并且提供一系列完整的能力去保障业务的完好运行。 平台化整体能力大部分时候，我们关心的都是开发阶段的一些问题与解决，开发虽然是跨端方案影响和作用最大的一个环节，但在整个过程中，开发仅占用一部分环节。既然我们希望做一个平台化的能力，那么我们就必须考虑到整个过程的能力。 首先我们需要明确的是，我们的目标是希望所有参与人员，都去关注整个业务，而不是自己这一环节，之前也说过这是未来业务开发模式的一种革新方向。我们不希望产品提了需求就不管了，也不希望开发测试仅仅跟踪到上线这个环节。目前难以做到这一点的主要原因是因为整个流程是割裂的，不同环节都隶属于不同的团队，业务分工足够细，且需要大量人员参与。这种问题在越大的团队会越明显，那么需要平台化去整合的需求也会越强烈。 同时，在整个过程中，人员的因素太过于复杂，需要协调好各个人员与角色，显然不可以仅仅通过沟通与默契来解决，我们必须在整个过程中加入足够多的自动化过程，来推动整个流程的前进，而这自动化的过程，就需要平台化的能力。 跨端方案有很多选择，其之间有很多的相同点，也有很多的区别，而我们在整个过程中，如果因为这其中的不同，从而分化出不同的开发流程，反而会给所有人带来很大的困惑，增加各自的人力成本。 所以可以看到，平台化来整合所有能力也是非常重要的。 业务维度细化如果需要实现以上所说的全流程整合，那么每个业务功能则必会细化为一个个微服务，或者说是微应用。每个业务模块也是按照一个应用的流程来管理。 由于这些应用（业务）所承载的服务其实是比较小的内容，所以人员可以变得灵活调配，与普通开发人员调动不同，调配的不仅仅是“人力”，而是微型“团队”，以此也可以大幅减少沟通成本。 业务细化肯定会带来大量的微应用，就像淘宝这样的巨应用，存在着无数的微应用。我们需要管理所有的微应用，则不论使用跨端技术，都需要提供一套统一的管理流程。 在我们拥有这一个完整的流程后，可以来看看每个阶段需要哪些东西。 技术选型在业务方案的选择中，我们可以提供一个简单的筛选条件，但是并不是一个强制的约束。 在具体的业务场景中，我们所需要考虑会比这些条件多的多。比如有些强依赖原生能力的业务需求，如果我们使用跨端方案去实施，最终结果可能完全的违背了跨端的优势，从而导致多端开发的成本直线上升，可能短时间内看似美好，但从长远来看，将会陷入维护的泥潭。 所以这在很多场合是一个比较经验主义的过程，在我们选型的时候，不要先入为主的去决定使用哪种技术，而应该仔细分析业务场景，使用什么技术可以满足需求的同时，尽可能的减少成本。 框架在引入跨端方案的时候，如果我们毫无节制与约束的使用，最终肯定会变得非常糟糕，那么在此基础上必须有一定的规范来组织与约束大家的使用。 那么下面我们从组织结构、抽象层、沙盒化三个角度进行分析。 组织结构 我们的结构大致分为以上几个层次，这里解释一下中间2层代表的是什么。 基础能力桥接层，是与业务无关的能力，是组建所有应用都需要使用到的能力，可以认为这是一套像POSIX标准接口的定义。所有app内的这一层都是相同的，那么在我们想要移植一个跨端应用到另一个app的时候，就会变的非常简单。事实上我们也的确有一些这样的需求。另一个好处是，统一的标准能够让开发人员更好的进行跨应用间的开发，就像为什么支付宝会故意去抄袭微信小程序的api规范一样。 业务相关桥接层，每个应用必然是会有各自业务的特殊性，导致一些无法进行标准化与通用的能力，那么我们就需要这一层来做一些脏活了。 抽象层 为了满足上述组织结构中的标准接口定义，那么我们必须要引入一个抽象层，来屏蔽各个跨端技术与app之间的不同。 我们的抽象层大致是这么设计的，实现方案这里就不讨论了，后续会增加一篇该方案的文章[Native RPC]。抽象层给使用者与开发者都屏蔽了多端的特性，所表现出来的是完全的一致性。 我们会有一个专门管理接口定义的平台，从该平台上可以自动生成接口调用代码与demo工程，这样可以大大减少接入、测试、回归等成本。 沙盒化 业务细化后我们必须面对的是这些业务对主应用的影响，以及相互之间的影响。这种影响客户端以及平台层面上是无法把控的，所以需要对各个微应用之间进行沙盒化隔离。 沙盒化后带来的另一个需求则是权限管理，由于目前业务都是面向内部的，所以权限方面要求不是特别严格，这里暂不将权限控制作为重要的一环。 业务层多平台统一 上面所涉及的都是跨端与原生之间的一个统一，那么在各个跨端之间的也可以进行一次统一，比如比较有名的有Taro, rax等。 但这种统一仅仅是为了降低前端开发的学习成本与一些降级策略，强行将这些东西糅合到一起，反而可能会导致开发成本变高，不兼容性与性能下降。在我们有比较固定的人力做单平台业务开发的时候，完全没有必要再引入一层复杂的适配，带来额外的复杂度。 这种方案的适用场景比较局限，适合大量且业务复杂度不高的业务，可以快速搭建与上线，适合多平台3方应用的接入，比如各个平台的小程序。 所以这里并不考虑把这种方案作为我们其中一个目标，就像阿里也并没有吧rax作为内部的主流技术。 测试由于我们的跨端能力大部分是使用在业务场景中，所以大部分场景做自动化测试的成本都非常高，所以测试环节基本将会是黑盒测试。而得益于部分跨端技术的动态性，问题的修复成本与原生开发相比会小很多。 线上监控我们选择跨端应用的时候，会比较担心一些跨端应用的负面效果，比如性能，错误率等，所以必须建立比较完善的线上监控系统。 监控系统应该具备我们普遍会关心的一些数据，比如加载时长、错误率、性能指标等，同时提供横向对比的能力，提供业务方一个指导性的意见，同时增强线上预警的能力。 现在这么多不同的跨端技术方案，面临的问题是监控系统的分散，从而无法形成有效的闭环，所以建立一个统一的完整的系统，串联整个迭代链路。 总结随着跨端技术的发展与应用，也给我们的很多基础设施提供了巨大的挑战，如何将跨端的优势真正的发挥出来，来提高我们的效率与灵活性，这是我们必须面对与解决的问题，而在这之中，如何完善与整合多端能力则是重中之重。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"跨端","slug":"跨端","permalink":"http://djs66256.github.io/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"h5","slug":"h5","permalink":"http://djs66256.github.io/tags/h5/"},{"name":"小程序","slug":"小程序","permalink":"http://djs66256.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"react native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"flutter","slug":"flutter","permalink":"http://djs66256.github.io/tags/flutter/"}]},{"title":"谈谈苹果禁用HTML5应用","date":"2020-02-08T04:06:53.000Z","path":"2020/02/08/2020-02-08-谈谈苹果禁用HTML5应用/","text":"苹果在2019年更新了审核条款，其中可能对我们影响最大的就是HTML技术的应用了。 App Updates for HTML5 Apps 总所周知，苹果一向以来都不喜欢动态特性，从最早的其他语言限制，以及到jspatch的禁用。这里涉及到的就有两个问题了。 一是苹果自身所说的保证其生态以及用户体验一致性，这样的确能够淘汰一大批低质量和壳应用，清洗了整个生态环境。 二则是苹果自身的利益。苹果不予许一些应用绕过他的审核，来做一些事情。 国内开发者对于苹果对动态化的态度非常的不满，目前国内对于动态性的热情依然还是非常高涨，这得益于国内软件开发现状。但在我看来，这事情有好有坏。 对于我们客户端开发来说，这个饭碗不会那么容易丢了。 目前市面上的应用参差不齐，还有很多违法的，这的确能够减少很多这样的现象。 对于大部分应用来说，有没有动态化其实并没有太大的影响。 反对的人则主要觉得： 无法热修复（这个人觉得真不能怪苹果，自己的质量不过关，给应用埋下一个后门真的不太好，特别是一些涉及用户隐私和金钱的） 无法实现3端统一，无法一套代码多端使用，减少人力成本。（个人认为想要做3端统一，则必须要牺牲一些平台特性，反而可能造成不符合当前平台的行为。而所谓的write once，目前证明大部分都是夸张的。阿里已经抛弃weex，Facebook自己也没有用RN。至于较少人力成本，这个还真不一定，毕竟想要找到能够了解多端特性的人才还是非常困难的。） 快速响应，快速上线（由于苹果的审核机制，这个是国内最大的痛点。这可能与国内的环境有关，没有长远、详细的计划，经常改变策略） 那么我们真的无法使用HTML5技术了吗？下面我们来解读一下苹果条款。 App Store Review Guidelines: 4.7 HTML5 Games, Bots, etc. Apps may contain or run code that is not embedded in the binary (e.g. HTML5-based games, bots, etc.), as long as code distribution isn’t the main purpose of the app, the code is not offered in a store or store-like interface, and provided that the software (1) is free or purchased using in-app purchase; (2) only uses capabilities available in a standard WebKit view (e.g. it must open and run natively in Safari without modifications or additional software); your app must use WebKit and JavaScript Core to run third-party software and should not attempt to extend or expose native platform APIs to third-party software; (3) is offered by developers that have joined the Apple Developer Program and signed the Apple Developer Program License Agreement; (4) does not provide access to real money gaming, lotteries, or charitable donations; (5) adheres to the terms of these App Review Guidelines (e.g. does not include objectionable content); and (6) does not support digital commerce. Upon request, you must provide an index of software and metadata available in your app. It must include Apple Developer Program Team IDs for the providers of the software along with a URL which App Review can use to confirm that the software complies with the requirements above. 苹果并没有禁止HTML5，而是指出要合理的利用HTML技术。从苹果最终还是上了PWA这件事上来说，苹果并没有阻止HTML5这样的技术。苹果只是希望控制应用的权限，不要做一些挂羊头买狗肉的事情。那么我们来看看目前几种比较热门的技术吧。 RN、WEEX苹果已经警告过这两个方案了，后续虽然苹果并没有对这两个技术下手，但个人觉得从这次苹果的态度来说，还是非常反对这种技术的，因为这个技术太容易做到挂羊头卖狗肉的事情了。虽然这个和热修复来说，只是公开了有限的能力，但其本质上来说和HTML5应用还是一样的。 那么我们一点都不能用了吗？以目前苹果的态度来说，也没有完全禁止，只是禁止使用这些技术做核心功能，而一些次要功能应该暂时还是安全的。如果是纯RN应用，那么个人建议还是尽早想想退一步的方案了。优化好的网页也不比原生的差。 小程序小程序这个其实已经动到了苹果的利益了，如果你不是大厂，个人不太建议去试探苹果。 而这次更新，苹果更是明确说了HTML5应用更适合在浏览器上使用，而不是一个独立的app。\b所以个人并不太看好这个方案。 flutter以目前来看，最符合苹果的方案只有flutter了。 因为在iOS系统中，flutter是以二进制打包进去的，并没有违反苹果的条款。 听说咸鱼团队已经开始做flutter的字节码虚拟机了。恩。。。这个个人还是持保留态度，也建议小厂不要没事和苹果干。 最后最后，我们需不需要动态特性依然还是需要看自身业务需求，大量展示型的，没有复杂交互的页面使用这类技术的确拥有更多优势，但是动态性的投入产出比可能并不一定能有那些技术宣传的那么好。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"开发标准化杂谈","date":"2020-01-31T14:12:41.000Z","path":"2020/01/31/2020-01-30-开发标准化杂谈/","text":"在iOS开发这一块，国内的标准化做的都不太好，和国外的一些项目相比，差距非常大，所以这里就来谈谈标准化的重要性吧。 标准化需要标准化的场景非常多，比如： 文档 代码规范 接口 方案设计 就拿文档来说，目前应该几乎没有对注释的覆盖率有要求的，特别是客户端这种以写业务为主的场景，没有注释那是自然的。 Why为什么个人非常看重标准化这个问题。 因为在这些年的工作经验中，发现有很大一部分bug是由于标准化做的不足而引起的，而这些问题往往是那种非常简单的错误。 另外一个是在做一些重构或者整合的时候，没有做标准化的业务几乎很难去重构，需要花费大量精力去“适配”这种不标准。 比如： 用户id的定义，可能是id，userId，resourceId，这些不同的名字往往会让人非常困扰。更为困扰的是拥有相同名字，却有不同的含义的内容。 这些都非常影响软件的质量。 How其实这类问题并不是我们才有的问题，这些问题基本上都有现成的比较权威的方案。 比如代码规范，Google整理的各种语言的规范，阿里的java白皮书这种都可以参考。 比如接口中分页的设计，以前总要在pageSize，lastId，lastTime等众多方案中挑选一种，而没有采用一些更优秀的设计（可以参考GraphQL的分页方案）。 标准化的解决方案，大部分问题我们都可以参考现有的解决方案。 困难虽然标准化这个事情看起来非常简单，但是要实施起来却非常困难。 标准化不仅仅是单端的问题，甚至可能从需求方开始就要改善。这样所涉及的人过于庞大，更不要说像阿里这种大厂了。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"页面组件化设计汇总","date":"2019-11-29T17:58:55.000Z","path":"2019/11/30/2019-11-30-页面组件化设计汇总/","text":"现在的应用都是越来越大，越来越复杂，更加需要模块的精细化切分，以及支持多人共同合作开发。 目前大量应用单纯一个页面的业务量级已经非常庞大，这里就来再次从页面级别讨论一下页面组件化。 前言我们可以将任何一个页面都视作一个列表，每类元素都可以看做列表中的一个cell。之前，在美学新项目启动的时候，按照页面组件化的思路做了一个组件化拆分方案（DDComponent），在当时的业务场景来说，已经基本足够，但是在不停的使用过程中，也逐渐发现了一些问题，比如 数据源不匹配。这是一个非常常见的问题，异步、没有正确reloadData都是引起这类问题的原因，目前我还没有看见过有哪个开源方案能够彻底解决这个问题的。 reloadData效率问题。当一个列表足够长的时候，每次reloadData都将会非常消耗性能。 size计算。在布局和构建列表的时候，最让人麻烦的就是size计算，这会让我们的布局工作量加倍，而系统提供的方法实际效果并不好，虽然有FD的自动计算方案，但依然存在很多问题。 通信问题。组件间应该是相互独立的，如何解决相互间的通信问题也是一个重点。 这次重新设计的这套数据驱动系统主要考虑了如下几个目标： 开发效率。在目前的业务开发过程中，效率永远是第一的，决定业务快速迭代的基础。 并行开发。在这个多人合作的场景中，如何减少沟通成本也是非常关键的，而从架构层面解决这个问题是最有效的。 复用。对于一些信息展示类为主的应用，到处存在着复用问题，而以前的复用层面仅仅是view、model，而无法把这个模块的MVC进行复用。 标准化。提供一套完全标准化的页面组件方案。 扩展性。能够应对平时的大部分场景以及不同类型布局系统。 执行效率。从架构的层面考虑性能问题，并为性能优化提供一系列方案，并且可以进行逐步优化。 数据源不匹配问题数据源问题是我们开发列表中遇到的最大的一个问题，也是非常难以解决的问题。 场景当一个列表比较简单的时候，我们很少会有这样的问题。但是随着业务发展，列表内容越来越复杂，那么就非常容易出现这类问题，主要可能表现为以下几个场景： cell 为空 数组越界 非法调用（类型不匹配） 原因在我们处理数据的时候，如果在if-else的条件里面遗漏了某种数据，可能会导致该数据返回空cell。这种情况在迭代和重构的时候，由于对现有业务没有透彻的理解，就很容易发生。 而数组越界、非法调用，往往是异步和时序问题。在我们更新数据源之后，如果没有及时、同步、正确的更新列表，就会发生这样的问题。这类问题一般是偶现的问题，难以排查，也难以修改。而且如果该页面是拆分后的结构，那么每个独立模块内可能是正常的，但是多个模块间相互影响可能就是有问题的。 如何解决这个问题？我们很难去保证每个人的开发素质，也很难去保证多人并行开发过程中的沟通和一致性。所以我们需要从架构层面去解决这个问题。 解决这个问题的关键在于数据源，我们列表中所展示的数据，和我们正在处理的数据并不能保证一致性，那么最好的解决办法就是保存两份数据源，一份是开发自己维护的，一份是用于页面展示的。 目前列表所有接口返回的都是位置信息，而不是我们展示的数据，我们需要得到数据就需要从数组中的位置去取，这也无法保证展示的数据源index和真实的数据源index的一致性。 那么这里需要解决的问题总结为： 展示数据源和当前数据源的分离 抹除位置信息，直接通过数据来表示 数据源分离实现其实做数据源分离的思路很简单，系统的很多设计思路也是类似的。在我们提交数据源变化的时候，我们直接创建一个只读的数据源快照，用于展示使用。当我们再次刷新的时候，同样需要生成一个新的快照用于刷新列表。大致的流程如下： 123456789--&gt; update data ---&gt; original data source --&gt; update data --&gt; original data source --&gt; ... | | reload reload | | v v snapshot ---&gt; display data source snapshot ---&gt; display data source | | v v UICollectionView UICollecitonView 绑定数据，而不是index我们开发过程中，一直以来都是以index为核心进行布局数据，而没有从数据进行布局列表，这是导致这类问题最根本的思路上的问题，如果我们所有接口都是直接得到相应的数据，我们不需要操作index，那么我们就绝对不会出现越界等问题了。 那么我们可以把接口设计成这样： 123456- (NSArray *)viewModelsForComponent:(NELayoutEntityComponent *)component;- (Class)component:(NELayoutEntityComponent *)component cellClassForViewModel:(id)viewModel;- (CGSize)component:(NELayoutEntityComponent *)component sizeForViewModel:(id)viewModel;- (void)reloadViewModel:(id)viewModel;- (void)deselectViewModel:(Type)viewModel animated:(BOOL)animated; 所有行为都必须通过数据来执行，让真实的数据作为模块的核心。那么这里数据就必须具备唯一性这个条件。 可能你要说，并不是每一个模块都是有这么明确的数据类型来表示，那么这时候可以让该组件自己作为数据来表示。因为这里每一个组件的数据可以认为是每个组件的全局唯一id，只要保证其唯一性即可。 reload 效率问题列表刷新的效率问题主要集中在两个地方： 刷新导致重新计算布局 刷新导致大量更新视图数据 要解决这两个问题，可以增加size缓存、减少计算量以及视图更新的频次。为了减少计算量，这里引入增量系统。 对应于上面所述，我们将数据作为列表的核心，所以我们可以对数据源进行增量计算，对比得到变化的部分进行更新。而这也是很多系统所采用的方式，比如IGList。 这里为了一些异步能力考虑，并没有采用IGList这些成熟的开源框架，而是重新设计了更新流程。 1234567main thread: new data source -+ +-&gt; force update -&gt; reload collection view v ^thread1: +-&gt; size ----+ | |thread2: +-&gt; differ --+ v cancel ---&gt; back to &#x27;new data source&#x27; state 在触发更新并且重新生成快照之后，会进入两个异步线程，分别进行计算数据源增量和异步size计算（在需要极限优化性能的时候可以采用，在下个章节中讨论）。计算完增量后回到主线程，然后进行列表的更新。在这个过程中间如果触发了新reload，那么直接取消这一次的数据刷新操作，忽略该次结果。 这样，我们尽可能的减少列表的刷新和数据源的频繁计算，同时也在异步进行数据源增量计算（目前来看这个时间占总刷新时间的比例并不高）。 效率追踪在以前我们写一个大页面的时候，如果出现性能问题，我们需要去查找问题的原因往往靠经验，也就是猜测，然后一个个排查。这样大大降低了我们排查问题的效率和准确性。 而且以前的问题都是后知的，也就是发生严重影响的时候，才会反过来修改。 而我们进行组件拆分后，每个类型的组件都是独立的，我们可以在任意我们所需要的地方，比如： size计算 diff耗时 cell渲染 进行插桩、统计与分析。那么我们可以在投入生产之前就能得到一手数据，甚至在这些地方加入限制与报警，从而进行精确的优化。 数据源differ协议数据需要能够比对增量，就必须满足一定的规则，这里采用的和IGList一样的协议。但是这样会带来一些问题： 对每一个数据需要重写diffable协议，增加了开发工作量。 每一个数据都需要做copy，才能进行对比前后变化，这对工作量和性能都会有一定的影响。 并不能保证团队所有人都能够正确的理解和设计diffable内容，不良的设计可能直接导致增量系统的未知行为（比如不能保证数据的唯一性）。 在迭代过程中，数据diffable并不是一成不变的，可能会根据需求来改变其等价的条件。 在同一个应用中，可能在不同场景中的等价条件是互斥的，这样我们就无法复用该数据模型。 基于这些问题，我决定完全放弃基于diffable协议去做更新操作，而是基于数据去强制刷新。 12- (void)reloadDataWithForce:(BOOL)force animated:(BOOL)animated;- (void)reloadViewModel:(id)viewModel withForce:(BOOL)force animated:(BOOL)animated; 在很多场景下，我们仅需要更新某个cell的数据，就可以直接采用该能力，而默认我们则采用数据指针这一个唯一值作为参照条件。这样可以让我们减少需要小心维护数据协议的大量工作量。 size问题size计算一直是iOS开发过程中一个非常机械且重复的工作，而且特别容易出bug。 如果一个cell的布局非常复杂，那么这个计算过程也会显得难以阅读。 如果经过很长时间的迭代，也会让计算的逻辑变得复杂无比。 如果cell中有多行文字，那么计算文字既耗时，又会让逻辑变得混乱，同时一旦修改一个字体等属性，很容易遗漏了size计算中的属性。 如果cell中的元素比较动态，会根据不同数据做不同展示。 size计算如果由每个人去写，会产生各种各样的写法，甚至隐含了很多的问题（目前为止见过太多这样的问题了）。 自动计算其实cell最终展示的时候，我们是可以确认size的，比如安卓的listView，以及tableView的自动适应size。 既然我们可以根据cell的数据排版可以知道size，那么我们其实是可以自动计算出size的。这样不仅减少了一定的工作量，而且也避免了很多bug。 到这里，肯定很多人跳出来说，你这样做性能肯定不好。当然这么做性能可能会变差，但是以目前设备性能和未来的增长速度，大部分场景下性能是过剩的，那么我们为什么不去好好利用这一优势。就像有人说的，未来移动端肯定会被前端所统治一样。 要做到可以自动计算size，那么布局系统就不能使用手写frame的方式了。目前苹果提供给我们的AutoLayout布局就能很好的完成这个任务。 另外第三方的flexbox也是非常好的一种布局方式，关于flexbox布局之前我也介绍过，但是官方的YogaKit并不好用，所以我重新设计了一套与JSX、SwiftUI类似思想的方案，同时做了一些优化。这个之后可以专门介绍一下。 缓存size计算另一个非常重要的点就是缓存。我们的列表往往是增量加载的，所以每次的数据和展示并不会发生变化，所以也就没有必要每次都计算一次size。 目前有一些第三方库可以做到这一点，但是很多都是基于indexPath的，而且需要自己手动进行缓存与查找。而在这里，我们的架构有着天然的优势，那就是我们是完全基于数据的，所以这里可以做到完全自动的缓存能力。只需要开启该能力即可： 1self.cacheEnable = YES; 当然我们也会有手动清除缓存的接口和能力。 size性能优化当然，我们也不排除一些页面存在性能问题，比如一个页面加载了非常大量的数据，或者页面布局过于复杂，或者数据解析比较耗时等等，都可能导致我们的自动计算耗时增加。 一种方式是对解析完的数据和布局进行缓存，这样能够非常好的解决刷新与复用的问题。 如果随着业务迭代，我们发现了性能出现瓶颈，那么我们可以精确的对一类数据进行优化。如下表所示： 123 自动计算 自动计算+缓存 手动计算 手动计算+缓存 异步计算 异步计算+缓存 开发效率 &gt; &gt; &gt; &gt; &gt; &gt;执行效率 &lt; &lt; &lt; &lt; &lt; &lt; 但我们一般不推荐一开始就考虑性能问题，我们还是需要以质量和开发效率为主。 性能优化补充一般我们反对一开始就考虑性能优化，因为可能这里根本不会存在性能问题，没有必要浪费大量的时间在这，而且会把简单的东西变复杂了。 但是从架构上，我们还是需要考虑到需要优化的这种场景与需求，在架构层面我们就需要能够支持一步步的优化与数据验证，这样才能够看到量化的结果和形成闭环。 123开发 --&gt; 迭代 --&gt; 性能报告 ------&gt; 迭代 --&gt; 性能报告 \\ | 分析问题 --&gt; 优化性能 通信问题一个页面是有关联性的，当我们把一个页面拆分为多个组件的时候，就必然存在组件间通信的问题。 我这里的解决方案比较简单，做一个局部通知系统的机制，使用消息转发，只要组件实现了协议A，那么该组件就会自动接收到协议A的消息，从而达到了通信的目的。而这个通知系统只作用于当前vc和当前组件树中的组件，不会逃逸到其他地方。 这里为什么要使用通知这种方案呢？ 消息传递的层次性。我们要通过delegate从组件A上传递消息到组件B上，那么整个链路可能是：组件A-&gt;section A-&gt;viewController-&gt;section B-&gt;组件B，整个链路非常长，而且难以管理。 消息并不一定是一对一的，存在一对多的情况。比如viewController的appearence事件，可能任意组件都需要知道这个事件。 优点 开发效率高 灵活且适用性高 解决了链路长的问题 在不同组件组合的场景下，具有更高的兼容性与解耦性 避免了消息逃逸到其他页面 缺点 和常见的回调、通知机制不同，需要一定的了解学习 需要在组件树中的组件才会收到消息，会在某些时候产生一定的误解 其他方案这里并不限制和约束其他的通信方案，比如delegate，notification等。而该方案从总体来说，解耦的优势还是更为突出。 曝光问题对于cell的display事件来说，在某些情况下可能是不准确的： reloadData触发复用的时候 组件移除组件树的时候，或者组件发生替换的时候 这和CollectionView与拆分组件的机制有关，所以这里设计了一套全新的曝光方案，使用数据，而不是cell作为曝光源，来做到更为精确的曝光。 下面简单的说明下思路。 曝光检查此次采用的是主动检测方式，在列表发生滚动的时候，会触发一次曝光检查。检查的目的是为了找到： 哪些数据由不可见-&gt;可见 哪些数据由可见-&gt;不可见 这个可以利用CollectionView的visibleIndexPaths来查找，如果需要更为精确的数据，还可以自己再根据inset再校验一遍。 检查时间点那么那些场景可能会需要检查？ 列表滚动 reloadData viewControllerAppearance 以及其他根据业务需求可以增加的检查。 效率目前还未发现这种方案的效率问题，一般来说可见的组件也不会有很多，不会产生什么验证的效率问题。 并行开发与组件原子性每个组件我们希望承担的功能尽可能的单一，只负责一类数据与一类视觉展示，这样我们就能保证组件的最小粒度，以及其原子性。 这样，我们就可以很容易的将一个大型的复杂页面进行拆分，分配给多人开发，而不会产生很大的冲突和依赖。 同时这也非常有利于我们快速的开发一个功能，以适应市场变化。 复用性虽然组件化的一个很重要的特点是复用性，但是在实际情况下，可复用的组件依然占少数，而想要设计出一个能够比较好复用的组件是相当困难的，对人员的能力要求，以及对组件化的理解都很高。 所以这里我不想特意去要求高复用性，而更希望将组件做的更小，更简单，粒度更细。 最后这是从个人经验上，从最早的DDComponent拆分思想，以及后来出现的IGList的diff思路，经过自身的大量业务实践，最终总结所得，同时兼顾简单、易学的一套方案。 其实这里可以做的更激进一些，以满足一些比如动态化、DSL的能力，但考虑到受众应该是所有层次的开发，所以不便做的太过复杂。 由于项目原因，暂不便公开源码。","categories":[],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"UICollectionView","slug":"UICollectionView","permalink":"http://djs66256.github.io/tags/UICollectionView/"}]},{"title":"从响应链收集手动埋点","date":"2019-06-01T09:49:06.000Z","path":"2019/06/01/2019-06-01-从响应链收集手动埋点/","text":"背景手动埋点一直以来都是一个比较麻烦的行为，埋点不属于业务逻辑，而我们必须插入业务逻辑中，有可能就导致了我们不得不修改设计以满足埋点的需求。 同时数据方很多时候会要求带上额外的数据，而这些额外的数据甚至和当前模块毫无关系，也就是破坏了我们的独立性和解耦原则。比如在事件点击中加入当前页面的pageId，当前cell的index等等。 简介目前我们手动埋点的埋点信息可能包含的内容比较多，但也可以进行归类。 不同类型的埋点信息都是在不同的层上收集的，比如我们需要pageId，那么这个必然是在当前VC上才有，如果我们要收集上个页面的pageId，那么只有navigationController上会有该信息，而如果我们需要收集cell的位置信息，那么我们需要在dataSource上进行收集。 这给我们的埋点收集一个思路，我们手动埋点的时候不要马上收集完所有数据上报，而是收集当前层存在的信息，并把这个埋点任务抛向上层。每一层都会往埋点任务里面写入自己层的信息，直到结束，这样我们就可以收集一个非常完整的埋点信息。 当然这样做的缺点是埋点里面的信息比较多，比较冗余，但作为埋点信息来说，信息冗余并不是太大的问题。 要建立这样一个结构，如果是一些新业务或者组织架构设计较好的业务来说，会比较简单，但是对于一个已经成型的，有很多复杂的业务却比较麻烦。这里需要去寻找一种方法，使改动量尽可能的小，并且组织灵活。 数据流数据方向首先我们来看看一般应用的页面结构。 绿色：Application 蓝色：View 橘色：ViewController 我们更新页面的数据方向是这样的： 但是我们埋点触发，需要收集的数据却是这样的： 我们更新数据和收集数据的方向是完全相反的，这也就是导致我们手动埋点总是会感觉很别扭的原因。 而我们一般做埋点的方式，是将这个事件通过回调等方式一层层传递到ViewController上，然后进行统一埋点。 但是对于一个复杂的VC，我们往往会继续拆分，成为多个独立组件的组合（可以看我之前的DDComponent），这样不仅能避免VC的无限膨胀，也能解耦业务。但是遇到埋点需求时，我们却不得不打破这个组织方式，因为有很多信息必须要在VC上才能获取到。 数据流我们在上面了解到的埋点现状，可以抽象为一条数据流，在这个数据流上有多个节点，不同的节点可以收集必要的埋点信息。 而每一个节点，可以抽象为一个Stream。 这里我们可以看到每一个节点同时也是响应链的一部分，那么我们是不是就可以依靠响应链来连接整个数据流呢？这样我们就不需要大量改动代码，从而达到建立这套系统了。 123456@interface UIResponder (TraceStream)@property (nonatomic, strong, readonly, null_resettable) TraceStream *trace;@end 这里我们还需要为这条数据流创建一个终点，也就是最终输出端，可以选择Application上的节点为输出节点。 1234567891011121314@implementation UIApplication (TracePipeline)- (TraceStream *)trace &#123; NSAssert([NSThread isMainThread], @&quot;Must call on main thread.&quot;); TraceStream *stream = objc_getAssociatedObject(self, @selector(trace)); if (stream == nil) &#123; TraceStream *stream = [[LoggerTraceStream alloc] init]; objc_setAssociatedObject(self, @selector(nm_trace), stream, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return stream; &#125; return stream;&#125;@end 使用这里我们举一个列表中点赞埋点的列子： 在cell中的某个view中，触发了点赞： 12345678- (void)onPriase:(id)sender &#123; [self.trace addTraceInfoWithBuilder:^(TraceInfo * _Nonnull traceInfo) &#123; traceInfo .setAction(@&quot;praise&quot;) .setId(self.video.videoId) .setType(self.praised ? @&quot;1&quot; : @&quot;0&quot;); &#125;];&#125; 但是我们还需要知道这个cell是位于列表中的位置，那么我们可以cell中加入该信息： 12345678910- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = ...; [cell.trace.filter setFilterBlock:^BOOL(TraceInfo * _Nonnull traceInfo) &#123; traceInfo.set(@&quot;index&quot;, @(indexPath.row).stringValue); return YES; &#125; forKey:@&quot;index&quot;]; return cell;&#125; 然后我们还需要知道是在哪个页面中触发的，那么我们需要在vc中加入： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; [self.trace.filter setFilterBlock:^BOOL(TraceInfo * _Nonnull traceInfo) &#123; traceInfo.setPage(@&quot;test&quot;); return YES; &#125; forKey:@&quot;addPage&quot;];&#125; 那么最后我们收集到的埋点信息就会包括了praise, index, page信息。 自定义在开发过程中，我们可能还会有很多业务分割的部分，比如ViewModel，这些内容并不一定在响应链中，那么我们需要能够将这个数据流通过该组件来收集数据。 这里我们可以在默认的数据流中插入一个自定义节点来解决。本身这个数据流和响应链其实并没有什么关系，我们只是利用了响应链的结构而已。 12viewModel.view.trace.outStream = viewModel.trace;viewModel.trace.outStream = controller.trace; 这样我们就可以自定义数据节点了。 过滤器由于各种原因，我们的埋点并不能完全的通用，比如有时候，同样是点赞，有时候是praise，有时候是like。有时候我们又不希望触发某些埋点。 我们需要在某些确定的节点要求能够过滤或者转换某些埋点，那么我们需要在每个节点上添加过滤器： 123456[self.trace.filter setFilterBlock:^BOOL(NMTraceInfo * _Nonnull traceInfo) &#123; if ([traceInfo.action isEqual:@&quot;praise&quot;]) &#123; traceInfo.setAction(@&quot;like&quot;); &#125; return YES;&#125; forKey:@&quot;addPage&quot;]; 虽然这么做并不是特别好，但在一些无法抗拒的情况下还是能够给我们一个修改的机会。 逻辑型埋点另一种让我们所有人都头疼的就是逻辑型埋点。 一般来说我们的埋点都是事件埋点，也就是触发一个方法，我们埋一次。但是有些需求要统计时长，比如用户点播放，和点暂停之前的时间间隔。按照原有方法埋点，那么我们可能需要在VC里增加一个成员，专门为了记录这个时间间隔。而这些成员和业务毫无关系，只服务于埋点信息，导致了业务的耦合增加。 对于我们程序来说，事件的点是比较简单的，而这种逻辑型埋点则非常复杂。如果我们把逻辑型埋点都转化为事件埋点，那么就会减少很多复杂度。 123456789101112131415161718__block NSDate *playTime = nil;[self.trace.filter setFilterBlock:^BOOL(NMTraceInfo * _Nonnull traceInfo) &#123; if ([traceInfo.action isEqual:@&quot;play&quot;]) &#123; playTime = [NSDate date]; return NO; &#125; else if ([traceInfo.action isEqual:@&quot;pause&quot;]) &#123; // 得到两者之间的时间间隔 [self.trace addTraceInfoWithBuilder:^(TraceInfo * _Nonnull traceInfo) &#123; traceInfo .setAction(@&quot;play-pause&quot;) .setTime([playTime timeIntervalSinceNow]); &#125;]; playTime = nil; return NO; &#125; return YES;&#125; forKey:@&quot;play-pause&quot;]; 总结这种方案虽然能够解决很大一部分的埋点痛点，但也依然存在一些缺陷。 开发者必须要了解这种方案的原理，才能知道在什么节点收集埋点，以及如何插入自定义节点。 埋点信息会比较冗余，会带上一些无用信息。 埋点信息必须保证大部分是统一的，不然每个页面全部采用不同的key和埋点方式，也会让这个系统失去复用的能力。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"流程状态机架构","date":"2019-05-30T15:24:20.000Z","path":"2019/05/30/2019-05-30-流程状态机架构/","text":"背景在现实的项目过程中，由于人员的更替，以及业务的发展，总是会导致一个问题，那就是流程细节的丢失，项目时间越久，这个问题越是严重。所以往往会出现产品在不知道这个功能的流程的情况下设计方案，开发在开发过程中才发现流程上的设计缺陷，这不仅仅导致了项目时间的推迟，更可能导致整个业务流程上出现漏洞而危害整个产品，如果是云音乐这种类型产生问题可能表现不大，但像考拉这种涉及到钱的项目严重的可能导致信任危机。 要解决这个问题传统的做法就是详细业务文档，这需要： 文档要求详细，并且在统一的地方维护 人员交接的时候，文档需要完整交接 多方（产品、开发、测试等）的信息同步 遗憾的是，这么多年的工作中，我没有发现一个项目能够做到这一点的，遇到问题只能人肉阅读代码。在目前国内企业的环境来看，要写一份详细完整的文档，也是几乎不现实的。 无论在哪种问题下，产品不了解流程，或是视觉不知道中间的弹窗，或是多方出现理解分歧，最终都是由开发阅读老代码来判断以前的流程是怎么样的，所以代码中的逻辑一般是最准确和详细的。在需求变更后，最先更新的也往往是代码（上帝也不能保证产品会把变革更新到文档）。 那么我们如果能从我们的代码逻辑中直接提取这个流程，并且通过流程图的形式展示出来，也就省去了很多一部分为别人服务的时间。而且拥有流程图之后我们也可以直观的检查我们的代码逻辑是是不是存在bug。 markdown有一个流程图表的功能，很多markdown编辑器也已经支持了，这给了我一个开发一个能够解决流程问题的思路。 mermaid graph TD 简述我们需要这个新的框架能够足够通用，能够适用于大部分场景。 每个流程需要足够的独立，不能依赖太多的外部信息，能够复用和自由组合。 可以输出可读性强的流程信息，比如markdown等。 有一定的自检能力，保证整个流程的完整性和正确性。 这里我们用一个最简单的点赞流程来解决： 实现1. 结构1.1 状态 State我们在看流程图的时候，把一整个流程拆分为一个个节点的时候，可以看到每个节点（状态）都可以抽象为拥有一个输入，多个输出的结构： 每个具体状态必须只做一件事情，每个条件分支也必须为一个独立的状态。 123456if (isLogin) &#123; // do login&#125;else &#123; // do unlogin&#125; 需要抽象为： 12StateIsLogin --&gt; |isLogin| loginStateIsLogin --&gt; |!isLogin| unlogin 多个状态可以组合成为一个复杂的状态，这个复杂的状态其行为依然和最简单的状态一致。当我们最终组合而成的点赞功能，也应该是一个状态机，拥有一个输入和多个输出。 1.2 规则 Rule不同的状态之间，是通过某种规则进行连接。 最简单的规则就是执行下一步，最普遍的规则就是匹配上一个状态输出的结果。 为什么这里要加入个规则的概念，而不是直接建立状态直接的依赖关系？主要原因有： 设计上更简单、明确，通用性更强，我可以自定义规则来实现一些多参数的匹配等 条理更清晰，可以方便的转化、输出文档 可以集中化管理，可以方便的跟踪当前状态的变更 1.3 组合这里演示为了代码的可读性，所以采用了c++，实际使用的时候语言并不是阻碍。 所有的状态创建统一通过工厂创建： 1234567891011auto b = Builder(ctx);auto checkNetwork = b.check(^BOOL(NSDictionary *params) &#123; return ![self isOffline];&#125;).debugName(@&quot;网络连接&quot;);auto checkLogin = b.check(^BOOL(NSDictionary * _Nullable params) &#123; return [self isLogin];&#125;).debugName(@&quot;用户登录&quot;);... 那么上述一个简单的点赞流程可以写作： 12345678910111213141516171819202122b.start() &gt;&gt; checkNetwork;checkNetwork &gt;&gt; Result::Yes &gt;&gt; checkLogin &gt;&gt; Result::No &gt;&gt; b.end();checkLogin &gt;&gt; Result::Yes &gt;&gt; praiseRequest &gt;&gt; Result::No &gt;&gt; b.end();praiseRequest &gt;&gt; Result::Success &gt;&gt; successToast &gt;&gt; Result::Failure &gt;&gt; failureToast;successToast &gt;&gt; b.end();failureToast &gt;&gt; b.end(); auto praiseMachine = b.compositeMachine(); 那么我们最终得到的状态机可以在需要的时候启动： 1[praiseMachine startWithParams:@&#123;@&quot;test&quot;: @&quot;Test Value&quot;&#125;]; 这里就不再描述具体结构了，详细可以看我的demo 1.4 纯粹性/原子性一个状态在被使用过后，可能会产生很多垃圾，会污染了这个状态的内部。反之我们可以定义在执行前后不会发生变化的状态为纯状态。 如果我们的子状态机都是纯状态，那么我们组合而成的状态机也必然是纯状态。 纯状态的一个好处就是可以被反复使用，而不需要重新创建，减少创建的开销，以及提前创建流程状态机。 2. 输出文档我们把结构改成状态机虽然能够在代码流程上更为清晰，但也会增加学习成本和代码量，单纯这么做的意义并不大，所以我们需要将这个流程以更可见的形式输出。 某些markdown编辑器集成了流程图的语法，我们刚好可以借助这个功能。下面我们将我们的结构格式化后打印出来： 123DDStateMachineMarkdownWriter *writer = [DDStateMachineMarkdownWriter new];[praiseMachine debugWriteMarkdownText:writer];NSLog(@&quot;%@&quot;, writer.markdownText); 打印结果是 123456789101112graph TDDDBlockStateMachine1(网络连接) --&gt; |YES| DDBlockStateMachine2(用户登录)DDBlockStateMachine1(网络连接) --&gt; |NO| DDContinueStateMachine1(End)DDBlockStateMachine3(点赞请求) --&gt; |success| DDBlockStateMachine4(提示)DDBlockStateMachine3(点赞请求) --&gt; |failure| DDBlockStateMachine5(提示)DDContinueStateMachine2(Start) --&gt; DDBlockStateMachine1(网络连接)DDBlockStateMachine5(提示) --&gt; DDContinueStateMachine1(End)DDBlockStateMachine2(用户登录) --&gt; |NO| DDContinueStateMachine1(End)DDBlockStateMachine2(用户登录) --&gt; |YES| DDBlockStateMachine3(点赞请求)DDBlockStateMachine4(提示) --&gt; DDContinueStateMachine1(End) 复制到markdown编辑器中，可以转化为流程图： 当然这只是一种导出方式，我们可以自行设计更好的导出方式。 我们可以通过比对流程图，来看我们修改的逻辑流程是否发生了正确的改动。 甚至我们可以在自动化测试脚本中加入流程的验证，或者控制流程的走向。 在线上我们也可以用于记录用户操作，是在什么环节出现了错误导致本次流程的失败或者撤销。 3. 状态跟踪当我们把流程封装成一个状态后，就相当于一个黑盒系统了，我们无法在这个流程中插入一些额外的非流程内的东西了，比如统计埋点等。 这里我们需要给外部系统提供一个状态跟踪的能力，当触发这个状态变更的时候给予外部一个信号或者执行一段代码，具体能力可以依据需要实现。这也是上述为什么要设计Rule这一结构的原因之一。 以上的流程代码可改为： 123checkLogin &gt;&gt; Result::Yes &gt;&gt; Trace(@&quot;login&quot;) &gt;&gt; praiseRequest &gt;&gt; Result::No &gt;&gt; b.end(); 那么我们就可以去监听@”login”这个信号，在请求成功后就会自动触发。比如在这里增加一个埋点信息。（关于埋点，我们后续可以再讨论一篇） 比如打印信息：Machine (用户登录) will goto (点赞请求) with log (login) 4. 完整性检查另一个开发中比较容易出现的问题就是对异常和特殊情况的判断，这个问题在传统的开发中并没有什么特别有效的方法去避免，只能靠个人能力和测试的完备。 一个简单的例子就是，我们会在请求之后判断成功而更新UI，但会比较容易忽略失败的场景，而对于某些场景我们还是需要去处理失败的。 而在这种新的结构下，我们就比较容易做这个检查了。 我们需要在强制检查的状态中指定可能会返回的结果： 1machine.validResults = @[Result::Yes, Result::No]; 然后去检查可能的结果是否都已被Rule处理了： 12345NSError *error = nil;[praiseMachine checkRuleCompleteWithError:&amp;error];if (error) &#123; NSLog(@&quot;Error: %@&quot;, error.localizedDescription);&#125; 如果发现缺失，则会输出哪一个状态的哪一条规则缺失：Error: &lt;DDBlockStateMachine&gt; 用户登录 do not obey result(YES);。 这样我们就可以强制开发者必须保证逻辑流程的完整性，以防止我们在不经意间引入一些问题。 总结以上几个能力是我觉得在现实的场景中比较重要的，现实项目中，特别是大型项目，人员流动频繁，有些时候整个业务都可能会进入一个不可控的场景，这时候我们不能保证外部给我们信息是完整的，也不能保证内部人员足够的熟悉项目的细节，那么只能从架构上进行约束，将很多流程规范化，结构化，进行强校验才是解决这类问题的方法。 采用新的架构也必然会导致整个学习成本的上升，同时也要求整体人员的水平能够从更高的角度去看待问题，能够去理解这么做的原因和原理。 约束并不是目的，而是在约束下我们能更好的保证质量。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"Corountines 看似美好却危险重重","date":"2019-04-06T17:11:27.000Z","path":"2019/04/07/2019-04-07-Corountines-看似美好却危险重重/","text":"协程Coroutines这个概念在5、6年前就已经比较热门了，而且也涌现了一波以该目标的第三方库，但是这个概念并没有被广泛的应用，这里来看看Coroutines给我们带来的便利和危险吧。 简介关于Coroutines、Generator的介绍有大量优秀文章和wiki的介绍，这里不做赘述。 协程出现的时间非常早，在一批语言（C#，Go，ES7）从语言本身开始支持这种特性而再一次受到关注。同时也有一大批C/C++类库的出现，来实现协程的特性，比如PCL, fiber, coroutine，以及支持Coroutine的网络库asio。甚至有人提议C++标准组织增加关键字来支持【N3858】【N3985】。 化异步为同步Coroutine主要想解决的问题是异步回调问题，这个问题自从多线程开始就是另大家头疼的问题，我们使用过很多方法，都无法很好的解决这个问题。比如Callback和Promise，都存在着一些瑕疵。 123456// Callbackfs.readFile(&#x27;a.txt&#x27;, function (error, data) &#123; fs.readFile(&#x27;b.txt&#x27;, function (error, data) &#123; ... &#125;)&#125;) 1234567// PromisePromise.all([ fs.readFile(&#x27;a.txt&#x27;), fs.readFile(&#x27;b.txt&#x27;)]) .then(function () &#123; ... &#125;) 对我们来说同步执行的逻辑是最简单的，也是最清晰的，我们将很多同步功能放到异步执行往往是为了解决阻塞问题，所以我们是完全可以将异步的功能写成同步的。 12await fs.readFile(&#x27;a.txt&#x27;)await fs.readFile(&#x27;b.txt&#x27;) 这里我们可以用关键字await来表示这个方法是一个异步过程。有很多语言天生自带这一类特性，但是C系列语言并不具备这个关键字，下面来看看如何实现这个功能。 实现这里盗C++论文一张图来说明一下我们需要实现协程的流程： 123async foo() &#123; await bar()&#125; 我们需要在await的时候，将代码执行能力转交给bar，然后在bar异步回调的时候，将执行权限交还给foo，这需要一种上下文切换的能力，从CPU层面来说上下文就是寄存器，那么我们要实现上下文切换的功能也就非常简单了。 个人比较熟悉arm架构，所以这里简单说明下coobjc的setcontext和getcontext。对汇编不熟悉的人可以跳到C语言实现上下文切换。 1234567891011121314151617_coroutine_getcontext: stp x18,x19, [x0, #0x090] stp x20,x21, [x0, #0x0A0] stp x22,x23, [x0, #0x0B0] stp x24,x25, [x0, #0x0C0] stp x26,x27, [x0, #0x0D0] str x28, [x0, #0x0E0]; stp x29, x30, [x0, #0x0E8]; // fp, lr mov x9, sp str x9, [x0, #0x0F8] str x30, [x0, #0x100] // store return address as pc stp d8, d9, [x0, #0x150] stp d10,d11, [x0, #0x160] stp d12,d13, [x0, #0x170] stp d14,d15, [x0, #0x180] mov x0, #0 ret 12345678910111213141516_coroutine_setcontext: ldp x18,x19, [x0, #0x090] ldp x20,x21, [x0, #0x0A0] ldp x22,x23, [x0, #0x0B0] ldp x24,x25, [x0, #0x0C0] ldp x26,x27, [x0, #0x0D0] ldp x28,x29, [x0, #0x0E0] ldr x30, [x0, #0x100] // restore pc into lr ldr x1, [x0, #0x0F8] mov sp,x1 // restore sp ldp d8, d9, [x0, #0x150] ldp d10,d11, [x0, #0x160] ldp d12,d13, [x0, #0x170] ldp d14,d15, [x0, #0x180] ldp x0, x1, [x0, #0x000] // restore x0,x1 ret x30 arm64中寄存器分为两类：普通寄存器和向量寄存器（也可以称为浮点寄存器）。根据C++ abi文档，各种寄存器的功能如下： registers role SP stack pointer r30 LR r29 FP r0-r7 参数寄存器 r8 IR r9-r15 临时寄存器 r16/r17 PLT(目前我也不了解) r18 平台寄存器/临时寄存器 r19-r28 Callee寄存器，必要时由被调用者保存 v0-v7 参数寄存器 v8-v15 Callee寄存器，必要时由被调用者保存 v16-v31 其他 由此，我们可以知道必须缓存的寄存器是哪些了。 C语言实现上下文切换当然系统其实也给我们提供了相似的功能，原理其实都是一样的，下面介绍一下几种系统提供的方式，详细信息可以参考相关文档： setjmp/longjmp这种方式非常的容易理解，唯一的缺点就是返回值类型是int，所以在32位系统上我们可以返回上下文指针，而64位系统就不能这么做了。 ucontext目前苹果已经不支持了。 signal信号也是通过类似方式实现的。 危险具体实现细节还是需要自己去研究，这里说明一下其中带来的几个问题。 栈在我们的功能特性中，在执行async函数时，是需要直接返回的。由于C语言调用栈的结构，在函数返回时，是需要销毁栈的，所以我们必然不能在当前栈上运行我们的async函数，不然等异步返回的时候，函数栈帧已经被回滚（unwind）。所以在我们第一次（当前上下文的首次）启动一个async函数的时候，必须要为该函数申请一个不会被立刻销毁的栈，也就是malloc一块内存作为栈使用。目前像coobjc默认是64k的大小，对于性能要求比较关键的地方就需要好好考虑了。当然，按目前来说，一定的性能损耗给我们开发带来便捷还是可以接受的。 但是，上下文的切换可能让我们debug陷入一个无尽的深渊。大家在开发多线程的时候，都感觉比较难以调试，因为线程之间是独立的。而我们一旦切换了上下文，同时重新创建调用栈，也就意味着我们丢失了起点，有点像一个独立的线程，是无法找到调用地点的，除非我们在创建新栈的时候，将旧的栈全部拷贝，但这明显是不现实的，比较现实的可能是拷贝若干附近的栈帧数据。总之，c系语言的协程，debug将是一个比较困难的场景。 而coobjc在会库内部产生很多的栈帧，也增加了调试的复杂度。如果能够在切换上下文的时候将栈回滚，则会减少很多干扰调试的调用信息。 stackful目前来看C系的协程基本上都是stackful的，也就是可以在其他函数内部触发： 123456789101112function some_function() &#123; yield &quot;OK&quot;;&#125;function async_call() &#123; // stackless 则必须在该函数栈帧内触发yield，比如javascript some_function();&#125;function do() &#123; await async_call();&#125; 在语言本身并没有相关的特性的时候，我们很难检查目前方法是否支持协程，特别是整个链路比较长的时候，更加难以知道。一些规范也只是较弱的约定，依然无法保证在一个复杂的应用中是否会出现一些遗漏的问题。 如果我们只允许其中的async/await与promise特性，则会将影响面控制在一定范围内，应该会好一些。实际上我们依然无法规避这种问题。 多线程个人认为这是我们应用协程最大的挑战，这里的问题往往已经颠覆了我们的平常认知，这里可以看一个例子： 12345// on Thread 1await do_something1()// on Thread 2await do_something2()// on Thread 3 我们无法预知在await函数之后会在哪个线程！这给多线程开发带来了非常大的挑战，因为这里几乎必然会发生竞争问题！ 虽然在一个过程中，我们的调用是有顺序的，是不会产生什么问题，但是我们的场景往往不会只触发一次那么简单。我们需要在每个await调用上思考多线程问题，这个反而给我们的开发带来了更大的麻烦。 当然我们可以约定，回调必须发生在主线程等，但是约定始终是约定，无法作为强制性的禁止，完全依赖个人的开发能力。 总结可以看到，协程作为C系语言的扩展，依然存在巨大的缺陷，C++标准组委会到目前为止，也依然没有将其作为一个特性。协程的目的是为了化异步为同步，简化我们的开发和理解，但在真实的多线程环境中，反而对开发者的要求更高了，已经脱离了初衷。 参考Glibc armasm_user_guide IHI0055C_beta_aapcs64 https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html https://en.wikipedia.org/wiki/Setjmp.h https://en.wikipedia.org/wiki/Setcontext https://en.wikipedia.org/wiki/Iterator https://en.wikipedia.org/wiki/Continuation https://en.wikipedia.org/wiki/Coroutine C Generator C++ Generator Boost fiber C++ stackful coroutines C++ Coroutine A C++ await/yield emulation library for stackless coroutine Stackless vs. Stackful Coroutines n3985","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"coobjc","slug":"coobjc","permalink":"http://djs66256.github.io/tags/coobjc/"},{"name":"coroutines","slug":"coroutines","permalink":"http://djs66256.github.io/tags/coroutines/"}]},{"title":"C++虚函数表一探","date":"2019-02-03T11:39:14.000Z","path":"2019/02/03/2019-02-03-C-虚函数表一探/","text":"虽然iOS中对C++的要求并不是必须的，但是很多基础都是用C++写的。我们都说C++难学，除了众多的特性以及为了兼容底层语言的一些妥协，导致特性极其复杂，虽然经过C++11之后的标准，已经更加完善和易用了，但我们还是需要去了解一些C++的实现原理及特性，才能避免掉入坑中。 这里将不会一一说明C++的基础知识，我相信有很多人应该比我说的更好。 虚函数C++的虚函数实现是通过虚函数表，这是大家都知道的。那么虚函数表是一个什么样的结构呢？ 这里我们用类C语言的描述来说明一下。 123456789class A &#123;public: virtual void f() &#123;&#125;&#125;;class B : public A &#123; void f() override &#123;&#125; virtual void g() &#123;&#125;&#125;; 以上用C结构表示大概是这样的： 12345678910111213141516struct vtable_A &#123; void f(A *this) &#123;&#125;&#125;struct A &#123; vtable_A *__vtable;&#125;;struct vtable_B &#123; vtable_A _super; void g(B *this) &#123;&#125;&#125;struct B &#123; vtable_B *__vtable;&#125;; 编译器会在类中自动生成一个指向虚函数表的指针，并在构造类的时候帮我们把对应的虚函数指针填上。那么如果我们重写了某个基类的虚函数的时候，我们的虚函数表相对应的虚函数会改写为子类的函数指针，如下： 12345vtable_A: | A::f() |如果没有重写f()，B的虚函数表应该如下：vtable_B: | A::f() | B::g() |如果重写了f()，B的虚函数表则会变为：vtable_B: | B::f() | B::g() | 所以我们从表中查找出来的将会是B::f。这也解释了为什么C++类，只含有虚函数的class，size也是需要有一个指针的大小。 当有多个基类的时候，这时候为了分辨多个来源的时候，将会采用多个虚函数表结构： 123456789101112class A &#123; virtual void f() &#123;&#125;&#125;;class B &#123; virtual void f() &#123;&#125; virtual void g() &#123;&#125;&#125;;class C &#123; void f() override &#123;&#125;&#125; 这时候的C的虚函数表将会是这种感觉： 123456vtable_A: | C::f() |vtable_B: | C::f() | B::g() |class C &#123; vtable_A *__vtable_a; vtable_B *__vtable_b;&#125; 而更复杂的情况也是这目前的扩展，这里就不赘述了。 函数参数我们都知道，C++能和C无缝链接，其实就是对C语言的一个扩展，其大部分机制，比如参数传递都是和C语言一模一样的。而C语言是不支持this这种语法的，那么C++是如何传递参数的呢？ 虽然我们看来A::f()就是该函数定义，但实际上我们是有一个this的隐式参数，也就是说A::f(A *this)才是该函数的真正定义。 结合上节，那么我们就可以动态的取出vtable内的函数指针，进行调用，实现类似“动态语言”的某些特性。 1234567typedef void (*Fun)(void*);C c;uintptr_t cptr = reinterpret_cast&lt;uintptr_t&gt; (&amp;c);uintptr_t *vtable = reinterpret_cast&lt;uintptr_t *&gt; (cptr);Fun *vtc = reinterpret_cast&lt;Fun *&gt;(*(vtable + 0));Fun f = *(vtc);f(&amp;c); 多基类的this指针上节我们知道this指针将会是一个隐式参数，那么出现多个基类的时候，又是如何处理的呢？ 123456789101112131415161718192021222324252627class A &#123;public: virtual void f() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125; virtual void g() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;;class B &#123;public: virtual void f() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125; virtual void k() &#123; this-&gt;f(); std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;;class C : public A, public B &#123;public: void f() override &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;; 如果我们调用 12C c;c.k() 此时调用的是子类的C::f()还是自己的B::f()呢？ 按照我们对面向对象语言的理解和要求，最终调用的肯定是C::f()。但是按照vtable的布局要求，B::f()中this所指向的是&amp;c+8的地址，那么基类又是怎么知道最终需要调用C::f()并且找到子类的地址&amp;c呢？ 以上代码的打印为： 123class Cvirtual void C::f() this: 0x7ffeefbff560virtual void B::k() this: 0x7ffeefbff568 可以看到this指针的确是真实的vtable指针，概括为C语言大概是这样的： 12345678struct C c;B::k( &amp;c + 8 /* sizeof(B::f) */ );// 而k()中的调用可以解释为void B::k(B *this) &#123; func_ptr p = vtable_get(this, B::f); p(this);&#125; 要知道编译器具体为我们做了什么魔法操作，那么我们就需要看看其汇编结果了。 在this-&gt;f()单步跟踪，我们会发现他会进入一个奇怪的函数。 12345670x100001620 &lt;+0&gt;: pushq %rbp0x100001621 &lt;+1&gt;: movq %rsp, %rbp0x100001624 &lt;+4&gt;: movq %rdi, -0x8(%rbp)0x100001628 &lt;+8&gt;: movq -0x8(%rbp), %rdi0x10000162c &lt;+12&gt;: addq $-0x8, %rdi0x100001630 &lt;+16&gt;: popq %rbp0x100001631 &lt;+17&gt;: jmp 0x100001540 ; C::f at main.cpp:103 说明我们虚函数表里面的C::f()并不是我们所写的那个方法，而是编译器帮我们封装了一层，专门进行了this-8这样的还原指针地址的操作。 可以说这一顿操作真的是很厉害，我们平时用的时候都不曾注意这些，也不曾深入了解为什么C++中有些方法必须是虚函数，或者有些时候虚函数存在设计缺陷。 不过在debug的过程中，xcode中this指针永远是显示的子类的指针，不知道做了如何的处理。 最后C++依然是一门比较复杂的语言，虽然我个人还是比较喜欢C++的特性，拥有非常大的灵活性，但是不得不说要用好还是非常难的。","categories":[{"name":"C++","slug":"C","permalink":"http://djs66256.github.io/categories/C/"}],"tags":[{"name":"vtable","slug":"vtable","permalink":"http://djs66256.github.io/tags/vtable/"}]},{"title":"CPU分支预测","date":"2019-01-28T18:27:04.000Z","path":"2019/01/29/2019-01-29-CPU分支预测/","text":"CPU在我们不知道的情况下做了很多的优化，下面我们就来看看。 Case如下，有一个n长度的数组，内容为0~256的随机数。 1234567int array[i];int sum = 0;for (int i = 0; i &lt; n; i++) &#123; if (array[i] &lt; 128) &#123; sum += array[i]; &#125;&#125; 如果该数组是一个排好顺序的数组，那么同样条件下执行该逻辑。 我们会发现排序的会比未排序的执行效率高很多，甚至是其几倍的关系，这是为什么呢？ 这就涉及到CPU在执行条件语句的时候所做的优化了，也就是分支预测。 Why?分支预测是指在执行条件分支前，就去猜测其条件结果。其目的是为了提升CPU流水线的执行效率。在现代CPU中，分支预测扮演着一个非常重要的，提升效率的角色。 如果没有分支预测，那么CPU需要等待条件执行完后才能知道下一步的跳转地址。为了消除之间的等待时间，CPU会去预测其条件结果，是更倾向于true，还是更倾向于false。在预测错误的情况下，需要忽略之后的指令，并且重新加载正确的指令。 重新加载指令所造成的时间浪费取决于流水线架构CPU的层级。比如下图最简单的4级流水线。现代CPU往往拥有非常大的流水线级别，很容易造成10~20时钟周期的浪费。所以就更需要更智能的分支预测了。 流水线架构流水线架构CPU在执行指令的时候一般有如下几个过程： 取指 Fetch 译指 Decode 执行 Execute 回写 Write-back Static branch prediction / 静态分支预测静态分支预测是一个非常简单的策略，不依赖执行环境和执行过程中的状态。比如某些CPU，总是会预测一个条件是false的，有些则会对向前条件和向后条件做不同的预测，甚至有些架构允许插入预测代码。但总的来说，静态预测永远是编译器就已经做好了。 Dynamic branch prediction / 动态分支预测动态分支预测则是在运行期间来决定我们的预测结果。接下来我们要分析的均是动态分支预测。 前提在做分支预测前，我们所确定的是，所有分支都是有偏好的，即可能80%都会是true，或是false。 向前条件 / Forward conditional branches123for (int i = 0; i &lt; n; i++) &#123; if (condition) continue;&#125; 向后条件 / Backward conditional branches12if (condition) &#123;&#125; 无条件跳转 / Unconditional branches 动态分支预测 / Dynamic Conditional Branch Prediction动态分支预测相比于静态分支预测，最大的区别就是在运行的时候进行预测。一般对于结果的预测都是依赖于历史结果，也就是该条件前几次的执行结果进行统计。 这里描述几个简单的方案： 分支历史表 / Branch History Table (BHT) BHT中记录历史结果大小，可以为 1-Bit Prediction Quality1 bit只能记录 taken 和 not taken 两种结果，在很多场合下会降低预测准确率，特别是在循环中。 2-Bit Branch-Prediction2 bit就能记录4中状态： Strongly not taken Weakly not taken Weakly taken Strongly taken 这就需要2次不同的结果才能反转当前预测。当然可以选择更多 bit，但实验表明 2 bit 和 4096 个存储单元已经能够覆盖 82% - 99% 的场景了。 Two-Level Predictors and the GShare Algorithm另外还有一些更为复杂的方案，比如2层的预测算法，这里就不做描述了。 Branch Target Buffer (BTB)另一种是BTB，这个表内存的是地址映射，也就是能够让我们在取指的时候就知道这是一个条件指令，那么下一个取指就可以根据该表得到预测的分支地址了。 一般情况下，我们需要在译码阶段才能知道该指令是否是条件指令，才能决定下一个指令是否需要分支预测，利用BTB可以继续提前一步。","categories":[{"name":"CS","slug":"CS","permalink":"http://djs66256.github.io/categories/CS/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"http://djs66256.github.io/tags/CPU/"},{"name":"Branch Prediction","slug":"Branch-Prediction","permalink":"http://djs66256.github.io/tags/Branch-Prediction/"}]},{"title":"Objc类型推断","date":"2018-11-24T15:42:04.000Z","path":"2018/11/24/2018-11-24-Objc类型推断/","text":"Objc是一门非常啰嗦的语言，而且历史悠久，背靠C语言，发展缓慢。自从苹果有了新宠swift，更是对他不管不顾了，所以有很多现代语言拥有的优秀特性，Objc都无法享受到。其中一项就是类型推断。 每次我们在定义变量的时候，都需要先写类型，而Objc中类型名字又往往非常的长，所以很多时候一行初始化代码就让我们感到非常冗长。 1MYDoSomethingViewController *viewController = [[MYDoSomethingViewController alloc] init]; 而大部分时间，这些变量的含义相当明确，我们也并不需要去知道具体的类型，而我们却要每次去声明一次，显得非常多余。 得益于C语言的发展，在2015年，GCC和LLVM都先后的支持了类型推断，这样我们可以用于日常开发来增加代码可读性和简洁性。 首先我们定义两个类型推断关键字： 12#define var __auto_type#define let __auto_type const 以下是两者的对比： 12345678910111213141516171819- (void)t &#123; let view = [UIView new]; view.backgroundColor = UIColor.redColor; let dict = @&#123; @&quot;view&quot;: view &#125;; __weak let wself = self; __block var num = 0; let block = ^(UIView *view, NSDictionary *dict) &#123; __strong let self = wself; num = 1; [self func]; &#125;; block(view, dict); for (var i = 0; i &lt; 5; i++) &#123; &#125;&#125; 123456789101112131415- (void)t &#123; UIView *view = [[UIView alloc] initWithFrame:CGRectZero];; view.backgroundColor = UIColor.redColor; NSDictionary *dict = @&#123; @&quot;view&quot;: view &#125;; __weak typeof(self) wself = self; __block NSInteger num = 0; void(^block)(UIView *view, NSDictionary *dict) = ^(UIView *view, NSDictionary *dict) &#123; __strong typeof(wself) self = wself; num = 1; [self func]; &#125;; block(view, dict);&#125; 遗憾的是，由于这个特性是C语言的特性，所以目前无法识别oc中的一些特定语法，比如forin和容器模板类型。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"roadmap之objc","date":"2018-09-25T17:33:55.000Z","path":"2018/09/26/2018-09-26-iOS-roadmap之objc/","text":"objc是iOS的首要开发语言，在很多厂还是以objc为主，所以我们需要对objc更深入的了解，这里主要分为3个难点进行总结，runtime，runloop和block。 RuntimeObjc runtime是Objc运行的核心，我们都知道Objc是一门动态语言，为了实现其特性，必须需要一些动态的初始化。这里从几个方面进行介绍。 概念首先我们在了解runtime之前，必须要知道几个objc中重要的概念，才能更好的理解接下来的一些内容。 Class / Meta Class / isa在面向对象中，非常重要的一个概念就是类。在objc中，我们需要除了需要知道类的概念，还要知道元类的概念，以及他们之间的关系。 Class代表着一个对象的原型，所有对象都是在此模板上“复制”出来的。 而Meta Class可以认为是Class的原型，而Meta Class的原型则是NSObject。为什么需要这么设计呢？主要为了区分实例方法和类方法，也就是-和+方法。所有的实例方法均取自Class中，而类方法均取自元类中。 一个对象如何确定所属的类呢？是通过isa指针来实现的。在对象的第一个内存地址中就是isa指针，会指向其对应的类。而类中的isa指针则指向其元类。下图就能表示相互间的关系。 propertyproperty一般代表的是一个类的成员，也有一些特殊情况，我们会重写他，但是其含义都是一样的，都表示了这是一个成员对象，并且拥有getter或者setter方法。同时property会拥有部分特殊含义的标识，比如assign/strong/weak, readonly, class, non/atomic, setter/getter等，编译器会根据其标识自动生成不同的代码。在老版本的objc中还需要自已去绑定其成员对象@synchronize，现在则会默认生成一个_开头的同名对象，或者可以通过该方法重新命名一个名字。 在运行时，property也有一个对应的数组进行保存其名字与属性。 ivarivar在这里是真正的代表了一个成员对象的信息，包括其类型，大小，以及对应基址的偏移量。 一个实例对象，可以认为就是一个struct，我们需要访问成员就必须知道其偏移量才行。ivar的作用，就是记录其偏移量。 在我们访问成员变量的时候，并不是通过简单的self+offset来实现的，而是通过self+ivar-&gt;offset来实现的。这么做的原因是在objc中会有一个ivar rebase的过程，就是会通过父类的信息去重新推导出子类的偏移量。这样的好处是我们在编译上就不需要强依赖了，同时在升级过程中，也不会出现修改父类导致子类偏移量不对的问题了。 selector这是我们熟悉的方法对象，在实现上可以认为SEL就是常量字符串const char *，但是是由一个全局表所管理的字符串，其内容都是唯一的。所以我们再比较SEL的时候，是可以使用==来判断是否相等的，但是我们在传递SEL的时候不能简单的使用C字符串来表示。同时不同类上的同名方法也是指向了同一个地址的。 IMPselector代表的是这个方法的名字，而IMP则是这个方法的函数指针（关于函数指针可以去了解下C语言）。 在objc中方法名SEL和其具体实现IMP是分离的，也就是说我们是可以改变这两者的映射关系的。 IMP我们也是可以直接调用的，但是由于其隐去了参数等信息，所以相对来说是比较危险的，不太符合我们强类型的一些要求。 tagged point在64位系统中，有一种优化的指针类型，叫做tagged point，这种指针不会申请新的内存，而是把数据保存在指针中。由于64位系统的指针范围非常大，而我们的设备物理内存远远达不到这个量级，所以会有很多位是永远空余出来的，为了充分利用这一部分内存，就会把小数据写入这部分空闲区域，最常见的就是短字符串了。这类指针的最高位为1，所以可以通过判断&lt;0来确定是否是tagged point。 objc_msgSend这是objc种最核心的一个方法，是由汇编写成，为的是参数和返回值的透传，也可以去掉objc_msgSend的调用栈。 这个方法还有一些神奇的内容，这里就不细究了，建议自己学习汇编和C abi来研读这段简短的代码，\b这里做一个简单的流程介绍。 \b如果是nil，返回0 通过SEL指针，在cache中查找。这里的cache是hash table，并且保留了一定的容量，hash key是指针值，所以查找速度还是很快的。 如果没有找到，则到class的method_list中查找，这是一个数组的顺序遍历过程，所以会比较慢。这里可能会触发class的initialize。 找到对应方法，会更新到缓存中，然后再返回，以方便下次缓存中就能命中。另外这个缓存是没有过期一说的，也就是说会越加越多。 通过找到的这个函数指针，直接进行直接调用。 动态特性我们都说objc是一门动态语言，那么动态体现在什么地方呢？个人认为主要体现在2个地方，分别是类的动态性和方法的动态性。 类的动态性一般来说，类的创建只能是在编译期就已经确定好的，但是由于objc的特性，类的创建其实是在\b\b动态库加载的时候，这个特性很像一些脚本语言。 在全局有一个类的表保存着所有的类，如果我们导入一个动态库，那么\blibobjc会在其\b加载之后去读取其中的类的信息，并且创建\b\b一个类加入这个全局表中，这个加载过程我们之后再讨论，这里我们要知道objc的类并不是我们\b认知的那样，在编译的时候就固定了的。 当然，我们也可以手动通过代码来动态的创建一个类，并且加入\b全局表中，\b比如KVO就是这样实现的。 当然我们无法对已经存在的类进行修改，可以想象，一旦修改了会发生什么严重的后果。 方法的动态性方法的动态特性\b应该都很熟悉了，为什么会有这样特性，归功于objc_msgSend的机制，类并不会和函数指针绑定，而是通过SEL间接绑定的。 应用我们知道了objc的动态特性，也要知道他被应用于哪些地方。 category category是一些面向对象语言的特例，很少有强类型语言是支持这种写法的。那么为什么objc可以这么写呢？这还是要归功于objc类的创建是在运行期的。在加载完类后，会去遍历该macho中的category，并找到所对应的类，将其方法拷贝到类的method_list头部，这也是为什么category方法会覆盖原始类中的方法的原因了。而不同category之间，由于其加载顺序的不确定，所以不能确保谁的方法优先级会更高。如果想要通过这种方法来重写原本的方法，是强烈不推荐的，至于原因也不用多说了。 weak weak属性也是我们平时使用非常多的，weak属性虽然不在动态特性里，但是由于和associate非常相似，所以也拿出来说说。 weak的实现方式是将该对象和weak属性的指针的指针加入一个全局weak表中（源码中是SlideTable），如果该对象释放了，则会去weak表中清除所有指针所指向的内容，也就是把该指针置为nil了。 associate 我们都奇怪，为什么category能够增加方法，却不能增加成员呢？这也是由objc的特性所导致的，一旦category可以增加成员，那么会导致一个类的大小和成员偏移量都是不固定的，一旦载入了某个动态库，导致这些信息发生改变，对已经存在的对象是无法处理的，所以无法对已经存在的类进行ivar相关的修改了。 associate的实现和weak非常类似，也是在一个全局的表中，加入该对象，在释放的时候会去遍历该表，并将其内容进行释放清理。 method swizzle 这个应该是我们最先意识到其动态能力的功能了，很多库都用到了该实现。其原理也很简单，改变了SEL和IMP的映射关系而已。 网上有很多人讨论是否需要使用该特性。个人的观点是能不用则不用。如果你是一个小团队开发，大家天天都能面对面讨论，那么这个问题不会特别大，但是如果这个项目庞大到必须进行模块拆分，很有可能就会给项目带来不可控因素。由于objc runtime是一个全局的东西，你无法把风险只控制在一个模块内，一旦出了问题就会非常严重。 比如很多项目可能都会去改写objectAtIndex:，去除其越界的可能和NSNull对象，但是很有可能就因为表面上不会产生crash了，但是问题依旧存在，逻辑上的问题也依旧存在，如果这是一个支付功能，可能就会变成错误的金额导致严重的线上问题。 KVO 这是苹果后来新加入的一个特性，他会动态的为被观察对象创建一个子类，并且重新其观察属性的setter方法，并将该对象的isa指向新的子类。 这个子类在使用过程中并没有被察觉是因为他还重写了他的- class方法，如果你使用objc runtime方法获取，则会得到其真正的类型。 所以在setter方法中，我们就不需要再去写willChangeValueForKey了，写了反而会导致触发两次。 JSPatch， RN 这一类都是通过其方法的动态特性实现的，通过方法名来反射其真正的方法，这里就不在详细赘述了。 初始化为了更加了解objc，就需要了解其整个加载与初始化的过程。以及+load和+initialize的调用时机。（+load方法苹果官方已经不推荐使用，个人认为主要有2个原因，1是影响启动时间，2是加载的顺序太早，也早于C/C++的constructor方法，可能会导致一些初始化顺序上的错误。我们也尽量避免使用吧。） load / initialize我们要知道这两个方法被调用的条件是什么。 load方法是类被初始化的时候调用，也就是在内存构建出全局类表之后，再统一调用其+load方法，当然，在加载依赖动态库的时候会先调用动态库的+load方法。 initialize是类被实例化的时候会被调用，他和+load没有直接连接，也没有先后顺序关系。 objc_init这个是libSystem初始化objc runtime的入口，在这里比较重要的就是他会注册一个回调_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);。在动态库加载的生命周期中会进行objc类的初始化和+load方法的触发。值得注意的是这个回调的调用时机非常早。 然后会遍历macho文件中的objc信息，读取Class信息，并且将创建好的Class加入全局类表中，读取注册所有的SEL，读取并注册所有的protocol。 然后开始realizeClass，主要就是准备各种状态，基类元类信息和protocol，property等信息。 然后开始读取category信息，并且将其方法列表拷贝到class的method_list头部。 此后，开始调用+load方法 message forward当objc接收到不存在的SEL的时候，这时候会触发message forward，也就是系统给予我们一次机会，重新定向消息，比如转发给第三者。有些实现就是利用这个特性实现其proxy的功能。 除了发生不能响应消息会触发forward外，其实我们也能够直接手动通过_objc_msgForward来实现。 forward转发需要生成invocation来实现，这会导致性能的大幅下降，所以尽量不要使用这种特性。也有些地方介绍将其导向到一个空方法来避免这类crash，但这也会带来一些不可预期的错误，比如返回值问题，可能会产生一些随机值，带来更大的影响，所以个人不太建议这种方式去处理奔溃率的问题，这就是一种偷懒的自欺欺人方式。 Runloop接下来我们来看看另一个非常重要的概念，runloop。runloop对于我们来说非常重要，可以说在我们刚入门的时候就已经在使用它了。 runloop其实就是一个死循环，在新的任务进入前一直保持等待状态，同时保证加入的任务按照顺序执行，这个在其他平台也有对应的实现。其目的有3个： 保证线程不会直接退出 保证线程内的子任务按照顺序执行 用于线程间通信，也就是异步调用 线程要了解runloop和线程之间的关系，两者并不是等同的，runloop并不属于多线程的技术，只是在一个线程内保持一个事件队列来保证线程等待。 runloopMode需要理解不同mode对应的触发时机，什么时候需要使用不同的mode。 timertimer需要结合mode来理解和使用。 autorelease pool为什么要把autorelease pool放到这里说呢，主要是因为他触发的时机和runloop相关。他会注册两个observer在runloop中，分别为BeforeWaiting和Exit的时候，这能增加我们对于程序运行的理解，虽然现在arc很少碰到autorelease对象，但也要明白什么时候进行内存回收的。 BlockBlock内容比较简单，首先我们要知道我们平时所使用的block分为3种，也是从其内存所处位置来区分的： malloc block stack block global block 了解上述几种类型的区分主要是为了能够更清楚的处理内存循环引用的问题，知道哪些情况下会出现循环引用。在arc中，一般很少存在stack block，因为一旦被赋值则会自动进行拷贝操作。 strong和copy属性对于block来说其实都是一样的，最终转化为_Block_copy，但习惯和约定上我们都使用copy属性。 block按照生命周期来看，可以分为逃逸型(ESCAPE)闭包和非逃逸(NONESCAPE)型闭包，逃逸型闭包往往会引发内存泄露问题。 内存泄露特别需要注意隐式self的循环引用。 需要了解block, weak, __strong之间的区别和作用。 进阶block其实就是一个struct对象，其结构和objc对象布局类似，不过会有一个固定的void (*invoke)(void *, ...);成员，可以了解下这个方法的参数分别是什么，和objc_msgSend有什么类同和区别。 然后会把所有捕获的参数拼在结构最后，也可以看看block对象是如何实现其功能的，这里简单说一下，block对象是直接在堆上生成的，所以不受栈的限制。 既然是按照objc对象布局的，所以也就可以接收objc消息，和像objc对象一样使用了。 具体实现可以自行研读libclosure源码。 总结要了解这些基础知识非常建议自己去读读源码，而他需要很多的基础编程知识，才能够读通其源码。 这里介绍了一些关键点，但并没有很详细的对每个点进行讨论，我仅仅作为抛砖引玉，个人还是建议亲自研读源码或者官方文档。 可以前往github查看其思维导图。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"roadmap","slug":"iOS/roadmap","permalink":"http://djs66256.github.io/categories/iOS/roadmap/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"http://djs66256.github.io/tags/runtime/"},{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"},{"name":"objc","slug":"objc","permalink":"http://djs66256.github.io/tags/objc/"},{"name":"runloop","slug":"runloop","permalink":"http://djs66256.github.io/tags/runloop/"}]},{"title":"iOS-roadmap之前言","date":"2018-09-24T16:25:37.000Z","path":"2018/09/25/2018-09-25-iOS-roadmap之前言/","text":"在经历了这么多年的iOS开发，当初一个什么也不懂的大学生，也通过自身的努力，慢慢的有了一些心得和体会，所以这里准备将自己这么多年在iOS方面的经验进行一个总结。 做这件事的主要目的有两个： 这么多年零碎的学习，却没有一个比较完整的总结，形成不了一个体系，我也感到比较遗憾，所以这里进行一些总结和归纳，让自己能更系统更全面的审视iOS开发。 自己在iOS开发的道路上几乎都是自己摸索，也走了不少弯路，所以想能够给新的开发者一些建议和引导。 这里会涉及的东西并没有那些控件的使用，类的使用，我认为这些东西官方文档才是最清楚和正确的，所以我不会去讨论如何编码这么细节的内容。 同时这里可能会涉及一些比较底层的内容，也有一些比较生僻的东西，可能需要读者拥有一定的基础。 并不想单纯的罗列这些知识点，可能会详细讨论某些问题，或者按照一定的顺序去讲解内容，尽量保证我们对于知识的理解是有条理的，全面的。 内容的会持续更新，我会在博客和github同时更新。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"roadmap","slug":"iOS/roadmap","permalink":"http://djs66256.github.io/categories/iOS/roadmap/"}],"tags":[]},{"title":"程序在执行main方法之前都在做什么","date":"2018-09-19T14:40:34.000Z","path":"2018/09/19/2018-09-19-程序在执行main方法之前都在做什么/","text":"我们很少关注应用启动前，系统会给我们做些什么事情，可能知道+ load和constructor会在main方法之前执行。那么这次我们来看看main方法之前都做了哪些事情。 以下代码均经过摘取简化。 1. _dyld_start系统启动应用的入口是_dyld_start，是用汇编写的。 12345// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)bl __ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm// LC_MAIN case, set up stack for call to main()br x16 首先dyld会调用dyldbootstrap::start，该方法会返回main函数的函数指针，并将其保存到x16中，然后才会继续调用main方法。但是调用这两个方法的方式是不一样的，bl是真正意义上的方法跳转，是会产生堆栈信息的，而br则相当于long jump，是不会产生新的栈帧信息的，所以我们在断点的时候，只能看到main作为程序入口的栈信息了。 那么接下来我们来详细看看dyldbootstrap::start里面做了些什么。 2. dyldbootstrap::start12345678910// if kernel had to slide dyld, we need to fix up load sensitive locations// we have to do this before using any global variablesrebaseDyld(dyldsMachHeader, slide);// allow dyld to use mach messagingmach_init();// now that we are done bootstrapping dyld, call dyld&#x27;s mainuintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); 首先，我们都知道系统为了安全性，其实每个程序都会有一个随机的偏移值的，那么这里首先要对应的去除这个偏移量，以及初始化mach内核。 然后调用dyld::_main，这个最终会返回main函数地址。 3. dyld::_main123456//// Entry point for dyld. The kernel loads dyld and jumps to __dyld_start which// sets up some registers and call this function.//// Returns address of main() in target program which __dyld_start jumps to// 12345678910111213141516171819202122232425262728293031// add dyld itself to UUID listaddDyldImageToUUIDList();// instantiate ImageLoader for main executablesMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);// load any inserted librariesloadInsertedDylib(*lib);link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);// link any inserted libraries// do this after linking main executable so that any dylibs pulled in by inserted// dylibs (e.g. libSystem) will not be in front of dylibs the program useslink(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);// only INSERTED libraries can interpose// register interposing info after all inserted libraries are bound so chaining worksimage-&gt;registerInterposing();// apply interposing to initial set of imagessImageRoots[i]-&gt;applyInterposing(gLinkContext);// run all initializersinitializeMainExecutable();// notify any montoring proccesses that this process is about to enter main()notifyMonitoringDyldMain();// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getThreadPC(); 我们按照注释所说的，首先会加载inserted libraries，这个是通过运行参数中的配置，加载其中的lib，我们一般用不到。 然后是链接，也就是macho文件的初始化，绑定一些符号表等，这个在下面进行详细说明。 interpose在iOS中是被禁用的，其功能相当于swizzle，这里我们也不去详细说明了。 然后是执行初始化工作，包括oc的运行时初始化，c++的静态对象初始化，c的constructor方法。 最后返回main方法的地址。 3.1 dyld::link这里我们来看看link都做了些什么。 12345678910// add to list of known images. This did not happen at creation time for bundlesif (image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked()) addImage(image);// we detect root images as those not linked in yetif (!image-&gt;isLinked()) addRootImage(image);// process imagesimage-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); 3.2 ImageLoader::link12345678this-&gt;recursiveRebase(context);this-&gt;recursiveBind(context, forceLazysBound, neverUnload);if ( !context.linkingMainExecutable ) this-&gt;weakBind(context);// interpose any dynamically loaded imagesthis-&gt;recursiveApplyInterposing(context); 3.3 ImageLoader::recursiveBind12345678910111213// Normally just non-lazy pointers are bound immediately.// The exceptions are:// 1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately// 2) some API&#x27;s (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately// bind lower level libraries firstfor(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload);&#125;// bind this imagethis-&gt;doBind(context, forceLazysBound); 在绑定的时候会先递归绑定其依赖的动态库，然后再来绑定自身。 3.4 ImageLoaderMachOCompressed::doBind没啥好说的，看注释吧。 1234567891011121314151617// run through all binding opcodeseachBind(context, &amp;ImageLoaderMachOCompressed::bindAt);// if this image is in the shared cache, but depends on something no longer in the shared cache,// there is no way to reset the lazy pointers, so force bind them nowif ( forceLazysBound || fInSharedCache ) this-&gt;doBindJustLazies(context); // this image is in cache, but something below it is not. If// this image has lazy pointer to a resolver function, then// the stub may have been altered to point to a shared lazy pointer.if ( fInSharedCache ) this-&gt;updateOptimizedLazyPointers(context);// set up dyld entry points in image// do last so flat main executables will have __dyld or __program_vars set upthis-&gt;setupLazyPointerHandler(context); 3.5 eachBind12345// resolve symbolsymbolAddress = this-&gt;resolve(context, symbolName, symbolFlags, libraryOrdinal, &amp;targetImage, last, runResolver);// do actual updatereturn this-&gt;bindLocation(context, addr, symbolAddress, type, symbolName, addend, this-&gt;getPath(), targetImage ? targetImage-&gt;getPath() : NULL, msg); 4. dyld::initializeMainExecutable我们回到初始化这里来。经过上面的macho绑定工作以后，虽然已经是一个完整的程序结构了，但是仍需要完成一些运行时的初始化。 12345// run initialzers for any inserted dylibssImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]);// run initializers for main executable and everything it brings upsMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); 5. ImageLoader::runInitializers1234567// Calling recursive init on all images in images list, building a new list of// uninitialized upward dependencies.this-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);// If any upward dependencies remain, init them.if ( ups.count &gt; 0 ) processInitializers(context, thisThread, timingInfo, ups); 此时依赖的动态库会递归的调用初始化方法。 12345678910111213141516// initialize lower level libraries firstfor(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) &#123; // don&#x27;t try to initialize stuff &quot;above&quot; me yet if ( libIsUpward(i) ) &#123; uninitUps.images[uninitUps.count] = dependentImage; uninitUps.count++; &#125; else if ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123; dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps); &#125;&#125;// initialize this imagebool hasInitializers = this-&gt;doInitialization(context); 这里可以看出来，动态库的初始化方法是早于自身被执行的。 12345678bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); return (fHasDashInit || fHasInitializers);&#125; 而初始化方法主要就是macho中被标识为S_MOD_INIT_FUNC_POINTERS的section中的方法，详细可以去了解下macho相关知识。 6. libSystem_initializer以上其实就已经是整个初始化过程了，这里主要讲下一个非常重要的初始化方法。位于libSystem动态库中的libSystem_initializer。 大家都知道，在iOS中所有的系统基础库均出自libSystem，所以这个库一般都是第一个被初始化的。接下来我们来看看他具体做了什么。 12345678910111213141516171819__libkernel_init(&amp;libkernel_funcs, envp, apple, vars);__libplatform_init(NULL, envp, apple, vars);__pthread_init(&amp;libpthread_funcs, envp, apple, vars);_libc_initializer(&amp;libc_funcs, envp, apple, vars);// TODO: Move __malloc_init before __libc_init after breaking malloc&#x27;s upward link to Libc__malloc_init(apple);_dyld_initializer();libdispatch_init();_libxpc_initializer();_container_init(apple);__libdarwin_init(); 这里我们可以根据名字看到其初始化都做了些什么，有个关键的libdispatch_init，我们再来看看。 12345678910111213void libdispatch_init(void)&#123; _dispatch_hw_config_init(); _dispatch_time_init(); _dispatch_vtable_init(); _os_object_init(); _voucher_init(); _dispatch_introspection_init();&#125;void _os_object_init(void)&#123; _objc_init();&#125; 最终他会去调用objc的运行时初始化。 12345678910111213141516171819void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_2_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; 在这个初始化中，会注册一个动态库初始化完成的回调。 12345678910111213141516171819/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/const char *load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; // Discover load methods load_images_nolock(state, infoCount, infoList); // Call +load methods (without runtimeLock - re-entrant) call_load_methods(); return nil;&#125; 在这个回调中，会去初始化objc的运行时，并且与当前objc运行时合并，这里的合并可能会导致一些方法被覆盖等问题，category会覆盖原本的方法，主应用会覆盖动态库的方法，当然你也可以利用这个特性，做一些黑科技（个人不建议这样去覆盖方法，尽可能使用runtime来做，或者不要去做）。这些都是题外话了。 然后才是调用load方法。load方法和其他constructor方法一样都是被依赖的动态库中的方法是早于依赖方调用的。 注意，dyld_image_state_dependents_initialized这个事件是在自己doInitialization之前被调用的，所以一个动态库中load方法会早于自己的其他constructor类型的方法，在做某些黑科技的时候不要搞错了。 最后这里我们主要需要注意的就是初始化方法调用的顺序问题，在做一些初始化的时候不要出现违反顺序的情况。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"dyld","slug":"dyld","permalink":"http://djs66256.github.io/tags/dyld/"}]},{"title":"函数式编程思想简介","date":"2018-09-16T08:15:38.000Z","path":"2018/09/16/2018-09-16-函数式编程思想简介/","text":"在平时的iOS开发中，我们大部分还是依靠着最早的MVC的思想开发着，最多也是进行了部分变种，比如MVP，MVVM，这些都是完全的面向对象的思想，在处理一些简单的场景的时候还是非常有效的，但是在某些场合，我们总会觉得难以解耦，难以进行模块化拆分，这是由于目前大部分架构中，在业务逻辑部分依然是过程性的，整个过程中还是需要依赖大量的其他模块，这次我们来看看函数式编程的思想，以另一种角度来看问题是否能够去解决部分问题。 概念函数式编程对于我们这种熟悉了面向对象的人来说，是非常别扭和难以理解的。首先我们需要了解几个概念，这里不讨论严格的概念，可以说这是我结合iOS开发的部分特性所做的一些理解。 函数是一等公民这是函数式编程中最重要的思想基础。万物都是对象，包括函数。这个思想的引入，让我们可以将函数作为参数、返回值这一类原本对象才可以做的事情。在objc中的block，swift中的closure都可以认为是函数式编程的基础。 高阶函数参数或者返回值中存在函数对象的，都认为是高阶函数。可以说高阶函数是函数式编程中的连接器，他同样也可以实现比如函数修饰器这样的功能。 纯函数没有副作用的函数，简单的说就是给以相同的输入，必定有相同的输出。这也是函数式编程思想中非常重要的一个点，因为没有副作用可以让我们的设计变得更加简单。 monad关于monad这个概念，很多人都有不同的理解，但基本上都是把纯函数连接起来的一种设计模式，同时这也是纯的。这个概念在业务开发中基本上不太可能实现，但是在业务的部分场景还是可以做到的。 优势由于函数式编程中要求大量的纯函数，那么我们就可以很容易的进行单元测试。 同时在多线程编程中，由于其独立性和无副作用，我们也不需要思考数据竞争，死锁等这类问题。也能更灵活的进行功能拆分和执行分配。 函数式编程是一套比较全面的编程思想，对于我们面向对象比较熟悉的人来说，有些地方确实会比较奇怪。虽然说我们也可以用面向对象来实现类似的功能，但是函数式编程会更加简单和直接。 框架函数式编程是专门为了计算这类场景而生的，目前由于脚本语言的兴盛，这类思想也同时融入了很多面向对象语言中。 promisepromise可以说是我最早接触到的函数式编程相关框架。promise的初衷是为了解决异步callback的多次调用而开发的。 123456789step1(function (err) &#123; if (err) print(err) else step2(function (err) &#123; if (err) print(err) else step3(function (err) &#123; // go on ... &#125;) &#125;)&#125;) 那么通过promise，我们可以改写为： 12345step1().then(step2).then(step3).then(/* go on ... */).catch(print) ReactiveX同样类似的ReactiveX也具有相同的效果，不过RX把注意点更加放在了对数据的处理上面，这也就正式的把我们从逻辑的思维中脱离开来，从而关注数据的流动上。后面会来讨论这种思维的变化给我们带来了什么。 RX中signal, observer, observable, subject主要负责数据的流动，scheduler负责执行线程相关操作。 Redux参考ReSwift 可以说这是我接触到的第一个以函数式编程为基础的，专注于数据流动的框架。 关于这个框架的详细介绍，我相信有很多人都比我更加了解，也比我讲的好，所以这里就不做介绍了。 数据流动一个请求的例子在我们平时的开发过程中，基本上关注的是业务的流程实现，按照逻辑的顺序进行思考和设计，如果我们按照标准的面向对象来设计一个请求，那么很有可能是这样的。 12345678910111213141516171819- (void)request &#123; Request *req = [Request new] req.delegate = self; [req start];&#125;- (void)requestComplete:(Request *)req &#123; Request *req = [Request new]; [req startWithComplete:^(Request *req) &#123; if (req.error == nil) &#123; NSDictionary *json = [JSON parse:req.data]; ClassA *a = [ClassA from:json]; // ... &#125; else &#123; &#125; &#125;]&#125; 这是一个非常典型的设计方式，当我们只有一个请求的时候这样做也非常简单，但是一旦拥有多个请求的时候，事情就变得很复杂。那么如果我们使用函数式来改写，就比如AF所做的那样。 12345678910111213- (void)request &#123; Request *req = [Request new]; [req startWithComplete:^(Request *req) &#123; if (req.error == nil) &#123; NSDictionary *json = [JSON parse:req.data]; ClassA *a = [ClassA from:json]; // ... &#125; else &#123; &#125; &#125;]&#125; 这样在出现多个请求的时候，回调也能保证其唯一性。但是这个依然还是有一些问题。 数据解析和model化等操作依然需要在回调时自己去调用，如果将这些放入Request中，又难以保持低耦合性。 自动化测试困难，因为请求返回后必然是接着视图的更新或者业务逻辑的执行，自动化测试一旦涉及这些会显得很臃肿。 当多个请求在需要并发，而回调需要保持同步的时候。 流量控制只能依赖于网络层的来控制，同时线程控制依然需要手动控制，可能GCD会让这类操作稍微简单一点。 那么如果我们只关注数据来改写呢，可能会是这样的，为了更适合函数式编程，这里采用js来改写： 1234567Request().then(data =&gt; &#123; let json = JOSN.parse(data) let a = ClassA.from(json) // ...&#125;).catch(err =&gt; &#123;&#125;) 那么我们来看看如何解决上述的几个问题。 为了保证低耦合性，我们不希望将解析等操作放入网络层中，但也不希望在业务层过多的出现这类代码。 12345Request().then(JSON.parse).then(ClassA.from).then(a =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;) 而其中分离出来的中间过程，由于是纯函数，是可以完全的单元测试的，这也就增强了单元测试的粒度。如果你说客户端业务代码的单元测试是否有这个必要，那么我觉得很多时候没有这个时间和必要，但是当我们做一些基础库，或者SDK时，涉及的面非常广时，我们不得不去考虑单元测试的必要性，而且覆盖率越高越好。 如果要实现并发这种呢？按照数据的角度去思考其实就非常的简单。 1234567let req1 = Request().then(JSON.parse).then(ClassA.from)let req2 = Reqeust().then(JSON.parse).then(ClassB.from)Promise.all([req1, req2]).then(ab =&gt; &#123; // reload data&#125;).catch(err =&gt; &#123;&#125;) 由于中间过程是纯函数，那么我们要将他们放入子线程也就非常的简单，甚至RX自己就提供了这样的接口。 函数修饰器这是某些语言的特性，所以拿出来简单说说。 一个函数修饰器的参数中必然至少有一个是函数，返回的也依然是函数。这个比较难以理解，我们来举一个例子： 123456function needLogin(f) &#123; if (login) return f else return function () &#123; print(&#x27;error&#x27;) &#125;&#125; 那么我们需要为某个函数增加这个检查的时候，只需要增加一层修饰即可： 12let NewRequest = needLogin(Request)NewRequest().then(...) python: 1234@needLogindef Request() # ... pass 这种方法的优势在于，我们不需要在请求里去增加这种业务代码，同时也不需要在业务层里进行复杂的校验，同时这样表示也会更加接近自然语言。 最后这里简单介绍了函数式编程思想，和我们平时开发所使用的方法都不一致，也没有哪一种方法更好的定论。但是这一种以数据作为主体的方法却是非常值得我们思考的，因为可以认为数据是不会存在高耦合这样的问题，这也给我们提供了一种新的解决问题的思路。 这是一种新的思考方式，可以说这里的一些内容是无法让你真正改变的，很多还是需要靠自身的理解和感悟，才能将其应用于平时的开发之中。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://djs66256.github.io/tags/functional/"}]},{"title":"资源竞争与死锁检测","date":"2018-04-12T14:52:12.000Z","path":"2018/04/12/2018-04-12-资源竞争与死锁检测/","text":"多线程编程一直是一个非常难的话题，而资源竞争和死锁问题则是比较常见的多线程问题，这里我们来看看如何检测这些问题。 LLVM其实llvm项目自身就有这两者的检测方法。而在xcode中也集成了该功能，要使用也非常简单，选中Thread Sanitizer，并且重新编译运行即可。 那么接下来我们来看看使用情况以及他们是如何实现的。 Data Race数据竞争是我们非常容易犯的一个错误，而且出现问题了也非常难解决。因为出现的概率并不高，而且出现了问题也不会直接表现出来，而可能是通过其他方式表现出来。 首先我们来看一个非常简单的数据竞争问题： 123456789101112131415161718char g_char;- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self setCharB]; &#125;); [self setCharA];&#125;- (void)setCharA &#123; g_char = &#x27;a&#x27;;&#125;- (void)setCharB &#123; g_char = &#x27;b&#x27;;&#125; 虽然更新一个字节这种操作非常简单，但依然需要在这里加上锁，如果没有加上则会报告如下错误： 1234567891011121314151617181920==================WARNING: ThreadSanitizer: data race (pid=62345) Write of size 1 at 0x0001032e0f10 by thread T2: #0 -[ViewController setCharB] ViewController.m:35 (MallocTest:x86_64+0x100001499) #1 __29-[ViewController viewDidLoad]_block_invoke ViewController.m:26 (MallocTest:x86_64+0x1000013da) #2 __tsan::invoke_and_release_block(void*) &lt;null&gt;:2136816 (libclang_rt.tsan_iossim_dynamic.dylib:x86_64+0x622bb) #3 _dispatch_client_callout &lt;null&gt;:2136816 (libdispatch.dylib:x86_64+0x3847) Previous write of size 1 at 0x0001032e0f10 by main thread: #0 -[ViewController setCharA] ViewController.m:32 (MallocTest:x86_64+0x100001472) #1 -[ViewController viewDidLoad] ViewController.m:28 (MallocTest:x86_64+0x100001381) #2 -[UIViewController loadViewIfRequired] &lt;null&gt;:2136816 (UIKit:x86_64+0x1ce190) #3 start &lt;null&gt;:2136816 (libdyld.dylib:x86_64+0x1954) Location is global &#x27;g_char&#x27; at 0x0001032e0f10 (MallocTest+0x000100003f10) Thread T2 (tid=1422519, running) is a GCD worker threadSUMMARY: ThreadSanitizer: data race ViewController.m:35 in -[ViewController setCharB]================== 同时在左边的导航栏里会显示如下结果： 那么LLVM是怎么实现的呢？ 资源竞争的检测其实分为两部分，一部分是编译期的处理，另一部分是运行期的监控。 编译期，编译器会在数据访问的时候插入一段代码，来告诉检测器具体的数据访问情况。这个效果可以看具体的汇编： 1234567891011-[ViewController setCharA]: 0x106bd4448 &lt;+0&gt;: pushq %rbp 0x106bd4449 &lt;+1&gt;: movq %rsp, %rbp 0x106bd444c &lt;+4&gt;: movq 0x8(%rbp), %rdi 0x106bd4450 &lt;+8&gt;: callq 0x106bd4798 ; symbol stub for: __tsan_func_entry 0x106bd4455 &lt;+13&gt;: leaq 0x2afc(%rip), %rdi ; g_char 0x106bd445c &lt;+20&gt;: callq 0x106bd47bc ; symbol stub for: __tsan_write1 0x106bd4461 &lt;+25&gt;: movb $0x61, 0x2af0(%rip) ; lock + 63 0x106bd4468 &lt;+32&gt;: callq 0x106bd479e ; symbol stub for: __tsan_func_exit 0x106bd446d &lt;+37&gt;: popq %rbp 0x106bd446e &lt;+38&gt;: retq 运行期的监控则是靠动态库来导入的（在早期是依赖于静态库）。 可以看到，需要做到在编译期插入代码，不禁会想已经编译好的二进制该怎么办？这里我们来看两个例子： 1234CoreFoundation`-[__NSArrayM addObject:]: ... 0x10e5b0d82 &lt;+18&gt;: leaq 0x3a3fa7(%rip), %rax ; __cf_tsanWriteFunction ... 在NSMutableArray的代码中，我们发现有一个方法很可疑__cf_tsanWriteFunction，这个方法似乎就是上面的__tsan_write1方法的objc版。同时这个方法在真机上是没有的。 pthread_mutex_lock(&amp;lock)在该模式下实际对应的方法是libclang_rt.tsan_iossim_dynamic.dylib wrap_pthread_mutex_lock，同时dispatch_sync对应的方法是libclang_rt.tsan_iossim_dynamic.dylib wrap_dispatch_sync，可以知道他们都来源于一个非标准的动态库，这也就是说明在该模式下，系统会给我们链接一个已经编译好的，插入相应代码的动态库。这也代表着如果你引用了第三方二进制库，不一定能够检测出其中的竞争问题。 这里还需要检测到线程的状态，则是使用了pthread的一个公开接口： 12345678910typedef void (*pthread_introspection_hook_t)(unsigned int event, pthread_t thread, void *addr, size_t size);enum &#123; PTHREAD_INTROSPECTION_THREAD_CREATE = 1, PTHREAD_INTROSPECTION_THREAD_START, PTHREAD_INTROSPECTION_THREAD_TERMINATE, PTHREAD_INTROSPECTION_THREAD_DESTROY,&#125;;pthread_introspection_hook_install(pthread_introspection_hook); 算法这个的检测算法较为复杂，这里简单的来描述一下。 首先每一个数据根据其内存地址与访问线程id都会有一个对应的内存区块来保存其访问数据，一般是8 bytes映射为1 bytes，所以这里的内存分配器也是需要进行相应的修改。 将当前状态和已保存的数据进行比较。 如果是非同一个线程，并且已保存的数据访问时间是在当前访问时间之后。 那么认为这是一次资源竞争。 Dead lock死锁的检测相对比较简单了，他并不需要编译期的介入，而是纯运行时的检测。不过遗憾的是xcode上并没有集成，可能是觉得死锁本身就会严重阻碍程序运行，容易被察觉吧。 主要需要做的是hook掉所有锁相关的api，掌管willLock和didLock的消息，LLVM提供默认hook了pthread的相关接口。 每次加锁之前都会产生一个锁-线程的匹配，加锁之后释放该锁-线程的匹配。 如果A锁被某线程持有，同时B锁也被该线程持有，那么就形成了A=&gt;B的一个关联，如果这样的关联形成了一个环，那么就说明产生了死锁。该方法可以利用邻接二维矩阵来实现高效的查找。 如果恢复产生的死锁问题呢？这里我没有找到更好的办法，只能做以下两种处理： 杀死某个非主线程的线程，这样能够解除死锁，但会引起资源泄露和逻辑缺失的问题。 直接返回，可能会引起资源竞争的问题。 参考The “Double-Checked Locking is Broken” DeclarationFinding races and memory errors with compiler instrumentation.ThreadSanitizerAlgorithmllvm-compiler-rtvalgrind Dynamic Race Detection with LLVM CompilerThreadSanitizer – data race detection in practiceAddressSanitizer: A Fast Address Sanity Checker","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"data-race","slug":"data-race","permalink":"http://djs66256.github.io/tags/data-race/"},{"name":"dead-lock","slug":"dead-lock","permalink":"http://djs66256.github.io/tags/dead-lock/"},{"name":"muti-thread","slug":"muti-thread","permalink":"http://djs66256.github.io/tags/muti-thread/"}]},{"title":"深入理解内存分配","date":"2018-04-04T13:04:19.000Z","path":"2018/04/04/2018-04-04-深入理解内存分配/","text":"相信大家在学习C语言的时候，malloc是最早遇到的几个方法之一，这里就来深入的了解下，macOS/iOS中用户空间的内存分配。 引言首先，我们来看几个有意思的例子，以下几个在x86_64或者ARM64中的运行情况。 123char *str = malloc(32);free(str);str[0] = &#x27;a&#x27;; 123char *str = malloc(32);free(str);str[12] = &#x27;a&#x27;; 123char *str = malloc(32);free(str);str[18] = &#x27;a&#x27;; 这里先说一下结果，之后再来分析为什么，看看你有没有猜对。 这里均不会在str[x] = &#39;a&#39;;这一行崩溃，而可能在下次内存分配的时候崩溃。 第一个会报malloc: *** error for object 0x60000003cfa0: Invalid pointer dequeued from free list。 第二个会触发BAD_ACCESS的错误。 第三个运行一切正常，不会崩溃。 内核内存申请malloc方法并不止提供了向内核申请内存（syscall）的功能，它还提供了一整套用户态的内存管理。比如linux-2.3之后使用的ptmalloc，FreeBSD使用的jemalloc，以及macOS/iOS使用的malloc_zone及libmalloc。 向内核申请内存，触发系统调用，比较通用的接口有sbrk和mmap。在mac上，sbrk已经被废弃，而所有内存申请的内核调用最终都会转到 1234567kern_return_t mach_vm_allocate( vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags); 这个内核方法，我们可以通过vm_allocate去间接的调用它。 有人建议使用系统自带的malloc来构建自己的内存管理程序，这样就不用考虑不同平台的差异性；也有人认为在别人的管理系统上创建，不能达到更好的性能。这些还是具体情况具体分析吧，后面会简单介绍下如何构建自己的内存管理系统。 回到内核内存，内核内存都是按页管理的，你不可能向内核申请1byte的内存，所有的内存申请都需要经过round，否则会导致申请内存失败，其定义如下： 12345extern vm_size_t vm_page_size;// These macros assume vm_page_size is a power-of-2.#define trunc_page(x) ((x) &amp; (~(vm_page_size - 1)))#define round_page(x) trunc_page((x) + (vm_page_size - 1)) 用户态内存申请用户态的内存管理方案实在太多了，这里主要说一下大家都比较通用的部分，以及libmalloc的实现。 由于系统提供的内存，最少是一页，那么程序如果申请小块内存，特别像Objc这种含有大量小内存的情况，我们总不可能为一个指针分配一页内存吧。 这里几乎所有的内存分配库都采用了相同的做法，即将内存分为不同大小来管理，某些地方称为size class，某些地方称为chunk，而mac中就是malloc_zone了。 mac中的malloc_zone大致分为以下几种： nano zone. &lt;256 tiny zone. &lt;同nano small zone. &lt;1024 bytes (64-bit), &lt;512 bytes (32-bit) large zone. 申请不同大小的内存将会被派分到对应的zone，而各自的zone会采取不同的策略，比如nano, tiny, small是在内存页链表中寻找到一块拥有足够空闲空间的页，在这个页中分配该大小的内存；而large则是直接分配多个内存页，销毁的逻辑也完全不一样。 这里看到nano和tiny是重合的，他们之间有什么区别呢？这个问题放到下面多线程中去详细描述。 为什么需要将内存分配做这样的切分呢。由于我们平时使用到的内存大部分为小内存（这个在之后我会给一个统计结果），特别像是Objc这种语言，由于所有对象存在都是heap中的，所以基本都是以小指针对象，可能会导致大量小内存的申请和销毁，那么作为一个较为通用的内存分配器，那么肯定要考虑到优化小指针的分配效率。 这里再看一下Google的tcmalloc的划分策略。 The size-classes are spaced so that small sizes are separated by 8 bytes, larger sizes by 16 bytes, even larger sizes by 32 bytes, and so forth. 可以看到它对size-class的划分更为细致，而且它会在运行时根据具体情况具体可能会调整这个粒度，同时不会在同一页中分配任意size-class的内存，这样做是为了避免碎片。更高细粒度的划分会让程序在划分的时候更为简单，从而增加了效率，但这样也会增加缓冲内存的大小，个人觉得正是这个原因导致tcmalloc并没有考虑移动设备。 用户态内存销毁以上说明了内存申请的方式，现在来看看如何销毁内存的。 如果是大块内存(large zone)，那么视系统有没有指定内存页的缓存，否则就直接归还给系统。 那么如果是小内存（nano除外），在调用free之后 会先根据配置情况是否需要将内存重置为0x55，正常情况下不会执行这一步。 由于最小内存为2 * sizeof(void *)，所以会将第一个指针位置更新成为一个token。 合并旁边的空闲内存。 将第二个指针位置更新为下一个空闲内存的地址或者NULL。 将当前空闲内存加入free-list缓存，当下次申请新内存的时候，会优先在缓存中寻找是否有适合的空闲内存段，没有才会向系统申请新的内存页。 这里和我们的理解上有些偏差了，free并没有第一时间把我们的内存还给系统，也就是说free之后的内存其实还是在用户空间的，我们有可能还是可以任意读写该段内存的。这也就是引言中的例子。 但是如果我们修改了小内存的第一个指针位置，会导致我们的token失效，结果在复用该free-list中的缓存时候，会去校验当前缓存的token，导致Invalid pointer dequeued from free list错误。就如下所示： 1234typedef struct chained_block_s &#123; uintptr_t double_free_guard; struct chained_block_s *next;&#125; *chained_block_t; 12345void free(nanozone_t *nanozone, void *ptr) &#123; // ... ((chained_block_t)ptr)-&gt;double_free_guard = (0xBADDC0DEDEADBEADULL ^ nanozone-&gt;cookie); // ...&#125; 而如果我们修改的是第二个指针位置的数据，则会导致该指针非NULL，导致查询下一个空闲内存块的时候内存访问错误。 而如果我们去修改其他位置的数据，则不会有任何问题。 这里我们看到，一些非常奇怪的崩溃，有可能是由于这种写入释放后指针引起的。 tcmalloc可以看到上面的free过程中，是会有空闲内存的合并问题，这些当然也就会产生内存碎片。 123| 64 | 64 | || null | 64 | || 48 | null | 64 | v 如上图所示，中间的16byte可能就无法进行新的利用，好在我们的objc对象几乎都是几个指针的大小，加之malloc也会进行一次round，所以利用率还不错。 那么tcmalloc是怎么来进行优化的呢？由于tcmalloc在设计之初就不存在一个chunk中存在多个size-class的情况，所以一旦free，只需要将其丢进free-list中就可以了，在需要的时候再进行GC，将多余的空闲内存出让给别人或者还给系统。这样就避免了合并的性能开销。 多线程安全问题现在的应用都是多线程的，按照我们上面所述的，均没有涉及到线程安全问题，那么最简单的方法就是对所有内存申请及销毁进行加锁。但是锁是一种相对比较耗资源的东西，普通锁可能会涉及到系统调用，spinlock又可能会导致优先级反转等问题，那么大家都是怎么解决这个问题的呢？ libmalloc的解决方式比较传统，也就是加锁，但是在nano malloc中会有特别的优化。 每个CPU都会分配一个属于自己的分配器，也就是说每个CPU都有属于自己的内存缓存。 内存划分和tcmalloc类似，一个slot（size-class）中只有一种大小的对象，这样就不存在内存合并的问题了。 在修改free-list的时候采用的是原子操作，而不是传统意义的锁。 只在需要扩展堆，也就是增长空闲内存的时候，才使用真正的锁。 64位系统才开始支持，因为需要指针长度达到64位。 所有的指针均有相同的开头，比如x86_64上一定是0x00006nnnnnnnnnnn，arm上这个值会不一样。 所有的slot（size-class）最大容量均为0x20000大小，而里面存在的对象个数会不一样。 当申请对象个数超过对应slot的最大个数的时候（slot_exhausted），会fall through进入scalable zone进行申请。 造成以上几个魔法数字的原因是nona分配器使用指针储存了部分free-list的信息： 12345678910111213struct nano_blk_addr_s &#123; uint64_t nano_offset:NANO_OFFSET_BITS, // locates the block nano_slot:NANO_SLOT_BITS, // bucket of homogenous quanta-multiple blocks nano_band:NANO_BAND_BITS, nano_mag_index:NANO_MAG_BITS, // the core that allocated this block nano_signature:NANO_SIGNATURE_BITS; // the address range devoted to us.&#125;;// 这个是指针，也是该内存对象的信息typedef union &#123; uint64_t addr; struct nano_blk_addr_s fields;&#125; nano_blk_addr_t; 可以说nano_malloc_zone是专门为了OC而优化的。 而tcmalloc和部分其他分配器(jemalloc)，则是采取每一个线程上都独立拥有一个分配器，那么在该线程上进行free-list的操作时（申请内存的时候从缓存读取，及释放内存的时候直接加到缓存），就实现了无锁。当然，增长缓存以及GC等需要和其他线程交互的时候，还是需要锁的。这么做也会减少空闲内存的利用率。 思考之前看到过如何解决一些主线程大量释放对象的问题，为了优化释放所消耗的时间，将所有释放工作都放到子线程中，这是否真的是一种好的方案呢？ 内存分配优化根据我们上面的分析，可以看到这些分配器都是通用型分配器，它考虑了各种长度大小的性能，但是没有考虑过一些对象的生命周期等。 在一些特殊的场景和应用中，比如音乐、视频、人工智能、游戏等，可能会出现大量特定长度的对象，也可能会出现一些常驻内存，而这些对象会导致通用内存分配器的性能降低，以及重复利用率降低。 如果我们要做到极致性能的内存管理，那么我们就需要进行分析应用的内存分配情况，以及性能。然后根据需要自定义内存管理模块，并与通用管理进行对比。 替换系统默认内存分配方式替换默认malloc的方法很多，如果是使用的C++，替换new的方式也比较常见，鉴于默认new都是基于malloc实现的，这里只看替换malloc的方法。 define1#define malloc(size) my_malloc(size) 这种方法很傻瓜，只能替换可以被宏替换的地方，在部分场景替换还是很方便。 alias12void my_malloc () &#123; /* Do something. */; &#125;void malloc () __attribute__ ((alias (&quot;my_malloc&quot;))); 利用编译器进行符号的替换，这样可以替换本身以及静态库中的malloc。得益于MachO文件的二级命名空间，并不会替换动态库中的方法。 符号覆盖123void *malloc(size) &#123; dlsym(RTLD_NEXT, &quot;malloc&quot;);&#125; 在项目内可以直接定义新的malloc方法，链接器会将自身和静态库的malloc链接到自己的方法，如果需要调用原本的方法，可以使用dlsym(RTLD_NEXT, &quot;malloc&quot;)。同样无法替换动态库的malloc。 mac上可行1__attribute__ ((section(&quot;__DATA, __interpose&quot;))) iOS上被禁用的特性。 动态库符号链接替换fish_hook提供了一种修改动态库符号链接的方法，前提是替换的被替换的对象需要在动态库中，也是只能替换映射到自身的malloc，无法替换动态库的方法。 但是这种方式比较灵活，可以根据情况动态的打开关闭。 malloc_zone影响面最大的就是替换malloc_default_zone了，这样动态库的malloc也会使用新的内存管理。 系统并没有公开方法给我们替换default_zone的方法，其实私有方法也没有替换的方法，这里就用到了一个技巧，malloc_zone_unregister的时候，会将unregister_zone和zone列表最后一个zone交换来填补zone数组，所以就可以用以下方式来替换。 1234malloc_zone_register(my_zone);malloc_zone_t *default_zone = malloc_default_zone()malloc_zone_unregister(default_zone);malloc_zone_register(default_zone); 替换完以后必须把unregister的注册回去，不然可能会导致某些对象释放时找不到对应的zone。 同时这些方法之间无法保证线程安全，由于内部的锁并未公开，所以这里需要在程序运行之前，也就是main函数开始时，或是更早进行替换。 这样我们就得到了一个完全属于自己的内存管理方案。 应用内内存使用分析在进行替换之前，我们需要去分析当前内存使用状况，以及性能状态，从而才可以得知我们替换的内存管理方案有效。 为了做这个脚手架，也耗费了我相当长的时间。这里来看看如何去实现收集内存使用状况。这里就不能使用task_info，host_statistics和sysctl这样粗略的统计方法了。 由于性能以及Objc对象无法完全摆脱malloc_zone（会导致统计的死循环），所以这里使用C++来实现统计分析。 线程安全首先，需要考虑到的是线程安全，这里可以使用锁来简单的解决这个问题，但是这样同时也会大大影响性能，甚至可能会影响统计结果，所以这里采用ThreadLocal的方案。 每一个线程都有自己独立统计数据存放池，这样在新增数据等操作的时候就不需要加锁了，也尽量避免对性能有太大的影响。 malloc死循环我们统计malloc，在生成统计数据的时候依然可能会调用到malloc，这样我们就可能形成了一个死循环，那么我们需要解决这种循环有两种方法。 在统计过程中修改标志位，统计结束重置该标志位，在这之间的malloc不进入统计。如果上面选择使用的是锁，那么这里也要加锁，如果上面选择的是ThreadLocal，那么这里每个线程也需要一个独立的标志。 修改内存申请方式，不用malloc，使用系统底层实现vm_allocate。 这里，我选用第2中方案，为此需要C++的Allocator： 1234567891011121314151617181920212223242526template &lt;class _Tp&gt;class VMAllocator : public std::allocator&lt;_Tp&gt; &#123;public: typedef typename std::allocator&lt;_Tp&gt;::pointer pointer; typedef typename std::allocator&lt;_Tp&gt;::size_type size_type; pointer allocate(size_type __n, std::allocator&lt;void&gt;::const_pointer = 0) &#123; size_type n = round_page(__n * sizeof(_Tp)); vm_address_t addr; kern_return_t rt = vm_allocate(mach_task_self(), &amp;addr, n, VM_FLAGS_ANYWHERE); if (rt != KERN_SUCCESS) &#123; throw std::bad_alloc(); &#125; vm_protect(mach_task_self(), addr, n, true, VM_PROT_READ|VM_PROT_WRITE); return reinterpret_cast&lt;pointer&gt;(addr); &#125; void deallocate(pointer __p, size_type __n) noexcept &#123; size_type n = round_page(__n); kern_return_t rt = vm_deallocate(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(__p), n); if (rt != KERN_SUCCESS) &#123; &#125; &#125;&#125;; 获取每一个内存申请数据那么我们如何去获取这样详细的统计数据呢？只能去hook malloc的方法了，这里我们需要去hook malloc_zone-&gt;malloc的方法。 我们如何才能获得malloc_zone的真正对象呢，其实这些对象都是有全局的名字的。 12extern &quot;C&quot; malloc_zone_t **malloc_zones;extern &quot;C&quot; int32_t malloc_num_zones; 其中malloc_zones[0]就是default_zone。 由于malloc_zone是readonly状态，我们需要先修改权限才能继续hook。同时由上面所说的，这些都是非线程安全的操作，所以需要在启动的时候就完成，并且运行过程中不能修改。 123mprotect(orig_zone_ptr_, sizeof(malloc_zone_t), PROT_READ|PROT_WRITE);orig_zone_ptr_-&gt;malloc = Wrap::malloc;mprotect(orig_zone_ptr_, sizeof(malloc_zone_t), PROT_READ); logger其实系统也开放了两个钩子对象，分别给我们统计系统调用和malloc调用的情况： 123456789// For logging VM allocation and deallocation, arg1 here// is the mach_port_name_t of the target task in which the// alloc or dealloc is occurring. For example, for mmap()// that would be mach_task_self(), but for a cross-task-capable// call such as mach_vm_map(), it is the target task.typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *__syscall_logger; 123456789// We set malloc_logger to NULL to disable logging, if we encounter errors// during file writingtypedef void(malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *malloc_logger; 由于这里我们不需要统计malloc的数据（我们更关心OC对象），但是我们还是希望了解系统调用发生的次数（系统调用是一种比较慢的操作）。 启动这里我做了一个不完整的工具放在github，欢迎大家进行补充。只需要将动态库导入，并在程序开始的时候配置就可以了。 12345678910111213#import &lt;MallocDetector/MallocDetector.h&gt;int main(int argc, char * argv[]) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; malloc_detector_show_inspector(); &#125;); malloc_detector_attach_zone(true); malloc_detector_start(); @autoreleasepool &#123; return UIApplicationMain(argc, argv, NSStringFromClass([Application class]), NSStringFromClass([AppDelegate class])); &#125;&#125; 统计结果下面就来看看我在我们app里面统计得到的结果。 设备iPhone 7。在此期间系统调用12898次。这里是内存申请大小之和按照时间顺序的情况，其中size作log2处理。 可以看到主线程都比较平稳，而ui线程则是和用户行为相关，网络更是和网络请求密切相关。 下面是内存size-class的分布，这里粒度比较低（2^n)，个数(/1000) 可以看出来，我们对于256 bytes以下的对象占有绝对的比例，其中32 - 64 bytes最多。每个线程的分布也不一致，说明特定的业务场景会拥有不同的内存需求。 下面是不同大小耗费时间的分布，时间的单位为time_t。 可以看出来256 bytes一下的时间消耗具有优势。 以上统计结果可能并不能代表所有，统计的样本也不够多，但也能代表部分真实状况。 替换default_zone本来想替换为tcmalloc，但是它没有支持iOS系统，所以这里转而替换为jemalloc，由于时间有限，我也没有成功移植到arm上，所以这里看看模拟器的情况： 其中左边为苹果默认的分配器，右边为jemalloc。 在内存分布相近的情况，jemalloc看似略微好于苹果默认分配器，但这种差距似乎很小，可能在误差之内。 最后在移动应用中，内存的管理似乎并没有起到非常重要的地位，也不可能出现服务器那样的长时间运行，所以目前没有人做过这方面的优化处理。但是从这些点可以了解内存分配的一些情况，给我们一些不同的视角，具体情况下可以做一些特殊的优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"malloc","slug":"malloc","permalink":"http://djs66256.github.io/tags/malloc/"},{"name":"malloc_zone","slug":"malloc-zone","permalink":"http://djs66256.github.io/tags/malloc-zone/"}]},{"title":"原子性内存栅栏问题简述","date":"2018-03-28T17:09:17.000Z","path":"2018/03/29/2018-03-29-内存栅栏问题简述/","text":"内存栅栏(Memory fence)，也称为内存屏障(Memory barrier)，以前碰到这类概念都是基于锁的理解，比如dispatch_barrier。在看bmalloc的源代码时，发现其在使用原子性(atomic)的时候，出现了一种memory_order的概念，所以这里来简单看看原子性方面的问题。 Atomic方法在iOS中，我们平时最常用的原子特性大部分来自于OSAtomic，可是当我打开这个文件的时候，却发现这些方法已经被弃用了。 123OSATOMIC_DEPRECATED_REPLACE_WITH(atomic_compare_exchange_strong)__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)bool OSAtomicCompareAndSwap32( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue ); 很好奇这个新的方法，它来自于C标注库stdatomic.h中，而这个头文件是C11才引入的，说明这是一个非常新的方法。而在C++11中，STL增强了C++的多线程编程能力，所以也是这个时候引入的std::atomic。 atomic和volidate，atomic是真正的原子性，而volidate则仅标记对象为易变，提交给编译器优化使用的，并不能确保原子性。 Memory Order12345678typedef enum memory_order &#123; memory_order_relaxed = __ATOMIC_RELAXED, memory_order_consume = __ATOMIC_CONSUME, memory_order_acquire = __ATOMIC_ACQUIRE, memory_order_release = __ATOMIC_RELEASE, memory_order_acq_rel = __ATOMIC_ACQ_REL, memory_order_seq_cst = __ATOMIC_SEQ_CST&#125; memory_order; 关于memory_order这个概念，非常的令人困惑。其关键就是atomic能够保证单个的操作的原子性，但不能保证两个原子操作之间的顺序，这涉及到CPU对缓存刷新时进行的顺序重排。这里看两个简单的例子就可以理解了： 和我们平时的理解完全不一样，内存的修改顺序和实际的顺序居然可能不一致，这就是为什么会引入memory_order这个概念了。 Spin lock最后再来看看SpinLock的实现，所有SpinLock都是基于原子操作进行的，目前我碰到的大致分为两种： 比较无赖，强制for循环等待 比较友善，在超过一定循环次数，会放弃当前时间片 伪代码： 12345atomic flagwhile flag: loop_count++ if loop_count &gt; MAX_LOOP_COUNT: yield // iOS中可以是thread_swtich 所以当某些调度算法，即使是在优先级高的线程中yield放弃时间片，依然不能分配给优先级低的线程，就会导致优先级反转而死锁。 参考A Tutorial Introduction to the ARM and POWER Relaxed Memory Models","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"内存栅栏","slug":"内存栅栏","permalink":"http://djs66256.github.io/tags/%E5%86%85%E5%AD%98%E6%A0%85%E6%A0%8F/"},{"name":"内存屏障","slug":"内存屏障","permalink":"http://djs66256.github.io/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"},{"name":"fence","slug":"fence","permalink":"http://djs66256.github.io/tags/fence/"},{"name":"barrier","slug":"barrier","permalink":"http://djs66256.github.io/tags/barrier/"}]},{"title":"如何判断block回调未被调用","date":"2018-03-20T14:44:58.000Z","path":"2018/03/20/2018-03-20-如何判断block回调未被调用/","text":"在处理异步过程中，我们经常会碰到这种情况，需要异步处理并异步回调completionHandler，但是有些场景下，如果你在处理完异步逻辑，而不回调completion的时候，会产生逻辑上的bug或者内存泄露问题，那么我们就需要知道调用方是否调用了completion。 这里举几个比较典型的例子，比如WKUIDelegate中的回调： 1234- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler; 如果不回调其completionHandler，会导致其逻辑上的错误，那么这里我们来看看如何动态监测completionHandler是否被调用过。 这里说一下，WK是通过WTF的C++模板来实现的，我这里采用C语言来实现，其思路是大致相同的。 Block首先我们来看看Block是什么。虽然我们平时可以像OC对象那样去使用它，但它严格意义上来说并不是一个OC对象，或者说它是一中极为特殊的OC对象。 1234567891011121314struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void *, ...); Descriptor *descriptor; // imported variables&#125;;struct Descriptor &#123; uintptr_t reserved; uintptr_t size; void (*copy)(void *dst, const void *src); void (*dispose)(const void *);&#125;; 上面就是Block的内存布局，其中Block_layout是一个不定长的结构体，我们平时看到的捕获变量都会存在结构尾部。这里我们看到和OC对象一样，也有isa指针，但是这里的指针永远只会指向几个地方，这个之后会说。 其实我们在调用Block的时候，实际上调用的是block-&gt;invoke()，第一个参数是Block本身，然后是入参按顺序排下去，这一部分编译器都会给我们做好，所以一个block调用实际是这样的： 1block-&gt;invoke(block, arg1, arg2, arg3); 可以看到和OC的objc_msgSend方法相同的是第一个参数是对象本身，但是不同的是第二个参数不再是SEL。 既然知道了Block的结构，那么我们就可以自定义block了。 Block类型Block定义的类型有： 12345678910111213BLOCK_EXPORT void * _NSConcreteGlobalBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteStackBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteMallocBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteAutoBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2); 其中只有前2种是公开的，而我们平时会碰到的基本都是前3种类型，其中Global是永远不会被释放的，Stack是在栈上，所以只要栈销毁了就会被释放，Malloc和普通OC对象一样，采用引用计数来决定生命周期的。 那么我们回到最初的目的，如何判断是否被调用了呢？因为这个调用有可能是异步的，所以不可能通过__block bool called这样的临时对象来判断，也不能通过其是否由Stack拷贝成Malloc来判断，因为copy了并不一定会被调用。 Block Wrap这里要判断Block是否被调用，肯定是需要在原始Block基础上包裹一层可以计数调用次数的Block。C++会方便的多，可以直接通过模板来构造一个签名一样的Block。 这里我们利用了MallocBlock在未被任何人引用的时候会销毁的特性，在其被释放之前，来监测计数是否为0。如果是0则说明从来没有被调用过，不是0则说明被调用了。 那么接下来我们来看看如何动态构建这样一个Block，以及如果去包裹其实现体。 动态构建Block123456789101112struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void); void *descriptor; // imported variables void *block; int64_t called; char *message;&#125;; 首先我们将我们所需要的几个参数定义在Block末尾，分别是原始的Block，调用计数，以及错误信息（这个在报错的时候使用，和该方案关系不大）。 然后，我们需要定义自己的descriptor。这里重写了dispose方法，我们需要在这里判断是否计数为0，同时也要在这里将对象释放掉（由于在C环境中，所以block也需要手动将其释放）。 123456789101112131415161718192021222324void block_call_assert_wrap_dispose(const void * ptr) &#123; struct Block_layout *self = (struct Block_layout *)ptr; if (!((struct Block_layout *)ptr)-&gt;called) &#123; if (exception_handler) &#123; if (self-&gt;message) &#123; char *buf = (char *)malloc((strlen(self-&gt;message) + 64) * sizeof(char)); sprintf(buf, &quot;ERROR: Block must be called at %s!\\n&quot;, self-&gt;message); exception_handler(buf); free(buf); &#125; else &#123; exception_handler(&quot;ERROR: Block must be called at %s!\\n&quot;); &#125; &#125; &#125; Block_release(self-&gt;block); if (self-&gt;message) free(self-&gt;message);&#125;static const struct Descriptor descriptor = &#123; 0, sizeof(struct Block_layout), NULL, block_call_assert_wrap_dispose&#125;; 接下来就是将我们的所有数据内容填入Block_layout，来合成一个Block对象。 12345678910111213141516171819202122232425void *block_call_assert_wrap_block(void *orig_blk, char *message) &#123; struct Block_layout *block = (struct Block_layout *)malloc(sizeof(struct Block_layout)); block-&gt;isa = _NSConcreteMallocBlock; enum &#123; BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), &#125;; const unsigned retainCount = 1; block-&gt;flags = BLOCK_HAS_COPY_DISPOSE | BLOCK_NEEDS_FREE | (retainCount &lt;&lt; 1); block-&gt;reserved = 0; block-&gt;invoke = (void (*)(void))block_call_assert_wrap_invoke; block-&gt;descriptor = (void *)&amp;descriptor; block-&gt;block = (void *)Block_copy(orig_blk); block-&gt;called = 0; size_t len = strlen(message)*sizeof(char); char *buf = (char *)malloc(len); memcpy(buf, message, len); block-&gt;message = buf; return block;&#125; 其中invoke方法被我们的新方法block_call_assert_wrap_invoke所替换，在这个方法里面，会更新计数，并且调用原始block的invoke方法。 block_call_assert_wrap_invoke的实现block的方法是非常灵活的，参数个数以及返回值不一样的时候，经过前几篇内容，我们知道不能简单的通过方法调用来实现参数的传递，而且在这里我们也无法知道参数的个数以及类型。那么我们要怎么做才能简单而又实用呢？ 这时候，我们想到objc_msgSend方法，它就实现了非常技巧的实现了arguments forward的功能（其功能特性可以参考C++模板的多参传递template &lt;typename Args...&gt;）。 由于这里找不到i386的系统和arm32的系统了，所以只给出x86_64和arm64的实现方案。 123456789101112131415161718#if __x86_64__.align 4.global _block_call_assert_wrap_invoke_block_call_assert_wrap_invoke:mov %rdi, %r10movq $1, 0x28(%r10) // calledmovq 0x20(%r10), %r11 // blockmovq %r11, %rdimovq 0x10(%r11), %r11 // block-&gt;block-&gt;invokejmp *%r11#endif 123456789101112131415161718192021#ifdef __arm64__.align 4.global _block_call_assert_wrap_invoke_block_call_assert_wrap_invoke:mov x9, x0add x10, x9, #0x20 // &amp;blockadd x11, x9, #0x28 // calledmov x12, #1str x12, [x11]ldr x12, [x10] // blockadd x12, x12, #0x10 // block-&gt;invokeldr x12, [x12]mov x0, x11br x12ret#endif 这里简单的说明一下段汇编的逻辑。 取出block-&gt;called，并置为1（可能改为真正的计数会比较好）。 取出原始block block-&gt;block，并放到第一个参数位置。 调用原始block的invoke call block-&gt;block-&gt;invoke。 这样我们就非常简单的包裹了原始invoke方法，并且插入了自己的逻辑。 使用首先我们需要设置上述的exception_handler。 1234void exception_log(const char *str) &#123; NSLog(@&quot;%s&quot;, str);&#125;block_call_assert_set_exception_handler(exception_log); 这里我只是让他打印出错误，更好的应该是直接抛出异常[NSException raise:]。 在此基础上，定义一个宏以方便使用，以及可以加入#if DEBUG，来禁用线上环境的该功能，并且把当前的位置传递给exception_message： 123456789#define BLOCK_CALL_ASSERT(x) (&#123; \\ typeof ((x)) blk = x; \\ char *message = (char *)malloc(512); \\ memset(message, 0, 512); \\ sprintf(message, &quot;(%s:%d %s)&quot;, __FILE__, __LINE__, __FUNCTION__); \\ typeof (blk) ret = (__bridge_transfer typeof(blk))block_call_assert_wrap_block((__bridge void *)blk, message); \\ free(message); \\ ret; \\&#125;) bridge，恩我们是支持的ARC，所以在此为了防止类型转换的warning和error，在此使用宏来定义。（好像Objc++会有警告） 那么在使用的时候就是这样： 12345678910- (void)doAsyncWithCompletion:(block_t)completionBlock &#123; dispatch_async(..., ^&#123; completionBlock(...) &#125;);&#125;[self doAsyncWithCompletion:BLOCK_CALL_ASSERT(^&#123; do_after_completion(); do_clear();&#125;)]; 那么在此时，如果被调用者没有调用过completionBlock()时，就会触发exception_handler。这样我们就可以检测到是否出现可能的逻辑错误和内存泄露了。 1ERROR: Block must be called at (BlockCallAssert/BlockCallAssert/BlockCallAssert/ViewController.mm:41 -[ViewController test2])! 最后一般来说，我们一旦设计了包含completionBlock这样的接口，基本是需要回调方100%的回调的，如果可以不用回调，那么我们为什么不改变设计方案呢。 当我们的调用方是自己的时候，我们可以确保，而如果是SDK，我们就很难确保，文档这个东西是不靠谱的，那么我们就让调用方在忽略了回调的时候给他一个重拳吧（exception）。 这个方案的实现我放在github，和cocoaPods BlockCallAssert。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"}]},{"title":"C语言的动态调用","date":"2018-03-03T17:05:22.000Z","path":"2018/03/04/2018-03-04-C语言的动态调用/","text":"我们都认为C语言是一种非常静态的语言，几乎没有什么动态特性，同时往往在编译器就决定了整个运行方式，运行期是很难改变其运行状态的。其实C语言也是可以比较动态的，只是由于C语言是一个跨平台兼容语言，每个平台都有不同的实现，其动态化很难统一。这里我们看看在AArch64平台上的动态化实现。 其他语言的动态化脚本语言是非常具有动态特性的，其中典型的js就可以如下方式动态调用方法。 1234function hello() &#123; console.log(&#x27;hello world&#x27;)&#125;eval(&#x27;hello()&#x27;) 平时开发常用的Objc也有一定的动态特性，比如NSInvocation和 1- (id)performSelector:(SEL)aSelector; 都可以通过方法名称来调用。 那么我们来看看C语言的表现。 C语言的动态化根据上两篇内容，我们了解了iOS/Mac系统的执行文件格式MachO，而linux常用的ELF也是类似，执行代码都在TEXT段，如果我们要执行对应的方法，我们只需要拿到对应的地址（也就是函数指针）就行了。 那么如何从字符串找到对应的地址呢？这就涉及到函数符号表了，根据上篇的内容，不难找到其对应的函数指针，这里系统也给我们提供了一个封装好的方法。 1234567891011NAME dlsym -- get address of a symbolSYNOPSIS #include &lt;dlfcn.h&gt; void* dlsym(void* handle, const char* symbol);DESCRIPTION dlsym() returns the address of the code or data location specified by the null-terminated character string symbol. Which libraries and bundles are searched depends on the handle parameter. 有了函数指针之后，只需要将我们的参数填入对应位置，我们就可以实现方法调用了。如何填入参数呢？根据之前的讨论和aapcs64ARM官方文档的说明，我们可以按照这种思路去填入参数。 这里我们简单的把所有参数都认为是int64（或者说void *)类型，这样我们可以把以上逻辑简化为： 按x0-x7顺序填入寄存器 剩下的都放入栈中 这里设计个简单的动态调用接口： 12345extern void dynamic_call_func_name(const char *func, int64_t argc, int64_t *args) &#123; void *funcPtr = dlsym(RTLD_DEFAULT, func); dynamic_call_func((uintptr_t)funcPtr, argc, args);&#125;extern void dynamic_call_func(uintptr_t func, int64_t argc, int64_t *args); 以及测试函数： 12345678void one_arg(int64_t a1);void two_arg(int64_t a1, int64_t a2);void eight_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);void nine_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9);void ten_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10);void eleven_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t a11);void more_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t aa1, int64_t aa2, int64_t aa3, int64_t aa4, int64_t aa5, int64_t aa6, int64_t aa7, int64_t aa8); 那么动态调用可以写作： 1234int64_t args[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;dynamic_call_func_name(&quot;eleven_arg&quot;, sizeof(args)/sizeof(int64_t), args); 这样我们就实现了C语言的动态调用了。比如可以从其他端获得方法名和参数列表，就可以直接调用C方法了。这也是一些高级语言调用C语言的实现方式（cpython），以及一些rpc的实现方案。 接下来我们来看看如何填入参数，dynamic_call_func的实现方式。 动态设置参数这里我们只能通过汇编来设置参数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122.align 4// C方法会自动加上前缀`_`.global _dynamic_call_func_dynamic_call_func:// if func == NULL then returncbz x0, DCReturnZero// 申请栈空间，0x10用于缓存fp和lr，剩下的用于临时变量// 这里不能确定调用的方法是否会用到栈空间来传递参数，所以这里暂不考虑，fp == spsub sp, sp, #0x20stp x29, x30, [sp]mov x29, sp// 栈参数长度，初始化为0mov x15, #0str x15, [x29, #0x18]// 缓存一些入参，需要给下个方法腾出寄存器// x9 = func// x10 = x11 = argc// x12 = x13 = argsmov x9, x0mov x10, x1mov x11, x1mov x12, x2mov x13, x2// 没有参数直接 CALLcbz x11, DCCallFunc// 第一个参数ldr x0, [x12]sub x11, x11, #1cbz x11, DCCallFunc// 第二个参数ldr x1, [x12, #0x8]sub x11, x11, #1cbz x11, DCCallFuncldr x2, [x12, #0x10]sub x11, x11, #1cbz x11, DCCallFuncldr x3, [x12, #0x18]sub x11, x11, #1cbz x11, DCCallFuncldr x4, [x12, #0x20]sub x11, x11, #1cbz x11, DCCallFuncldr x5, [x12, #0x28]sub x11, x11, #1cbz x11, DCCallFuncldr x6, [x12, #0x30]sub x11, x11, #1cbz x11, DCCallFunc// 第八个参数ldr x7, [x12, #0x38]sub x11, x11, #1cbz x11, DCCallFunc// 栈参数// 开始计算栈空间，由于我们的参数都是int64类型// 所以栈空间x15 = x11(剩余参数个数) * 8mov x16, #8mul x15, x11, x16// The NSAA is rounded up to the larger of 8 or the Natural Alignment of the argument’s type// 这里需要对齐，我也不明白为什么and x16, x15, #0x8cbz x16, DCNoFixAlignDCFixAlign:add x15, x15, #0x8DCNoFixAlign:// 现在开始重新申请参数栈空间，并将栈空间大小存入临时变量`fp + 0x18`DCStoreStackArgsLength:str x15, [x29, #0x18]sub sp, sp, x15mov x15, spadd x13, x12, #0x38// 循环剩下的参数，逐个将其入栈:// for arg in args+8:// push(arg)DCPushStackArgs:add x13, x13, #0x8ldr x14, [x13]str x14, [x15]sub x11, x11, #1add x15, x15, #0x8cbnz x11, DCPushStackArgs// CALLDCCallFunc:blr x9// 这里首先销毁参数栈空间ldr x15, [x29, #0x18]cbz x15, DCRestoreStackDCRestoreStackArgsLength:add sp, sp, x15// 然后还原fp, lr// 销毁当前栈空间DCRestoreStack:ldp x29, x30, [sp]add sp, sp, #0x20ret// ReturnZero:DCReturnZero:mov x0, 0ret 经过测试，可以看到所有参数都被正确的传递过去了，说明这种思路是正确的。 总结那么C语言动态调用能给我们一些什么好处呢。这是一种rpc的思想，而且这不需要额外的rpc支持，就可以直接调用几乎所有C方法，但是这样也给我们的程序带来了一定的风险，包括权限，参数类型等问题。 同时也是快速实现，或者说兼容C实现高级语言的一种方式，比如cpython就是利用了这种思想。 由于不同平台的差异性，可能会导致兼容工作非常庞大，那么我们可以设计几种类型的参数，或者固定几个参数，来简化我们的兼容工作，比如将所有的对象都放到堆上，使用指针来传递。 开源项目libffi实现了多平台的动态调用，有兴趣的人可以自己去了解其实现。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[]},{"title":"运行时获取函数调用栈","date":"2018-01-20T18:02:57.000Z","path":"2018/01/21/2018-01-21-运行时获取函数调用栈/","text":"在之前做debug工具的时候，就有一个想法，在页面产生卡顿的时候，如果能够获取主线程的函数调用栈就好了，就可以分析出哪里出现了性能瓶颈。由于当时对这部分内容还不是很了解，就没有继续下去，现在重新来实践一次。 原理上篇说到的C方法的参数调用时，描述了C函数调用的大致流程，我们也知道通过BL跳转的函数调用会将返回地址存在LR寄存器中，如果还有后续的函数调用，则会把LR存入栈帧进行保存。 还是拿出我们的栈帧分布图： FP当前位置储存的是上一个FP所在的地址，也就是FP = &amp;FP0，而LR被储存在FP的下一个，由于栈是向上增长的，所以LR = *(FP + 1)。也就是说我们如果能拿到当前的FP就可以依次获得所有的二进制中的调用顺序： 1234while(fp) &#123; pc = *(fp + 1); fp = *fp;&#125; 以上就是我们此次遍历调用栈的最重要的思路，如果你了解汇编，这一部分应该很简单。 MachOMachO是MAC和iOS的可执行文件格式，包括动态库静态库。想要从调用地址获得方法名称，就必须要了解MachO的基本结构，这次我们不需要了解每个字段和数值都代表什么，只需要关心特定的几个字段。（苹果官方有关MachO的文档特别少，我们能够获得的相关文档 MachORuntime 也是非常的古老，甚至现在在官网上已经搜不到了，所以MachO是比较难以理解的一部分。） 关于MachO内容查看和解析，官方有几个命令行工具： The file-type displaying tool, /usr/bin/file, shows the type of a file. For multi-architecture files, it shows the type of each of the images that make up the archive. The object-file displaying tool, /usr/bin/otool, lists the contents of specific sections and segments within a Mach-O file. It includes symbolic disassemblers for each supported architecture and it knows how to format the contents of many common section types. The page-analysis tool, /usr/bin/pagestuff, displays information on each logical page that compose the image, including the names of the sections and symbols contained in each page. This tool doesn’t work on binaries containing images for more than one architecture. The symbol table display tool, /usr/bin/nm, allows you to view the contents of an object file’s symbol table. 这里我们使用GUI工具MachOView来说明，使用上更加简单方便。 一个MachO大致分为三部分： Header Load Commands 数据段 headerHeader中保存了CPU架构，load commands的个数等信息，这次我们都在ARM64的基础上进行分析： 12345678910struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; load_commands紧接着Header的就是load command了，这里存着一些加载信息，动态库，main函数和数据段等一些信息。所有的结构前两位都是一样的： 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 这次我们会遇到的有segment, symbol table相关的load commands。这里我们先不说明每个字段的作用，之后在使用过程中再来说明。 12345678910111213141516171819202122struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;struct symtab_command &#123; uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; /* symbol table offset */ uint32_t nsyms; /* number of symbol table entries */ uint32_t stroff; /* string table offset */ uint32_t strsize; /* string table size in bytes */&#125;; 数据段数据段包括了很多内容，也是最复杂的部分，大致包含了 TEXT可执行代码，DATA数据段，符号表，字符表等内容，这里我们需要了解的是Section(_TEXT,__text)和Symbol Table。 其中TEXT段就是我们的代码执行部分，可以直接进行反汇编。比如下面就是从微信SDK中获取的一段反汇编代码： 123456789-[AppCommunicateData MakeCommand:]:0000000000001e94 stp x29, x30, [sp, #-0x10]!0000000000001e98 mov x29, sp0000000000001e9c adrp x8, #0x40000000000000001ea0 ldr x1, [x8, #0x998]0000000000001ea4 bl _objc_msgSend0000000000001ea8 orr w0, wzr, #0x10000000000001eac ldp x29, x30, [sp]!, #0x100000000000001eb0 ret 而符号表就是保存了我们代码中全部的公开符号，包括动态链接的符号。比如下面就是一个解析后的符号表内容： 这里我们简单的介绍了一下MachO和本次所需要了解的内容，由于MachO是一个非常庞大而且复杂的结构，这里就不再深入了。接下来我们来简单看看一个函数的动态调用过程，来理解如何通过符号（也就是函数名称），来获取执行的地址（也就是下一个PC的位置）。 函数调用我们以上面+[ObjcException test]来进行说明。 首先我们从load_command中获取到符号表的位置。 然后在符号表中查找，得到上图的结构，其中value字段代表着在该文件中的偏移量0x1AF0。 我们找到在(__TEXT,__text)段中的这一行： 那么，要实现开头所说的符号查找，也就是该过程的一个逆过程，也就打通了道路。 LR查找符号我们从堆栈中获取的LR值并不是该函数的起始位置，也就是符号表中所记录的位置，而是函数返回地址，我们再来看看微信SDK的这一段代码： 123456789-[AppCommunicateData MakeCommand:]:0000000000001e94 stp x29, x30, [sp, #-0x10]!0000000000001e98 mov x29, sp0000000000001e9c adrp x8, #0x40000000000000001ea0 ldr x1, [x8, #0x998]0000000000001ea4 bl _objc_msgSend0000000000001ea8 orr w0, wzr, #0x10000000000001eac ldp x29, x30, [sp]!, #0x100000000000001eb0 ret 这里bl _objc_msgSend，LR所记录的应该是0000000000001ea8，而不是开头的0000000000001e94，那么我们要怎么定位该符号呢？ 我们知道，在执行代码区域，每个符号之间是连续的，而且符号会全部保存在符号表中，那么我们可以遍历符号表，查找到小于LR位置，并且距离LR最近的一个符号，那么我们就可以认为我们的函数跳转发生在该函数内部。 这样就找到了我们所需要的符号名称了。 下面就从实现角度来说明。 实现这里我们用纯C/C++来实现这部分，使用lambda来让代码更容易理解。这里的实现并不是完美的，只是作为说明整个流程。 准备工作在获取调用栈之前，我们最好将对应线程暂停： 123456789pthread_t thread;pthread_create(&amp;thread, nullptr, [](void *p) &#123; thread_suspend(main_thread); // generate symbols of (main_thread); thread_resume(main_thread); void *ptr = nullptr; return ptr;&#125;, nullptr); 获得线程当前状态MachO提供了获取暂停线程上下文环境的接口thread_get_state 1234567891011121314151617#if defined(__x86_64__) _STRUCT_MCONTEXT ctx; mach_msg_type_number_t count = x86_THREAD_STATE64_COUNT; thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&amp;ctx.__ss, &amp;count); uint64_t pc = ctx.__ss.__rip; uint64_t sp = ctx.__ss.__rsp; uint64_t fp = ctx.__ss.__rbp;#elif defined(__arm64__) _STRUCT_MCONTEXT ctx; mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT; thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;ctx.__ss, &amp;count); uint64_t pc = ctx.__ss.__pc; uint64_t sp = ctx.__ss.__sp; uint64_t fp = ctx.__ss.__fp;#endif 可以看到不同架构的获取方式是完全不一样的，这是由于不同平台底层实现的不同所导致的，但是对于C语言层面上来说，都是一致的，都有最基本的几个概念PC, SP, FP, LR。 遍历调用栈依照我们开头所说的方法来遍历: 12345do &#123; // print symbol of (pc); pc = *((uint64_t *)fp + 1); fp = *((uint64_t *)fp);&#125; while (fp); 查找符号一般来说，我们一个应用内会有多个动态库，也就是会有多个MachO被映射到内存空间，所以我们不是简单的查找某个Image就可以了，而是要遍历所有已载入的Images。 123456uint64_t count = _dyld_image_count();for (uint32_t i = 0; i &lt; count; i++) &#123; const struct mach_header *header = _dyld_get_image_header(i); const char *name = _dyld_get_image_name(i); uint64_t slide = _dyld_get_image_vmaddr_slide(i);&#125; 这里我们就能够拿到各自的mach_header了，计算其相对于image的地址时，需要进行矫正： 1uint64_t pcSlide = pc - slide; 在查找符号前，我们定义一个快捷的函数，来遍历load commands，因为之后会多次查找load commands： 1234567891011121314void enumerateSegment(const mach_header *header, std::function&lt;bool(struct load_command *)&gt; func) &#123; // \b这里我们只考虑64位应用。第一个command从header的下一位开始 struct load_command *baseCommand = (struct load_command *)((struct mach_header_64 *)header + 1); if (baseCommand == nullptr) return; struct load_command *command = baseCommand; for (int i = 0; i &lt; header-&gt;ncmds; i++) &#123; if (func(command)) &#123; return; &#125; command = (struct load_command *)((uintptr_t)command + command-&gt;cmdsize); &#125;&#125; 回到上面，首先我们需要遍历segment，来确定当前pc是否落在这个image的区域内。由于一个程序空间内，虚拟地址都是唯一的，动态库也会被映射到一段唯一的地址段，所以如果pc不在当前的地址段内，就可以确定不属于该MachO的方法。 1234567891011121314151617bool found = false;enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SEGMENT_64) &#123; const struct segment_command_64 *segCmd = (struct segment_command_64 *)command; uintptr_t start = segCmd-&gt;vmaddr; uintptr_t end = segCmd-&gt;vmaddr + segCmd-&gt;vmsize; if (pcSlide &gt;= start &amp;&amp; pcSlide &lt; end) &#123; std::cout &lt;&lt; segCmd-&gt;segname &lt;&lt; std::endl; found = true; return true; &#125; &#125; return false;&#125;);if (!found) continue; 定位符号我们需要遍历符号表，首先要从load_command中定位到符号表的位置，而symtab_command并没有给我们一个绝对的位置信息，只有一个stroff和symoff，也就是字符串表偏移量和符号表偏移量，所以我们还需要找出其真正的内存地址。而我们可以从LC_SEGMENT(__LINKEDIT)段中获取到绝对位置vmaddr和偏移量fileoff，所以就可以得到： 12345uint64_t baseaddr = segCmd-&gt;vmaddr - segCmd-&gt;fileoff;// 符号表nlist_64 *nlist = (nlist_64 *)(baseaddr + slide + symCmd-&gt;symoff);// 字符串表uint64_t strTable = baseaddr + slide + symCmd-&gt;stroff; 这里我们就可以按照上面的想法，在nlist中找到最符合的符号字符串了。综合起来如下： 12345678910111213141516171819202122232425262728293031323334353637383940enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SYMTAB) &#123; struct symtab_command *symCmd = (struct symtab_command *)command; uint64_t baseaddr = 0; enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SEGMENT_64) &#123; struct segment_command_64 *segCmd = (struct segment_command_64 *)command; if (strcmp(segCmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; baseaddr = segCmd-&gt;vmaddr - segCmd-&gt;fileoff; return true; &#125; &#125; return false; &#125;); if (baseaddr == 0) return false; nlist_64 *nlist = (nlist_64 *)(baseaddr + slide + symCmd-&gt;symoff); uint64_t strTable = baseaddr + slide + symCmd-&gt;stroff; uint64_t offset = UINT64_MAX; int best = -1; for (int k = 0; k &lt; symCmd-&gt;nsyms; k++) &#123; nlist_64 &amp;sym = nlist[k]; uint64_t d = pcSlide - sym.n_value; if (offset &gt;= d) &#123; offset = d; best = k; &#125; &#125; if (best &gt;= 0) &#123; nlist_64 &amp;sym = nlist[best]; std::cout &lt;&lt; &quot;SYMBOL: &quot; &lt;&lt; (char *)(strTable + sym.n_un.n_strx) &lt;&lt; std::endl; &#125; return true; &#125; return false;&#125;); 结论\b我们再模拟器上实验，最后的结果来说是完全符合预期的，除了有部分系统符号不能打出来。这里整理一部分结果： 123456789101112131415161718192021222324252627282930313233343536373839404142Found: cfunction.app/cfunctionSYMBOL: -[ViewController viewDidLoad]Found: UIKit.framework/UIKitSYMBOL: -[UIViewController loadViewIfRequired]Found: UIKit.framework/UIKitSYMBOL: -[UIViewController view]Found: UIKit.framework/UIKitSYMBOL: -[UIWindow addRootViewControllerViewIfPossible]Found: Frameworks/UIKit.framework/UIKitSYMBOL: -[UIWindow _setHidden:forced:]Found: /UIKit.framework/UIKitSYMBOL: -[UIWindow makeKeyAndVisible]......Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopDoSource0Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopDoSources0Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopRunFound: CoreFoundation.framework/CoreFoundationSYMBOL: _CFRunLoopRunSpecificFound: GraphicsServices.framework/GraphicsServicesFound: UIKit.framework/UIKitSYMBOL: _UIApplicationMainFound: cfunction.app/cfunctionSYMBOL: _main 和xcode所展示的调用关系： 以上是在模拟器的环境下，那么在真机上是什么表现呢？很遗憾，在真机上，很多私有API的符号都被去掉了，只能显示&lt;redacted&gt;，但是部分公开的API和自己的符号均能被打印。所以还是能帮助我们对问题的分析。 最后MachO还是一个非常庞大的知识点，而且官方资料也特别少，和很多业务层代码不同，这些内容对开发能力的影响可能不大，毕竟平时业务层的东西很少需要这些东西。但是这些东西有时候能够产生一些新奇的想法和不同的思路。下面简单说几个相关的内容。 C方法的method swizziling，Facebook的fishhook。 __attribute__(section(&quot;__DATA,custom&quot;))，自定义全局对象，React就是采用这种方式自动采集方法列表的。这个思路可以简化很多编码方式，但是可移植性会降低。 C方法的动态调用，我们可以运行时去调用指定的C方法。这个方式危险程度较高，但却是很多高级语言的基础。 参考KSCrashMachORuntime","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"调用栈","slug":"调用栈","permalink":"http://djs66256.github.io/tags/%E8%B0%83%E7%94%A8%E6%A0%88/"},{"name":"卡顿分析","slug":"卡顿分析","permalink":"http://djs66256.github.io/tags/%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90/"},{"name":"crash","slug":"crash","permalink":"http://djs66256.github.io/tags/crash/"},{"name":"stack","slug":"stack","permalink":"http://djs66256.github.io/tags/stack/"},{"name":"KSCrash","slug":"KSCrash","permalink":"http://djs66256.github.io/tags/KSCrash/"}]},{"title":"C方法的调用参数与ARM汇编","date":"2018-01-11T12:43:57.000Z","path":"2018/01/11/2018-01-11-C方法的调用参数与ARM汇编/","text":"在平时开发和调试中，经常遇到C调用栈和汇编，所以这里来统一的了解下这部分内容，本章需要一定的汇编基础才能更好的理解。 函数签名在JavaScript中，我们定义函数和调用函数都是相当自由的： 12345function func(a, b, c) &#123; console.log(a, b, c)&#125;func(1)func(1, 2, 3, 4, 5, 6) 这样做完全没有问题。但是在C语言中，方法调用却是非常严格的，如果参数类型或者个数不对，就会直接编译失败（隐式转换除外）。 123456789int arg1_func(int a) &#123; return a;&#125;int arg2_func(int a, int b) &#123; return a+b;&#125;arg1_func(1, 2);arg2_func(1); 以上C语言将会直接编译不通过，原因之后再说。这里我们把int(*)(int)称为这个函数的函数签名。 为什么我们要了解函数签名呢？由于C方法的参数传递是和函数签名相关的，而且是编译期就需要确定的。他决定了参数是如何传递给具体方法，并且返回参数是如何返回的。 那么接下来就让我们来了解C语言的参数传递方式。由于不同架构平台拥有不同的处理方式，但大同小异，这里我们就用AArch64架构来做介绍。 Registers在了解底层之前，我们需要一点ARM的预备知识，这里做一个简单的介绍，具体ARM汇编可以参考官方文档armasm_user_guide和ABI。 ARM_ASM (4.1节)In AArch64 state, the following registers are available: Thirty-one 64-bit general-purpose registers X0-X30, the bottom halves of which are accessible asW0-W30. Four stack pointer registers SP_EL0, SP_EL1, SP_EL2, SP_EL3. Three exception link registers ELR_EL1, ELR_EL2, ELR_EL3. Three saved program status registers SPSR_EL1, SPSR_EL2, SPSR_EL3. One program counter. ABI (9.1节)For the purposes of function calls, the general-purpose registers are divided into four groups: Argument registers (X0-X7) These are used to pass parameters to a function and to return a result. They can be used as scratch registers or as caller-saved register variables that can hold intermediate values within a function, between calls to other functions. The fact that 8 registers are available for passing parameters reduces the need to spill parameters to the stack when compared with AArch32. Caller-saved temporary registers (X9-X15) If the caller requires the values in any of these registers to be preserved across a call to another function, the caller must save the affected registers in its own stack frame. They can be modified by the called subroutine without the need to save and restore them before returning to the caller. Callee-saved registers (X19-X29) These registers are saved in the callee frame. They can be modified by the called subroutine as long as they are saved and restored before returning. Registers with a special purpose (X8, X16-X18, X29, X30) X8 is the indirect result register. This is used to pass the address location of an indirect result, for example, where a function returns a large structure. X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers. These can be used by call veneers and similar code, or as temporary registers for intermediate values between subroutine calls. They are corruptible by a function. Veneers are small pieces of code which are automatically inserted by the linker, for example when the branch target is out of range of the branch instruction. X18 is the platform register and is reserved for the use of platform ABIs. This is an additional temporary register on platforms that don’t assign a special meaning to it. X29 is the frame pointer register (FP). X30 is the link register (LR). 根据官方文档，这里我们需要知道的是X0-X30个通用寄存器，D0-D31个浮点寄存器，堆栈寄存器SP，和独立不可直接操作的PC寄存器。 其中通用寄存器在C语言的ABI定义中，X29作为栈帧FP，X30作为函数返回地址LR，X0-X7作为参数寄存器，X8为Indirect result location（和返回值相关），X9-X15为临时寄存器。其他的寄存器和目前我们的内容没有太大的关系，所以不做介绍了。这里有个官方的简要图： 在阅读以下内容需要明确上述的几个寄存器，特别是LR=X30，FP=X29，其中W0和X0代表同一个寄存器，只是W是32位，X是64位。 需要了解的存取指令是LDR（load），STR（store），其他存取指令都是以这两个为基础。相关运算可见ABI 6.3.4节，这里介绍下下面会遇到的运算： Example Description LDR X0, [X1, #8] Load from address X1 + 8 LDR X0, [X1, #8]! Pre-index: Update X1 first (to X1 + #8), then load from the new address LDR X0, [X1], #8 Post-index: Load from the unmodified address in X1 first, then update X1 (to X1 + #8) Stack Frame在C语言调用过程中，SP和LR是成对出现的，他们代表了一个函数的栈区域，也称为栈帧。 一个栈帧的大概结构如下： 这个结构对我们来说非常重要，也是本次我们讨论的重点。 少参数调用对于一个函数的调用，入参会放入X0-X7中，返回参数会放在X0中返回，那么我们就来分析下一个简单的例子： 123int lessArg(int arg1, char *arg2) &#123; return 0;&#125; 调用前： 1234567891011caller: 0x100791c6c &lt;+20&gt;: mov w9, #0x0 0x100791c70 &lt;+24&gt;: stur w9, [x29, #-0x14] 0x100791c74 &lt;+28&gt;: stur w0, [x29, #-0x18] 0x100791c78 &lt;+32&gt;: str x1, [x8, #0xa0] 0x100791c7c &lt;+36&gt;: mov x1, #0x0 ; // 第二个参数 arg2 = 0 0x100791c80 &lt;+40&gt;: mov x0, x9 ; // 第一个参数 arg1 = 0 0x100791c84 &lt;+44&gt;: str x1, [sp, #0x88] 0x100791c88 &lt;+48&gt;: str x8, [sp, #0x80] 0x100791c8c &lt;+52&gt;: str w9, [sp, #0x7c] 0x100791c90 &lt;+56&gt;: bl 0x100791a60 ; CALL &#x27;lessArg&#x27; 12345678cfunction`lessArg: 0x104491a98 &lt;+0&gt;: sub sp, sp, #0x10 ; 由于栈是向下增长的，所以 SP = SP - 0x10 0x104491a9c &lt;+4&gt;: mov w8, #0x0 0x104491aa0 &lt;+8&gt;: str w0, [sp, #0xc] 0x104491aa4 &lt;+12&gt;: str x1, [sp] 0x104491aa8 &lt;+16&gt;: mov x0, x8 ; 返回值 X0 = 0 0x104491aac &lt;+20&gt;: add sp, sp, #0x10 ; 销毁栈 0x104491ab0 &lt;+24&gt;: ret 由以上结果看的确按照ABI所描述的，在&lt;=8个参数的时候，参数是放在寄存器中传递。 多参数调用那么如果参数超过8个呢？据ABI描述是通过堆栈的形式来传递，我们来看下结果： 123int moreArg(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10, int arg11, int arg12, int arg13, char *arg14) &#123; return 0;&#125; 12345678910111213141516171819202122232425262728caller: 0x100791c9c &lt;+68&gt;: mov x1, sp ; x1 = SP 0x100791ca0 &lt;+72&gt;: ldr x30, [sp, #0x88] 0x100791ca4 &lt;+76&gt;: str x30, [x1, #0x18] 0x100791ca8 &lt;+80&gt;: orr w9, wzr, #0xc 0x100791cac &lt;+84&gt;: str w9, [x1, #0x10] ; SP+0x10 = arg13 0x100791cb0 &lt;+88&gt;: mov w9, #0xb 0x100791cb4 &lt;+92&gt;: str w9, [x1, #0xc] ; SP+0xc = arg12 0x100791cb8 &lt;+96&gt;: mov w9, #0xa 0x100791cbc &lt;+100&gt;: str w9, [x1, #0x8] ; SP+0x8 = arg11 0x100791cc0 &lt;+104&gt;: mov w9, #0x9 0x100791cc4 &lt;+108&gt;: str w9, [x1, #0x4] ; SP+0x4 = arg10 0x100791cc8 &lt;+112&gt;: orr w9, wzr, #0x8 0x100791ccc &lt;+116&gt;: str w9, [x1] ; SP = arg9 0x100791cd4 &lt;+124&gt;: orr w2, wzr, #0x2 ; w2 = arg3 0x100791cd8 &lt;+128&gt;: orr w3, wzr, #0x3 ; w3 = arg4 0x100791cdc &lt;+132&gt;: orr w4, wzr, #0x4 ; w4 = arg5 0x100791ce0 &lt;+136&gt;: mov w5, #0x5 ; w5 = arg6 0x100791ce4 &lt;+140&gt;: orr w6, wzr, #0x6 ; w6 = arg7 0x100791ce8 &lt;+144&gt;: orr w7, wzr, #0x7 ; w7 = arg8 0x100791cec &lt;+148&gt;: ldr w10, [sp, #0x7c] 0x100791cf0 &lt;+152&gt;: str w0, [sp, #0x78] 0x100791cf4 &lt;+156&gt;: mov x0, x10 ; w0 = arg1 0x100791cd0 &lt;+120&gt;: orr w9, wzr, #0x1 0x100791cf8 &lt;+160&gt;: mov x1, x9 ; w1 = arg2 0x100791cfc &lt;+164&gt;: str x8, [sp, #0x70] 0x100791d00 &lt;+168&gt;: str w9, [sp, #0x6c] 0x100791d04 &lt;+172&gt;: bl 0x100791a7c ; moreArg at main.mm:16 从上面可以看出来，arg9以上的入参被存在了SP ~ (SP+0x10)的位置，也就是当前栈的栈底，下一层栈帧的栈顶。 123456789101112131415161718192021222324252627282930cfunction`moreArg: 0x104491ab4 &lt;+0&gt;: sub sp, sp, #0x40 ; 申请栈空间，这里我们将原来的sp记作&#x27;SP0&#x27; ; 那么 SP = SP0 - 0x40 0x104491ab8 &lt;+4&gt;: ldr x8, [sp, #0x58] 0x104491abc &lt;+8&gt;: ldr w9, [sp, #0x50] ; w9 = SP + 0x50 = SP0 - 0x40 + 0x50 = SP0 + 0x10 ; 也就是w13 = arg13 ; 按照这样的推导，下面依次为arg9 ~ arg12 0x104491ac0 &lt;+12&gt;: ldr w10, [sp, #0x4c] 0x104491ac4 &lt;+16&gt;: ldr w11, [sp, #0x48] 0x104491ac8 &lt;+20&gt;: ldr w12, [sp, #0x44] 0x104491acc &lt;+24&gt;: ldr w13, [sp, #0x40] ; w13 = SP + 0x40 = SP0 - 0x40 + 0x40 = SP0 ; 也就是w13 = arg9 0x104491ad0 &lt;+28&gt;: mov w14, #0x0 0x104491ad4 &lt;+32&gt;: str w0, [sp, #0x3c] 0x104491ad8 &lt;+36&gt;: str w1, [sp, #0x38] 0x104491adc &lt;+40&gt;: str w2, [sp, #0x34] 0x104491ae0 &lt;+44&gt;: str w3, [sp, #0x30] 0x104491ae4 &lt;+48&gt;: str w4, [sp, #0x2c] 0x104491ae8 &lt;+52&gt;: str w5, [sp, #0x28] 0x104491aec &lt;+56&gt;: str w6, [sp, #0x24] 0x104491af0 &lt;+60&gt;: str w7, [sp, #0x20] 0x104491af4 &lt;+64&gt;: str w13, [sp, #0x1c] 0x104491af8 &lt;+68&gt;: str w12, [sp, #0x18] 0x104491afc &lt;+72&gt;: str w11, [sp, #0x14] 0x104491b00 &lt;+76&gt;: str w10, [sp, #0x10] 0x104491b04 &lt;+80&gt;: str w9, [sp, #0xc] 0x104491b08 &lt;+84&gt;: str x8, [sp] 0x104491b0c &lt;+88&gt;: mov x0, x14 0x104491b10 &lt;+92&gt;: add sp, sp, #0x40 ; =0x40 0x104491b14 &lt;+96&gt;: ret 由此可见，大于8个的参数会被放入栈中SP ~ (SP + count - 8)，和预期的一样。 struct参数及返回上面说了基本类型的传递情况，在C语言中，还有一类不定长数据类型可以直接传递，那就是struct。那么我们来看看struct参数是怎么传递的。 小struct12345678struct SmallStruct &#123; int arg1;&#125;;struct SmallStruct smallStructFunc(int arg1, struct SmallStruct arg2) &#123; struct SmallStruct s = arg2; return s;&#125; 12345678caller: 0x100791d24 &lt;+204&gt;: ldur w9, [x29, #-0x30] 0x100791d28 &lt;+208&gt;: mov x1, x9 ; x1 = arg2 ! ; 这里struct内容直接赋值给了x1，因为x1的容量完全够用！ 0x100791d2c &lt;+212&gt;: ldr w9, [sp, #0x7c] 0x100791d30 &lt;+216&gt;: str w0, [sp, #0x64] ; w0 = arg1 0x100791d34 &lt;+220&gt;: mov x0, x9 0x100791d38 &lt;+224&gt;: bl 0x100791b04 ; smallStructFunc at main.mm:32 123456789101112cfunction`smallStructFunc: 0x1003b5b04 &lt;+0&gt;: sub sp, sp, #0x20 ; =0x20 0x1003b5b08 &lt;+4&gt;: mov x8, x1 ; x8 = arg2 0x1003b5b0c &lt;+8&gt;: str w8, [sp, #0x10] 0x1003b5b10 &lt;+12&gt;: str w0, [sp, #0xc] 0x1003b5b14 &lt;+16&gt;: ldr w8, [sp, #0x10] 0x1003b5b18 &lt;+20&gt;: str w8, [sp, #0x18] 0x1003b5b1c &lt;+24&gt;: ldr w8, [sp, #0x18] 0x1003b5b20 &lt;+28&gt;: mov x0, x8 ; x0 = x8 = arg2 ; 这里直接将x0作为struct返回值 0x1003b5b24 &lt;+32&gt;: add sp, sp, #0x20 ; =0x20 0x1003b5b28 &lt;+36&gt;: ret 可见，小型struct，可以直接放在寄存器中传递，和普通基本类型的传递没有太大的区别。 大struct那么struct足够的大呢，导致不能简单的用寄存器容纳struct的数据？ 这里就要涉及到X8的一个特殊身份了(XR, indirect result location)，这里我们将X8记作XR。 1234567struct BigStruct &#123; int arg1; int arg2; int arg3; int arg4; int arg5; int arg6; int arg7; int arg8; int arg9; int arg10; int arg11; int arg12; int arg13; char *arg14;&#125;;struct BigStruct bigStructFunc(int arg1, struct BigStruct arg2) &#123; struct BigStruct s = arg2; return s;&#125; 1234567891011121314151617181920caller: 0x100791d3c &lt;+228&gt;: mov x9, x0 0x100791d40 &lt;+232&gt;: stur w9, [x29, #-0x38] 0x100791d44 &lt;+236&gt;: ldr x8, [sp, #0x80] 0x100791d48 &lt;+240&gt;: ldur q0, [x8, #0x78] 0x100791d4c &lt;+244&gt;: str q0, [x8, #0x30] 0x100791d50 &lt;+248&gt;: ldur q0, [x8, #0x68] 0x100791d54 &lt;+252&gt;: stur q0, [x29, #-0xa0] 0x100791d58 &lt;+256&gt;: ldur q0, [x8, #0x58] 0x100791d5c &lt;+260&gt;: stur q0, [x29, #-0xb0] 0x100791d60 &lt;+264&gt;: ldur q0, [x8, #0x48] 0x100791d64 &lt;+268&gt;: stur q0, [x29, #-0xc0] ; 以上是将临时变量arg2赋值到Callee的参数栈区 ; 这样子函数修改就不会改动原始数据了 ; 为方便，后面将已拷贝的数据成为 arg2 0x100791d68 &lt;+272&gt;: add x8, sp, #0xb0 ; XR = SP + 0xb0 ; Callee save area ; 这是一个空的区域，用作返回的临时存储区 0x100791d6c &lt;+276&gt;: sub x1, x29, #0xc0 ; x1 = FP - 0xc0 = &amp;arg2 0x100791d70 &lt;+280&gt;: ldr w0, [sp, #0x7c] ; w0 = arg1 0x100791d74 &lt;+284&gt;: bl 0x100791b2c ; bigStructFunc at main.mm:36 123456789101112131415cfunction`bigStructFunc: 0x1003b5b2c &lt;+0&gt;: sub sp, sp, #0x20 ; 申请栈空间 SP = SP0 - 0x20 0x1003b5b30 &lt;+4&gt;: stp x29, x30, [sp, #0x10] ; 这里和以上几个不同，是因为这里有函数调用，所以需要把LR和FP压栈 0x1003b5b34 &lt;+8&gt;: add x29, sp, #0x10 0x1003b5b38 &lt;+12&gt;: orr x2, xzr, #0x40 ; struct 的 size = 0x40，作为第三个参数 0x1003b5b3c &lt;+16&gt;: stur w0, [x29, #-0x4] 0x1003b5b40 &lt;+20&gt;: mov x0, x8 ; dst = x0 = XR = SP0 + 0xb0 ; 第一个入参dst为caller的临时存储区 ; 第二个参数为x1，也就是caller的 &amp;arg2 0x1003b5b44 &lt;+24&gt;: bl 0x1003b62f0 ; symbol stub for: memcpy ; void *memcpy(void *dst, const void *src, size_t n); ; 这里居然直接调用了memcpy，赋值！ 0x1003b5b48 &lt;+28&gt;: ldp x29, x30, [sp, #0x10] 0x1003b5b4c &lt;+32&gt;: add sp, sp, #0x20 ; =0x20 0x1003b5b50 &lt;+36&gt;: ret 这样返回值就放在了*XR所在的位置，caller只需要再拷贝到临时变量区中即可。 可以看到，在处理大型struct时，就会出现多次内存拷贝，会对性能造成一定影响，所以这类方法尽量不要直接传递大型struct，可以传递指针或者引用，或者采用inline的方案，在优化期去除函数调用。 struct参数的分界线根据AAPCS 64的Parameter Passing Rules节所述： If the argument is a Composite Type and the size in double-words of the argument is not more than 8 minus NGRN, then the argument is copied into consecutive general-purpose registers, starting at x[NGRN]. The argument is passed as though it had been loaded into the registers from a double-word- aligned address with an appropriate sequence of LDR instructions loading consecutive registers from memory (the contents of any unused parts of the registers are unspecified by this standard). The NGRN is incremented by the number of registers used. The argument has now been allocated. 大致说的是如果X0-X8中剩余的寄存器足够去保存该结构，那么就保存到寄存器，否则保存到栈。 If the type, T, of the result of a function is such that void func(T arg) would require that arg be passed as a value in a register (or set of registers) according to the rules in §5.4 Parameter Passing, then the result is returned in the same registers as would be used for such an argument. 返回值也遵守以上规则。 这个文档不是最新的，而且是beta版，暂时没有找到正式版本。而且这里还涉及到很多其他的因素，所以这里也就不深究了。 va_list以上都是确定参数，那么如果是不确定参数，又是怎么传递的呢？ 在AAPCS 64文档里有明确的说明，但是这里我们从汇编的角度来看这个问题。 1234567891011int mutableAragsFunc(int arg, ...) &#123; va_list list; va_start(list, arg); int ret = arg; while(int a = va_arg(list, int)) &#123; ret += a; &#125; va_end(list); return ret;&#125;mutableAragsFunc(1, 2, 3, 0); 在函数入口打断点，打印参数寄存器： 12345678x0 = 0x0000000000000001x1 = 0x000000016fce7930x2 = 0x000000016fce7a18x3 = 0x000000016fce7a90x4 = 0x0000000000000000x5 = 0x0000000000000000x6 = 0x0000000000000001x7 = 0x00000000000004b0 可以发现除了x0是正确的第一个参数，其他都是随机的，那么说明参数肯定被放到了栈上。 12345678910111213141516171819cfunction`main: 0x100121be4 &lt;+0&gt;: sub sp, sp, #0xa0 ; =0xa0 0x100121be8 &lt;+4&gt;: stp x29, x30, [sp, #0x90] 0x100121bec &lt;+8&gt;: add x29, sp, #0x90 ; =0x90 0x100121bf0 &lt;+12&gt;: mov w8, #0x0 0x100121bf4 &lt;+16&gt;: stur w8, [x29, #-0x4] 0x100121bf8 &lt;+20&gt;: stur w0, [x29, #-0x8] 0x100121bfc &lt;+24&gt;: stur x1, [x29, #-0x10] 0x100121c00 &lt;+28&gt;: mov x1, sp 0x100121c04 &lt;+32&gt;: mov x9, #0x0 0x100121c08 &lt;+36&gt;: str x9, [x1, #0x10] ; 压栈 0 0x100121c0c &lt;+40&gt;: orr w8, wzr, #0x3 0x100121c10 &lt;+44&gt;: mov x9, x8 0x100121c14 &lt;+48&gt;: str x9, [x1, #0x8] ; 压栈 3 0x100121c18 &lt;+52&gt;: orr w8, wzr, #0x2 0x100121c1c &lt;+56&gt;: mov x9, x8 0x100121c20 &lt;+60&gt;: str x9, [x1] ; 压栈 2 0x100121c24 &lt;+64&gt;: orr w0, wzr, #0x1 ; arg = 1 0x100121c28 &lt;+68&gt;: bl 0x1001218d8 ; mutableAragsFunc at main.mm:67 也就是表明被明确定义的参数，是按照上面所说的规则传递，而...参数全部按照栈方式传递。这从实现原理上也比较容易理解，在取va_arg的时候，只需要将栈指针+sizeof(type)就可以了。 错误的函数签名那么现在，我们回过头来看看第一个问题。C语言为什么会有函数签名？ 函数签名决定了参数以及返回值的传递方式，同时还决定了函数栈帧的分布与大小，所以如果不确定函数签名，我们也就无法知道如何去传递参数了。 那么错误的函数签名会导致什么样的后果呢？运行时是否会崩溃？我们来看： 123456789101112131415int arg1_func(int a) &#123; return a;&#125;int arg2_func(int a, int b) &#123; return a+b;&#125;void arg_test_func() &#123; int ret1 = ((int (*)(int, int))arg1_func)(1, 2); int ret2 = ((int (*)(int))arg2_func)(1); int ret3 = ((int (*)())arg1_func)(); int ret4 = ((int (*)())arg2_func)(); printf(&quot;%d, %d, %d, %d\\n&quot;, ret1, ret2, ret3, ret4);&#125; 首先说结果，结果是一切运行正常，只是结果值有部分是错误的。那么我们来看看汇编代码： 1234567891011121314151617181920212223242526cfunction`arg_test_func: 0x1003462cc &lt;+0&gt;: sub sp, sp, #0x50 ; =0x50 0x1003462d0 &lt;+4&gt;: stp x29, x30, [sp, #0x40] 0x1003462d4 &lt;+8&gt;: add x29, sp, #0x40 ; =0x40 ; 以上都是处理栈帧 0x1003462d8 &lt;+12&gt;: orr w0, wzr, #0x1 ; w0 = 1 0x1003462dc &lt;+16&gt;: orr w1, wzr, #0x2 ; w1 = 2 0x1003462e0 &lt;+20&gt;: bl 0x100346298 ; arg1_func at main.mm:87 0x1003462e4 &lt;+24&gt;: orr w1, wzr, #0x1 ; w1 = 1 0x1003462e8 &lt;+28&gt;: stur w0, [x29, #-0x4] ; 将结果存入临时变量 ret1 ; 按照寄存器的状态，这里相当于调用了 arg1_func(1) ; 其结果是正确的，只是可能没有符合预期 0x1003462ec &lt;+32&gt;: mov x0, x1 ; x0 = 1 0x1003462f0 &lt;+36&gt;: bl 0x1003462ac ; arg2_func at main.mm:90 0x1003462f4 &lt;+40&gt;: stur w0, [x29, #-0x8] ; 将结果存入临时变量 ret2 ; 相当于 arg2_func(1, 1) = 2 ; 第二个参数取决于上一次x1的状态 ; 所以结果应该是随机的 0x1003462f8 &lt;+44&gt;: bl 0x100346298 ; arg1_func at main.mm:87 0x1003462fc &lt;+48&gt;: stur w0, [x29, #-0xc] ; 相当于 ret3 = arg1_func(2) = 2 0x100346300 &lt;+52&gt;: bl 0x1003462ac ; arg2_func at main.mm:90 0x100346304 &lt;+56&gt;: stur w0, [x29, #-0x10] ; 相当于 ret4 = arg2_func(2, 1) = 3 所以结果应该是1, 2, 2, 3。 这里的结果不能代表任何在其他环境下的结果，可以说其结果是难以预测的。这里没有奔溃也只是随机参数并不会带来奔溃的风险。 所以我们是不能用其他函数签名来传递参数的。 obj_msgSend接下来，我们来说说iOS中最著名的函数obj_msgSend，可以说，这个函数是objc的核心和基础，没有这个方法，就不存在objc。 根据我们上面的分析，理论上我们不能改变obj_msgSend的函数签名，来传递不同类型和个数的参数。那么苹果又是怎么实现的呢？ 以前我们一直说obj_msgSend用汇编来写是为了速度，但这并不是主要原因，因为retain，release也是非常频繁使用的方法，为什么不把这几个也改为汇编呢。其实更重要的原因是如果用C来写obj_msgSend根本实现不了！ 我们翻开苹果objc的源码，查看其中arm64.s汇编代码： 12345678910111213141516171819202122232425262728293031 ENTRY _objc_msgSend MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x9, x13, #ISA_MASK // x9 = class LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncachedLNilOrTagged: b.eq LReturnZero // nil check // tagged adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x9, [x10, x11, LSL #3] b LGetIsaDoneLReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret END_ENTRY _objc_msgSend 看出于上面其他C方法编译出来的汇编的区别了吗？ 那就是obj_msgSend居然不存在栈帧！同时也没有任何地方修改过X0-X7,X8,LR,SP,FP！ 而且当找到真正对象上的方法的时候，并不像其他方法一样使用BL，而是使用了 12.macro CacheHitbr x17 // call imp 也就是说并没有修改LR。这样做的效果就相当于在函数调用的时候插入了一段代码！更像是c语言的宏。 由于obj_msgSend并没有改变任何方法调用的上下文，所以真正的objc方法就好像是被直接调用的一样。 可以说，这种想法实在是太精彩了。 objc_msgSend对nil对象的处理大家都知道，向空对象发送消息，返回的内容肯定都是0。那么这是为什么呢？ 还是来看obj_msgSend的源代码部分，第一行就判断了nil： 12cmp x0, #0 // nil check and tagged pointer checkb.le LNilOrTagged // (MSB tagged pointer looks negative) 其中tagged pointer技术并不是我们本期的话题，所以我们直接跳到空对象的处理方法上： 123456789LReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret 他将可能的保存返回值的寄存器全部写入0！（为什么会有多个寄存器，是因为ARM其实是支持向量运算的，所以在某些条件下会用多个寄存器保存返回值，具体可以去参考ARM官方文档）。 这样我们的返回值就只能是0了！ 等等，还缺少一个类型，struct！如果是栈上的返回，上文已经分析过是保存在X8中的，可是我们并没有看到任何有关X8的操作。那么我们来写一个demo尝试一下： 12345678void struct_objc_nil(Test *t) &#123; struct BigStruct retB; printf(&quot;stack: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6); retB = ((struct BigStruct(*)(Test *, SEL))objc_msgSend)(t, @selector(retStruct)); printf(&quot;msgSend: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6); retB = [t retStruct]; printf(&quot;objc: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6);&#125; 首先我们打开编译优化-os(非优化状态，栈空间会被清0)。其结果居然是： 123stack: 50462976,185207048,0,0,0,0,msgSend: 1,0,992,0,0,0,objc: 0,0,0,0,0,0, struct类型两者的返回并不一致！按照我们阅读源码来推论，随机数值才是正确的结果，这是为什么呢？ 我们还是来看汇编，我将关键部分特意标注了出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778cfunction`struct_objc_nil: 0x10097e754 &lt;+0&gt;: sub sp, sp, #0x90 ; =0x90 0x10097e758 &lt;+4&gt;: stp x20, x19, [sp, #0x70] 0x10097e75c &lt;+8&gt;: stp x29, x30, [sp, #0x80] 0x10097e760 &lt;+12&gt;: add x29, sp, #0x80 ; =0x80 0x10097e764 &lt;+16&gt;: bl 0x10097e9d4 ; symbol stub for: objc_retain 0x10097e768 &lt;+20&gt;: mov x19, x0 0x10097e76c &lt;+24&gt;: adr x0, #0x1730 ; &quot;stack: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e770 &lt;+28&gt;: nop 0x10097e774 &lt;+32&gt;: bl 0x10097e9f8 ; symbol stub for: printf 0x10097e778 &lt;+36&gt;: nop 0x10097e77c &lt;+40&gt;: ldr x20, #0x262c ; &quot;retStruct&quot; 0x10097e780 &lt;+44&gt;: add x8, sp, #0x30 ; =0x30 0x10097e784 &lt;+48&gt;: mov x0, x19 0x10097e788 &lt;+52&gt;: mov x1, x20 0x10097e78c &lt;+56&gt;: bl 0x10097e9b0 ; symbol stub for: objc_msgSend 0x10097e790 &lt;+60&gt;: ldp w8, w9, [sp, #0x30] 0x10097e794 &lt;+64&gt;: ldp w10, w11, [sp, #0x38] 0x10097e798 &lt;+68&gt;: ldp w12, w13, [sp, #0x40] 0x10097e79c &lt;+72&gt;: stp x12, x13, [sp, #0x20] 0x10097e7a0 &lt;+76&gt;: stp x10, x11, [sp, #0x10] 0x10097e7a4 &lt;+80&gt;: stp x8, x9, [sp] 0x10097e7a8 &lt;+84&gt;: adr x0, #0x170f ; &quot;msgSend: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e7ac &lt;+88&gt;: nop 0x10097e7b0 &lt;+92&gt;: bl 0x10097e9f8 ; symbol stub for: printf //////////////////////////////////////////////////////////-&gt; 0x10097e7b4 &lt;+96&gt;: cbz x19, 0x10097e7d8 ; &lt;+132&gt; at main.mm:134 ; 这里的意思是： ; IF X19 == NULL THEN ; GOTO 0x10097e7d8 ; 而 0x10097e7d8 就是内存清0的地方！ ; X19 在 0x10097e768 被赋值为 objc 对象 &#x27;nil&#x27; ; 而在第一次调用 &#x27;obj_msgSend&#x27; 就没有这一段！ ; （由于优化，有些逻辑和代码中有变化） ////////////////////////////////////////////////////////// 0x10097e7b8 &lt;+100&gt;: add x8, sp, #0x30 ; =0x30 0x10097e7bc &lt;+104&gt;: mov x0, x19 0x10097e7c0 &lt;+108&gt;: mov x1, x20 0x10097e7c4 &lt;+112&gt;: bl 0x10097e9b0 ; symbol stub for: objc_msgSend 0x10097e7c8 &lt;+116&gt;: ldp w8, w9, [sp, #0x30] 0x10097e7cc &lt;+120&gt;: ldp w10, w11, [sp, #0x38] 0x10097e7d0 &lt;+124&gt;: ldp w12, w13, [sp, #0x40] 0x10097e7d4 &lt;+128&gt;: b 0x10097e800 ; &lt;+172&gt; at main.mm:135 ; 这里有一段清0的代码！正好就是返回值的局部变量地址 0x10097e7d8 &lt;+132&gt;: mov w13, #0x0 0x10097e7dc &lt;+136&gt;: mov w12, #0x0 0x10097e7e0 &lt;+140&gt;: mov w11, #0x0 0x10097e7e4 &lt;+144&gt;: mov w10, #0x0 0x10097e7e8 &lt;+148&gt;: mov w9, #0x0 0x10097e7ec &lt;+152&gt;: mov w8, #0x0 0x10097e7f0 &lt;+156&gt;: stp xzr, xzr, [sp, #0x60] 0x10097e7f4 &lt;+160&gt;: stp xzr, xzr, [sp, #0x50] 0x10097e7f8 &lt;+164&gt;: stp xzr, xzr, [sp, #0x40] 0x10097e7fc &lt;+168&gt;: stp xzr, xzr, [sp, #0x30] 0x10097e800 &lt;+172&gt;: stp x12, x13, [sp, #0x20] 0x10097e804 &lt;+176&gt;: stp x10, x11, [sp, #0x10] 0x10097e808 &lt;+180&gt;: stp x8, x9, [sp] 0x10097e80c &lt;+184&gt;: adr x0, #0x16c8 ; &quot;objc: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e810 &lt;+188&gt;: nop 0x10097e814 &lt;+192&gt;: bl 0x10097e9f8 ; symbol stub for: printf 0x10097e818 &lt;+196&gt;: mov x0, x19 0x10097e81c &lt;+200&gt;: bl 0x10097e9c8 ; symbol stub for: objc_release 0x10097e820 &lt;+204&gt;: ldp x29, x30, [sp, #0x80] 0x10097e824 &lt;+208&gt;: ldp x20, x19, [sp, #0x70] 0x10097e828 &lt;+212&gt;: add sp, sp, #0x90 ; =0x90 0x10097e82c &lt;+216&gt;: ret 0x10097e830 &lt;+220&gt;: b 0x10097e834 ; &lt;+224&gt; at main.mm 0x10097e834 &lt;+224&gt;: mov x20, x0 0x10097e838 &lt;+228&gt;: mov x0, x19 0x10097e83c &lt;+232&gt;: bl 0x10097e9c8 ; symbol stub for: objc_release 0x10097e840 &lt;+236&gt;: mov x0, x20 0x10097e844 &lt;+240&gt;: bl 0x10097e98c ; symbol stub for: _Unwind_Resume 到这里我们就能够明白了，为什么struct返回值也会变成0。是编译器给我们加入了一段判定的代码！ 那么’objc空对象的返回值一定是0’这个判定就需要在一定条件下了。 总结对这一部分的探索一直持续了很久，一直是迷糊状态，不过经过长时间的多次探索，慢慢思考，总算有一个比较清晰的认识了。可以说底层的东西真的很多很复杂，这里只是其中很小的一方面，其他方面等有时间了另外再写吧。 参考资料armasm_user_guide ABI AAPCS GNU C &amp; ASM Apple ASM","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"C","slug":"C","permalink":"http://djs66256.github.io/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"http://djs66256.github.io/tags/ARM/"},{"name":"ASM","slug":"ASM","permalink":"http://djs66256.github.io/tags/ASM/"}]},{"title":"2017年总结","date":"2017-12-29T18:36:29.000Z","path":"2017/12/30/2017-12-30-2017年总结/","text":"2017年很快就过去了，在这期间发生过很多事情也明白很多事情，这里就来做个年终总结吧。 职业能力以前，总以为自己要多了解些东西，多掌握点其他方面的技术，认为成为一个多面手或许更为有用。对于一个创业小团队或者小公司，事事都要你去涉及的情况下，或许是对的，但是对于一些成熟的稳定的团队来说，是根本不需要的，他们所看重的，所需要的仅仅是你所对应职位的技能。 在一个团队，掌握一方面开发技能的人比比皆是，根本不需要别人去插足，而能够真正深入一项技能，并且有所想法的人却少之又少，而能把想法实现并且能够推广实用的人更是凤毛麟角。 虽然简单的说深入，可是真正实施起来确是非常的困难。因为平时能够碰到的都是基本逻辑，根本不会遇到这些更加深入的技能。就算是遇到了，也是这其中非常片面的一方面，要让一个更为资深的人来评价你，由于双方的知识体系并不一致，也很难在短时间内给出非常准确的判断。 在这一年中，深刻的感觉到了深入是多么的困难，很多东西和概念都是全新的，完全区别于上层，而且这类东西的资料极少，没有很多可以参照的东西。而且越是深入，越是发现各种知识体系的相关性，所以往往在了解某一种技术的时候，会涉及的越来越多，越来越复杂。 拥有一些想法并不是难事，但是要将这些想法实现出来就需要更多的知识，这就不仅仅需要深入的技能，也需要更为广泛的技能。然而这些事情也并不是做出来就是成功了，很多的场景下或者业务下，这些东西有用，但并不被需要，也不被别人所信服，能够解决他们的需求，所以也就不了了之了。 所以很多时候，目前的职位决定了自己的能力定位。 对事很多事情，并不是你认为的就是别人所相信的，别人想要的只是他们想要的答案，而不是你真实的东西。 如果别人认为你的月薪是1万，那么你告诉对方5千，对方会认为你在骗他，告诉对方5万，对方依然会认为你在骗他，对方所需要的只是对方心里所认知的，所能理解的答案罢了。 所以很多时候，我们能给的，需要给的并不是正确的答案，而是对方满意的答案。很多时候在你看来是对的东西，在不同的立场不同的场景下，或许就是错误的，你可以保持你的正确性，但也无力去改变别人的正确性。 未来发展对于未来的发展，以前我一直比较看好物联网，到如今，物联网已经基本成熟了，被小米玩的特溜，所以也就不存在未来了，已经是进行时了。那么我们来预测下接下来几年的发展。 今年忽然间火起来的是机器学习和AI，我认为这两个仅仅是个表象，真正越来越重要的还是数据，只是以前的数据更加简单精准，而目前的数据更为庞大，所以才产生了这些技术来处理这些人为已经处理不了的数据了。 既然看好数据在未来的发展，那么今后就需要向这方面努力，虽然可能做不到数据研究人员那么专业，但也不能落后于时代啊。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"高性能计算","date":"2017-12-17T08:09:44.000Z","path":"2017/12/17/2017-12-17-高性能计算/","text":"我们平时在做业务的时候很少会有性能上的瓶颈，偶尔产生的UI层的卡顿也是我们对程序结构设计的不合理产生的。但是性能优化却是一个好的程序员所应具备的，而且在某些特殊的场景下，我们还要有能力去解决很多极限的性能问题，这里就来聊聊高性能计算方面的问题。 首先我们将这类问题分为两种： 减少计算量 加快单位时间的计算量 减少计算量对于减少计算量来说，大家都是最熟悉的，也是平时碰到的最多的方法。 算法优化最常见的要属算法优化，比如查找算法，用二分法代替顺序查找，排序用快速排序代替冒泡排序。 另一个比较典型的例子就是高斯模糊算法，将一次二维矩阵的乘法转化为两次一维矩阵的乘法，虽然看似改变很小，但是在整个图片的计算量上出入非常的大。以3*3大小的矩阵来看，一次二维矩阵乘法需要9次浮点乘法，而两次一维矩阵仅需要2*3次浮点乘法，如果是6*6的矩阵，这个比例将会达到36/12。 数据结构优化在我们需要更高性能的时候，我们不太可能一个方案能够满足所有的情况，往往需要特定的场景使用特定的方案。 在随机读取远大于随机写入的时候，数组的确是一个好方案，但是如果随机写入远大于随机读取的时候，链表的性能就会优于数组。如果读取和写入都比较频繁，那么树的结构可能会是你的首选，根据所需不同可以采用平衡二叉树，B/B+树，跳跃链表等。 如果需要大量写入磁盘，顺序的读取，比如日志系统这种，那么Google的LevelDB也是一个非常好的选择。 总之，根据需要来选择适合的数据结构也能大量的提升性能。 空间换取时间要知道，很多的计算是重复的，而这些重复的计算可能会消耗我们大量的时间，那么我们在空间充足的情况下，何不缓存这一部分的数据的？ 其实很多的第三方库都使用了这种思想的，索引也可以认为是这种思想。这里举个简单的例子。 在图片处理的过程中，卷积的计算量是非常大的，而乘法占了很大一部分比例。而根据我的了解，ARM在处理乘法的时候，可能需要6个时钟周期，而加法只需要一个，如果能将乘法的结果缓存下来，通过加法访问是不是一种可行的方案呢？一个颜色的色值只有0~255的区间，是一个可以穷举的范围，所以缓存这部分结果，通过偏移量（也就是加法）来访问结果，是否也可以减少计算时间呢。 这种方法一般都会有一个阈值，超过这个阈值之后才会有明显的性能差距，所以在使用之前需要评估好自己的场景是否会处于优化的阈值内。 低等语言实现很多高级语言在实现的时候，会附加一部分高级语言的特性，比如内存回收机制等，越是底层的语言我们越是能够控制其计算量。 极端的例子就是采用汇编方案，这样能够最为极限的控制其性能。当然这样的问题是兼容性问题，需要为多个平台分别写汇编代码。其中OpenCV中的部分计算过程就是采用了汇编语言实现的。 这种方案对于其他高级语言（JAVA，JS等），采用C来实现其底层，或许是个好的尝试。但是使用汇编这种方法虽然有效，但是不太建议，毕竟在晦涩程度和兼容性上考虑，带来的性价比并不高，只有在极少数的特定情况下，才会考虑。 加快单位时间的计算量除了从计算量上来优化，我们还可以通过一些其他手段，包括更优秀的硬件来帮助我们。 并行计算目前的大部分CPU都不是单核的了，包括很多移动设备上的。但是如此高的性能我们往往不能很充分的利用。 在iOS中就有一个适合并发计算的接口dispatch_apply。采用多线程可以最大限度的开发出CPU的潜能。 CPU层面上的浮点计算很多场景下，都是浮点乘法运算消耗了大量的时间，特别是对于ARM系列，但是新型的ARM特别设计了关于浮点及向量的优化（VFP或者称NEON）。 在iOS中，vImage就是利用了这一特性进行了优化，如果有少量的图片运算可以使用vImage来加快我们的速度。 ARM流水线优化ARM系列的CPU一般都有采用流水线的架构，因为每一条指令的执行都需要经过取址-译码-执行这几个步骤，采用流水线架构可以增加执行效率。 但是这也有一个反例，就是在B相关跳转指令的时候，需要清空流水线，重新加载，这也会带来一定的性能损耗。 也就是说： 1234567891011int i = 0; x += i; i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i; 比 1for (int i = 0; i &lt;= 10; i++) x += i; 效率要高很多。当然这里有点吹毛求疵了，一般情况下我们还是不需要考虑这部分内容的。 GPU其实目前来说，影响最大的莫过于图像的处理，普通的业务慢一点和快一点其实很难分辨出来，也没有必要去如此极限的优化，而图像的计算量之庞大，很容易就可以感觉出来，同时图像处理速度还制约着视频的帧率问题，所以问题的严重程度要高很多。 那么说到图像处理，就不得不涉及到GPU了。目前移动端基本都支持OpenGL2.0或OpenGL3.0，所以如果要跨平台使用可以考虑OpenGL来优化。但是如果只考虑iOS平台，让我们来看看iOS平台有哪些特定的利用GPU进行优化的方案。 GPUImage这是一个利用OpenGL的开源库，是一个跨平台的第三方库，里面封装了很多滤镜，同时也支持图片、视频的处理，对于自定义和扩展也比较方便，是一款非常好用的开源库。 CIContextCore Image是苹果官方提供的一款图像处理库，里面包含了众多的滤镜。其中CIContext可以指定为glContext，就是GPU环境了。一般来说，我们平时开发使用，CIImage已经足够了。 CImage的扩展也非常方便，有一种类似于openGL的GLSL的语言，KLSL。有兴趣的人可以自己去研究研究。 MetalMetal是苹果比较新的一个库，专门为了替代OpenGL而做的，降低了OpenGL的学习成本。 据官方称，加入了众多的优化。其中一个比较明显的就是，将shader的编译过程放到了编译期，而不是运行期，也就是说，比起OpenGL，少了一步glCompileShader。 同时Metal也和iOS的特性结合的比较好，使用起来也比OpenGL简单很多。当然这些都是iOS平台的特性，不支持跨平台。 OpenCL这个是对应于mac系统的，其他系统上也有实现，目前还不支持移动端。 多缓冲FrameBuffer的GPU对于视频这类连续的计算，以上的方案已经非常的优秀了，但是我们还是没有榨干机器的性能。:D 一张图片的处理流程可以表示为上图，CPU需要将数据参数准备好，然后拷贝到GPU内存空间，然后等待GPU执行。GPU执行完之后，需要等待CPU准备好下一张图片的数据并拷贝到GPU空间，在这之间是留了很多的空白时间的。 我们知道OpenGL并不是线程安全的，也就是说GPU空间是可以多线程同时访问的，那么我们可以通过多个缓冲区来解决上述空白时间的问题。 上图就是我们想要达到的效果，而下图是我们采用3个缓冲区，实际上的效果。 最后以上是对高性能计算几种方式的一个简单概括，具体的情况需要根据自己的实际情况来选择。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://djs66256.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"property的系统实现分析","date":"2017-12-08T13:20:51.000Z","path":"2017/12/08/2017-12-09-property的系统实现分析/","text":"我们在使用@property这个快捷定义的时候，都没怎么注意系统是怎么实现的，那么我们来看看系统实现的，和我们自己写的setter方法是否一致呢？ Strong我们来分析一下最简单的strong类型的实现。 1@property (nonatomic, strong) NSString *str; 如果是我们自己写setter方法大概是： 123- (void)setStr:(NSString *)str &#123; _str = str;&#125; 如果是MRC的话，可能是这样的： 123456- (void)setStr:(NSString *)str &#123; if (_str != str) &#123; [_str release]; _str = [str retain]; &#125;&#125; 当然系统的方法是经过优化的，直接调用的C方法，所以这里不再考虑MRC的写法，直接来对比ARC的结果。 store strong首先我们来看下objc是如何实现strong的，根据objc的源码可以知道，强引用是通过一个objc_storeStrong的方法来实现的。其实现入下： 12345678910void objc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); *location = obj; objc_release(prev);&#125; 这和我们上面MRC的写法类似，只不过是通过C方法来实现了retain和release。 转换为C语言大家都知道objc的方法其实都是通过send message的方式转换为C语言调用的，所以一个基本的setter方法的最终结果应该是这样的： 1void setter(id self, SEL selector, NSString *str); 具体实现根据反汇编结果，其中系统默认的实现汇编如下： 12345678910111213141516171819sub sp, sp, #0x30 ; 申请栈空间stp x29, x30, [sp, #0x20]add x29, sp, #0x20 adrp x8, 17add x8, x8, #0xfc0 stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x2, [sp, #0x8]ldr x0, [sp, #0x8]ldur x1, [x29, #-0x8] ; x1 = selfldrsw x8, [x8] ; 偏移量add x8, x1, x8 ; x8 = self + 偏移量str x0, [sp] mov x0, x8 ; x0 = x8ldr x1, [sp] ; x1 = strbl 0x1000bcad8 ; objc_storeStrong(self + 偏移量, str)ldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; 退栈ret 翻译为C语言大概就是这样的： 123void setStr(id self, SEL sel, NSString *str) &#123; objc_storeStrong(self + delta, str);&#125; 而我们自定义的setter方法 123- (void)setStr:(NSString *)str &#123; _str = str;&#125; 的反汇编结果却比系统的结果多出一些函数调用 12345678910111213141516171819202122232425262728sub sp, sp, #0x30 ; =0x30stp x29, x30, [sp, #0x20]add x29, sp, #0x20 ; =0x20add x8, sp, #0x8 ; =0x8mov x9, #0x0 ; stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x9, [sp, #0x8]mov x0, x8mov x1, x2bl 0x104d14ad8 ; symbol stub for: objc_storeStrongadrp x8, 17add x8, x8, #0xfc8 ; =0xfc8ldr x9, [sp, #0x8]ldur x0, [x29, #-0x8]ldrsw x8, [x8]add x8, x0, x8mov x0, x8mov x1, x9bl 0x104d14ad8 ; symbol stub for: objc_storeStrongmov x8, #0x0add x9, sp, #0x8 ; =0x8mov x0, x9mov x1, x8bl 0x104d14ad8 ; symbol stub for: objc_storeStrongldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; =0x30ret 翻译成C语言大概是这样的： 123456void setStr(id self, SEL sel, NSString *str) &#123; id tmp = nil; objc_storeStrong(&amp;tmp, str); objc_storeStrong(self + delta, tmp); objc_storeString(&amp;tmp, nil);&#125; 可以看到这里多出一个临时变量，而且即使编译优化为-os，也是同样的结果。这里不清楚为什么会产生一次临时变量，从结果上来看，是不如系统的默认行为的。 Weak在objc的源码中，weak是通过objc_storeWeak来实现的，这个方法的实现比较复杂，涉及到了全局的弱引用表，这里就不作介绍了。 同样，我们来对比下系统默认实现的weak类型，和我们重写的setter方法，从结果上来看也是产生了一个strong类型的临时变量。 1234567891011121314151617181920sub sp, sp, #0x40 ; =0x40stp x29, x30, [sp, #0x30]add x29, sp, #0x30 ; =0x30adrp x8, 17add x8, x8, #0xfd0 ; =0xfd0stur x0, [x29, #-0x8]stur x1, [x29, #-0x10]str x2, [sp, #0x18]ldr x0, [sp, #0x18]ldur x1, [x29, #-0x8]ldrsw x8, [x8]add x8, x1, x8str x0, [sp, #0x10]mov x0, x8ldr x1, [sp, #0x10]bl 0x104f38ae4 ; symbol stub for: objc_storeWeakstr x0, [sp, #0x8]ldp x29, x30, [sp, #0x30]add sp, sp, #0x40 ; =0x40ret 1234567891011121314151617181920212223242526272829sub sp, sp, #0x30 ; =0x30stp x29, x30, [sp, #0x20]add x29, sp, #0x20 ; =0x20add x8, sp, #0x8 ; =0x8mov x9, #0x0stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x9, [sp, #0x8]mov x0, x8mov x1, x2bl 0x1044d8ad8 ; symbol stub for: objc_storeStrongadrp x8, 17add x8, x8, #0xfc8 ; =0xfc8ldr x9, [sp, #0x8]ldur x0, [x29, #-0x8]ldrsw x8, [x8]add x8, x0, x8mov x0, x8mov x1, x9bl 0x1044d8ae4 ; symbol stub for: objc_storeWeakmov x8, #0x0add x9, sp, #0x8 ; =0x8str x0, [sp]mov x0, x9mov x1, x8bl 0x1044d8ad8 ; symbol stub for: objc_storeStrongldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; =0x30ret","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"property","slug":"property","permalink":"http://djs66256.github.io/tags/property/"}]},{"title":"数据埋点与视图控件的反馈式定位","date":"2017-12-07T13:42:49.000Z","path":"2017/12/07/2017-12-07-数据埋点与视图的反馈式定位/","text":"我们想要做一个插件，能够直接在界面上就能显示该页面和该事件的pv和uv（据说淘宝就有这种功能），那么就必须将埋点数据和控件进行一一对应。然而我们是行为埋点，很多东西并不会直接绑定控件，所以如果要做这种效果则必然需要对埋点架构进行重新设计，所以这里采用了一个小技巧，来实现大部分控件与埋点的绑定。 埋点方案一般来说，数据埋点可以分为两种。自动化埋点和手动埋点，各有各的好处和缺点。 自动化埋点一般来说，自动化埋点都是依据界面层次结构或者控件标签等来进行区分与标记的。 这种方式的好处是避免了大量人工埋点带来的繁琐和错误，也减少了代码的复杂度，同时又保证了非常详细的用户行为。 但是这种方式的缺点也是比较明显，对于功能不是那么稳定的情况下，埋点标记可能会经常变动，不易于后期的统计。同时这种方式对于埋点数据的整理也比较麻烦，可能就需要借助开篇所说的工具来获取。同时对于一些需要数据参数的场景，可能需要人为或者特殊场景下的处理。这种方式对于一个复杂的交互动作，则不能很好的统计，需要后期根据多个连续的统计点来确定一个动作。 对于这种方案的一个优化建议是，限制其自动采集的范畴，弱化和简化其全局性的采集，将自动化限制在一个特点的范围内或者框架内，这样会减少很多的垃圾数据以及更加精准的采集。这种方式就急需要一种工具来整理和归纳埋点数据了。 手动行为埋点手动行为埋点不需要任何的标记或者swizzle，是非常简单与灵活的一种，在需要的地方，比如事件触发的地方，加入埋点就可以了。但这也存在非常大的问题。 埋点数据的整理，随着时间的推进，数据将是非常庞大与混乱的。 代码的侵入性，可能会在代码的很多地方都充满着这种恶性的统计代码，导致难以重用以及难以抽离成组件。 维护性低，经历多个版本以及多个人员的迭代，维护会越来越困难，可能会出现埋点数据错误的情况，而且无法对线上的数据进行修复。 插件需求以上的两种方案各有优劣，自动埋点可以直接将控件和埋点绑定，那么我们就很容易的可以将一个页面上所有的埋点给“扫描出来”，并且标记出各个控件，个人猜想阿里的方案就是这样的。 但是由于我们的项目变动较大，界面也不稳定，所以采用的是手动行为埋点的方案，那么事实上控件与埋点是完全独立的，也就不能“扫描出来”。我们也不可能对目前埋点方案进行如此大规模的重构，那么如何将控件与埋点进行绑定呢？这里用到一个小技巧。 首先我们分析我们的场景： 大部分埋点都是在点击后才触发的。 点击，和埋点触发是顺序关系，且这中间一般不会有其他的点击操作了，也就是说可以认为是同步关系。 这种场景满足了我们90%以上的需求，也就是很少有比这种更加复杂的埋点了。 那么我们可以想到首先记录点击的控件，然后观察埋点数据，如果产生顺序的关系，那么我们就可以认为两者是绑定关系。那么我们就可以通过一次自己的点击来获取该控件的埋点信息了。 思路 hook UIWindow的hitTest方法，将得到的视图记录下来。 在埋点方法中增加监听点，等待用户点击触发埋点。 将最近的两者绑定起来，可以使用弱引用表来保存，以防内存泄露。 这里需要注意的几个问题是埋点要过滤掉一些比较常见的非点击事件，来避免出现很多的误判。 在UICollectionView和UITableView中会比较特殊，为了避免reuse view给我们的视图绑定带来错误的结果，需要hook - prepareForReuse，在这里移除绑定关系。 有些点击可能会打开新的页面，那么我们也可以增加一个锁定页面跳转的功能，hook Controller的push和present方法成为空操作，就可以禁用跳转了。重新恢复也很简单，再次swizzle就可以替换回来了。 最后这种方法简单对目前的代码结构几乎没有影响，虽然有可能出现部分误判的情况，但作为一个debug的测试工具已经足够了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"埋点","slug":"埋点","permalink":"http://djs66256.github.io/tags/%E5%9F%8B%E7%82%B9/"}]},{"title":"讨论Gif的一些问题","date":"2017-11-19T08:58:45.000Z","path":"2017/11/19/2017-11-19-讨论Gif的一些问题/","text":"gif是我们平时非常常见的图片格式，同时也是一种非常古老的动画图片格式。在我们平时使用的过程中也会有相应的问题，这里我们来看看Gif所带来的一些问题以及解决方式。 压缩率gif的压缩率其实是非常低的，一小段动画图片远比一般的视频格式要大很多。 这里我分别对gif以及h264编码的视频进行对比 Gif 视频 496KB 192KB 4.4MB 1.4MB 由此可见两者之间的差距还是非常大的。 内存占用如果你使用的是UIImage自身的animatedImage来展示Gif，那将是会非常恐怖的。假设我们有一个100帧400*300的Gif，那么我们完全解析成位图放在内存中将是100*400*300*4 = 45MB。而目前主流的设备分辨率都在1080级别的了，所以如果遇到了非常大的gif图，这种方式肯定是承受不住的。 目前处理gif比较有名的开源库是FLAnimatedImage。但是在内存占用过高的时候，不会缓存所有帧，有需要的时候再去载入，如果播放速度和载入速度不能匹配，那么就会丢弃该帧，导致掉帧的现象发生。这种方案对于帧数多，但是像素低的图片比较好，如果是非常大的图片，那么这种方案的效果不会特别好。 新的方案基于以上的分析，这里提出一种新的方案，来解决大型gif的播放问题。那就是将gif转换为视频格式，由于视频播放是由系统优化的，所以不会产生性能方面的问题。这里来简单描述下。 gif由ImageIO来实现读取操作，视频采用AVFoundation来实现写入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162AVAssetWriter *assertWriter = [[AVAssetWriter alloc] initWithURL:url fileType:AVFileTypeMPEG4 error:nil];NSDictionary *writerSettings = @&#123; AVVideoCodecKey: AVVideoCodecTypeH264, AVVideoWidthKey: @(gif.width), AVVideoHeightKey: @(gif.height) &#125;;AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerSettings];[assertWriter addInput:writerInput];NSDictionary *pixelBufferAttributes = @&#123; (id)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA), (id)kCVPixelBufferWidthKey: @(gif.width), (id)kCVPixelBufferHeightKey: @(gif.height) &#125;;AVAssetWriterInputPixelBufferAdaptor *writerInputAdaptor = [[AVAssetWriterInputPixelBufferAdaptor alloc] initWithAssetWriterInput:writerInput sourcePixelBufferAttributes:pixelBufferAttributes];NSEnumerator&lt;CIImage *&gt; *enumerator = gif.CIImageEnumerator;CIContext *ctx = [CIContext contextWithOptions:@&#123; kCIContextPriorityRequestLow: @YES &#125;];double frameHZ = gif.delayTime == 0 ? 10 : 1/gif.delayTime;__block CMTime time = CMTimeMake(0, frameHZ);CMTime frameTime = CMTimeMake(1, frameHZ);NSInteger loopCount = gif.loopCount;if ([assertWriter startWriting]) &#123; [assertWriter startSessionAtSourceTime:time]; [writerInput requestMediaDataWhenReadyOnQueue:dispatch_get_global_queue(0, DISPATCH_QUEUE_PRIORITY_DEFAULT) usingBlock:^&#123; while (writerInput.isReadyForMoreMediaData) &#123; CIImage *ciImage = [enumerator nextObject]; if (ciImage == nil) &#123; [writerInput markAsFinished]; [assertWriter finishWritingWithCompletionHandler:^&#123; [[DDVideoCache defaultCache] setLoopCount:loopCount forKey:name]; DDVideoData *video = [[DDVideoData alloc] initWithPath:path]; complete(video); &#125;]; return ; &#125; CVPixelBufferRef pixelBuffer; CVReturn ret = CVPixelBufferPoolCreatePixelBuffer(NULL, writerInputAdaptor.pixelBufferPool, &amp;pixelBuffer); if (ret != kCVReturnSuccess) &#123; DDDebugInfo(@&quot;[Error] CVPixelBuffer create error with code (%zd)!&quot;, ret); complete(nil); if (pixelBuffer) CVPixelBufferRelease(pixelBuffer); return; &#125; if (pixelBuffer) &#123; [ctx render:ciImage toCVPixelBuffer:pixelBuffer]; if (![writerInputAdaptor appendPixelBuffer:pixelBuffer withPresentationTime:time]) &#123; DDDebugInfo(@&quot;[Error] Assert write error!&quot;); complete(nil); CVPixelBufferRelease(pixelBuffer); return; &#125; CVPixelBufferRelease(pixelBuffer); time = CMTimeAdd(time, frameTime); &#125; &#125; &#125;];&#125; 这里使用CIImage来实现图片的转换，如果需要裁剪缩放，或者其他滤镜处理，都可以在这里处理。 这种方案有一个缺点，那就是转换过程比较花时间，需要一定的转换时间，那么我们就需要缓存转换后的视频文件。 这种方案可以处理非常大型的gif文件，但仅仅是一种退而求其次的方法，如果是小型gif文件，完全没有必要使用这样的方法。这里只是提出一种优化的思考方式。 这里我实现了一套简单的带有缓存的方案，具体参考DDGif2Video。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"gif","slug":"gif","permalink":"http://djs66256.github.io/tags/gif/"}]},{"title":"浅析GPUImage的设计思想","date":"2017-10-31T14:32:34.000Z","path":"2017/10/31/2017-10-31-浅析GPUImage的设计思想/","text":"在移动端图片处理时，往往因为大量的计算导致需要较长的时间，为了充分利用设备的潜能，所以产生了利用GPU来处理计算的方案。其中最有名的开源方案就是GPUImage。 结构GPUImage的设计思路参考了流式的结构，所有东西都被概括为input或者output，其中最重要的filter则既是input也是output。这样设计统一了整个流程，但让整个结构变的更加死板和复杂。大概的流程如下： 1Image &gt;&gt; Input &gt;&gt; Filter_1 &gt;&gt; Filter_2 &gt;&gt; Filter_x &gt;&gt; Output 当存在多个Filter的时候，整个结构上就会变的比较难以理解，所以个人认为，需要分开的结构还是分开比较好： 1234Image &gt;&gt; Dispatch &gt;&gt; Output / \\ / \\ Filter_1 ... Filter_x 性能优化GPUImage自身在设计的时候就考虑到了优化，所以有些时候你可能会感觉某些结构上有些奇怪。 比如GPU内存申请基本上是在输入端就创建好了，在Filter中是不会新申请内存的，都是重用了开始就申请好的内存，除非改变了画布大小。 Filter最好进行重用，因为OpenGL es首先需要利用CPU将GLSL编译为GPU可执行的代码，最好的情况是能够重用这部分已经编译完成的代码。 当我们利用GPUImage来处理图片时，一般不会有什么性能问题，但是如果我们利用他来处理视频时，就需要考虑到极限下的性能问题。我们来模拟下多个Filter情况下的GPU处理1帧的情景： 123Image &gt;&gt; Input &gt;&gt; Filter_1 &gt;&gt; Filter_x &gt;&gt; Output / \\ Prepare(CPU) &gt;&gt; Process(GPU) 可以看到每个Filter之间是同步执行的，所以无法很好的利用CPU多线程的能力。理想状况下应该是这样： 12345Image &gt;&gt; Input &gt;&gt; Filter_1 ... Filter_x | | Prepare(CPU) &gt;&gt; Prepare(CPU) | | Progress(GPU) &gt;&gt; Processor(GPU) &gt;&gt; Output 这样就可以将串行执行改为CPU和GPU并发执行，不过GPUImage目前无法改造为这样的结构。 OpenGL es目前iOS平台支持的GPU平台编码主要有2种方式，一种是OpenGL es，另一种就是Metal。按照官方说法，Metal的性能会比OpenGL更好，好像是因为在编译期就进行了一次初期编码，将代码转化为一种类似于bitcode一样的中间码。 OpenGL的基本流程如下： 12345CPU: 创建FrameBuffer + GLSL | drawGPU: main() | readPixelCPU read to RAM GLSL想要了解GPUImage就必须先学会使用OpenGL，那么就离不开学习GLSL，如果你使用CIImage，你也可能会需要KISL，是GLSL的一种子集。 GLSL并不复杂，是一种非常类似于C语言的DSL，但是要与程序进行交互则会变得麻烦。 总结要实现自己的Filter，则首先需要学习OpenGL以及GLSL，这是一个比较大的障碍点。 如果仅仅是为了图片处理，那么GPUImage已经足够了。如果你需要高分辨率高帧率的视频渲染，GPUImage可能就满足不了你，优化思路是并发和利用空间去换取时间。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"GPUImage","slug":"GPUImage","permalink":"http://djs66256.github.io/tags/GPUImage/"},{"name":"OpenGL es","slug":"OpenGL-es","permalink":"http://djs66256.github.io/tags/OpenGL-es/"}]},{"title":"被滥用的category","date":"2017-10-10T17:26:16.000Z","path":"2017/10/11/2017-10-11-被滥用的category/","text":"objc的最大一个特性就是动态性，利用动态特性，我们可以做很多事情，包括对已有的类和对象添加替换方面属性。但是这也给我们带来了一些隐藏的风险，以及让人很不愉快的一些体验。 绝对不能做的事情假如我们定义一个category，如下面： 12345678@interface UIView (My)@end@implementation UIView (My)- (void)setFrame:(CGRect)frame &#123;&#125;@end 那么会发生什么事情？ 系统方法会被替换。这是什么原因呢？是因为主类被先加载，然后才会去加载category，然后会导致原来的方法被替换。 那么我们是不是可以利用这种特性来屏蔽一些我们不能修改的类的方法呢？答案是绝对不能这么做。首先，我们替换了方法，可能会导致一些未知的问题。其次，这种替换是不能保证顺序的，在另一个地方也做了这样的处理，我们无法预知最后是哪一个方法。 所以我们绝对不能使用category来替换原有的方法，真的要替换可以使用method_exchange。 隐藏的风险有些时候在使用category给第三方类增加方法时，也有可能不小心替换了原有的私有方法，从而导致了一些未知的问题。所以也就是为什么大家提倡在方法名前面增加扩展，以最大可能的避免重名。 理解性下降越多的扩展就会引入越多的概念，很多api并非系统api，可能会产生一些意义相近，但是有细微区别的情况，这些都会对我们的理解产生不好的影响。 当我们大量引入这类文件的时候，会产生一大串扩展的方法。特别是当我们把这类util方法作为pch文件全局引入的时候。 性能降低越多的category，会让一个类的方法变多，使方法调用所产生开销也会越大，缓存命中失效的概率也会变大。虽然这些多余的开销微不足道，但是在比较常用的对象上，比如UIView，就会累积。当然这些性能都不是问题。 丑陋的api方法名前加前缀的确是一种解决方案，至少尽可能的减少了冲突的可能，但并不代表不会冲突。 然而这种api却是极其丑陋。 12- (id)my_property;- (void)my_setProperty; 同时这种api使用KeyPath也会非常的麻烦。 甚至可能会出现这样的情况，大家都为同一个功能添加了一个方法： 123- (CGFloat)my_height;- (CGFloat)daniel_height;- (CGFloat)jack_height; 改善那么我们就要讨论如何改善这种情况了。 第三方帮助类这种方式可以说是最优雅的，虽然有点破坏面向对象。 其中系统就提供了几种关于frame的帮助方法： 12CGRectGetHeight()CGRectGetMaxY() 其中React Native中应用了比较多的转换类： 12[Convert stringValue:obj];[Convert integerValue:obj]; 这样就避免了在原有类中添加方法了。实际情况是，很多场景我们也不应该把这些方法加入到扩展中，因为从逻辑上来说，某些方法也不应该出现在这个类中，我们不要单纯的因为方便给一个内容引入太多概念。 属性扩展另一种方式是通过第三方对象转换到自身的方法。比如上面height属性可以改为： 123view.my.heightview.daniel.heightview.jack.height 这样也会带来一些优点，比如可以按照功能设计不同的第三方对象： 12obj.convertor.stringValue()obj.builder.string(@&quot;a&quot;).integer(1) 同时这样做还有一个好处就是可以动态的替换第三方转换对象，从而实现更灵活的控制： 12345protocol Convertable &#123; stringValue()&#125;date.convertor.stringValue() 只要我们把上面的convertor替换掉，就可以更换时间的format方式了。 这样做的缺点是增加了一个对象的生成，但这并不会产生太多的负面影响。 保持私有化如果你真的需要使用扩展方法，那么尽量的保持这类方法的私有化，特别是对一些第三方库来说。 然后通过import来部分载入我们所需要的方法。如果一开始就让这些方法暴露在外，那么会形成比较恶性的情况。 比如我们在NSObject上添加了一个关于model的方法，然而我们在UIView上也将会看到，并可以使用了，我们需要尽量去避免这样的设计。 最后说了这么多，是想建议第三方库的作者不要仅仅为了方便从而滥用category，好好的思考如何才能更好的表达意义。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"category","slug":"category","permalink":"http://djs66256.github.io/tags/category/"}]},{"title":"自定义KVO的一些错误使用方式","date":"2017-10-04T12:51:23.000Z","path":"2017/10/04/2017-10-04-KVO的一些错误使用方式/","text":"很多时候我们讲KVO，使用的时候需要注意移除监听，循环引用等问题，但是在自定义KVO的时候，却容易忽视几个问题。 12345678910111213141516171819202122232425@interface KVOObject : NSObject@property (strong, nonatomic) NSString *a;@property (strong, nonatomic) NSString *b;@property (strong, nonatomic) NSString *c;@end@implementation KVOObject@dynamic c;- (void)setB:(NSString *)b &#123; &#125;- (void)setC:(NSString *)c &#123; [self willChangeValueForKey:@&quot;c&quot;]; [self didChangeValueForKey:@&quot;c&quot;];&#125;- (NSString *)c &#123; return nil;&#125;@end 如果是上述对象，分别对a,b,c监听，其结果是怎么样的呢？ 结果是a是正常的，b触发一次，但是其变化的结果都是nil，c触发2次，其结果都是nil。我们来分析下这样的结果吧。 首先，系统KVO的实现是什么？是自动创建一个虚拟对象，并重写set方法，那么这就和这个属性是不是真的存在实现（比如空，或者associate object）无关了。所以当我们再次去调用willChangeValueForKey和didChangeValueForKey就产生了2次调用，很多在set方法中再次重申变化是一个错误。 那么我们什么时候需要用到这两个方法呢？当在非set方法里面，通过非set方法变更了属性的值时，就需要手动去触发了。这包括了self-&gt;_a这样的调用。 然后，KVO变化的值是怎么取出来的呢？依据willChangeValueForKey的接口来看，并没有传入值的参数，那么显而易见，值是从get方法中取出来的。所以如果set和get方法不是对称的，比如- (id)c所返回的并不是对应c的内容，可能就会出现一些问题，变化的时候并没有触发KVO，触发KVO的时候内容并没有变化。 以上两个在平时碰到的应该比较少，比较自己自定义KVO的场景就比较少。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"KVO","slug":"KVO","permalink":"http://djs66256.github.io/tags/KVO/"}]},{"title":"内存循环引用算法","date":"2017-09-30T13:28:56.000Z","path":"2017/09/30/2017-09-30-内存循环引用算法/","text":"平时我们最容易犯的一个错误就是循环引用，而且难以察觉，而FBRetainCycleDetector则是专门在运行期来检查循环引用，那我们来看看他是怎么做到的。 开始首先，我们来看看在arc环境下，什么时候会发生强引用。 自身属性，被定义为strong类型的变量，都会产生一次强引用。 associate object，被定义为retain类型的也会被强引用。 block，在被闭包捕获的时候，strong类型对象也会被强引用。 特殊对象，比如NSTimer的target，集合类型的addObject。 associate object如何记录associate object的持有情况呢？这里要说一下C语言的hook，也就是在链接的时候替换掉objc_setAssociatedObject方法，然后记录源对象和持有对象。关于hook可以参考fishhook这个库。 propertyobjc的对象会有自身的布局记录（layout），取出每个类中的Ivar的属性，就可以知道哪些属性是强引用的，也就可以知道每个对象所持有的对象了。 block和property一样，每个block也是有对应的layout的。 其他其他一些特殊情况，则需要特殊考虑，细节这里就不说明了。 算法首先，我们将每个需要检测的对象视作一颗颗树，叶子是每个强引用的对象。 作者使用了堆栈来替换递归实现路径点的查找，基本原理是： 1234567891011121314151617181920212223242526// 堆栈用于保存所遍历过的路径NSMutableArray&lt;FBNodeEnumerator *&gt; *stack = [NSMutableArray new];// 集合用于保存该路径上的所有对象，用于判断是否有对象相等，也就是循环引用了。NSMutableSet&lt;FBNodeEnumerator *&gt; *objectsOnPath = [NSMutableSet new];// ...while ([stack count] &gt; 0) &#123; // ... if ([objectsOnPath containsObject:firstAdjacent]) &#123; // 发现循环引用并记录 ... &#125; else &#123; // ... shouldPushToStack = YES; &#125; [objectsOnPath addObject:top]; // 如果没有发现循环引用，则查找其子节点，并push进堆栈 if (shouldPushToStack) &#123; if ([stack count] &lt; stackDepth) &#123; [stack addObject:firstAdjacent]; &#125; &#125; else &#123; // 如果已经没有子节点了，就退出堆栈，开始判定父节点的下一个节点 [stack removeLastObject]; [objectsOnPath removeObject:top]; &#125;&#125; 算法其实很简单，源码也就100行以内。 最后这种方式给予我们一种能够在运行时检查循环引用的方法，但是这并不代表完全正确，比如CFArray，NSHashMap我们就无法判断子元素的引用情况。还有一些虽然形成了循环引用，但在整个流程的结尾，是必定会解除的，会形成误判。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"FBRetainCycleDetector","slug":"FBRetainCycleDetector","permalink":"http://djs66256.github.io/tags/FBRetainCycleDetector/"}]},{"title":"操作符重载和隐式转换的思考","date":"2017-09-29T08:10:11.000Z","path":"2017/09/29/2017-09-29-操作符重载和隐式转换/","text":"从刚开始工作的时候，就有很多人批判C++的操作符重载和隐式转换，我也是一直坚持显式调用的，但是最近看了一些C++相关的库后，发现其实这两者并没有那么的恐怖，反而在某些方面是一颗近乎完美的银弹！ 在iOS开发中有一个描述算法的NSPredicate，关于这个类的使用方式，就相当的复杂。 在sql中，有些很复杂的判断逻辑，比如a &gt; b AND a &lt; 100之类的，但是这些并没有严格的类型限制，如果a是一个时间类型，那么&lt; 100这个条件可能就是一个无效或者未知行为。虽然可以在运行的时候发现这个问题，但却不能在编译期就发现这样的问题。而C++就能很好的解决上面的问题，有严格的类型判定，以及一些类型转换。 在Objc中，有太多的api都非常的啰嗦，虽然说好听点能够表意，但很多时候简单的事情都会让代码非常的复杂。比如： 12[string stringByAppendingString:@&quot;string&quot;];[a isEqualToString:b]; 而我们默认的几种方式并不会产生任何认知上的歧义： 12string + &quot;&quot;;a == b; 在现在很多的计算并不是在CPU中执行的，而是需要放到GPU中执行，比如机器学习、渲染图片。那么如何定义GPU中的运算方式呢？著名的OpenGL就定义了自己的一套GLSL语言，iOS的CIImage也定义了一套类似的语言。但是这些都有同样的问题，那就是运行期进行编译和执行，依然不能在编译器发现问题。那么如果要放到编译期就必然需要利用语言的特性了，最简单的一个向量运算如果不能重载操作符，那么描述一个最简单的运算vec2 = vec1 * 2 + 2也将是灾难性的。 所以，在某些场合下，利用这样的特性是非常方便而且对代码的可读性也有提高。 iOS中就有部分库是利用这样的特性，比如realm和wcdb。 当然这里说的优势并不代表没有劣势，但是利用好这种特性也能给可读性带来更高的提升。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://djs66256.github.io/tags/C/"}]},{"title":"navigation-bar的黑魔法","date":"2017-09-26T17:31:39.000Z","path":"2017/09/27/2017-09-27-navigation-bar的黑魔法/","text":"平时我们在处理页面跳转的时候有一个非常难受的情景，就是当两个页面的导航栏背景色不一致的时候，系统不能很好的处理这两者间的交互动画，这就导致整个导航栏的背景转换非常的生硬，那么这里就来看看现在的一些主流的处理方式。 自定义navigationBar在每个Controller的内部自己实现一个navigation bar，来替代系统UINavigationController的bar。 这种方式最简单直接，也不需要考虑太多的兼容措施和特殊情况。但是这种方式太繁琐，同时和系统的特性相差比较多，不太利于以后的移植和扩展。 要简化这种方式可以定义一个基类，包含实现navigationBar，其他都继承于该基类: 123@interface BaseViewController: UIViewController@property (readonly, strong, nonatomic) UINavigationBar *navigationBar;@end 转换NavigationBar的background像微信这种，导航栏的按钮等动效还是和系统一致，但是背景动效却是跟随页面的。其实是伪装了部分navigationBar。 12345678\\----------------\\ \\ navigation bar \\ \\----------------\\\\------------------------\\ \\ navigation bacckground \\ \\------------------------\\ \\ view \\ \\------------------------\\ 在每次设置navigation background相关属性的时候，自动为其转入到一个第三方的background view中实现。而系统的navigation bar永远是透明的，所以看到的永远是在下面的假的背景。这里要注意的是，需要将这个background永远放在最上层的视图。 这里background有两种方式实现，比如微信，是直接生成一个UINavigationBar，而有些库则是截屏然后渲染为image对象来展示。不管哪种方式，其思想都是一致的。 这种方式和第一种方式类似，只是将部分（背景）放到了view中实现，这种方式既符合了系统的编写方式，又简化了实现的方式，是一种比较好的方式。甚至可以两者结合起来，设置背景的时候不要调用self.navigationController.navigationBar，而调用上面的self.navigationBar。 多层嵌套NavigationController上面的方式都是制造了一个假的navigationBar来解决这类问题，这个方式是完全的使用系统特性来解决这个问题，比如云音乐就是这样的。 既然UINavigationController自带navigationBar，那么我们为什么不利用这个特性呢。我们每次push进去的不是一个单纯的UIViewController，而是一个UINavigationController。 1234- (void)pushViewController:(UIViewController *)controller animated:(BOOL)animated &#123; UINavigationController *navi = [[UINavigationController alloc] initWithRootController:controller]; [super pushViewController:navi animated:animated];&#125; 这样我们虽然使用的是系统方式，然而我们push进去的是一个UINavigationController。 这种方式所得到的navigation bar是真正的系统特性，无需做任何的适配。但这种方式也给整个结构带来了破坏，这里来说说： push进去的是一个controller，而从self.navigationController.viewControllers中取出来的却并不一致，也就产生了api含义的不对称性。如果你要判断上一个Controller是什么页面就会比较麻烦了。当然这种不对称性可以通过重写方法来解决，但还是在使用者无感知的情况下，破坏了其整体结构： 12345- (NSArray *)viewControllers &#123; return [[super viewControllers] map:^(UINavigationController *navi)&#123; return navi.rootController; &#125;];&#125; 总结就以上几种方式来看，本人更倾向于第二种方式，既按照系统的特性来，有避免了改动系统结构，对系统api的含义转换我还是比较谨慎的，副作用会让人感到疑惑和难以察觉。 如果你还有其他的方式，可以告诉我。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"navigationBar","slug":"navigationBar","permalink":"http://djs66256.github.io/tags/navigationBar/"}]},{"title":"数据存储的一些思考","date":"2017-09-09T13:49:43.000Z","path":"2017/09/09/2017-09-09-数据存储的一些思考/","text":"上篇主要讲述了我们在平时iOS开发中常见的一些缓存及其区别，虽然这已经满足了绝大多数的场景，但是当我们遇到特殊场景的时候，又该如何呢。 缓存策略一般来说，客户端使用LRU的缓存策略就已经足够，但是在特定场合就不是那么适用了。比如淘宝每秒百万级别的查询，如果使用LRU，那么可能有些热门商品就会被清理出缓存，从而得不偿失了。 First In First Out (FIFO) Last In First Out (LIFO) Least Recently Used (LRU) Time aware Least Recently Used (TLRU)拥有过期时间的LRU，常见的比如http缓存 Most Recently Used (MRU) Random Replacement (RR) Segmented LRU (SLRU) Least-Frequently Used (LFU) Least Frequent Recently Used (LFRU) LFU with Dynamic Aging (LFUDA) 如果真的有如此特殊的场景，就需要我们去选择最优的策略来保证缓存的命中率了。 memory map其中很多方案都提到了内存映射的技术。 内存映射会少去很多的解析编码、内存拷贝操作，所以性能上会优于普通的文件读写。 但是内存映射本身就存在一些缺陷，比如32/64操作系统的兼容性，大端小端的兼容性，字节对齐问题。所以并不是任何情况下都适合使用内存映射。如果需要保证兼容性，则需要在设计的时候就要考虑到这样的问题。 搜索优化作为数据存储最频繁的当然是查询功能，那么如何保证查询的性能呢，那么就涉及到索引了。 操作系统本身的文件系统就带有B/B+数所做的索引，所以我们在目录下查找一个文件其实是很快的，就算这个文件夹下内容非常的多。所以一般情况下我们并不需要为文件系统做额外的索引优化。 如果是内存中的缓存，那么使用hash表是最通用的一种方式了。如果是数组则要考虑好承载能力了，少量的数据可能没有问题，当数量到达一定程度后就会暴露出来。这时候可以使用自平衡二叉树、B树、跳跃链表等来做优化了。 sqlite是我们使用最多的一种数据存储方式，提升sqlite搜索速度的方式就是对某列增加索引，具体需要根据具体情况来分析。默认的sqlite索引是B树，也可以配置为R树索引，在坐标数据库表可能会表现更优秀。 存储格式数据的存储格式也是非常关键的一个部分。 像UserDefault这种全量更新的方式，在单一数据变化的时候就需要全部重新序列化并且全部保存，所以如果拥有大量数据或者数据非常庞大的时候，就会变得效率低下。 像ImageCache这种按照单文件保存，如果是小数据，每次都需要去读磁盘，反而效率会降低。由于磁盘的读取和写入并不是单字节的，都是按块读写是最有效率的，所以多个小数据可以一次性读取和写入。 如果是像sqlite那样按照chunk来局部更新文件，则需要非常小心的处理每个数据存储模块，同时也要非常小心处理多线程的问题。另外也需要添加索引来确保效率。 如果是随机读为主的情况下，sqlite能够完成这个任务，但是如果是以写为主，那么sqlite就可能出现性能问题（虽然按照移动客户端来说不太可能有这么大的写的需求）。 最后如何去选择缓存和存储方案，还是需要根据实际情况，通常一个通用的方案已经足够，但是在某些特殊场景还是需要我们去自己设计这一套方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"http://djs66256.github.io/tags/Cache/"},{"name":"数据库","slug":"数据库","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"realm","slug":"realm","permalink":"http://djs66256.github.io/tags/realm/"},{"name":"leveldb","slug":"leveldb","permalink":"http://djs66256.github.io/tags/leveldb/"}]},{"title":"选择你所需要的缓存","date":"2017-08-30T10:02:24.000Z","path":"2017/08/30/2017-08-30-选择你所需要的缓存/","text":"我们在处理数据的时候，第一步就会接触到缓存。这里就来看看应该选择什么样的缓存来解决你的问题。 在一般的场景下，我们并不会去考虑缓存的所带来的优化与损耗，因为大部分场景这一点损耗都可以忽略不计，但是在某些极限情况下，这就不能被忽略了。那么我们就需要来思考采用什么样的方式去缓存数据。 首先，缓存可以被分为两类： 内存缓存 磁盘缓存，也可以称为持久化 那么我们按照这两者来分析下，现在比较流行的几种方式。 Memory CacheNSCache官方提供的缓存一般来说已经足够使用了，线程安全，功能也特别完善，拥有灵活的控制，在内存不足时也会回收内存。底层应该是基于hash表的，所以性能表现也十分优秀。 但是系统实现的缓存失效策略却是未知的，无法保证是LRU策略。同时NSCache会在系统回到后台的时候清空缓存，如果你希望在app的生命周期内都可以缓存，那么NSCache难以做到。 一般来说NSCache是首选，除非需要一些特殊的要求。 NSArray &amp; NSDictionary这两者是系统内置集合类型，可以用作缓存数据，但是是非线程安全的，在使用中需要特别小心，同时需要自己去控制缓存失效。 在数据量比较小的时候，这两者都是没有问题的，但是在数据量变得庞大的时候就会有一定的性能问题。 由于NSArray是数组实现，位置查找的效率为1，内容查找的效率为n，所以在大量频繁的内容查找中，会降低其性能。这时候推荐NSSet或者NSOrderedSet来替代NSArray。NSSet的底层是hash表。 在使用hash表的时候，如何来更好的实现其查找性能呢，就需要保持key的hash随机分布。一般来说我们都会使用string作为key，在自己实现的key值别忘了重写hash。 在某些情境下，使用集合类型也非常有效。 其他也可以根据自己的需求来设计自己的容器类，比如自平衡二叉树、B树等。不过首先要了解上述几种是否已经满足自己的需求。 Persistent持久化缓存拥有多种不同的数据格式和存储方式，这里按照几种方式和开源库来看看各自的方案。 NSUserDefaults这是系统提供的最简单的一种保存数据的方式，自带了缓存和同步机制，利用的是NSCoding的方式，所以NSCoding拥有的缺陷UserDefault也会拥有。 当数据量增多变大，会导致plist文件太大，从而影响加载性能，所以只能保存少量的小型数据。 NSCoding这是系统提供的持久化方案，不仅仅保存了数据，同时也保存了类别信息。但这也带来了部分缺陷，那就是数据兼容问题。 当软件升级时，修改了类名，或者改动了内部成员实现，就可能导致数据错误设置崩溃。所以需要小心控制数据版本信息。 由于这种方式是一次性的读取与写入，在数据量大的时候也会产生一些问题。同时这种方式并不适合部分读取部分修改的场景，如果数据比较大需要重新考虑。 JSON另一种代替NSCoding的方式便是使用JSON来保存，虽然在数据兼容性上会比NSCoding稍微优秀一些，但依然没有根本解决这个问题，所以这是一个可选方案。 YYKitYYKit使用了LRU策略，明确了缓存失效策略。 内存缓存使用了线性链表+NSDictionary来实现，由于LRU的特性，插入永远在开始，而删除永远在结尾，所以拥有较高的性能。但是查找还是依赖于hash表来实现。这样在插入和查找都避免了对方的缺陷，实现了更加高效的结果。缺点是需要同时保存和修改两份数据索引。 磁盘缓存使用了sqlite来保存文件缓存信息（filename, last_modify_time)，所以在读写小数据的时候（20KB）会直接在sqlite中读写，而不会生成一个独立的文件。所以在小文件和未命中的情况下效率会高很多。而读写大文件时，效率会降低一些，考虑到sqlite的缓存和执行，并不会降低太多。由于sqlite对时间创建了索引，所以在缓存过期查找上面会优秀一些。这种设计解决了小文件和未命中的效率问题，但是并不能实现高并发读写文件。 这种按照数据量来区分数据存储方式的方法解决了大文件和小文件之间的性能差别，但也给缓存系统带来了一定的复杂性。同时如果sqlite的索引失效会导致查找效率的降低。 YYCache带来了一种通用型的存储方式，但在很多时候还是需要自己来实现特定的需求。 PINCache使用了大量的Lock来处理多线程读写，拥有异步读写接口，没有太多的特别优化。 磁盘缓存单纯使用了文件缓存，在初始化的时候就把整个目录及其元素的属性读到内存，来提高效率，但是使用的是数组存储，效率一般。 SPTPersistentCache他将数据信息通过memory map的方式写到了文件头部，说是为了并发读写，但这也时每次更新updateTime需要写整个文件，这样必定会导致性能降低。个人建议还是把文件信息写到另一个文件中，方便内存缓存。 这种方式比较适合的场景是只读数据，对于经常变化的数据反而可能会降低性能。 Haneke &amp; SDWebImage这两者非常相似，Haneke功能更少，但是更加紧凑，代码结构也更加好。而SDWebImage功能非常完善，使用的人也非常的多。但也并非没有瑕疵。 图片缓存读取全部在一个子线程中进行，导致在高并发读取的时候会阻塞线程，同样下载和解码也会有类似的问题。这么设计同时也是为了保证线程安全，所以采用了顺序队列的操作，但是对于单文件来说，这样是正确的，对于多文件来说没有必要这样做。在目前移动端以及pc端来看，性能的瓶颈还不在这个地方，依然在IO上面，所以除非特殊情况，不会出现性能问题。 图片的二次处理能力不够（比如手动加圆角，裁剪，滤镜），需要自己去处理并且缓存，这对于一个图片库来说是一个遗憾，好在目前大部分工作CDN都会帮我们做掉。 预加载图片无法和正常加载使用同一套机制，预加载和正常加载如果同时触发会加载2次。SD没有考虑到预加载和正常加载使用同一个Operation缓存，导致双方都会触发真实的下载，从而浪费了流量。 作为一个图片库，图片一般内容都比较大，所以采用了文件缓存的机制，使用key作为文件名。由于文件系统自身拥有的缓存，所以在查找的效率上并不低。 FastImageCache这也是一个图片缓存方案，增加了处理图片的一些中间件。 该作者认为效率问题主要出现在图片从磁盘读取到内存，再进行解压，以及渲染前的内存拷贝。解决这类问题的最好方法就是进行memory map，将处理好的内容直接写入文件，这样在下一次载入的时候就不需要重新处理了。 作者也指出了这种方式会导致一张高压缩率的图片，进行内存映射后会变得很大，这一非常大的缺陷。 内存映射也是一种很好的方案，在存储资源丰富，而处理需要很长时间的情况下，是最简单的处理方式。随着现在设备性能的提高，一般不会存在处理的性能瓶颈，所以也需要按情景来判断。 最后这里分析了几种内存缓存和磁盘缓存的情况，一般内存缓存较为简单，不会有太多的性能问题，而磁盘缓存拥有很多的方案，每种方案都有各自的适用场景，需要根据自身的实际情况来选择。 这里所列的几种磁盘缓存都比较简单，之后会介绍一些比较复杂的存储方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://djs66256.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"Cache","slug":"Cache","permalink":"http://djs66256.github.io/tags/Cache/"}]},{"title":"Hybrid简介","date":"2017-08-19T19:07:47.000Z","path":"2017/08/20/2017-08-20-Hybrid简介/","text":"现在的中大型app中，为了满足快速迭代以及动态更新的需求，就往往需要使用混合架构，来达到动态更新的目的。这里就来简单介绍下目前比较主流的混合框架及其优劣。 目前的框架我大致将他归为为3种： X-native web-native template / DSL X-native这个目前最具有代表性的就是js-native了，还有一些像lua-native等，由于很久没有人维护了，就不做介绍了。 自从前端框架出现了virtual dom这个技术，就给我们的native化创造了先决条件，下面的技术都是根据virtual dom来驱动的。 react-native这是一个非常热门的项目了，贡献者就达到了1.4k，是其他项目无法比拟的，可以说是目前世界上最热门的项目之一了。 功能强大，可以说项目本身就基本包含了所有app功能。你可以不用写一行native代码，就能写一整个应用。也可以单独去渲染部分页面，非常灵活。作为一个需要快速迭代和动态更新的页面，往往也不需要特别高的交互性，所以单纯的展示已经足够了，react-native本身所提供的功能其实已经远大于渲染一个页面了。目前我尝试下来也没遇到什么坑。 正因为热门，所以社区支持非常完善，遇到什么问题，google、Stack Overflow上都有答案。所以不用担心遇到什么无法解决的问题。文档和例子也非常完善，有大量优秀的开源组件支持，很多功能都被封装为单独的组件，不需要自己去重新写了。 debug功能非常强大，而且非常好用。而且有非常多第三方的debug tools。比如专门对redux的react-dev-tools。 但是react本身就是一个非常大的话题，需要一定的学习成本。同时react-native的目标并不是统一多平台实现，而是把多平台实现转化到react，所以难以只写一份代码就能兼容所有平台，所以还是需要很多的兼容代码。这样就需要写代码的人对多平台都有所了解，同时又要理解前端技术，可以说这样的人才其实还是很少的。当然，如果只是写比较简单的页面，使用各平台通用的一些组件，还是比较简单的。 这里就有一个例子，之后也会用这个列子来验证： 这里的图片是动态显示的，有才会显示。布局如下 123456 ------------------| Title | || SubTitle | Image | ------------------| name | ------------------ 实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React from &#x27;react&#x27;import &#123; View, Text, Image, StyleSheet&#125; from &#x27;react-native&#x27;import Sep from &#x27;./seperator&#x27;export default class Answer extends React.Component &#123; render() &#123; let &#123;data&#125; = this.props return ( &lt;View style=&#123;style.container&#125;&gt; &lt;View style=&#123;style.content&#125;&gt; &lt;View style=&#123;style.textContent&#125;&gt; &lt;Text style=&#123;style.title&#125; numberOfLines=&#123;2&#125;&gt;&#123;data.question.title&#125;&lt;/Text&gt; &lt;Text style=&#123;style.subTitle&#125; numberOfLines=&#123;3&#125;&gt;&#123;data.description&#125;&lt;/Text&gt; &lt;/View&gt; &#123; data.images &amp;&amp; data.images.length &amp;&amp; &lt;Image style=&#123;style.image&#125; source=&#123;&#123;uri: data.images[0]&#125;&#125; /&gt; &#125; &lt;/View&gt; &lt;View style=&#123;style.textSep&#125;&gt;&lt;/View&gt; &lt;Text style=&#123;style.nickName&#125;&gt;&#123;data.author.nickname&#125;&lt;/Text&gt; &lt;Sep style=&#123;style.sep&#125;/&gt; &lt;/View&gt; ) &#125;&#125;let style = StyleSheet.create(&#123; container: &#123; marginLeft: 20, marginRight: 20, alignItems: &#x27;stretch&#x27; &#125;, content: &#123; marginTop: 20, width: &#x27;100%&#x27;, flexDirection: &#x27;row&#x27; &#125;, textContent: &#123; flexDirection: &#x27;column&#x27;, flexShrink: 1 &#125;, image: &#123; marginLeft: 10, width: 100, borderRadius: 2, aspectRatio: 1 &#125;, textSep: &#123; height: 1, width: 20, backgroundColor: &#x27;#ccc&#x27;, marginTop: 10 &#125;, title:&#123; fontSize: 16, lineHeight: 20, fontWeight: &#x27;600&#x27;, marginTop: 0 &#125;, subTitle: &#123; marginTop: 8, fontSize: 13, lineHeight: 17, color: &#x27;#999&#x27; &#125;, nickName: &#123; marginTop: 14, fontSize: 12, color: &#x27;#999&#x27; &#125;, sep: &#123; marginTop: 20 &#125;&#125;) 在使用下来，没有任何的问题，不论布局还是元素内容。由于使用的是js和jsx，和前端的编码非常类似，所以如果从前端转过来的学习成本会非常低。同时css布局使用的是flex，几乎完全兼容web端的布局方式。 官方的debug工具如下： weex现在来看下非常相似的weex，由阿里出品。号称能多平台使用一份代码。那么真实情况是怎么样的呢？我也去尝试了下。 weex使用的是vue框架，所以更像web的编码方式，所以学习成本会低一些。 weex的文档也比较完整，但是开源组件显然就少了很多。 虽然weex号称能够统一多平台，但是能够使用的特性只有多平台共有的特性，这一点其实react-native也能做到。这样就导致weex被限定在一个比较小的方面了。 同时weex说能够无缝降级为h5实现，然而我实践下来发现其实并不能做到完全的无缝，因为两者之间有些东西并不能等价。react-native降级会更为麻烦一些，还要考虑多平台的原生组件。所以实际上weex的降级方案并没有他说的那么好用。 布局系统，虽然三方（h5，weex，react-native）都可以使用flex布局来实现，但还是有部分出入。react-native和web的flex兼容的最好，上面就是按照web的方式来写的，但是有部分是web没有的。weex比较奇怪，他实现了部分flex功能，同时又自己自创了几个，所以说降级并没有那么好用。下面的例子就是就可以看出来，如果按照web的写法会有一些错乱。 可以这么认为：1react-native flex (Yoga) &gt; web flex &gt; weex flex weex的社区支持比较小，也就国内的几个厂家在使用，所以能获得的帮助也会少一些。 下面就是使用weex来实现的例子，css和上面的保持一致，发现有些布局已经发生错乱： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div class=&#x27;container&#x27;&gt; &lt;div class=&#x27;content&#x27;&gt; &lt;div class=&#x27;textContent&#x27;&gt; &lt;text class=&#x27;title&#x27;&gt;&#123;&#123;answer.question.title&#125;&#125;&lt;/text&gt; &lt;text class=&#x27;subTitle&#x27;&gt;&#123;&#123;answer.description&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;image v-show=&quot;cover&quot; class=&#x27;image&#x27; :src=&#x27;cover&#x27; &gt;&lt;/image&gt; &lt;/div&gt; &lt;div class=&#x27;textSep&#x27;&gt;&lt;/div&gt; &lt;text class=&#x27;nickName&#x27;&gt;&#123;&#123;answer.author.nickname&#125;&#125;&lt;/text&gt; &lt;div class=&#x27;sep&#x27;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; answer: Object &#125;, computed: &#123; cover() &#123; return this.answer.images &amp;&amp; this.answer.images.length &amp;&amp; this.answer.images[0] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .container &#123; margin-left: 40; margin-right: 40; align-items: stretch; &#125; .content &#123; margin-top: 40; flex-direction: row; &#125; .textContent &#123; flex-direction: column; flex-shrink: 1; flex-grow: 1; &#125; .image &#123; margin-left: 20; width: 200; height: 200; border-radius: 4; flex-shrink: 0; /* aspect-ratio: 1; */ &#125; .textSep &#123; height: 2; width: 40; background-color: #ccc; margin-top: 20; &#125; .title &#123; lines: 2; font-size: 32; line-height: 40; font-weight: 600; margin-top: 0 &#125; .subTitle &#123; lines: 3; margin-top: 16; font-size: 26; line-height: 34; color: #999; &#125; .nickName &#123; margin-top: 28; font-size: 24; color: #999; &#125; .sep &#123; margin-top: 40; height: 2; background-color: #ccc; &#125;&lt;/style&gt; 官方提供的工具可以看下： js-native如果你要问我选用哪个框架，根据上面的两个例子，心里应该就有选择了。react-native是一个非常大型的完善的项目，如果你不想折腾，那么就选择react-native吧。如果你想要极致的选择，你可以尝试下weex。而多平台支持并不是你选择的理由，react-native的子集完全可以做到多平台支持。 H5这是一个非常古老，但是非常有效的策略了。而且不需要更多的学习成本。缺点当然就是没有native那么的高效。 最有名的当然就是cordova这个开源项目了。他把很多native的功能通过module的方式暴露给web，让web能够使用很多的原生功能。而事实上很多情况下web只是作为一个app的附加功能，并不会给web如此多的权限。所以如果整个app是架构在web的基础上的话，可以尝试下cordova这类的项目。而仅仅是内嵌web，则需要考虑到控制不同的web需要拥有不同的权限。 另外一个非常有名的项目是JSWebviewBridge，他可以让我们定制化的注入几个功能，提供web端调用。这种定制比较简单，也没有module的概念，不能够构建复杂的功能。 h5最为常用和成熟，而且和原生系统关系不大，所以这里就简单介绍下。 Template / DSL剩下的基本就可以概括为模板技术和DSL技术了。这两者的应用面更加狭窄，往往作为并不要求那么灵活多变的场景。但是这种方式更为稳定和搞笑。 Tangram淘宝首页的模块化技术。可以想到，淘宝首页对动态化的要求没有那么高，首页的运营都是非常稳定的，样式也是非常稳定的，只有内容变化非常大，那么模板技术就是最适合的了。 其实很多app都在用这种方案，只是做的更加的简单些，比如： 12345678910[ &#123; &quot;type&quot;: 1, &quot;data&quot;: &#123;&#125; &#125;, &#123; &quot;type&quot;: 2, &quot;data&quot;: &#123;&#125; &#125;] 这种数据结构，type所对应的就是模板的代号。只是Tangram将这个更加的泛化了而已，并且增加了很多后台配置和管理的功能。 官方的例子： Jasonette这是一个依赖于JSON的DSL，包括布局、事件处理都可以在JSON中配置完成。 布局使用UITableView，UICollectionView，UIStackView来实现，所以也有部分的兼容问题。 同时对于新的DSL，学习成本比较大，也缺乏debug和开发工具，手写JSON太不友好了。 这是我用Jasonette写的例子： 基本的布局可以实现，但有些布局还是不能很好的完成。 官方的例子： samurai-native / BeeFramework这是利用xml或者html来布局的框架，虽然可以做到绑定事件，但并不能处理事件，所以局限非常大。这两者已经很久没人维护了。 总结可以看到目前这类想法除了模板技术，其他的都已经被X-native所替代了，因为这种技术的局限性实在是太大了。所以也建议大家慎重考虑这种局限比较大的方案。 最后以上介绍了目前比较热门的几种hybrid方案，就目前的情况来说，除了h5，其他都在向javascript-native方向发展，可能因为javascript这门语言的火热，同时又有大量前端开发。可见一个方案的优劣还是需要从更大的方面来看待，而不是从功能的实现上来看待，易用和学习成本还是非常重要的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"hybrid","slug":"hybrid","permalink":"http://djs66256.github.io/tags/hybrid/"},{"name":"weex","slug":"weex","permalink":"http://djs66256.github.io/tags/weex/"},{"name":"cordova","slug":"cordova","permalink":"http://djs66256.github.io/tags/cordova/"},{"name":"Jasonette","slug":"Jasonette","permalink":"http://djs66256.github.io/tags/Jasonette/"},{"name":"Tangram","slug":"Tangram","permalink":"http://djs66256.github.io/tags/Tangram/"}]},{"title":"javascript-native调用实现","date":"2017-08-19T14:54:55.000Z","path":"2017/08/19/2017-08-19-javascript-native调用实现/","text":"在现在流行的多元框架中，最常见的就是JavaScript的应用了。这里就来分析下react-native的实现。 react-native并不是只有一种实现。因为他不仅仅支持JavaScriptCore来实现交互，也考虑到了某些场景下需要使用WebView来实现，同时也有很多debug工具，需要将JavaScript的执行环境转移到浏览器。大概的结构如下： 1234567891011 ------------------------------| native | ------------------------------ | bridge ⅴ|------------------------------|| Executor ||------------------------------|| JSContext | WebView | Chrome ||------------------------------| 其中执行器部分（Executor）可随意替换为不同实现。这里我们来分析下JSContext中的实现。 Module要实现react-native这样大型的框架，javascript就不能被散乱的放置，那么就必须进行分模块。调用模块时需要使用CommonJS或者ES6的方式。 12var module = require(&#x27;module&#x27;)import * as module from &#x27;module&#x27; 同时也需要考虑到如此多的模块，一次性载入所带来的性能损耗，就必须采用惰性加载的方式。 队列和其他项目的实现方式类似，react-native依然使用了message queue来实现通信，而不是JavaScriptCore自带的绑定功能，这是为了兼容上面说的多Executor。 与其他方案不太相同的是，react-native在module，module-method和callback都使用了id: number来取代名字，个人猜测可能是为了性能考虑。 那么我们就JSContext这种情况来说下整个通信实现的过程。 实现这里使用console来作为例子，这里使用JavaScriptCore的c接口是为了和react-native保持一致，同时忽略了内存问题。 模块表观察发送给JSContext的数据发现会有很多类似这样的JSON数据： 12345[ &quot;WebSocketModule&quot;, null, [&quot;connect&quot;,&quot;send&quot;,&quot;sendBinary&quot;,&quot;ping&quot;,&quot;close&quot;,&quot;addListener&quot;,&quot;removeListeners&quot;]] 可以看出来，[0]表示的是module名字，而[2]表示的是module的方法，正式这一份表，才对应了javascript和native双方的indexId，所有的通信都是对应于这一份表来进行的。 所以双方都会有一份自己维护的模块，而js的模块表我们这里定义为 1234// id =&gt; module 这是native调用js module时，传递的是idvar nativeModuleByIds = &#123;&#125;// name =&gt; module 这是js调用js module时，传递的是namevar nativeModules = &#123;&#125; 载入模块在javascript端，如果需要载入模块，那么我们会使用 1var console = require(&#x27;console&#x27;) 那么在JSContext还没有console模块的情况下如何进行初始化呢？这里就需要一个NativeRequire，来载入native模块，结合上面的模块配置表，require的实现如下： 1234567var NativeRequirefunction require(moduleName) &#123; if (nativeModules[moduleName]) &#123; return nativeModules[moduleName] &#125; return NativeRequire(moduleName)&#125; NativeRequire在初始化JSContext时，我们就需要为通信做好连接的准备，直接注入3个方法。(这里react-native其实还有另外一个方式触发require，通过nativeModuleProxy对象的getProperty来触发，这里讨论最原始的require方式) 1234567891011121314151617181920JSClassDefinition definition = kJSClassDefinitionEmpty;JSClassRef global = JSClassCreate(&amp;definition);g_ctx = JSGlobalContextCreate(global);JSObjectRef globalObj = JSContextGetGlobalObject(g_ctx);&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeRequire&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeRequire); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125;&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeFlushQueueSync&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeFlushQueueSync); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125;&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeFlushQueueAsync&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeFlushQueueAsync); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125; 关于NativeFlushQueueSync和NativeFlushQueueAsync到下面再解释。 这里native的模块表就不实现了，直接使用[&quot;console&quot;, null, [&quot;log&quot;, &quot;getName&quot;], [1]]。 1234567891011121314151617181920212223242526272829303132333435JSValueRef NativeRequire ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 1) &#123; JSValueRef jsModuleName = arguments[0]; if (JSValueIsString(g_ctx, jsModuleName)) &#123; char buffer[128] = &#123;0&#125;; JSStringGetUTF8CString(JSValueToStringCopy(g_ctx, jsModuleName, nil), buffer, 128); // 0. 当js调用&quot;NativeRequire(&#x27;console&#x27;)&quot;的时候 // 1. 我们会在本地的模块表里根据名字去查找 // 这里就简单的strcmp来表示 if (strcmp(buffer, &quot;console&quot;) == 0) &#123; CFStringRef config = CFSTR(&quot;[\\&quot;console\\&quot;, null, [\\&quot;log\\&quot;, \\&quot;getName\\&quot;], [1]]&quot;); // 2. 构造js对应的模块表，这里的顺序必须和native是一一对应的 // [ moduleName, constants, methods, async indexes ] JSValueRef jsonConfig = JSValueMakeFromJSONString(g_ctx, JSStringCreateWithCFString(config)); JSObjectRef global = JSContextGetGlobalObject(g_ctx); JSValueRef genNativeModules = JSObjectGetProperty(g_ctx, global, JSStringCreateWithCFString(CFSTR(&quot;genNativeModules&quot;)), nil); JSValueRef args[] = &#123;JSValueMakeNumber(g_ctx, ConsoleModuleId), jsonConfig&#125;; // call JS =&gt; genNativeModules(moduleId, config) // 3. 调用js，初始化native模块，将函数表中的string转换为function实现 // 这里接下节 JSValueRef module = JSObjectCallAsFunction(g_ctx, JSValueToObject(g_ctx, genNativeModules, nil), global, 2, args, nil); return module; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 这里会同步调用初始化模块方法，并且将模块返回给JSContext。 但是可以发现模块表中的方法都是string，也就是方法名，我们如何去使用console.log()这样的方法呢？这里就需要中间的初始化模块这个作用了。 初始化模块回到上节的第三步，此时native传给js一个模块表，让js去构造这个模块。让我们回到js： 123456789101112131415function genNativeModules(moduleId, config) &#123; let [name, constants, methods, asyncs] = config let module = &#123;&#125; // 这里将所有的方法名都转换为function methods.forEach(function(method, methodId) &#123; module[method] = function (args) &#123; // call native flush &#125; &#125;, this); nativeModules[name] = module nativeModuleByIds[moduleId] = module return module&#125; 这样便把string转换为function了，可以像正常的js方法那样使用了。 到这里注册js模块已经完成，下面来说说调用的过程。 同步方法的调用同步方法的调用对于JSContext来说会简单很多，而对于很多基于webview的实现来说就会麻烦一些，因为参数不能直接编码在url中，最后我们来讨论下这个问题。 上节说到将方法名转换为function，那么function具体实现是怎么样的呢？ 首先来看看同步方法的实现： 123module[method] = function (args) &#123; return NativeFlushQueueSync(moduleId, methodId, ...args)&#125; 这里的NativeFlushQueueSync方法就是一开始我们注入的方法，作用是执行对应模块的对应方法。 1234567891011121314151617181920212223242526JSValueRef NativeFlushQueueSync ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 3) &#123; // 这里通过查找native的模块表，查找到对应的方法，并执行 if (JSValueIsNumber(g_ctx, arguments[0]) &amp;&amp; JSValueIsNumber(g_ctx, arguments[1])) &#123; if (JSValueToNumber(g_ctx, arguments[0], nil) == ConsoleModuleId) &#123; if (JSValueToNumber(g_ctx, arguments[1], nil) == 0) &#123; // call Native &lt;= console.log if (JSValueIsString(g_ctx, arguments[2])) &#123; // console.log转换为NSLog NSString *str = (__bridge NSString *)JSStringCopyCFString(NULL, JSValueToStringCopy(g_ctx, arguments[2], nil)); NSLog(@&quot;%@&quot;, str); &#125; &#125; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 然而react-native并没有完全严格上的同步执行方法。因为很多调用UI层的功能必须在主线程上，而JSContext是在自己的线程中执行，所以如果需要严格的同步执行，需要阻塞JS线程。而几乎所有功能都是不需要执行结果的（return void），所以只要触发native去执行该方法就行了，无需等待执行完再返回。而需要有返回值的接口都被设计成异步的了。 异步回调说到异步回调，大家用的方案好像都是一样的，那就是callbackId。 1234567891011121314var messageQueue = &#123;&#125;var messageQueueId = 0function JsMessageQueueAdd(args) &#123; messageQueueId ++ messageQueue[messageQueueId] = args return messageQueueId&#125;function JsMessageQueueFlush(queueId, args) &#123; let callback = messageQueue[queueId] if (callback &amp;&amp; typeof(callback) === &#x27;function&#x27;) &#123; callback(args) &#125;&#125; 创建异步module方法的方式会有点不一样： 1234module[method] = function (args) &#123; let queueId = JsMessageQueueAdd(args) NativeFlushQueueAsync(moduleId, methodId, queueId)&#125; 然后来看看native的实现： 12345678910111213141516171819202122232425262728293031JSValueRef NativeFlushQueueAsync ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 3) &#123; if (JSValueIsNumber(g_ctx, arguments[0]) &amp;&amp; JSValueIsNumber(g_ctx, arguments[1])) &#123; if (JSValueToNumber(g_ctx, arguments[0], nil) == ConsoleModuleId) &#123; if (JSValueToNumber(g_ctx, arguments[1], nil) == 1) &#123; // call Native &lt;= console.getName JSValueRef queueId = arguments[2]; NSInteger queueIdCopy = JSValueToNumber(g_ctx, queueId, nil); dispatch_async(dispatch_get_main_queue(), ^&#123; JSObjectRef global = JSContextGetGlobalObject(g_ctx); JSValueRef flush = JSObjectGetProperty(g_ctx, global, JSStringCreateWithCFString(CFSTR(&quot;JsMessageQueueFlush&quot;)), nil); JSValueRef args[] = &#123; JSValueMakeNumber(g_ctx, queueIdCopy), // callback queueId JSValueMakeString(g_ctx, JSStringCreateWithCFString(CFSTR(&quot;My iPhone&quot;))) &#125;; // call JS =&gt; JsMessageQueueFlush(queueId, args) JSObjectCallAsFunction(g_ctx, JSValueToObject(g_ctx, flush, nil), nil, 2, args, nil); &#125;); &#125; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 可以看到和同步方式的区别是就是回调会缓存在队列里。 应用123456var console = require(&#x27;console&#x27;)console.log(&#x27;Hello Javascript!&#x27;)console.getName(function (name) &#123; console.log(`Hello $&#123;name&#125;`)&#125;) 123// output:Hello Javascript!Hello My iPhone 装饰实际情况不会这么简单，js也不会直接使用native提供的模块的，一般会包装一层。比如像这样 1234567var nativeLog = NativeRequire(&#x27;NSLog&#x27;)var console = &#123; log: (args) =&gt; NSLog(args), info: (args) =&gt; NSLog(&#x27;[INFO]&#x27;, ...args), error: (args) =&gt; NSLog(&#x27;[ERROR]&#x27;, ...args)&#125;export default console 实际真实情况不会像上面那么简单，需要考虑到多线程，每个module的运行线程，js消息队列等保证js的安全顺序执行。 WebView其他项目的方案也是类似的，但也有少许的不同。 比如NativeRequire，在Web里面除了通过iframe来实现，还可以通过script标签来导入模块文件。 123var script = document.createElement(&#x27;script&#x27;)script.setAttribute(&#x27;src&#x27;, &#x27;file://module.js&#x27;)document.head.appendChild(script) 同时由于web通过url传递参数的限制，所以web的参数传递是通过native去主动拉取的。大概的流程如下： 1234[web] call native --&gt; push &lt;call info&gt; --(iframe url)--&gt;[native] get &lt;call info&gt; --(executeJs)--&gt;[web] pop &lt;call info&gt; --&gt;[native] call *** 同时很多方案，会使用名字来传递模块和方法，这样做最简单也最直接。但是如果存在频繁交互的过程可能会降低性能。 最后总的来说，javascript-native交互还是挺简单的，只要在初始的设计上比较符合现在与未来的发展，还是可以做到很灵活的。至于使用哪种方案，做到什么样的程度，可以依据自身的需求来判断。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://djs66256.github.io/tags/javascript/"},{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"JSWebviewBridge","slug":"JSWebviewBridge","permalink":"http://djs66256.github.io/tags/JSWebviewBridge/"}]},{"title":"谈谈程序员","date":"2017-08-06T12:48:44.000Z","path":"2017/08/06/2017-08-06-谈谈程序员/","text":"在很多人印象里，程序员总是那些呆板的形象。那么什么才是真正的程序员，什么才是优秀的程序员呢？ 国内的互联网蓬勃发展，但是却很多程序员在吐槽，这是为什么呢，程序员在国内的环境究竟如何呢？ 能力能力在程序员的世界里其实是非常容易衡量的，而且是非常容易区分的。我曾经面过一些人，也被面过很多次，这里来简单说下。 差的程序员学习别人教给他们的，学会需要使用到的，能够运用学会的知识，解决一些简单的问题。 这也是为什么近些年这么多培训机构，然而程序员的职位依然短缺的原因。没有一定的知识基础，大学学的一些其他辅助学科，仅仅学会一门语言，一种编程模式，是没有什么太大意义的。就如培训机构所说的，几个月就让你学会Java开发。这种量产出来的东西终究不能成为一名合格的程序员。 合格程序员会自主的学习新的知识，学习别人的项目，学会使用别人的功能。 这种人员能够自我提高和更新，主要体现在技术的体量和深度上。一个合格的程序员不仅仅知道自己项目中存在的一些功能，还知道其他人也实现了类似的功能，以及之间的区别优劣。他能完成很多分派的任务，也不需要去担心太多的风险。 可以说，很多公司其实就是要这样的人，这也是没有办法的事实，毕竟所有公司的目的是为了盈利，而不是为了更好的程序。对于他们来说，足够就行，而不是足够优秀。 优秀程序员除了会主动学习，更多的是会主动思考。思考如何让一个项目更稳定，更加完美。 这是一种完美主义者的追求，所以很多时候经常捣腾点东西。可能有时候会给项目带来一点点小麻烦，也有可能会给项目带来极大的提升。但总的来说是往好的方向发展。 这个非常依赖个人的主观意见，每个人的理解并不一致，有些人可能觉得知识的体量和深度是衡量的标准，也有人可能认为创造性是一个标准。总而言之，这一区段的人员很难从合格中区分开来，需要有一定的见地，才能比较有效的衡量。 特别优秀程序员这是一个可以影响这个行业的人，将在优秀期间的思考升华，创造出拥有足够影响力的东西。 这个阶段的人也特别容易区分，往往已经成为业界的大佬。当然，也是寥寥几人。 做人以下可能有些会让人觉得不愉快，如果你觉得我说错了，就当我在胡说吧。 标准上面说到一名优秀的程序员是比较难以被辨识出来的，而且每个人在不同的角度来看也是不同的。 之前看到有一条动态，有人在嘲笑阿里p8的员工去面试，连基础的几个概念都搞不明白，在嘲笑阿里的技术水平。我们再从第三者的角度来看看这个问题。先不论这位阿里员工技术水平，招人方肯定是以技术能力来衡量的，面试官问一些细节、生僻的问题，来体现自己的厉害，但是这有意义吗？他们需要的是一个可以干活的合格程序员，又不是一个管理者或者架构师。 然而这个现象在招聘中依然非常普遍，因为其他方面的能力真的太难只经过一场面试就看出来了，所以只能通过技术来考察。而越是厉害的人可能更有所专精，通用的技术考察往往又不能达到他们的深度，可能他们的面试结果还不如某些刷了很多面试题的人呢。 所以现在就有很多人抱团取暖，相互贴金。 做人程序员这个群体都太过于自信和高傲了。这种自信对于写代码来说是必要的，可是在做人方面是完全失败的。 用通俗一点的话来说，你不干了，公司可以找一百个，一千个人来替代你，你又不是行业的大佬，这些人完全可以比你做的更好。不像其他的职位，做的久了，会建立很多关系，会有很多的回头客。这种现实又导致这个行业的极度缺乏安全感和安定。 就像现在的网络直播一样，有多少技术高超，甚至是世界冠军的人，在开播的时候还有些人来捧场，可是时间一长，身上的光环退去，也只能被淹没在众多的播主中间。 所以在学会做一件事之前，更多的去学会如何做一个人吧。 淘汰同时，程序员之间的竞争是非常残酷的。技术的更新迭代实在太快了，几乎每年都会有新的技术出现，所以程序员需要不停的去学习。只要你停下来了，就会有很多努力的人会超越你。 这样的现象更加严重的加剧了上述的一些现象，也更加压缩了程序员的时间。 有很多故事，都是碰到领导空降，赶跑了一大群老员工。不敢说是不是老员工真的能力不行，或者是反抗新领导。很大程度上是新领导为了自己的业绩，从而牺牲一些无关痛痒的老员工吧，谁让你是这么容易就可以被替代呢？不论老员工如何的哭诉，在老板那里肯定也是尽是老员工的不是吧。 那么，等年纪大了，不能达到公司产出的要求了，各方面能力都不及从前了，是不是就很容易被公司所抛弃了呢。 最后现在的互联网行业还是非常年轻的，但也是竞争非常严峻的，很多事情也不像代码这般清晰。所以程序员，收起你的自负，去学习如何做一个人吧。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://djs66256.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"完备路由系统","date":"2017-07-30T12:58:58.000Z","path":"2017/07/30/2017-07-30-完备路由系统/","text":"现在很多应用都在内部跳转中使用了路由系统，这种从web搬过来的东西。但是功能却并不完善，就像比较有名的JLRouter和MGJRouter。这里就来聊聊更加完善的系统的几个部分。 前言现在很多的应用都在一个非常大的量级了，已经不可能由几个人的小团队来开发了，那么模块化就非常必要了。相比很多人说的组件化（Component），我觉得模块化（Module）更为贴切一点。 说到模块化，那么模块间的通信就非常重要了，如果仅仅是通过api来做通信，就不够灵活，而且可能会增加了集成成本。一旦涉及到接口变更就需要修改多个模块。这样路由系统便是页面间跳转的一个非常重要模块，可以说他承载了整个最核心的部分。一个好的，完善的路由系统可以让一个系统更加稳定和开发简单。而一个功能欠缺的路由系统则有可能将整个应用带入一个泥潭。 目前比较有名的几个实现，都非常简单，而且非常好用。但这是对一个整体的应用来说的，如果是一个多团队开发的应用，就有部分缺陷了。所以为了应对这种缺陷，蘑菇街和京东都开发了一个管理平台，来专门管理这些路由系统，解决这种缺陷。 这些路由实现在目前已经基本满足需求了，但是在未来可能会进行的模块拆分，则需要功能更加强大的路由系统。所以我提出一种更加完备的路由系统。可能这里有过度设计的成分，但是作为未来的扩展性，我觉得还是有必要的。 完备路由既然我们是从web那里抄过来的想法，那么为什么不抄的完整一些呢？ 回溯 history目前的几个路由系统都没有提供这个功能，而这个功能我觉的是非常非常重要的一个功能。当我们需要判断上个页面是什么页面的时候，只能通过判断controller队列中的类型！这完全违背了黑箱这种原则。 同时我们可能需要回退多个页面或者回退到某个页面的时候，没有历史记录的支持，在合作开发的时候绝对是个灾难。 history给我们的功能好处也是非常多的。除了上述几个场景中特别需要以外，对我们的debug以及分析也是非常有帮助的。甚至我们可以记录和导出history来查看用户的操作流程，虽然不能代表所有的动作，但也可以展示用户的一系列行为，或者在crash分析中自动带上该信息。 自定义进入退出我们的每个页面都不是固定的push的，也可能是present的，所以相应的返回也是不一样的，然而目前几个路由系统都只有进入的方式，并没有退出的方式。那么只能交给人来处理这种事情，当某个模块成为黑箱的时候，外部又怎么去判断呢？ 所以进入(push)和回退(pop)操作都需要有对应的行为，这就承接了上一个history的必要性了。这样我们同样是进入(push)和回退(pop)，当行为是present时，就对应为present和dismiss。 甚至在内嵌的网页中也可以接入native的路由系统，那么这样的push和pop就对应了网页的跳转和返回了。同时这样也屏蔽了模块内部的具体行为，模块修改展示方式也不会影响外部的处理逻辑。更好的形成一个黑盒模块。 子路由这个在web中是不存在的，但是在native的app中我觉得有必要。每个模块，或者内嵌的网页都应该是个子路由系统。 为什么需要子路由系统呢？这里举一个例子： 12345Root --[push]-&gt; VC | [present] \\ --&gt; VC2 --[push]-&gt; VC3 --&gt;... 当我们需要去完成一个系列的完整动作的时候，往往会present出一个新的navigation来处理这一系列动作，而这些行为在任意一个节点都可能会返回，同时又可能在任意的一个地方present出来。那么如果要满足这种情景又需要人为的去处理很多逻辑，这就埋下了隐患。 如果我们把present出来的这一系列行为定义为子路由，那么如果需要返回时，只需要退出子路由中所有的history就可以了。 黑盒路由如果项目变大以后，可能就会存在上百个路由，那么这些路由中实际有效的（其他模块可用，或者公开的）路由又有多少呢？我觉得应该会很少吧，因为外部进入一个其他模块的入口基本是固定的，所以我们为什么需要暴露这么多不必要的路由给外部呢。蘑菇街和京东为了管理这些路由干脆搞了一个管理系统，来防止路由冲突。那么为什么我们不让一个模块内的路由成为一个黑箱呢，只暴露外部需要的路由，而其他路由都经过保护不能随意访问。这样也防止外部访问不该访问的功能。 这个功能是承接子路由的实现，我们保持每个子路由内部的黑盒，可以减少我们的错误。 保持子路由的黑盒性的一个简单做法就是base url。依照restful来设计路由，不同子路由系统给与一个base url，比如登录模块的路由可以增加base url /auth。那么内部和外部的行为可以概括为： 12345678910// 外部push(&quot;/auth&quot;)push(&quot;/auth/password&quot;)// 内部push(&quot;~&quot;)push(&quot;~/phone&quot;)push(&quot;~/verify&quot;)push(&quot;~/password&quot;)// 退出整个模块pop(&quot;~&quot;) 重定向有些页面在某些条件下是不能进入的，这时候需要重定向去特定模块来完成这个条件，完成后再次进入该模块。所以我们需要重定向的功能，否则就会增加很多依赖项，导致不能真正的模块分离。 比如某个功能需要登录模块，在我们没有集成登录模块的时候就难以完成功能，而集成了登录模块又会导致模块化仅仅只是个表面上的分离了，可能在真正开发的时候还是把一大堆其他模块给搞进工程，那么这样的模块化有什么意义？如果拥有重定向就可以伪造一个重定向，让他自动放回需要的结果就可以了。这样就可以排除其他模块的干扰了和依赖了。 路径依赖这个其实时承接上个需求的，可以相当于一个语法糖。 按照上个场景，我们如何去注册一个需要重定向的路由呢。那么我们可以引入一个路由依赖的功能，可以标记每个路由的依赖选项。比如登录的@requireLogin。 这算是一个扩展的功能吧。 中间件目前主流的几个路由还有一个非常欠缺的功能就是中间件。我们无法去从路由系统内部知道我们经过了哪些操作，是否需要过滤某些操作。 这个话题其实也关系着黑盒路由和重定向的问题。依照服务端的中间件设计方式，我们应该需要为路由系统留出控制以及debug的入口。 拥有了中间件我们可以做什么？ debug，打印所有的入口和出口，完善我们的日志 分模块开发的时候，可以mock其他有依赖的模块 监视，是否调用了非法的接口或者使用了非法的参数 个人觉得中间件是一个系统所必须的功能，可以提供外部实现更多的功能和更灵活的控制。 热插件这是一个额外的话题。由于我们的路由注册基本上是在+load方法里面做的，所以当我们的路由越来越多的时候，启动性能也会越来越差，那么提供热插拔的功能是最好的。同时热插拔功能也相对应的提高了路由的黑盒性。 做成热插件的形式还有一些好处。比如abtest的时候，可以加载不同的插件来进入不同的页面。又或者在某个页面出了线上问题，需要降级为web来实现，也可以通过替换插件来替换不同的页面。 这是一个锦上添花的功能，所以我把他列到了最后。 总结以上说的几个点可能给我们的编码增加一些复杂度，而且还需要去理解这些概念才能很好的运用。但这里的规划完全是以模块化为前提的，并且独立为一个系统，不去依赖UIKit。所以从长远来看这样的实现是绝对有好处的，如果有时间可以把这个想法实现出来。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Router","slug":"Router","permalink":"http://djs66256.github.io/tags/Router/"},{"name":"路由","slug":"路由","permalink":"http://djs66256.github.io/tags/%E8%B7%AF%E7%94%B1/"},{"name":"蘑菇街","slug":"蘑菇街","permalink":"http://djs66256.github.io/tags/%E8%98%91%E8%8F%87%E8%A1%97/"}]},{"title":"单向数据流之用户行为统计","date":"2017-07-28T14:32:34.000Z","path":"2017/07/28/2017-07-28-单向数据流之用户行为统计/","text":"这几年的开发中，最让人头疼的事情之一就是数据统计。这里就来看看以单向数据流的角度如何改进统计系统的设计。 面向切面埋点我非常的反对使用面向切面埋点来处理用户行为，理由有三个： 统计数据极度依赖视图结构，或者需要将每个数据绑定到视图上。 不能完成复杂的交互统计，仅能实现简单的事件数据。 视觉上的修改会影响统计结果。 以前在使用切面埋点的时候，就遇到很多的问题，虽然说每个数据点都不可能漏埋或者错埋，但是每次上线后数据分析都需要跑过来让开发给他们看看这些行为的埋点数据是怎么样的。这样也很难实现一个多期的版本对比。 用户行为统计那么按照标准的用户行为统计又有哪些问题呢？ 每个数据深入业务底层。需要统计要么把事件层层代理到Controller，要么在底层这些看似不合理的地方埋点。 复用问题。业务虽然一样，但是埋点信息并不能完全保持一致，而且有些场景下也无法保持一致，因为可能会有重复场景。 埋点数据回归测试。由于是人工埋点，所以可能会漏埋错埋的情况发生。 目前目前我们的埋点方案主要有3点： 数据尽量保持统一。相同的业务埋相同的点，然后根据页面区分。这样就能够实现重用，缺点是有少部分需要特殊化的场景。 代理到业务层，然后再埋。缺点是如果中间层次过多，会出现多级代理，而仅仅是为了埋点。 子类化。专门子类化该页面的专有子类。缺点是子类的目的就是为了区分埋点，有点多余。 以上都没有一个很好的方案能够解决数据回归测试的问题。而回归测试也只能靠人工执行。 单向数据流方案统计即是数据，那么当然也非常符合数据流模型，那么我们就用数据流模型来简化埋点方案，增加每个模块的独立性和复用性，同时也把埋点放到一个地方去做，减少埋点数据在整个应用内的散乱分布。 以上就是这套方案的大概结构。用户触发行为时，和之前直接统计行为不同，而是创建一个Action对象，将统计所需要的参数，或者自身包含数据包装在Action内，发送给Store。Store作为一个数据中心，负责接收和分发数据，他将收到的数据分发给订阅者Subscriber，最后由Subscriber完成统计数据，并上报服务器。 Store、Action是完全可复用的，同时这两者并不关联实际业务，所以完全可以模块化，同时只要行为足够完整，也不需要关系具体业务方统计数据的样式。这样就可以让其他模块完全的复用了。 那么如何提升复用性，我们来关联下之前讨论过的MVP。 这里，红色框内的部分都是逻辑性的，是完全可复用的；View也是独立与逻辑的，也是可复用的；只有Subscriber和Controller是和业务强相关的，是不可复用的。那么我们就可以知道需要把哪些东西放到不可复用的地方，哪些东西放到可以复用的地方了。 同时我们也需要考虑下测试的问题，来解决埋点数据的完整性和正确性。 只要我们mock了Store部分，就可以轻易的检查发生的Action，或者向订阅者发送对应的Action，这样就可以比较简单的去回归测试数据了。只不过这样做的收益可能并不高。 实现这里我们来看看实现的方式。 首先定义基础的Store和Action 1234567891011121314class StatAction &#123; var type: String? var params: [String: Any]?&#125;protocol StatSubscriber &#123; func newStatAction(action: StatAction)&#125;class StatStore &#123; func dispatch(_ action: StatAction) &#123;&#125; func subscribe(_ subscriber: StatSubscriber) &#123;&#125; func subscribe(_ subscriber: (StatAction)-&gt;Void) &#123;&#125;&#125; 那么在ViewController里就可以这样配置。 1234567891011func viewDidLoad() &#123; super.viewDidLoad() self.store = StatStore() self.store?.subscribe(&#123; action in // ... switch case action.type. // Track &#125;); self.submodule.store = self.store&#125; 而子模块中只需要使用store来分发行为就可以了。 12let action = StatStore(type: &quot;star&quot;, params: [&quot;id&quot;: &quot;1234&quot;])self.store?.dispatch(action) 这里订阅者甚至可以自己创建独立的类来处理这些情况，这样就更加的分离了行为统计这种不能划分为任何模块的内容了。 最后这个方案将行为统计从整个app中剥离出一个单独的模块，同时实现了高度可复用性，而且使得统计也成为可以单元测试的了。唯一的缺点是在具体统计的时候需要大量switch…case…来区分不同的行为。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"统计","slug":"统计","permalink":"http://djs66256.github.io/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"用户行为","slug":"用户行为","permalink":"http://djs66256.github.io/tags/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA/"}]},{"title":"单向数据流的应用与特性","date":"2017-07-25T16:47:00.000Z","path":"2017/07/26/2017-07-26-单向数据流的应用与特性/","text":"上次介绍了单向数据流的结构，这次来简单讨论下单向数据流的应用场景。 特性单向数据流从设计模式上看，应用了大量的命令模式，而命令模式的特定是行为通过命令来驱动，也就是说我们可以缓存命令，或者mock命令，来驱动整个流程和模块。 这就诞生了一个非常有意思的插件，录像功能。这里的录像并不是指的是用户的行为，而且录制整个app的行为。由于所有命令都会经过store，那么可以在中间件中设置一个序列化功能，将所有动作都记录下来，这样我们就可以回溯用户的操作了，比如在crash的时候。有些crash分析会去录制屏幕，来看用户当前操作，但是这样只能查看用户的操作，并不能恢复现场，往往我们去复现的时候，就没有问题了，因为数据以及不一样了。但是通过录制Action的方式录制的行为，数据也会一并被录制，这样就能完全的恢复现场了。 同时利用上述特性，我们还能跟踪用户行为。这里的跟踪就不仅仅是简单的用户事件统计了，而是把用户一连串的行为都记录下来，形成一个完整的流程。虽然这样做目前来说，还没有太大的意义，但是引入机器学习之后，对于用户推荐和喜好可能会有比较大的意义。 可以灵活的替换中间件，来处理一些额外的逻辑。比如上述的记录功能。 回溯功能在React中，有个工具React-Dev-Tools，他就是按照这种思路来做的。当你发生错误时，你可能回退几步操作，等功能修复好了，直接热部署，就可以进行接下去的操作。这都是依赖了记录Redux内部Action行为。iOS由于自己的原因实现热部署可能会有点困难，但是依然可以利用这种特性来做一些记录。 应用那么现实情况，我们可以在什么场景下按照这种思路进行开发呢？ 首先，这种方式是一种及其繁琐的形式，而且也不是一种非常主流的模式，在应用之前必须考虑到这点，并且考虑到团队内对于这种方式的接受程度，理解程度，不然可能会变得更糟。 其次，应用范围。我们有必要整体的使用吗？在目前的大部分开发中，都是敏捷开发和数据展示，使用这种方式反而显得累赘了。所以我认为，在某些场合下可以考虑使用这种模式： 模块间相互影响，且交互复杂 较高层面，处于整个app层面的，比如router系统","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"ReSwift","slug":"ReSwift","permalink":"http://djs66256.github.io/tags/ReSwift/"},{"name":"Redux","slug":"Redux","permalink":"http://djs66256.github.io/tags/Redux/"}]},{"title":"美学架构演化之路","date":"2017-07-22T18:33:55.000Z","path":"2017/07/23/2017-07-23-美学架构演化之路/","text":"项目发展到现在已经有一年的时间了，在这一年里，我们的crash free一直都保持的很好(99.5%+)。随着功能的不断增加，已经老代码的缺乏维护，逐渐陷入一个难以维护的地步，所以需要进一步去改善目前的架构，所以这里谈谈以前的架构和未来将要改善的一些方式。 开始最开始的阶段是完全的MVC，这种结构下最明显的问题就是massive controller。当然我们也遇到了这个问题。 此时我们要解决的问题主要有两点： 庞大的数据量，超长的页面，以及数据列表间的不同组合 不同页面相同数据列表的复用 好在在开始的时候我们就根据我们项目的一些特殊性进行了思考，以及尝试的几种组件化方案。所以在1.1的时候已经明确并且解决了这个问题。 C-MVCs在美学的表现层组件化之路文章中描述了我们使用DDComponent拆分组件化的方式。 这一次解决了单个页面的多功能模块拆分问题，增加了复用性，也奠定了未来半年的稳定开发基础。 组件统一化随着时间的推移，组件越来越多，导致同一种资源（比如User）拥有多种不同的component，每个人不同地方都使用了不同的代码，导致维护越来越困难。 所以需要将同一种类型的组件进行统一化和规范化。将目前所使用的组件分为特例组件和通用组件，并尽量在这两个范围内取用。同时每个组件都是经过几轮黑盒测试的，所以基本上不太可能出现bug。 但是这样依然会有问题，在目前应用调整的期间，很多组件都需要重写，重写的质量就很依赖个人了，那么我们统一后的组件依然难以保持很高的质量和通用性。 单元测试虽然经过上述几次的改善，目前已经没有太大问题。但其中的隐患一直没有被消除，而且在功能的大量增加和人员的变动，这种隐患就更加明显了。所以想要在我们的逻辑层加上单元测试。 关于实现方式之前的文章已经讨论过了，思路就是拆分Controller层，基本上是采用MVP，是否需要辅助Re方案还要继续观察。 那么最后我们的结构理想中应该是这样 这样我们将一整个ViewController拆分为多个子组件，子组件保持可测性。 这是目前我们需要去改进的。 模块化相信，经过上述的改善之后，我们的应用应该会趋于一个比较稳定的时期。那时的功能也会比现在多很多，那么就需要模块化管理，这是后话了，在一段时间内应该还到达不了如此量级。","categories":[],"tags":[]},{"title":"Aspect实现与应用","date":"2017-07-21T18:33:08.000Z","path":"2017/07/22/2017-07-22-Aspect实现与应用/","text":"在swift里面有个非常有意思的特性，那就是AOP，可以为协议增加默认实现。那么在Objc里面也有个类似的工具类Aspect，虽然还是有很多缺陷。这次我们来看看Aspect的实现方式。 第一想法Aspect就是通过method swizzling来实现方法的替换的，然而实际上并不是这样的。让我们来考虑几种场景： 对已有的类进行hook方法。 对一个实例对象hook方法。 如果是单纯的method swizzling，以上两者是一模一样的结果的。那么Aspect是如何实现的呢？ 对象Aspect的类型主要分两种： 对类层面进行的hook。包括类和元类(meta class)，也就是-方法和+方法。在Objc中类和元类的实现是一致的，所以采用的方式也是一致的。 对实例层面进行的hook。这里的实现比较像KVO的实现方式，也就是会利用runtime自动生成一个子类，子类来实现消息的转发，这样就不会影响到其他实例了。 方法Aspect并不直接method swizzling具体的方法，而是利用了forward message的特性。 12345/* Message Forwarding Primitives * Use these functions to forward a message as if the receiver did not * respond to it. */ void _objc_msgForward(void /* id receiver, SEL sel, ... */ ) Aspect将所有消息都转发到这个方法，然后统一从forwardInvocation:中处理。这样就可以统一管理，并且统一处理多种不同类型的消息了。 强校验Aspect还对hook方法进行了强校验，避免不同参数的方法调用导致的crash。 应用最大的应用场景就是单元测试了，和其他测试库一起配合使用还是非常方便的。当然也可以用于应用内的method swizzling，如果你的需求够大的话。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Aspect","slug":"Aspect","permalink":"http://djs66256.github.io/tags/Aspect/"},{"name":"AOP","slug":"AOP","permalink":"http://djs66256.github.io/tags/AOP/"}]},{"title":"从数据流动角度解决测试难题","date":"2017-07-21T15:36:20.000Z","path":"2017/07/21/2017-07-21-从数据流动角度解决测试难题/","text":"上篇讲述了增强逻辑功能测试而改进MVC为MVP，但是这样做可能还不够彻底，现在来讨论另一个纯粹从测试角度设计的框架。 首先我们来明确一下，测试中最核心的东西是什么。当然是数据，我们永远是围绕着数据来的，那么之前一些架构的问题是什么。无论哪个框架，数据的流通都是双向的，当数据流通成为单向了会怎么样呢？ 1in data ==&gt; Module ==&gt; out data 这样我们伪造数据进行测试就会非常方便了。按照这个思想就有了数据单向流通的架构。 数据单向流通的实现这个概念最早是在web中提出的，应用在React里，官方的方案是Redux。现在swift也提出了一种实现ReSwift。 我在之前写React的时候使用过这种方案，从开发角度来说，这种方案会大大增加开发难度，代码量也会大量增加，而且开发思路也需要从以前的思考方式转换过来。但是如果我们把这个思路转换过来，其实对整个流程是更加简化和分离的。 从测试角度看，我觉得无疑是我知道的最可测的一种框架，甚至可以测试部分视图的逻辑。 那么总的来说，很难说这种结构的好坏，就算不考虑增加的开发时间，也是一种难以给以一种评价的方案。 (Redux/ReSwift)框架介绍方案的几个核心是： 数据的单向流通 每个视图都可以看做一个状态机 pure function 关于pure function，我就不做太多介绍了，简单的说，就是同一输入必定会有相同的输出，是非常容易测试的一种函数。 首先，我们来看一下官方的架构图。 可以看到，数据流动方向都是朝一个方向进行的。那么下面从每个模块来介绍下，还是以star button为例子。 State视图状态机，也是所有会更新界面数据保存的地方，可以认为相当于ViewModel。 首先我们star会有以下几种视觉样式 123456enum StarButtonState &#123; case star case staring case unstar case unstaring&#125; 所以State可以定义为 1234struct StarState: StateType &#123; var state: StarButtonState var starCount&#125; Action首先我们定义几种状态机转换的Action类型 1234struct StarAction: Action &#123; &#125;struct StaringAction: Action &#123; &#125;struct UnstarAction: Action &#123; &#125;struct UnstaringAction: Action &#123; &#125; 以及相应的功能以及状态变更，这里异步请求采用延迟来代表。 12345678910111213141516func star(id: String) -&gt; Store&lt;StarState&gt;.ActionCreator &#123; return &#123; state, store in DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; store.dispatch(StarAction()) &#125; return StaringAction() &#125;&#125;func unstar(id: String) -&gt; Store&lt;StarState&gt;.ActionCreator &#123; return &#123; state, store in DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; store.dispatch(UnstarAction()) &#125; return UnstaringAction() &#125;&#125; View视图层其实很简单，只需要根据State的不同来更新就可以了。注意的是，更新都是无状态的，和上一个状态无关，所以view层是个无状态层。 1234567891011121314class StarButton: UIButton, StoreSubscriber &#123; let store = Store&lt;StarState&gt;(reducer: starReducer, state: nil) override init(frame: CGRect) &#123; super.init(frame: frame) self.store.subscribe(self) &#125; func newState(state: StarState) &#123; // update UI &#125;&#125; Reducer状态转换器，唯一可以更新State的地方。 123456789101112131415161718192021222324func starReducer(action: Action, state: StarState?) -&gt; StarState &#123; var state = state ?? StarState(state: .star, starCount: 0) switch action &#123; case _ as StarAction: state.state = .star state.starCount += 1 case _ as StaringAction: state.state = .staring case _ as UnstarAction: state.state = .unstar state.starCount -= 1 case _ as UnstaringAction: state.state = .unstaring default: break &#125; return state&#125; 数据传递那么最重要的就是数据如何传递的了。首先要明确的是每个模块能够修改的，或者说是传递的，只能是下个模块。 比如，用户star button触发了一个事件： 12345678func onButton(sender: StarButton) &#123; if (store.state.state == .unstar) &#123; store.dispatch(star(id: id)) &#125; else if (store.state.state == .star) &#123; store.dispatch(unstar(id: id)) &#125;&#125; 此时会创建Action，也就是将view事件转换为Action。然后会传递到store中，store会调用Reducer进行处理。Reducer更新state之后又会触发store的subscribe事件，回到view的func newState(state: StarState)。 1234View (User Event)==(create)==&gt; ActionCreator/Action==(dispatch)==&gt; Store &lt;--(Update State)--&gt; Reducer \\==(subscribe)==&gt; View (newState) 大概的一个流程就是这样了。 接下来说说这样做的模块化的优势。 模块化和测试性首先，我们需要有函数式编程的概念，函数也是一等公民，所以ActionCreator和Reducer都是独立的模块。 作为使用者，我们在不需要像MVC一样知道这些api所代表的操作功能，相对应的，我们需要去了解一个模块的动作（Action），比如以上例子就是 12func star(id: String)func unstar(id: String) 这样的划分比MVC要友好的多，真正的把逻辑功能从原本的C中分离开。需要触发这个行为也非常简单store.dispatch(star(id: id))。相比MVP，行为更加的独立，每个行为之间完全没有联系，也不会产生干扰影响。同时因为每个行为的独立性，可复用程度也就越高。 Reducer则代表了view层的更新，也可以非常明确的知道每个状态的变更发生了什么。相比其他模式，将界面更新完全交给view或者Controller，Reducer是最明确也是最清晰的。同时Reducer也是独立的，可以替换的。 对于UIkit层面我们无法单元测试，所以测试的主要部分是Action和Reducer。这两个模块可以说都是pure function或者在某些条件下是pure function的，所以测试也非常的简单。 对比和这个模式比较像的有状态机模式和Reactive。 状态机模式也是实现对应功能，以及对应状态，然后通过子类化的方式去实现Reducer的功能。 Reactive则比较像ActionCreator，只是Reactive返回的是信号量。 使用场景从上面可以看出这是一套非常优秀的模块划分方案，但同时也会大大增加代码量，而且需要改变以前的思维模式。而对于目前国内的现状来看，很难有这么多时间和精力让整个项目都使用这种模式。 但是这种模式的特点也非常的明显，在处理比较复杂的交互行为，并且存在较多的视图状态的时候，会是一种比较好的方案。比如视频播放界面。 所以个人认为，在一些简单的场景下并不需要使用该方案，但是在一些复杂的交互页面，而且又非常想要引入单元测试的场景，可以酌情考虑下这种方案。这种方案要求人们的思维方式的改变，需要有一定的函数式编程的概念。 虽然不一定会直接使用ReSwift，但是这种思想有很多值得借鉴的地方，利用这种思想做出类似的效果，以便达到可以容易进行白盒测试的目的。 最后以上虽然说不会全部使用该方案，但也可以部分使用。比如独立的小模块，亦或是app层面的一些东西。下次可以讨论下app层面如何来利用单向数据流来简化流程。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ReSwift","slug":"ReSwift","permalink":"http://djs66256.github.io/tags/ReSwift/"},{"name":"Redux","slug":"Redux","permalink":"http://djs66256.github.io/tags/Redux/"},{"name":"测试","slug":"测试","permalink":"http://djs66256.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"换个角度来看MVC与MVP","date":"2017-07-14T13:04:28.000Z","path":"2017/07/14/2017-07-14-换个角度来看MVC与MVP/","text":"之前了解架构的时候，虽然能够看得懂MVC和MVP这些概念，但是却没有实感，总感觉很多地方其实并没有那么的明确。最近想起之前的讨论TTD的文章，忽然想到，为什么不从另一个角度来看待这两种模式呢，所以忽然醒悟，现在来讲讲这两种模式解决的问题。 无法解决的单元测试最近在开发过程中，虽然大部分场景都比较简单，逻辑也非常清晰，但是也有部分场景的逻辑比较多，一些隐藏逻辑还难以通过造数据来进行测试，自然QA也基本覆盖不到这种测试场景，那么自然想到了单元测试，但是以目前我们项目的架构来说，单元测试基本不可能，业务逻辑、事件界面等揉合在一起，无从下手。 我们目前的架构来看，并不差，无论从实用性，易用性和复用性上来说。但是网上众多大神都极力推崇MVP和MVVM，我一直都没有太明白别人所说的优点真的如此神奇吗？直到最近想要对部分业务复杂的页面做单元测试，然后从TDD的角度再去看这些问题，才豁然开朗，下面就来简单介绍下。 架构之间的模糊性我们来探讨一下，现在官方推荐的MVC架构在实战中的情况，真的能够分的如此清楚吗？ 也有很多人把这种架构表示为这样： 123--------------------- ---------| view | controller | ----&gt; | model |--------------------- --------- 在现实中，view和controller往往是紧密而不可分的，事实上view也很难在不同的应用间（iPhone，iPad）复用。 很多时候为了模块的内聚性，需要映射view &lt;- model，这就是有人提出的增加一个helper类，来负责这样的映射，但我不是非常认同，我更倾向于创建一个中间viewModel来做，事实上很多时候我们把model就直接作为viewModel。 12345678910// Helper 方式Helper.apply(view:view, withModel:model)// ViewModel 方式class ViewModel &#123; init(model: Any)&#125;class View: UIView &#123; var viewModel: ViewModel &#123; set &#125;&#125; 那么按照这么做，MVC的界限就真的清楚了吗？其实并没有，所以让我们忘了MVC的分层吧，这仅仅是一种思路，抽象后的概念，真正在实践中去探索才是最好的。 之前看过百度的一位大神，他曾经嘲笑那些把请求放到view层的设计，但后来想不到自己也这么做了。那么这里我举个例子，我们就拿最常用的star功能来说吧。功能很小很简单，一个按钮一个请求就可以搞定，那么如果我们要严格按照MVC的方式来写，那么就至少需要在每一个V和C中都写逻辑，而这部分逻辑虽然都是一样的，但却很难以复用，那么就很容易出现’copy-paste’的情况，那么为了增加这种功能模块的内聚性该如何做呢？最简单的做法那就是直接在view里写逻辑！！！如下： 12345678910class StarButton: UIButton &#123; var id: String init(id: String) &#123; self.id = id self.addTarget(self, action: #selector(onStar(sender:)), for: .touchUpInside) &#125; func onStar(sender:UIButton) &#123; // request ... &#125;&#125; 使用时不需要关心具体逻辑，只要传入id就可以了。是不是比MVC写法更加的聚合？如果你说要在多平台复用，那么可以稍微改下，将逻辑部分改为策略模式，将创建改为工厂方法，这是题外话了。 所以接下来要忘掉所有所掌握的架构的知识，来看待这些问题，就如同张无忌学习太极剑法一样。 从结构上看的MVC我们先举一个非常简单的例子，登录页面。 1234567-----------------------| || name: [_______] || password: [_______] || [Login] || |----------------------- 基本功能是校验用户名密码，和登录。 那么我们想当然的就可以明白，所需要的两个方面： 1234class User &#123; var name: String? var password: String?&#125; 12345class View: UIView &#123; var nameTextField var passwordTextField var loginButton&#125; 那么这两者之间之间的交互逻辑呢，全部丢到一个第三方类中处理，这也就是我们的MVC结构中的Controller。 所以可以了解到，MVC是最符合我们了解一项功能的思维方式，所看到的东西抽象成view，所需要保存的数据结构抽象成model，那么剩下的所有东西都被丢到了controller中。这种方式非常容易理解，一个刚入门的新手也能很容易开始编码。但这也是噩梦的一个开始。 我相信大家所经历过的项目中，肯定一些controller超过1k行，甚至更多的，谁都不想去碰一下这类代码。这就是把其他东西全部丢进一个垃圾桶的缘故。最可悲的是这个垃圾桶很少会有人去清理，导致垃圾越来越多。 解决MVC中C的问题大家所说的Massive Controller的问题其实也很好解决，也有很多人来论述这种问题。 基本思路是细化MVC，将结构变成C-[MVCs]。比如上面可以拆分为 1234567891011121314151617class NameController &#123; var textField func validate() -&gt; (Bool, Error)&#125;class PasswordController &#123; var textField func validate() -&gt; (Bool, Error)&#125;class LoginController &#123; var button func login()&#125;class LoginViewController: UIViewController &#123; let nameController: NameController let passwordController: PasswordController let loginController: LoginController&#125; 注意Controller仅仅是一个概念上的划分，并不等于UIViewController。 如果是列表型可以参考DDComponent或者IGListKit的做法。 按照这种思路，我相信完全解决这类的问题。但是这样需要有经验的人士，或者在重构的时候进行拆分。 总的来说，MVC是一个非常简单，非常容易理解的架构。苹果选择MVC作为官方推荐架构应该也是有他的道理，毕竟要兼顾所有程序员，并且还要让大家能够容易的交流。但是要做好MVC也需要有一定的经验和思考。 从TDD来看MVP好，让我们忘了上面所说的东西，同样做一个登录的功能，但是这次我们从TDD的思路来进行。 首先，界面层是比较容易变化的，而且也是难以被单元测试的，亦或者说白盒测试view是没有什么意义的。其次数据层，单纯的测试model也没有特别大的意义，除非涉及到存储等这些功能。那么我们需要测试哪些东西呢，可以测试哪些东西呢，当然是我们的业务逻辑。 那么我们来理一下登录页面的业务逻辑 123func validateName(name: String) -&gt; (Bool, Error)func validatePassword(password: String) -&gt; (Bool, Error)func login(name: String, password: String) 然后可能有些内容需要更新回视图 1func applyView(view: UIView) 那么以上的内容我们称为Presenter 1234567891011121314protocol LoginView &#123; var name: String? var password: String?&#125;class Presenter &#123; var user: User var view: LoginView func validateName() -&gt; (Bool, Error) func validatePassword() -&gt; (Bool, Error) func login() func applyView()&#125; 这样就顺理成章的拥有了MVP的模式，那么UIViewController属于哪一层呢。按照我们测试的思路，UIViewController代表的是视图的行为，是不可测试的，当然就是属于View层的了。 从上面可以看出来，所谓的P特别像View-Model，其实两者可以说就是同一个概念。 MVP中P的问题首先，我看了很多人的文章，他们理解并不一致，都有部分的偏差，哪些属于P，P的概念也可大可小。虽然这种偏差并不影响这个架构的实现，但是让人感觉一种为了实现这种架构而实现的味道。而单纯的实现MVP并没有任何意义。 然后，MVP对人员的要求太高了。必须大家都是以测试优先来思考问题，而TDD本身就是一件非常困难的事情，对于整个团队的要求也非常高。 还有，MVP增加的代码量太大了，因为很多事件和逻辑都经过了一层转发，各个模块间的交互也增加了。 同样MVP也会遇到Massive Presenter的问题，解决方式与MVC也是类似的。 MVC与MVP那么Controller与Presenter的差别是什么呢？可以说如果代码写的好，两者几乎是一样的，仅仅是我们看问题的角度变化。当我们看问题的角度不一样时，所写的代码与逻辑就会产生差异，这种差异可能并没有我们想象的那么大，但在白盒测试这个环节上却是致命性的。 是否需要使用MVP结构，个人觉得很多情况下并不需要MVP，在结构良好的MVC中，完全可以解决大部分问题。在MVC中出现的一些问题，并不是单纯使用MVP就能解决的。 那么MVC和MVP能否结合使用？这个就像解决Massive Controller的方案一样，C-[MVPs]应该是较好的一种结合使用方式。 使用MVP改写StarButton的例子1234567891011121314151617181920212223242526272829303132333435363738394041protocol StarView: NSObjectProtocol &#123; var stared: Bool &#123; get set &#125;&#125;class StarPresenter &#123; var id: String weak var view: StarView? init(id: String, view: StarView) &#123; self.id = id self.view = view &#125; @objc func star() &#123; Request.request &#123; if let view = view &#123; view.stared = view.stared &#125; &#125; &#125;&#125;class StarButton: UIButton, StarView &#123; var id: String private var presenter: StarPresenter! var stared: Bool &#123; get &#123; return self.isSelected &#125; set &#123; self.isSelected = newValue &#125; &#125; init(id: String) &#123; self.id = id super.init(frame: .zero) presenter = StarPresenter(id: id, view: self) self.addTarget(presenter, action: #selector(StarPresenter.star), for: .touchUpInside) &#125;&#125; 可以感受下，这种方案和策略模式其实是非常类似的。不同点是MVP把界面更新这一步逻辑也移到了P中，对于白盒测试的可测性也更高。 最后从TDD的角度来看MVP，的确和MVC有着很大的不同，但是这些不同并不是单纯的代码上，而是思考的方式上，如果用这种思想去写MVC，我相信最后的结果和MVP也会趋于一致，所以请忘了我上面的胡诌。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"MVC","slug":"MVC","permalink":"http://djs66256.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://djs66256.github.io/tags/MVP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://djs66256.github.io/tags/MVVM/"}]},{"title":"KVOController简析","date":"2017-07-13T13:03:47.000Z","path":"2017/07/13/2017-07-13-KVOController简析/","text":"关于KVO的使用，最常用的一个类库就是FB的KVOController了，还有一个HTBKVObservation，是解决了FB的循环引用的问题，但是后来FB的循环引用问题解决了。现在我们来简单看看这两者的实现方式。 实现其实两者的思想都是一样的，都是增加一个第三者，将消息处理和清理工作交给第三者进行。其中FB是利用了associate object是随着本身对象的释放而释放的特性来清理KVO的，而HTB则是利用hook dealloc方法进行清理的。 HTB的实现比较简单，所有东西都被放在了HTBKVObservation中，而FB则分为3个部分FBKVOController，_FBKVOSharedController，_FBKVOInfo。为什么FB会分为这么多部分，我认为是为了分离职责，但是个人觉得没有必要进行集中管理，除非想要撤销所有KVO的功能，但是我觉得不可能会有这个功能吧。 清理FB存在一个问题，那就是被观察对象被释放了，观察者可能并没有被移除，因为外部可能会持有KVOController，但是这样好像并没有什么大问题，因为被观察者释放了也就不会有KVO的消息了。 HTB则是在被观察者dealloc的时候强制移除所有KVO。 ReactiveReactive中也有类似的实现，思想其实还是一致的，只是把释放交给了dispose这个单独概念。 总结在这几个方案中，可以想到很多类型的问题都可以利用这种第三者的思路来解决，其实还有很多开源库也是利用该方案解决的。 另外在扩展的时候也不要一股脑的往NSObject上堆方法，利用第三者来处理这些方法可能会更加的优雅。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"KVO","slug":"KVO","permalink":"http://djs66256.github.io/tags/KVO/"},{"name":"KVOController","slug":"KVOController","permalink":"http://djs66256.github.io/tags/KVOController/"}]},{"title":"从应用角度看ReativeX","date":"2017-07-09T16:50:29.000Z","path":"2017/07/10/2017-07-10-从应用角度看ReativeX/","text":"这篇从我个人的角度聊聊ReactiveX这种思想的应用场景。 首先不论MVVM的使用场景，我也没有特别丰富的MVVM的使用经验。那么什么场景更加适合呢？ 请求如果只是单独的请求，那么也没有Reactive什么事情，但是当多个请求的时候，那么问题就来了。 多个请求就涉及到多次返回，那么如何组织这多次返回呢？可能有些场景要求按照发请求的顺序返回，有些场景可能仅需要任一个请求返回，又或者有些需要所有都返回的时候才触发回调，甚至可能有些请求存在依赖。 如何比较好的处理这些需求，那么Reactive本身就给我们一个很好的解决方案，可以说就是为了处理这种场景而生的。 流程很多时候，我们的一个流程会非常长，比如注册、首次登陆等等，而这些流程可能中间的某些步骤是可以复用的，然而很多不同的步骤所需要的参数可能也会稍有不同，那么如何表示这种流程比较好呢？ 把每一个步骤都做成Signal，那么这个问题就非常简单的解决了，不管流程的走向和分支是怎么样的，Reactive都能很好的解决，也不需要每一步都精心做好回调，然后把事件传递的到处都是。 总结这就不得不提一下monad这个概念了，只要符合pure function操作的所有行为，其实都可以定义为signal，并且利用各种组合来解决一定的时序问题。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"Reactive","slug":"Reactive","permalink":"http://djs66256.github.io/tags/Reactive/"}]},{"title":"从实现角度看ReativeX","date":"2017-07-09T09:42:34.000Z","path":"2017/07/09/2017-07-09-从实现角度看ReativeX/","text":"有很多在给人介绍Reactive的几个开源项目(ReactiveCocoa, RxSwift)的使用，我就不想在这个方面写什么了。我是一个实践主义者，所以我从我的角度来谈谈这种方案：解决了什么样的问题，怎么实现的，以及适合应用的场景。同时也加深自己对Reactive的理解。 这里我们来看看是怎么实现的，关于pure function和monad的部分我也不准备介绍了，毕竟我在这方面还不是特别熟悉。 signal observer首先我们来想一下一个最简单信号的流程。当一个信号被订阅时(subscribe)，发出信号后会触发订阅者(observer)执行下一步(sendNext)。那么一个最简单的信号(signal)和订阅者(observer)的协议就如下。 123456789protocol Observer &#123; func send(next: AnyObject) func send(error: NSError) func sendComplete()&#125;protocol Signal &#123; func subscribe(_ observer: \u0010Observer)&#125; 那么现在实现一个最简单的UIButton的信号。 12345678910111213141516171819202122232425262728293031class ButtonSignal: Signal &#123; var observer: Observer? init(button: UIButton) &#123; button .addTarget(self, action: #selector(onButton(sender:)), for: .touchUpInside) &#125; @objc func onButton(sender: UIButton) &#123; self.observer?.send(next: sender) &#125; func subscribe(_ observer: Observer) &#123; self.observer = observer &#125;&#125;class ButtonSignal: Signal &#123; var observer: Observer? init(button: UIButton) &#123; button .addTarget(self, action: #selector(onButton(sender:)), for: .touchUpInside) &#125; func onButton(sender: UIButton) &#123; self.observer?.send(next: sender) &#125; func subscribe(_ observer: Observer) &#123; self.observer = observer &#125;&#125; 然后实现一个最简单的订阅者。 1234567891011class ButtonObserver: Observer &#123; func send(next: AnyObject) &#123; print(&quot;send next!&quot;) &#125; func sendComplete() &#123; print(&quot;send complete&quot;) &#125; func send(error: NSError) &#123; print(&quot;send \\(error)&quot;) &#125;&#125; 最后连接起来 12signal = ButtonSignal(button: button)signal?.subscribe(ButtonObserver()) 那么问题来了，难道我们要为每个信号都创建一个类吗。当然不是，我们可以创建一个通用的信号和订阅者。 123456789101112131415161718192021222324252627282930313233343536373839class BlockSignal: Signal &#123; typealias CreateBlock = (Observer)-&gt;Void var block: CreateBlock init(block:@escaping CreateBlock) &#123; self.block = block &#125; func subscribe(_ observer: Observer) &#123; self.block(observer) &#125;&#125;class BlockObserver: Observer &#123; var next: (AnyObject)-&gt;Void var complete: ()-&gt;Void var error: (NSError)-&gt;Void init(next: @escaping (AnyObject)-&gt;Void, complete: @escaping ()-&gt;Void, error: @escaping (NSError)-&gt;Void) &#123; self.next = next self.complete = complete self.error = error &#125; @objc func send(next: AnyObject) &#123; self.next(next) &#125; func sendComplete() &#123; self.complete() &#125; func send(error: NSError) &#123; self.error(error) &#125;&#125; 同时在使用的过程时通过block来创建具体信号。 1234567891011121314signal = BlockSignal(block: &#123; (observer) in self.button.addTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside)&#125;)observer = BlockObserver(next: &#123; (sender) in print(&quot;send next!&quot;)&#125;, complete: &#123; print(&quot;send complete&quot;)&#125;) &#123; (error) in print(&quot;send error&quot;)&#125;signal?.subscribe(observer!) 以上就是最简单的信号量和订阅者实现。这里为了简洁的说明问题，所以没有考虑到内存方面的问题。 dispose上节说了内存方面的问题。还有一个问题就是如何取消订阅呢。那么这里需要有模块负责释放(dispose)。 那么将接口改为 1234567protocol Disposable &#123; func dispose()&#125;protocol Signal &#123; func subscribe(_ observer: Observer) -&gt; Disposable&#125; 实现也按照block形式 1234567891011121314151617class BlockDisposable: Disposable &#123; var block: ()-&gt;Void init(block: @escaping ()-&gt;Void) &#123; self.block = block &#125; func dispose() &#123; self.block() &#125;&#125;class BlockSignal: Signal &#123; func subscribe(_ observer: Observer) -&gt; Disposable &#123; return self.block(observer) &#125;&#125; 使用时和上面基本一致 12345678910signal = BlockSignal(block: &#123; (observer) in self.button.addTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside) return BlockDisposable(block: &#123; self.button.removeTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside) &#125;)&#125;) 需要解除订阅的时候 12self.disposable = signal?.subscribe(observer!)self.disposable?.dispose() 之后到目前为止，可以说signal-observer部分已经完全实现了。 其中冷信号和热信号也非常简单 1protocol Subject: Observer, Signal &#123;&#125; Scheduler也比较简单，将执行放到对应的队列中即可。 下篇结合我的角度来聊聊应用场景。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"ReativeX","slug":"ReativeX","permalink":"http://djs66256.github.io/tags/ReativeX/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"ReativeCocoa","slug":"ReativeCocoa","permalink":"http://djs66256.github.io/tags/ReativeCocoa/"}]},{"title":"全局数据同步（三）终极方案","date":"2017-07-06T18:39:17.000Z","path":"2017/07/07/2017-07-07-全局数据同步（三）终极方案/","text":"在全局数据同步系列文章中（一）（二）分别解决了model和view的全局同步，但是依然有一些问题，所以在这里给一个终极解决方案DDKeyPathChannel。 Star 重新来说明下解决的问题由于各种原因，目前有两个表示同一种类型的model。 123456789101112131415@interface UserModel1 : NSObject@property (strong, nonatomic) NSString *id;@property (strong, nonatomic) NSString *name;@property (assign, nonatomic) NSInteger age;@end@interface UserModel2 : NSObject@property (strong, nonatomic) NSString *id;@property (strong, nonatomic) NSString *nickName;@property (assign, nonatomic) NSInteger age;@end 现在需要其中一个属性修改了，或者第三方要求更新属性，如何更好的同步各个不同model之间的属性呢？ 另一个问题，又如何把这个状态更新到UI上呢？ 以前方案的问题首先，来看看之前解决方案的几个问题。 所有基类都需要实现特定接口协议。这对于model来说会比较简单，但是对于UIView来说就比较麻烦。 使用上，实现上比较麻烦，需要注意的地方比较多，容易犯错误。 那么有没有不影响到原来的类的方式呢？ 新思路既然现有的类去实现这个协议比较麻烦，那么找一个第三方类，永久的实现这个接口，并且把消息转发到现有的类不就可以了吗。 我们都知道有一个类不继承于NSObject，功能就是代理，那么我们利用这个类来做消息转发。 接口如下 1234567891011121314151617181920212223242526272829303132@interface DDKeyPathChannelBaseProxy : NSProxy &lt;DDKeyPathChannelProtocol&gt;// 以下两个属性确定对象唯一性@property (readonly, nonatomic) NSInteger channelType;@property (readonly, nonatomic) NSString *channelId;// 原本的对象@property (weak, readonly, nonatomic) __kindof NSObject *target;- (instancetype)initWithChannelType:(NSInteger)channelType channelId:(NSString *)channelId target:(NSObject *)target;@end// 这是一个通过keyPath+白名单的实现，可以通过mapper来映射真正的keyPath@interface DDKeyPathChannelProxy : DDKeyPathChannelBaseProxy@property (strong, nonatomic) NSArray&lt;NSString *&gt; *whiteList;@property (strong, nonatomic) NSDictionary&lt;NSString *, NSString *&gt; *keyPathMapper; // messageKeyPath : realKeyPath@property (strong, nonatomic) void(^valueWillChangeBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@property (strong, nonatomic) void(^valueDidChangeBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@end// 这是一个block的实现，可以在同步的时候自定义转换与实现@interface DDKeyPathBlockChannelProxy : DDKeyPathChannelBaseProxy@property (strong, nonatomic) NSString *keyPath;@property (strong, nonatomic) void(^valueChangedBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@end 转发的核心在于消息的传递 123456789101112131415// keyPath- (void)setValue:(id)value forKey:(NSString *)key &#123; if (self.valueWillChangeBlock) self.valueWillChangeBlock(self.target, key, value); [self.target setValue:value forKey:key]; if (self.valueDidChangeBlock) self.valueDidChangeBlock(self.target, key, value);&#125;// block- (void)setValue:(id)value forKey:(NSString *)key &#123; if ([key isEqualToString:self.keyPath]) &#123; if (self.valueChangedBlock) &#123; self.valueChangedBlock(self.target, key, value); &#125; &#125;&#125; 那么我们怎么去挂载这个代理对象呢，想到associate object，那么我们也很容易的控制自己的生命周期了。 这样，我们就不需要在现有类中实现方法来支持该功能了，而且这样也更好的封装屏蔽了这些比较特殊的功能。在实践中感觉这种方式的使用成本是最低的，大家也比较容易接受。 12345678910111213141516[self.user1 bindChannelType:ChannelTypeUser channelId:self.user1.id];[self.user2 addChannelProxyWithChannelType:ChannelTypeUser channelId:self.user2.id config:^(DDKeyPathChannelProxy *proxy) &#123; proxy.keyPathMapper = @&#123; @&quot;name&quot;: @&quot;nickName&quot; &#125;;&#125;];// 更新属性[[DDKeyPathChannelManager sharedChannel] emitChannelType:ChannelTypeUser channelId:@&quot;1&quot; value:@&quot;Tom&quot; forKeyPath:@&quot;name&quot;];[[DDKeyPathChannelManager sharedChannel] emitChannelType:ChannelTypeUser channelId:@&quot;1&quot; value:@(30) forKeyPath:@&quot;age&quot;]; UI层更新也可以通过这种方式，也可以选择使用KVO。 题外话关于这个功能，很多人肯定想到了ReactiveX，关于这点，两者的确有部分相似的场景，但也有很多不同的地方。 关于更新UI这点，两者从效果上来看的确是一致的 1object -&gt; (signal, keyPath) -&gt; UI 两者最大的不同在于，ReactiveX是monad的思想，是有输入输出，拥有明确的输入对象和观察对象，行为流程是从上游到下游。而本套方案是一个中间人模式，是一个星状结构，更像通知一点。 但是两者思想是类似的，ReactiveX是把各种行为封装成Signal，而我们是把消息使用keyPath来承载与转发。 如果想要使用ReactiveX来实现这个功能也不是不可以，创建一个全局的热型号(subject)，控制好回收(dispose)，也是可以实现该功能，但总感觉和RX的概念有点偏差了。 总结从第一篇方案，到现在最终比较完美的一套方案，也是因为我们的需求在一步一步的变化，要求我们使用更好、更灵活的方案才能满足的结果。这个过程是一个不断思考不断反思的过程，从这个方案的演化中，我深有感悟，很多东西在创造出来的时候看似完美，但实际上还有很大的完善空间，同时别人的方案也会对自己的想法有很多的帮助。所以多了解别人的实现方案对自己的提升还是很有帮助的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"DDKeyPathChannel","slug":"DDKeyPathChannel","permalink":"http://djs66256.github.io/tags/DDKeyPathChannel/"},{"name":"ReativeX","slug":"ReativeX","permalink":"http://djs66256.github.io/tags/ReativeX/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"ReativeCocoa","slug":"ReativeCocoa","permalink":"http://djs66256.github.io/tags/ReativeCocoa/"}]},{"title":"部分LLVM编译优化与宏定义优化","date":"2017-06-23T17:08:16.000Z","path":"2017/06/24/2017-06-24-部分LLVM编译优化与宏定义优化/","text":"整理部分我用到的简单的宏定义以及编译优化。 字符串常量化平时可能会需要使用selector作为string来使用，通常使用的是NSStringFromSelector，但是却不知道在使用这种方法的时候产生了一次内存拷贝。为了能够充分利用内存，这里可以做一个优化。 12345#if DEBUG#define SelStr(sel) NSStringFromSelector(sel)#else#define SelStr(sel) @#sel#endif 这里和RAC比有个缺点就是不能处理sel1.sel2这样的keypath，但是不需要依赖变量。 同样，class也可以这么做。很多时候在register cell的时候，我习惯使用class name，这样可以确保唯一性，也可以减少定义常量的麻烦。 12345#if DEBUG#define ClassStr(cls) NSStringFromClass(cls)#else#define ClassStr(cls) @#cls#endif 这种方法简单，而且在开发的时候能够自动补全和校验正确性，但也存在着一些小问题，注意不要错误使用。比如： 12345SEL sel = @selector(action:)NSString *selName = SelStr(sel)Class cls = [self class]NSString *clsName = ClassStr(cls) Super保护super的调用 1NS_REQUIRE_SUPER Objc final关键字禁止子类化 1__attribute__((objc_subclassing_restricted)) constructor &amp; destructor12__attribute__((constructor))__attribute__((destructor)) 在程序或动态库载入和退出的时候调用，时机比main()要早。 __DATA, name1__attribute((used, section(&quot;__DATA,sectname&quot;))) 可以将全局变量数据放到sectname数据段，以区分其他数据段。可以通过getsectiondata取出。 format1__attribute__((format(printf, m, n))) 能够编译期识别format，提供warning信息 Assertion平时开发的时候很多人不注意的一点是不标明入参是否为空，或者其他一些临界情况，这是非常不好的一种习惯，而且很容易导致问题。 一种方法是使用编译器自带的检查nonull，但是这个需要在所有方法以及属性中标明，需要一定工作量，而且不能在.m中使用。 另一种方法是直接使用assert来断言参数，这种方法简单，而且只要看到第一行就能知道参数情况。并且能够在运行时帮助解决不合理调用的情况。而官方就提供了这类定义。 12NSParameterAssert(param != nil)NSCParameterAssert(param != nil) 使用非常简单，实现也是非常巧妙。 编译优化有时候考虑到性能，往往需要把函数定义为inline，编译器对于inline函数的行为是不确定的，也就是说inline函数最终编译结果可能不是inline的，这里可以强制使他成为inline。这种场景虽然少见，但也是一个优化点。 1__attribute__((__always_inline__)) 对于像工厂方法，创建对象的方法，如果返回值没有被使用也是一种浪费，这里可以让编译器直接报警告。 1__attribute__((warn_unused_result)) 宏编译上面提到了很多宏，平时使用过程中可能也会产生很多宏。在开发宏的过程尤为痛苦，这里就需要编译器的预编译宏功能来帮助我们了。 1clang -E 可以将宏编译为代码，这样就可以省去很多调试时间。","categories":[],"tags":[]},{"title":"数据源Diff算法分析","date":"2017-06-22T16:04:12.000Z","path":"2017/06/23/2017-06-23-数据源Diff算法分析/","text":"在IGList中有一个非常神奇的功能，就是可以根据数据源直接算出列表变化，采用update的方式更新列表，不需要每次都调用reloadData。我也想将这个功能引入DDComponent，所以就对diff功能稍微看了看。 由于IGList是数据驱动的，所以他有着天然的前提可以利用，而DDComponent是基于结构来组合的，所以需要一些额外的接口来暴露数据源。这些都是题外话了，现在来看看diff的两种实现。 恰好最近看到一篇文章介绍数据源diff的，他所介绍的是Doppelganger。现在就Doppelganger和IGList里面的算法进行分析。 Doppelgangerdiff的结果使用如下结构，这个设计其实有部分冗余，可能作者是为了返回结果的统一性才做成这样的。 12345678910111213typedef NS_ENUM(NSInteger, WMLArrayDiffType) &#123; WMLArrayDiffTypeMove, WMLArrayDiffTypeInsert, WMLArrayDiffTypeDelete&#125;;@interface WMLArrayDiff : NSObject@property (nonatomic, readonly) WMLArrayDiffType type;@property (nonatomic, readonly) NSUInteger previousIndex;@property (nonatomic, readonly) NSUInteger currentIndex;@end 算法部分 1234// delete和insert都比较简单，我们来看moveNSArray *moveDiffs = [self _moveDiffsWithDeletedObjects:deletedObject insertedObjects:insertedObjects];NSArray *deletionDiffs = [self _deletionsForArray:self.previousArray deletedObjects:deletedObject];NSArray *insertionDiffs = [self _insertionForArray:self.currentArray insertedObjects:insertedObjects]; 1234567891011121314151617181920212223242526__block NSInteger delta = 0;// 这里的delta代表了被删除的个数，realIndex = originalIndex - deltaNSMutableArray *result = [NSMutableArray array];[self.previousArray enumerateObjectsUsingBlock:^(id leftObj, NSUInteger leftIdx, BOOL *stop) &#123; if ([deletedObjects containsObject:leftObj]) &#123; delta++; return; &#125; NSUInteger localDelta = delta; // 同时新增一个的个数也会产生偏移, realIndex = originalIndex - deletedDelta + insertDelta for (NSUInteger rightIdx = 0; rightIdx &lt; self.currentArray.count; ++rightIdx) &#123; id rightObj = self.currentArray[rightIdx]; if ([insertedObjects containsObject:rightObj]) &#123; localDelta--; continue; &#125; if (![rightObj isEqual:leftObj]) &#123; continue; &#125; NSInteger adjustedRightIdx = rightIdx + localDelta; if (leftIdx != rightIdx &amp;&amp; adjustedRightIdx != leftIdx) &#123; [result addObject:[WMLArrayDiff arrayDiffForMoveFromIndex:leftIdx toIndex:rightIdx]]; &#125; return; &#125;&#125;]; 作者认为他的算法是o(n^2)，真的是这样吗？ 一眼看去这里出现了两个for循环，应该就是o(n^2)，但是别忘了[insertedObjects containsObject:rightObj]，很遗憾这里的复杂度应该为o(n)，所以最终他的算法应该是o(n^3)。 同时在计算delete和insert的时候，复杂度也不是o(n)的。而且在整个算法中大量调用isEqual:也会导致效率降低。 可以说这个如果是少部分场景使用是没有问题的，但是大量内容的时候可能会出现性能问题。 IGList很多时候，算法优化都是用空间来换取时间，这里来简要说明一下IGList的做法。 维护一个局部表table用来保存所有的元素，包括新的和旧的。 遍历一次新旧dataSource，加入1中的table，并且再生成两份包含位置信息的对应数组newArray, oldArray。 遍历一次newArray，由于元素包含新、旧的位置信息，所以不需要去old查找就可以直接根据index取出，这样就可以判断移动的元素了。 同样为了解决insert和delete导致的index偏移，IG采用的方式是创建一个数组，分别存储每个元素位置所对应的insertOffset和deleteOffset，这样也只需要for循环一次就够了。 如果不算table的复杂度，结果为o(n)，如果算table的复杂度，那么就是table的复杂度。 缺点是需要使用hash table，需要一个唯一的key(特定情况下可以是指针值)。 同时IG是用c++编写，大大降低了调用开销。以后DDComponent需要增加auto diff的功能的时候可以参考IG的实现方式。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"IGList","slug":"IGList","permalink":"http://djs66256.github.io/tags/IGList/"},{"name":"DDComponent","slug":"DDComponent","permalink":"http://djs66256.github.io/tags/DDComponent/"},{"name":"diff","slug":"diff","permalink":"http://djs66256.github.io/tags/diff/"}]},{"title":"dispatch备忘录","date":"2017-06-22T15:08:13.000Z","path":"2017/06/22/2017-06-22-dispatch备忘录/","text":"记录一些平时不会注意到的dispatch点 dispatch_groupdispatch_group的底层实现是怎么样的呢？ 在阅读官方源码的时候发现一个很有意思的地方，dispatch_group居然和semaphore是同一个东西。dispatch_group可以说是semaphore的一个特定扩展实现。 我们从业务需求上来说，的确group也是可以用semaphore来实现相同的功能。 dispatch_once以前一直以为dispatch_once是一个单纯的经过系统优化的锁而已，然而官方实现上要复杂很多，运行时会维护一个链表来执行，这样做可能是为了减少使用锁的情况。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"dispatch","slug":"dispatch","permalink":"http://djs66256.github.io/tags/dispatch/"}]},{"title":"DDSkin做更好的换肤框架","date":"2017-06-18T16:04:12.000Z","path":"2017/06/19/2017-06-19-DDSkin做更好的换肤框架/","text":"在很早的时候，就考虑过换肤功能的实现，一直到现在为止都没有看到特别好的系统化的实现。所以这里自己实现了一套自认为比较好的DDSkin，同时总结一下几种实现方式的利弊。 Star 实现方式总的来说实现方式应该是比较统一的，使用string类型的key来代替各个image, color属性。 最早的时候，考虑过使用Proxy来替换默认的image, color实现，将消息代理到真正的实例，这样就可以动态的替换底层映射的真实对象了。但是这样做有一个问题，真实对象变化后无法主动更新到界面，这个比较难以触发自动更新，所以不太靠谱。 手动模式在更换皮肤的时候发出通知，在各个需要变化皮肤的地方手动注册通知，并且更新UI。 这是最笨的方法，但是在少量场景的时候也是最好的解决方法，简单而且侵入性小。 method swizzling既然我们觉得注册通知并更新UI这种操作比较固定，而且繁琐，可以一次性的解决，那么很容易想到去hook部分接口，自动注册监听。 虽然这样解决了通知注册的问题，但是method swizzling本身就不是一种好的解决方案。 hook的方法是否可以被绕过，通过不同方式创建的对象所调用的方法是不一样的。 每个对象都会参与监听，会导致监听对象非常庞大，并且可能不需要更新的对象也会加入监听。 侵入性大，我们只能hook一些基类的方法，一不小心可能就会注册两次。 associated object同样作为通知的方案，既然method swizzling不行，那么可以让一个第三方对象去监听，然后自动触发更新。 这是一个比较好的解决方案，他减少了侵入性，并且更加灵活以及可靠。但是同样，作为一个修改基类来实现的方案也有很多的缺点。 由于associated object绑定实在基类进行，那么就不能排除子类覆盖了该方法的可能性，同时选定那个基类也是个问题，NSObject, UIView? 同时侵入性虽然小了，但还是存在的，毕竟影响的是基类的行为。 使用了objc runtime，这意味着什么呢？在一个swift为趋势的环境下，这种方案也是一种一般的解决方案。 weak table参考weak属性的实现方式，这里可以使用weak table。将所有有换肤需求的对象注册到一个weak table中，在换肤的时候只需要更新表中的对象即可，这样就不需要通知，同时也分离了换肤这个功能和实际对象之间的联系。 特性既然我们是一个通用型的框架，就必须考虑几点。 通用性既然我们支持了UIView的属性，那么可能我们会需要支持非视图的属性，比如View model，那么考虑到如此的通用性，设计的时候就不能局限于View。 同时，对于swift对象也可以比较好的支持。 扩展性有很多样式，不是简单的配置属性就能够达到效果的，比如富文本等，那么就要求框架能够有一定的扩展性。 DDSkin简介主要分成3部分 core 负责注册对象，并且在样式更新时触发所有注册对象的更新。 handler 对象更新操作，负责具体的更新操作。 storage 皮肤样式存储，可支持继承。 core使用了读写锁来确保线程安全，实际使用时由于UI操作需要在主线程，所以基本上来说都会在主线程操作，这里的锁可能会有点多余。 提供了c和oc两种接口，使用c是为了减少消息调用开销，实际情况应该也不会有太大影响。 1234567891011121314151617181920212223242526272829303132333435363738// 注册配置项void DDSkinRegisterTargetHandler(NSObject *target, DDSkinHandler *handler, BOOL apply) &#123; NSCParameterAssert(target != nil); NSMapTable&lt;NSObject *, NSMutableSet&lt;DDSkinHandler *&gt; *&gt; *mapTable = DDSkinGetTargetHandlerTable(); DDSkinTargetHandlerTableWriteLock(&#123; NSMutableSet&lt;DDSkinHandler *&gt; *handlerSet = [mapTable objectForKey:target]; if (handlerSet == nil) &#123; handlerSet = [[NSMutableSet alloc] init]; [mapTable setObject:handlerSet forKey:target]; &#125; [handlerSet addObject:handler]; &#125;); if (apply) &#123; // When apply is true, must call at main thread? // Usually apply is on the UI thread. // So we make it must be on the main thread! DDCAssertMainThread(); DDMainThreadRun(&#123; [handler handleSkinChanged:DDSkinGetCurrentStorage() target:target]; &#125;); &#125;&#125;// 更新配置void DDSkinRefreshAllTarget() &#123; NSMapTable&lt;NSObject *, NSMutableSet&lt;DDSkinHandler *&gt; *&gt; *mapTable = DDSkinGetTargetHandlerTable(); DDMainThreadRun(&#123; [[NSNotificationCenter defaultCenter] postNotificationName:DDSkinStorageWillChangeNotification object:nil]; DDSkinTargetHandlerTableReadLock(&#123; for (NSObject *target in mapTable.keyEnumerator) &#123; NSMutableSet&lt;DDSkinHandler *&gt; *handlerSet = [mapTable objectForKey:target]; for (DDSkinHandler *handler in handlerSet) &#123; [handler handleSkinChanged:DDSkinGetCurrentStorage() target:target]; &#125; &#125; &#125;); [[NSNotificationCenter defaultCenter] postNotificationName:NSCurrentLocaleDidChangeNotification object:nil]; &#125;);&#125; handler为了保证通用性和可扩展性，这里默认提供了两种实现。keyPath和block。keyPath使用的是setValue接口，属于上层接口，并不涉及oc底层，所以可以支持swift原生类。同时block提供了一种更为灵活的方案。 storage本身不同团队会有不同的数据存储方案，那么这一块的变动应该是框架里最大的，所以这里提供的是协议，并且默认实现了一套以NSDictionary为基础的的方案。 12345678910111213@protocol DDSkinStorageProtocol &lt;NSObject&gt;- (NSObject *)objectForKey:(NSString *)key;- (UIColor *)colorForKey:(NSString *)key;- (NSString *)stringForKey:(NSString *)key;- (NSURL *)urlForKey:(NSString *)key;- (UIImage *)imageForKey:(NSString *)key;- (NSNumber *)numberForKey:(NSString *)key;- (UIFont *)fontForKey:(NSString *)key;- (NSNumber *)booleanForKey:(NSString *)key;- (NSValue *)sizeForKey:(NSString *)key;@end 每种类型设计一个接口是为了确保类型安全，防止因为误操作而出现的类型错误。 关于image，如果我们每次解析完都保存为UIImage对象，会导致内存的浪费，所以这里提供一种lazy-load的方案。这是具体实现上的方案，完全可以自己实现。 123@protocol DDSkinStorageItemLazyLoad &lt;NSObject&gt;- (id)value;@end UI层扩展基于以上几点，那么UI层就不需要在基类中做什么事情了，只需要在支持的类型上增加部分扩展方法即可。 1234567891011121314151617181920@property (strong, nonatomic, nullable) IBInspectable NSString *backgroundColorSkinKey;- (NSString *)backgroundColorSkinKey &#123; DDSkinHandler *handler = DDSkinGetTargetHandlerByKey(self, DDSelStr(backgroundColor)); return handler.storageKey;&#125;- (void)setBackgroundColorSkinKey:(NSString *)backgroundColorSkinKey &#123; DDAssertMainThread(); if (backgroundColorSkinKey) &#123; DDSkinHandler *handler = [DDSkinHandler handlerWithKeyPath:DDSelStr(backgroundColor) valueType:DDSkinHandlerKeyPathValueTypeColor storageKey:backgroundColorSkinKey]; DDSkinRegisterTargetHandler(self, handler, true); &#125; else &#123; DDSkinUnregisterTargetHandler(self, DDSelStr(backgroundColor)); self.backgroundColor = nil; &#125;&#125; 由于大部分场景下这部分代码是重复的，所以这里使用了大量宏定义来解决这个问题。 12// 上述内容可以改为DDSkinPropertyDefine(backgroundColor, BackgroundColor, color, Color); xcode高亮状态： 为什么把key定义成这样，不加前缀是为了在IB中设置的时候不会每个都有个奇怪的前缀。 使用如果使用的是IB或者StoryBoard，可以直接设置属性一样配置 如果使用代码编写也只需要更新属性 12[self.view setBackgroundColorSkinKey:@&quot;red&quot;];self.view.backgroundColorSkinKey = @&quot;red&quot;; storage的默认实现为DDSkinDefaultStorageParser，也可以自定义实现。默认配置文件实现为plist，支持继承，super为父配置。 总结可以看到，虽然DDSkin的出发点是一套换肤方案，但实际上来说概念应该更加的广，应该定义为一套配置化方案。由于其他配置化的数据刷新可能不像UI那么简单，autolayout可以自动更新，使用上会稍显麻烦一点。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"DDSkin","slug":"DDSkin","permalink":"http://djs66256.github.io/tags/DDSkin/"},{"name":"换肤","slug":"换肤","permalink":"http://djs66256.github.io/tags/%E6%8D%A2%E8%82%A4/"},{"name":"夜间模式","slug":"夜间模式","permalink":"http://djs66256.github.io/tags/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"}]},{"title":"IGListKit简析与DDComponent","date":"2017-05-23T13:31:25.000Z","path":"2017/05/23/2017-05-23-IGListKit分析/","text":"在我们的项目中大量使用了列表以及模块化的思想，所以才有了DDComponent，这个的原理在之前的美学的表现层组件化之路详细的说明了使用方式。最近翻了翻IGListKit的代码，发现他的思想和我的思想非常的类似，但也有部分区别，这里就来分析下IGListKit的场景。 Star 首先，来看看IGListKit的使用IGListKit封装了UICollectionView的Api，下面是一个最简单的例子。 1234567891011let dataSource = [1, 2, 3, 4, 5, 6]func objects(for listAdapter: ListAdapter) -&gt; [ListDiffable] &#123; return dataSource&#125;func listAdapter(_ listAdapter: ListAdapter, sectionControllerFor object: Any) -&gt; ListSectionController &#123; return DisplaySectionController()&#125;func emptyView(for listAdapter: ListAdapter) -&gt; UIView? &#123; return nil &#125; 虽然经过封装，但还是逃不过回调布局，我觉得这是IGListKit没有做好的一步。 根据官方说明，这是一个数据驱动(data drive)的组件化实现。 那么数据驱动体现在哪儿呢？ 所有组件均对应于一个viewModel，而每个viewModel均对应于一个controller，每个controller实现视图，所以接口概括起来应该是 1Model -&gt; ViewModel -&gt; Controller &lt;-&gt; View 所有的组件都基于viewModel来组装和实现。所以如果需要更新列表就必须更新dataSource。这样设计有它的优点，也有它的一些缺点，在之后的内容中会展开分析。 IGListKit把各种回调dataSource和delegate都细分成各个组成部分，也就是说具体数据和事件还可以再细分下去（其实经过这一层的切分，每个controller一般不会太笨重）。 对比DDComponent的优劣两者的目的都是一样的，利用UICollectionView来布局一个内容非常多，非常长的页面，以减少复杂度。同时又将数据按照结构进行切分，分散到各个模块，然后加以重用。 IGListKit是一个备受关注的项目，而DDComponent在我们的项目中应用的非常广泛，可以说两者都具备很好的实践检验。 学习成本IGListKit基于系统API自己又封装了一层，目的是为了拆分后的dataSource和index能够一一对应，同时又把各种回调都拆成单个属性。这样做进一步的细化了每个组件的实现。 而DDComponent则完全使用了系统的API，使用上仅需要关心本模块的实现就好了。和UICollectionViewController一样，delegate和dataSource都是自身，可以看做是Controller的拆分。由于采用系统方法，所以暴露的是indexPath，和一个模块内的数据源可能不是一一对应的，这需要使用者自己处理。 总的来说，DDComponent和系统接口相似，学习成本较低。 拆分粒度IGListKit相当于把臃肿的dataSource和delegate移出controller和把UICollectionViewController拆分为多个子controller。所以IGListKit的粒度是要更细一些的。但是我们从实用程度来看看需要什么粒度。 根据我目前项目里的经验，controller中UICollectionView相关的功能都已经已到component中实现，目前只负责部分业务逻辑，所以一般不会超过500行。而每个component也只是负责本模块的展示与业务逻辑，也基本不会超过500行，所以从粒度来看，一次拆分已经足够了，应该能够满足绝大部分场景了。 结构IGListKit就如以上所说的 1Model -&gt; ViewModel -&gt; Controller &lt;-&gt; View 而DDComponent则较为简单，这里的Component对应于IGListKit的Controller+viewModel，这两者的功能都是类似的，相当于子controller，但两者都没有继承于UIViewController。 1Model -&gt; Component &lt;-&gt; View 所以在使用上DDComponent不需要必须为每个组件创建一个对应的viewModel，也就更为方便。 使用上虽然IGListKit将列表拆分为组件，但是依然还是依赖于numberOf和sectionControllerFor这样的回调来映射每个viewModel，这就导致了如果一个列表有太多类型的viewModel，依然会导致回调的代码膨胀。 同时IGListKit仅支持到section，不支持嵌套，也就是不能在组件中再放组件，所以灵活性上来说并不如DDComponent。 DDComponent组装结构依靠的是component数组，同时并没有限定一个component所对应的section或者item的数量，所以可以支持到每个item，并且支持嵌套。所以很容易支持到下面的结构。这种组合方式可以让我们将组件进一步拆分为子组件，使每个组件唯一对应于一种view。 123456RootComponent |-- SectionComponent(1) |-- SectionComponent(2-5) |-- SectionComponent(6) |-- ItemComponent(1) |-- ItemComponent(2-5) 同时DDComponent的思想是组成viewModel-component-view的一一对应，也就是说一个component所负责展示的只有一种类型，像header, footer这种也是完全拆分开来，完全根据配置和组合来建立页面。相比会更加灵活。 出发点IGListKit的思想来源应该是MVVM，核心是数据，界面按照数据来排布。 而DDComponent的思想来源则是传统的MVC，以controller为核心，通过各种形式的组合形成一个整体界面，组合是组件化的关键。 按照数据来切分(IGListKit)的优势在于对于数据的操作处理上会更加简单，比如增加、删除某条数据。而按照结构来切分(DDComponent)则在状态切换(Loading, Error…)，界面组合(Header, Footer)上更方便。 可扩展性两者都可以通过传递方法回调来进行功能扩展，不仅仅是delegate，可以是任意的协议。 两者都需要自己去增加传递的代码，都会比较麻烦，这一点希望未来我能解决DDComponent的消息传递问题。 复用性两者都是为了复用而产生的，所以双方的复用性都非常不错。不同的是IGListKit是强制依赖viewModel和controller两者来进行，而DDComponent必须的是component，当然也可以拆分为viewModel-component。 最后IGListKit我使用的并不多，所以有些地方的观点有些偏颇，可能有办法解决他不能灵活配置的问题。但是从我的观点来说，如果你的应用中有大量相同或者相似的列表模块，同时组合方式又是比较随机，我相信你会更喜欢DDComponent。如果你的列表数据源经常变化，比如编辑功能，IGListKit会做的更好一些。 以上谈到的DDComponent的组件化思想，经过半年时间，以及在自己项目中的使用和积累的心得，其实真正应用的场景比最初设计的场景要少得多，接口可以再进一步的简化和改善（indexPath的问题），将来会再做一次重构。同时解决一些扩展性的问题。相信可以完全媲美并且替代IGListKit。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"DDComponent","slug":"DDComponent","permalink":"http://djs66256.github.io/tags/DDComponent/"},{"name":"IGListKit","slug":"IGListKit","permalink":"http://djs66256.github.io/tags/IGListKit/"}]},{"title":"我们需不需要使用AsyncDisplayKit来优化速度","date":"2017-05-23T12:32:04.000Z","path":"2017/05/23/2017-05-23-我们需不需要使用AsyncDisplayKit来优化速度/","text":"我们项目单个页面比较复杂，内容比较多，对渲染的性能要求也比较高，之前也出现过几个性能问题，所以就去翻了下AsyncDisplayKit的源码，看看是否可以接入项目来优化性能。 AsyncDisplayKit的基本原理很简单，异步绘制图片，然后直接通过layer的contents直接传递给GPU绘制。的确这样永远不会卡在主线程，也不会卡在GPU的性能上，但是这么做也带来了一些不好的影响。 并没有实质性的优化性能。他只是把原本会阻塞主线程的内容，转移到了子线程，或者会阻塞GPU的内容，转移到了CPU中完成。这样做只是表面上帧率达到了很高，但是某些东西移到CPU后，反而不能更好的利用GPU，同时内存在CPU和GPU之间拷贝也会损耗部分性能，所以很多情况下是得不偿失的，界面会呈现空白一小段时间。 内存问题，在reuse view中，Node部分并不会发生重用，所以如果你在Node里面占用了很多内存的话，很容易导致内存上涨加快。 控制复杂，依赖程序员能力。AsyncDisplayKit很大程度是依靠图层的合并来做的，并且需要程序员自己来判断哪些需要合并，这就非常的依赖个人能力以及对AsyncDisplayKit的了解了。 在reuse view里面的表现并不好。在快速滑动时，确实不会有卡顿现象了，但是在快速的reuse过程中，绘制队列可能会进入一个产生小于消费的过程，这时候会导致界面的闪烁（新的库Texture表现好一点）。同时这也会导致空白时间的延长。 所以在绝大部分场景，我们都不应该依赖AsyncDisplayKit来解决我们的卡顿问题。事实上，我们项目经过几次的优化已经拥有了非常良好的体验，也没有使用如此庞大的一个系统，可以说目前的设备性能能够满足我们几户所有的视觉要求。 但是AsyncDisplayKit也有我们可以借鉴的地方。 内存释放。AsyncDisplayKit专门创建了一个子线程去释放内存，这可以给我们一个思路，在需要大量释放非UI内存的时候，完全可以抛给子线程做，这样就不会导致一次性大量释放内存带来的卡顿。参考下Java可怜的GC，一旦发生GC，整个程序都被暂停了。 异步绘制。的确有部分内容需要我们去异步绘制，控制好各个视图的合并和更新重绘能够提升性能。 布局。AsyncDisplayKit嫌弃苹果的AutoLayout太慢，直接自己搞了一套Flex布局，来提升性能。同样我们也可以尝试减少AutoLayout给我们带来的性能损耗，在一些常用控件和复杂场景使用手动布局的方式。 或许我们可以在非常小的范围使用它，但是在我看来，几乎没有需要引入整个开源库的必要，几乎没有那么复杂的视图需要我们如此去绘制。 ps. Texture 发展比较快，可以继续观察下他做了哪些优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://djs66256.github.io/tags/AsyncDisplayKit/"}]},{"title":"关于架构师的杂谈","date":"2017-05-20T13:30:08.000Z","path":"2017/05/20/2017-05-20-关于架构师的杂谈/","text":"看到一些讲架构的文章，和我早期的一些想法一样，有些时候过于的学术派，一定要区分个模块、套上什么模式之类的，所以这里聊聊我的看法。 在我入坑早期的时候，非常的看重设计模式这类的学术型论述，非常的崇拜那些一出来就把层级、架构讲的条条是道的人。曾经有位多年经验的人告诉我，不要太纠结于设计模式这种虚的东西。当时的我还不怎么认同，直到最近，自己从零开始，参与并作为主要开发人员完成了一个项目从无到有的过程，在此期间也遇到并解决了很多问题，由此感受到了之前别人所说的话的意义。 很多东西，比如层级、框架都不是一开始就能够完全的设计好的。在一开始的时候，我也不知道我们的应用会变成什么样子，或者说目前的结构和一开始构思的已经几乎完全不一样了。在不断的需求迭代过程中，我们才慢慢知道，真正需要的是一个什么样的框架。比如是一个快速迭代，功能有比较统一的可以尽量模块化来进行复用，而一个功能稳定的内容则需要设计的简单可靠。所以问你一个功能应该怎么设计是不能判断一个人的能力有多高的，虽然可以刷掉一部分差的。 现在大家说的mvc，mvvm这些模式也是别人总结出来的，我们难道一定需要按部就班的去按照这个模式去写吗。当然不是，人是活的，谁能知道以后会不会由你来创造一个新的模式呢。很多时候去争论某些内容是属于v还是属于m其实也是没有太大的意义的。当不同人从不同的角度去看问题的时候，自然就可能会有不同的理解，所以好用的才是好的。当然这里也不是鼓励不考虑这些框架，而是现实情况下，这些框架都有一部分的缺陷，为了简单可靠的弥补这些缺陷，可能就会有些争论的部分。 那么学术派的理论难道是没用的吗？当然不是，理论是高度概括的实践经验，当你了解了所有的设计模式，需要的不是想套用公式那样套用，而是真正的去理解这样做的是为了解决什么样的问题。就像张无忌学习太极，记住了所有招式，然后又忘记了所有招式。根据实际情况利用模式里面解决问题的方法才是学习理论的目的。不过好像目前iOS端能够使用到的设计模式比较单一，很多人也就停留在单例，工厂这些。 最后再来说说架构师。服务端，如果使用的是一个稳定的开源框架，比如spring，几乎不需要什么二次开发的，几乎所有功能组件都有现成的，仅仅需要按照文档来搭建好就可以了，一般的项目来说这些就足够了，那么什么样的程度才算的上是架构师这个职称呢？同样前端，目前的技术更新比较快速，但目前这些技术框架，比较有名的都来源于国外，国内都在忙这学习。那来说说客户端，客户端的模式基本比较单一，都是按照官方的规范来做，如果自己搞一套，那么简直作死，同时客户端的组件比较分散，既可以用a的组件也可以使用b的组件，但总体来说这些组件都是一些小功能小模块，还不足以按上一个架构的名号，同时国内大部分以业务开发为主的行情来看，如何才能达到架构师这个职称呢？所以在国内很多互联网行业所谓架构师的应该仅仅是技术选型的人员。 综合来说，架构师绝非一蹴而就，需要非常多的项目经验和理论知识，涉及多个编程领域，才能设计的出一个比较好用的东西。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"Flex箱型布局在移动端的应用","date":"2017-05-16T15:27:01.000Z","path":"2017/05/16/2017-05-16-Flex箱型布局在移动端的应用/","text":"在平时开发过程中，用的最多的布局方式当然就是苹果自带的AutoLayout，但是使用的过程中也发现AutoLayout自身也有很多的问题。在我们的项目中，由于展现逻辑比较灵活，视觉每期的变化比较大，在使用过程中，很大一部分时间都在调整视觉中，所以想引入一个更简单的布局方式，这就是大名鼎鼎的Flex，也叫箱型布局。 首先来看看我们在AutoLayout中遇到的几个问题AutoLayout自身的API简直反人类，所以大家使用过程中往往会引入第三方库（Masonry, PureLayout)。Masonry看上去更加直观，但是不太符合OC的编码习惯，PureLayout更符合OC的规范，使用起来也稍复杂点。两者都有很多的使用者。虽然第三方库简化了API，但并没有简化场景。 另一个AutoLayout令人诟病的问题，就是当视图增加的时候，计算复杂度成倍上升。AutoLayout依靠解线性方程组，所以越多的视图性能下降非常大。 在使用场景上，举几个例子。 123|---- View1 ----||---- View2 ----||---- View3 ----| 如果要排上图3个View的时候，AutoLayout必须指定相互间的依赖。 如果仅仅如此还好解决，那么现在告诉你，View1可能是个1行或者2行的Label，那么如何平均分配之间的大小和间隔呢？ 如果这样还是容易解决，那么再告诉你，View2可能是个没有内容的视图，当没有视图的时候1和3之间要保持之前的间距，这时候，不可能简单的解决了，必须修改依赖，一种方式是删除所有的AutoLayout，重新布局一遍，另外一种是保存AutoLayout实例，修改单个属性。无论如何，都不能避免修改依赖。 如果说到这里你都觉得轻松解决，那么下面这种呢 123| |---- View1 ----| | || Image |---- View2 ----| Action1 | Action1 || |---- View3 ----| | | 这是标准的TableViewCell样式，但是如果说View和Action都是动态的，可能会被隐藏，但隐藏的时候不能空着一块，垂直的需要居中，水平的需要拉伸。这时候就彻底的蛋疼了，恰好我们的项目中就有很多类似的场景，由此我们很多时间都浪费在调整UI上，又容易漏掉场景导致一些视觉bug。 在一次次的UI修改中，我终于受不了了在视觉排版这个从印刷术发明就存在的问题，到现在计算机领域，最成熟最靠谱的当然是Web技术，从互联网出现，到现在的响应式界面，web经历了历史的历练，从而产生了一套稳定靠谱的布局方式，而最新的就是不久前被加入标准的Flex布局（也可以称为Box布局）。 关于布局使用，有很多有名的介绍文章，我作为一个半吊子人士，就不做详细介绍了。简单来说，就是把每个视图都看作一个箱子，拥有内边距外边距，然后根据一定顺序排布下去，相互间不会产生依赖，当某个视图的属性display: none，自动忽略该视图。 比AutoLayout好的地方首先，Flex计算简单，不会因为视图的增加性能急剧下降。 同时也可以方便的解决上述的几种场景，可以动态的根据视图来排版，而不需要相对的去设置，同时拉伸和挤压也很好控制(flex-grow, flex-shrink)。 甚至可以解决部分需要UITableView或者UICollectionView才比较好解决的问题。举个例子，微信九宫格图片，如果不是用UICollectionView来做，那么可能你需要保存9个实例，然后在layoutSubview里面做各种判断，计算frame，那简直是太恐怖了！看到这样的代码谁还有兴趣读下去吗。而使用UICollectionView则可以很好的解决布局问题，还能复用，但是很多场景下并不会产生复用，而使用UICollectionView又会新引入很多层视图层级和一些不需要的功能，虽然很好解决了问题，但并不是特别简单。那么这时候Flex布局的优势就特别明显了，只要flex-wrap属性就可以搞定一切。 总的来说，使用简单，学习成本低，性能也很不错，兼容性也高，这也是很多人为什么会嘲笑苹果自己搞了一套复杂无比的布局系统。 缺陷Flex布局最大的缺陷就是视图层级的增加，每个箱子都是一个视图，看web的代码可以发现无数的div，单纯的为了实现一套布局。不过对于移动端来说，一个视图不会拥有太多的元素，可以说这个问题没有那么的严重。 我也在考虑是否可以创建一层virtual view，可以用来代替view作为箱型容器，或者把布局系统移除view作为容器这一web上的逻辑，分离布局和view。无论怎么样这两种方案都会增加复杂度。 同时，由于原生并不提供Flex支持，所以需要自己引入Flex库，并且需要在layoutSubview或者viewDidLayoutSubview中，手动触发计算。关于这个问题，可能自己创建系列Flex根控件比较好。 目前使用Flex的项目，或者类似的功能现在最有名的方案是Facebook的Yoga，遗憾的是iOS端的YogaKit正处于开发阶段，可能不是那么的稳定。 正在使用Yoga的开源项目也有很多，有名的有AsyncDisplayKit, React Native, weex。所以从目前使用场景来看是没有什么问题的。 比较相似的功能其实早有方案，比如Android的LinearLayout和iOS的UIStackView，可以说这两者都是阉割版的Flex。 YogaKit我们来看下YogaKit的一些API。不要问我为什么是swift，老外现在都在玩swift。 1234567root.configureLayout &#123; (layout) in layout.isEnabled = true layout.width = YGValue(containerSize.width) layout.height = YGValue(containerSize.height) layout.alignItems = .center layout.justifyContent = .center&#125; 如果是swift，将会非常简单，枚举的一半都被省略了，但是OC可能会稍微麻烦一点。API也是几乎参考的Masonry，重要的是，再也不会出现依赖了！！！感觉棒棒的。 同时Yoga不是完全的实现了Flex的功能，他是为移动端、客户端专门定制的布局系统，所以也有部分Flex没有的功能，也有部分Flex属性没有效果。 同时Yoga非常的精简，核心代码只有3000多行的c语言，引入成本也非常的低，所以决定在下一期实战型的使用下，来解决一直遗留的问题。 更多的考虑在项目的过程中，作为程序员，都希望代码能够复用，提高稳定性。然而现实是残酷的，其他人并不会替你思考这些问题，所以就有很多场景，明明看着一模一样，但是某几个字体就是不一样，大小就是差那么几个像素。那么要处理这种问题，一般有两种方案。 1，继承，基类写基本成员，子类来写布局和属性。这样会导致很多子类，不熟悉的人会很疑惑这些东西都在哪里用的。 2，增加style属性，使用style来重写布局和属性，这样可能会随着类型的增多switch-case也增加。 同样，这里web也给了我们一个很好的思路。内容-样式分离，我们可以做一套类似于css的系统，使用class来设置布局样式，这样布局样式也可以复用了！ 当然这个思路有部分人已经做好了开源库，css样式直接应用到控件。但是感觉没有那么完美，所以以后可以考虑下如何更好的把样式布局给统一到外部。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://djs66256.github.io/tags/flex/"},{"name":"layout","slug":"layout","permalink":"http://djs66256.github.io/tags/layout/"}]},{"title":"几种圆角处理在列表中的性能测试","date":"2017-04-24T15:41:56.000Z","path":"2017/04/24/2017-04-24-几种圆角处理在列表中的性能测试/","text":"在平时开发中，圆角处理是一个非常常见的场景，光栅化是一个最简单的优化方法，但是你所使用的方法真的如你所愿的在生效吗？这里对几种比较常用的方法对比一下。 首先按照最常用的几种方式设计了几个case，使用CollectionView来测试性能。Github 1. 纯粹的设置layer属性方式1234self.layer.cornerRadius = frame.size.width/2;self.layer.borderColor = [UIColor blackColor].CGColor;self.layer.borderWidth = 1;self.clipsToBounds = YES; 这里不考虑非clipsToBounds的情况，因为大部分场景是需要的，而且非clipsToBounds的话和其他case并不平等。 2. 增加光栅化处理12self.layer.shouldRasterize = YES;self.layer.rasterizationScale = [UIScreen mainScreen].scale; 3. 绘制Image1234567UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);[[UIColor blackColor] setStroke];UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0.5, 0.5, size.width - 1, size.height - 1) cornerRadius:size.width/2];path.lineWidth = 1;[path stroke];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 4. 绘制Image并且加上缓存测试以上case都是在init中就设置好了属性，不会产生reuse的性能问题。为了让效果更加明显，找了一个5s的设备进行测试。 下面是只有一个空的view的结果 从结果来看，似乎有点出乎意料，单纯的设置layer属性居然是表现最好的一个，而增加光栅化的表现明显最差，除去可能产生的误差，1和2的结果相差还是有点大。 打开模拟器的Offscreen-Rendered功能，发现1由于没有子视图，所以clipsToBounds属性无效，并不会发生离线渲染，而一旦指定了光栅化，就会强制执行离屏渲染，导致性能急剧下降。 那么我们在视图上加上一个视图 结果发生了戏剧性的变化。光栅化的视图直接接近0的帧率，而3和4除了初始化的时间有差别外其他基本符合预期，4高一点可能是用了同一份内存，拷贝到GPU的时候系统做了优化。 那么我们把label不要放在圆角view上这时候1和2表现一致，应该都产生了离屏渲染。 所以问题来了我们平时可能用到的光栅化为什么没用了。这要涉及到光栅化cache的策略了，我没有找到详细的官方文档，只找到一段话： 1And if you start setting lots of views with shouldRasterize, you&#x27;re going to overflow the cache and that ends up in a really, really bad situation, ends up being much worse than before because essentially you&#x27;re rendering every single view that you set with shouldRasterize offscreen and the back on the screen and we just talked about how doing that in every frame can really, really hurt your animation performance. 大量的光栅化导致缓存溢出，所以每次还是需要离屏渲染。 另外，该文章还说 1So make sure you don&#x27;t change anything during your view hierarchy while you have shouldRasterize on, otherwise you ended up rendering offscreen without great performance. 这就是我们平时说的“不能经常变动的视图”，但是注意的是，应该是整个视图树，而且是anything，这样的要求太过于严格。所以为什么很多时候的光栅化会让性能问题更加严重。 HOW最好的方式当然是绘制圆角并缓存。 另一种折中方案是使用blend，通过一张有透明通道的图片来遮盖实现圆角效果。 当你觉得你需要的时候，才开始优化。这才是最好的思路，不要做过早的优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"圆角","slug":"圆角","permalink":"http://djs66256.github.io/tags/%E5%9C%86%E8%A7%92/"},{"name":"cornerRadius","slug":"cornerRadius","permalink":"http://djs66256.github.io/tags/cornerRadius/"}]},{"title":"web图片下载转为native下载","date":"2017-04-23T15:30:03.000Z","path":"2017/04/23/2017-04-23-web图片下载转为native下载/","text":"早期版本的网易新闻每次点开新闻图片，都会重新去下载新的图片，而在某个版本开始，可以发现点开的时候并不会重新加载了，只有在保存的时候会下载高清图片，那么他是怎么做到的呢。 平时，我们网页基本都是自己负责自己的内容加载。但是有时候却希望能够拿到网页内的图片资源，此时我们不得不自己再去加载一遍，不仅仅浪费流量，而且影响用户体验。 由客户端帮助web下载图片，这样我们就可以让web和本地共用缓存，并且可以自定义缓存了。那么如何做到这样的效果呢？这里提供两种不同的思路来解决这种问题，分别对UIWebView和WKWebView下的运行情况进行分析。Github URLProtocol我们知道URLProtocol可以截获请求，那么我们是否可以直接截获所有URL，然后根据path来判断是否是图片，是否需要自定义下载。 根据demo试验来看，UIWebView可以完美的实现该方案，但是WKWebView却不能被截获，原因是WKWebView拥有自己的URLSession，虽然可以用黑科技获取URLSession并加入代理，但是不能通过苹果审核。 FileURL另一种方式是使用本地文件，这种方式更加符合规范而且更加安全。不过WKWebView支持本地资源的接口是在iOS 9.0才引入的，而且需要指定目录，所以需要先把所有资源拷贝到该目录下。 根据demo的试验来看，UIWebView和WKWebView都完美的支持了。 比较现在来比较下这几种方案。 URLProtocol能够在不改变网页内容的情况下直接对内容进行替换，但是不能支持WKWebView，而且全局的Protocol可能会带来某些隐患。 FileURL能够灵活的定制化下载方式，而且能够支持WKWebView，但是需要将img标签的http链接替换为file链接。 适用场景URLProtocol比较通用，普遍适用于各种网页。 FileURL更加偏向于定制化，这里来详细看看定制化的场景。 比如网易新闻的新闻内容格式大概是这样的： 12&lt;p&gt;正文正文正文&lt;/p&gt;&lt;img src=&quot;http://www.163.com/logo.png&quot; /&gt; 很多情况下，为了优化网络以及渲染，都需要类似的简化html，并且把css，js代码打包到App或者单独下载。那么其实我们有很多情况下是拥有一定固定格式的html代码段。而部分活动等特殊的网页我们一般也不会需要客户端下载资源来优化性能。那么有了这个前提，FileURL的适用面其实还是很广的。 动态创建DOM那么怎么样处理比较合适呢？我们以WKWebView来看，难道我们要首先用拼装好一个网页，然后保存为一个文件进行载入吗？ 当然不需要这么笨重的解决方案，这样做不仅影响了性能，而且特别不灵活，一旦内容需要变更就会特别麻烦。 目前前端技术有两个热门的概念，虚拟DOM和响应式，那么我们也可以利用类似的原理。下面是一个简单的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 在Web端：var imageList = []// 创建一个空的节点，用来占位和展示进度条function appendImage(url) &#123; let dom = document.createElement(&#x27;div&#x27;) dom.style.padding = &#x27;20px 10px&#x27; let img = document.createElement(&#x27;img&#x27;) let p = document.createElement(&#x27;p&#x27;) p.innerText = &#x27;0%&#x27; dom.appendChild(p) dom.appendChild(img) document.body.appendChild(dom) imageList.push(&#123;url, dom&#125;)&#125;function findDomByUrl(url) &#123; let obj = imageList.find(i =&gt; i.url == url) return obj &amp;&amp; obj.dom&#125;function updateText(url, text) &#123; // console.log(`update text at &lt;$&#123;url&#125;&gt; with &quot;$&#123;text&#125;&quot;`) let dom = findDomByUrl(url) if (dom) &#123; dom.firstChild.innerText = text &#125;&#125;// 更新进度条function updateProgress(url, progress) &#123; updateText(url, progress)&#125;// 更新错误状态function updateError(url, error) &#123; updateText(url, error);&#125;// 图片下载完成后，更新图片资源function updateImage(url, fileUrl) &#123; // console.log(`update image url at &lt;$&#123;url&#125;&gt; with &quot;$&#123;fileUrl&#125;&quot;`) let dom = findDomByUrl(url) if (dom) &#123; dom.lastChild.src = fileUrl &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 客户端// 初始化[self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;appendImage(&#x27;%@&#x27;)&quot;, url] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123;&#125;];// 这里为了测试伪造一个进度功能__block NSInteger progress = 0;if ([url hasPrefix:@&quot;http&quot;]) [NSTimer scheduledTimerWithTimeInterval:0.1 repeats:YES block:^(NSTimer * timer) &#123; progress += 5; [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateProgress(&#x27;%@&#x27;, &#x27;%zd&#x27;)&quot;, url, progress] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123; &#125;]; if (progress &gt;= 100) &#123; [timer invalidate]; &#125;&#125;];// 下载图片[[[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:url] completionHandler:^(NSData * data, NSURLResponse * response, NSError * error) &#123; if (error) &#123; // 错误态 [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateError(&#x27;%@&#x27;, &#x27;%@&#x27;)&quot;, url, error.localizedDescription] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123; &#125;]; &#125; else &#123; // 保存图片并且更新界面 NSURL * fileUrl = [self.cacheUrl URLByAppendingPathComponent:url.lastPathComponent]; [data writeToURL:fileUrl atomically:YES]; [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateImage(&#x27;%@&#x27;, &#x27;%@&#x27;)&quot;, url, fileUrl.absoluteString] completionHandler:^(id ret, NSError * error) &#123; &#125;]; &#125;&#125;] resume]; 这样我们就可以动态的更新界面了，而且我们拥有自己创建的dom信息，那么我们可以做更多的事情:) 最后这里讨论了两种把图片转为客户端下载的方式，如果要说如果这么做相当于客户端来编写网页了，还不如直接写原生的呢。但是这样做比原生更加灵活，可以应用不同模板，不同样式，就可以改变外观了。而且具体使用时也不一定需要这么死板的去创建dom，之后我会尝试下不同的方案来简化双方的FileURL实现。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"webView","slug":"webView","permalink":"http://djs66256.github.io/tags/webView/"},{"name":"image","slug":"image","permalink":"http://djs66256.github.io/tags/image/"},{"name":"download","slug":"download","permalink":"http://djs66256.github.io/tags/download/"}]},{"title":"疯狂日志系统","date":"2017-04-17T14:25:36.000Z","path":"2017/04/17/2017-04-18-疯狂日志系统/","text":"在日常的开发过程中，总有很多莫名其妙的问题出现在别人的手机上，就好像上帝开的一个玩笑。然后我们拿着别人的手机连上mac，重新编译后，问题又神奇的消失了，这时候我们只能摇摇头，问题不能重现，但这并不代表问题已经解决。 ExDebug Star 很多时候，比如打点情况，并不能直观的提供给测试人员验证，很多时候需要日志来提供一些验收，而在非联机的情况下日志的输出查看又比较困难。 经常有用户反馈卡顿等情况，而我们的测试机又有限，难以覆盖足够的场景，用户的反馈又比较模糊，并不专业，所以很多卡顿往往在猜测中并没有被解决。 由于我们项目目前的状况，是没有那么多的人力来配合做一套BI系统。所以这里我做了一套小型的日志和系统运行情况手机系统。 功能 设计之初就是设计成一对多的模式，所以可以支持多台手机连接到同一台电脑上，其实还可以更疯狂的连接方式，架构部分会详细描述。 每个设备双击打开都是一个窗口，每个设备只能打开一个窗口。 窗口的首页是几个基本统计项，内存、cpu、FPS，最短1秒就会有一次统计数据。 请求部分是使用URLProtocol来做的，所以只能统计http类型的请求。 这里是每个请求统计的数据，目前还没有好好整理。 这里是对所有请求的一个分析，和上面一样，其实没有好好的利用数据。暂时没有想出来怎么很好的利用这一部分的数据，如果有想法，可以告诉我。 这里统计的是主线程一个runloop运行时间超过1/60s的情况，项目之前有部分卡顿就是因为代码问题，导致主线程产生大量运算形成的。 这里如果时间超过一定阈值（暂定为0.5s），此时会触发截屏，所以在严重卡顿的时候会自动把卡顿的界面保存下来。 这是一个简单的文件管理系统，从应用沙盒的根目录开始。 同时可以选择某个文件进行下载，直接保存到电脑中。 这是连接日志输出系统的。debug日志会输出到3个地方： * xcode console * system log，这个可以从mac的日志查看器里面看 * socket log 同时我们可以选择过滤器，这样就会展示相应的日志。这里的过滤系统是根据我们项目中特定日志格式来做的，实际情况可能需要不同的定制。 在苹果爸爸还没有封杀jspatch的时候，我们为了验证patch真是煞费苦心，需要在工程中加入代码，然后计算md5验证。这里可以直接写patch代码，点击按钮就会直接传输给手机直接应用，非常方便。 架构 大致的架构如上图所示，其中通信方式使用的是socket。可能使用websocket这种比较成熟的方案会更好，但是想自己写网络层，所以就自己写了长连接部分。（目前这部分留下点坑，服务端处理分包粘包偶尔会有问题）。其中socket内容为双方通信，不能按照我们平常客户端-服务端这样的架构来看待，手机端（暂且称为客户端）也需要处理服务端下发的请求。 手机端是一个简单的长连接和部分处理请求的服务，和服务端保持一对一的链接。 服务端服务端其实包含的是两部分，nodejs和pc端，这里先说nodejs。其实这两部分是完全分离的，并没有任何关联。这里服务端就特指nodejs。它包含两种通信模式： 1. rpc 进程间通信，是和`pc端`通信的方式。 2. socket，是和`手机端`与其他`nodejs`端通信的方式，对，是和其他`nodejs`服务，所以这里可以和我们的网络模型一样，组成星状结构、环形结构、网状结构。（没有真实的测试过超过两个端的连接，不能保证性能如何，也没有对此进行优化） 在刚开始的设想中，运作方式有两种： 1. 自己独立和多台手机通信 2. 找一台电脑作为独立服务器，其他人可以连该电脑，这样我们可以把多个数据都集中到一起，可以有人专门管理 pc端是由Electron+React组成，选择这样的技术是因为electron的跨平台特性，同时React又是我比较熟悉的一种前端框架（React-native又是移动端的一种统一化方案）。技术内容没有什么特别的，有部分数据量多的列表会导致卡顿，这个需要做特别优化。 通信数据格式分为3种类型： request-response模式，和我们最熟悉的http请求一样，不过是双方通信模式 register模式，是注册-持续上传的模式，目前已经去除了注册这一步，会把所有数据一直持续上传服务端。 代理模式，是第三方服务端希望通过该服务端访问手机端，会把请求数据包装一层。这是纯粹服务端-服务端之间的通信格式。 总结最初的想法是在debug版本和内测版本都应用该系统，统一收集和处理数据，对部分问题设置报警系统。多个pc端可以直连服务端，这样可以多人同时查看当前所有设备中存在的问题。就能够在上线前尽可能的覆盖各种网络、机型等情况，尽可能早的发现问题，避免上线后才发现bug。由于工作量大，性能也没有评估（node支持的并发数应该还是不错的，瓶颈可能会在带宽），对数据处理的方式也没有什么经验，所以现在还是停留在个人使用中。 有什么好的建议与意见，欢迎给我反馈。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://djs66256.github.io/tags/debug/"},{"name":"log","slug":"log","permalink":"http://djs66256.github.io/tags/log/"},{"name":"socket","slug":"socket","permalink":"http://djs66256.github.io/tags/socket/"}]},{"title":"持续重构","date":"2017-04-16T17:05:18.000Z","path":"2017/04/17/2017-04-17-持续重构/","text":"在这一年的开发过程中，从什么都没有到现在的稳定迭代，其中经历了多次的重构工作，这里来聊聊其中的一些看法。 我们的模块，从开始的刚好能够满足需求，到后面能够胜任各种要求，再到最后，简单的调用就可以完美的胜任工作。这是持续根据实际情况思考，经过多次重构而得到的结果。 为什么要重构从出发点来看： 功能缺陷，已经很难修复或者修复导致代码更加混乱，希望通过重构能够彻底的解决问题 功能越来越复杂，代码越来越多，导致维护成本非常大 从最终点来看： 统一结构，将类似的东西统一，模块化，避免重复代码和相同的bug 细分功能，将一个复杂的功能细分，减少开发的复杂度，增加复用性 最终的目的都是为了使用者更加简单可靠 最佳时机这里我把重构最适合的时机概括为两种： 功能爆炸期，当功能复杂化，代码单纯的大量叠加时，必然形成很多复杂逻辑，并且冗余的代码 类爆炸期，当类似的功能经过一定的归类，导致每种类型的子类型随着项目进行而急剧增加的时候 以我们的项目经验来看，在前几期的时候，由于时间紧张，功能的大量累加，导致一个复杂点的页面就有上千行的代码，此时每次改动都会花费大量时间，而且有部分bug不能从根本上解决。这时候我们开始了第一次的大规模重构，主要包含以下几点： 提出组件化框架，拆分页面代码，并把之前的一些功能用组件化改写 统一相似组件，把视觉相似的组件进行统一化，并且对代码结构进行重新归类 归纳部分相似功能，比如导航栏、页面头部的交互变化，网络层重新整理 经过这次的整理拆分后，已经是一个比较同一的整体了，能够很好的复用和修改。 但是经过部多个版本之后，又出现了新的问题。每次对页面和功能的特例化，导致相同资源的组件或者功能越来越多，导致每次使用的时候都不太清楚用哪个组件比较好。而且每个组件的接口也有略微的差异，并不能无缝的切换。以及一些原来就存在的，还没有经过拆分的功能。 这次主要做的主要是统一化工作，比如最简单的点赞按钮，在很多地方使用，同时因为历史原因，很多图标并不是同一个资源，逻辑规则也并不统一，接口也不统一。经过对整个项目的观察，发现其实目前项目中点赞按钮只有大小两种样式，那么使用抽象工厂的方式进行归纳，对外暴露的只有一个类型，那么这样使用者就不需要知道其中具体有几个组件了。 123456public class PraiseButton &#123;+ (instanceType)buttonWithStyle:style;&#125;private class _SmallPraiseButton: PraiseButton;private class _BigPraiseButton: PraiseButton; 而其他组件和功能对同一个资源的描述目前也是比较分散，今后也会按照这样的方式，按照资源类型进行归类与统一。 重构目的目前来说两次重构的目的是： 第一次 拆分功能，让每个模块尽可能的简单，可复用；减少复杂度，减少隐藏的bug；能够给团队其他成员使用。 第二次 合并和归纳功能；统一合并相同资源、功能的接口；减少对外暴露的实现细节；让使用者面对的只有一个对象，使用更加简单；减少理解沟通成本。 犹如读书时候老师说的一件事，刚开始读书的时候，书是薄的；读的久了，书就变厚了；当你已经精通书中所有，书又变薄了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://djs66256.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"横竖屏的一个容易被遗漏的点","date":"2017-04-16T14:01:42.000Z","path":"2017/04/16/2017-04-16-横竖屏的一个容易被遗漏的点/","text":"最近在做横竖屏切换的时候，发现一个crash，是一个平时没有注意到的点。 1UIApplicationInvalidInterfaceOrientation&#x27;, reason: &#x27;preferredInterfaceOrientationForPresentation &#x27;landscapeLeft&#x27; must match a supported interface orientation: &#x27;portrait&#x27;! 从描述上看，错误很明显，我们从方法的描述上看看。 123Returns the interface orientation to use when presenting the view controller.The system calls this method when presenting the view controller full screen. When your view controller supports two or more orientations but the content appears best in one of those orientations, override this method and return the preferred orientation.If your view controller implements this method, your view controller’s view is shown in the preferred orientation (although it can later be rotated to another supported rotation). If you do not implement this method, the system presents the view controller using the current orientation of the status bar. 那么如果supportedInterfaceOrientations和preferredInterfaceOrientationForPresentation返回的内容不符，是不是就会crash，经过试验的确会crash。 但是我们在dismiss的时候呢，经过试验表明，也是会crash的，特别是preferredInterfaceOrientationForPresentation返回的是UIApplication.shared.statusBarOrientation时，是一个非常容易被忽略的问题。 那么push呢？表现是怎么样的？ 经过试验，在pop的时候，如果横竖屏状态不一致，并不会crash，但是转场动画采用了系统默认的了，不会进入转场动画的delegate。 所以，如果需要做流畅的转场以及横竖屏切换，在一些场合下，还是需要使用present方式，并且需要在双方都确保supportedInterfaceOrientations和preferredInterfaceOrientationForPresentation的正确。 自定义动画在做自定义转场动画的时候，可以注意到，如果是从竖屏进入横屏的动画过程中，横竖屏的状态是正确的，但是横竖屏状态只能存在一个，也就是[UIDevice currentDevice].orientation，那么系统是怎么做到的呢。 重写UIViewControllerAnimatedTransitioning中的动画方案- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext，在此时获取屏幕方向[UIApplication sharedApplication].statusBarOrientation，发现已经转换到下一个controller的方向了，那么前一个controller为什么显示正常呢。我们看一下前一个fromController.view.transform，发现他并不是CGAffineTransformIdentity，这样就一目了然了。系统在屏幕转向变化的时候，会把上一个视图自动旋转90度，这样就可以无缝的转场动画。 那么另一个问题是，此时的controller的生命周期会是怎么样的。经过尝试，此时已经在viewWillAppear:和viewWillDisappear之后了，符合我们的预期。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"转场","slug":"转场","permalink":"http://djs66256.github.io/tags/%E8%BD%AC%E5%9C%BA/"}]},{"title":"AVFoundation的一些点","date":"2017-04-16T14:00:59.000Z","path":"2017/04/16/2017-04-15-AVFoundation的一些点/","text":"最近做了一个视频的需求，使用的是AVFoundation。 页面切换的无缝连接主要需要解决的技术点在于，如何在视频的全屏化过程中无缝链接，不会出现视频断裂或者停顿的问题。 view的伪装切换使用view来伪装页面的切换，视频的全屏仅仅是view的transform。 这样做的优点是比较灵活，不需要依赖与苹果的框架，转场动画等都比较好控制。 缺点也比较明显，因为在同一个controller中，代码偶尔度会增加，这个controller的功能也会更加复杂，而且transform并不能控制系统的屏幕方向，所以一些系统的提示不是正确的方向，比如音量，push等。 present方式使用present方式，展示一个新的controller，这样业务也会分离的比较清楚，唯一需要考虑的是如何让两个页面间的视频播放更加平滑。 一开始的考虑是，是否可以把AVPlayer传递给下一级，视图层由各个负责，因为视频的播放位置和缓存信息都以及保存在了AVPlayer。实际发现，把同一个AVPlayer给不同CAPlayerLayer的时候，视频播放停止了，所以传递的时候要把这两者一起传过去。 另外，需要考虑的是转场动画，这里就不详细描述了。 这里查看了其他一些视频app bilibili 在视频切换的时候有明显卡顿 斗鱼、爱奇艺 在视频切换时，转场动画或多或少有些小问题 乐视 没有转场动画 腾讯视频、优酷 表现最好","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"AVFoundation","slug":"AVFoundation","permalink":"http://djs66256.github.io/tags/AVFoundation/"}]},{"title":"聊聊移动客户端开发中的git工作流","date":"2017-04-10T14:03:34.000Z","path":"2017/04/10/2017-04-10-聊聊移动客户端开发中的git工作流/","text":"现在git已经是我们日常开发必备工具，那么在移动客户端的日常开发中，应该怎样去管理git分支呢，是否目前普遍的几种工作流就可以满足目前的情景呢？ git flow最官方的流程，包含的主要分支有如下几个： master 也就是发布分支 develop 也就是开发分支，上线的时候会把develop合并到master feature 特性开发分支，每一个功能都会拉一个分支出去开发，完成后合并到develop，并删除自己 bug fix 日常的bug修复分支，这个是从master分支拉出来的，所以合并的时候要合到develop和master上，比较麻烦 按照以上说法，流程也是比较清晰明确，大致如下 12345678910111213141516171819 develop master * | ---------| | / | |feature1 | * | | |* | *| * /|* / | / || feature2 | bug-fix |* | | | || * | * || * | / \\ || \\ * -------/ \\ | \\ * * --------- * | |\\ | | \\----------- * release | | github flow 和 gitlab flowgit flow还是比较麻烦的，所以后来一些网站并没有推荐。 这两个工作流都是持续集成的模式，大致包含的分支如下： master 主分支，但是作用相当于git flow里面的develop，github flow也是release的分支 feature 或者说 merge request production 发布分支 功能分支和bug fix都是从主分支上拉出来改，再合并回去。流程上比git flow更加简单。 移动端现状但是以上几种真的适合目前我们的开发吗？ 首先来分析下git flow的应用场景。linux这种大型项目，人员分布于世界各地，而每一次发布的功能又非常的多，为了保证所有人的协同工作不会出现任何偏差，所以他们采用了git flow这种工作流。 这类项目有着如下特点： 每一次发布的周期很长，而且其中的bug fix会以单独的小版本或者补丁形式发布出来 每一次发布所更新的功能并不是固定的，哪些feature完成了，才会考虑合并入系统，而没有完成的继续开发，会在下一次版本发布时再考虑 每个feature之间的关系比较独立，相互间不会产生很大的影响 linux为了解决自身庞大的系统的情况，在git flow外面再套了一层git flow，有着相当严格的代码审查制度，这个是后话了。可以看出如果是一个瀑布型开发场景，还是非常合适的，但是我们目前的移动开发几乎都是敏捷开发。 再来看看github flow和gitlab flow 他们自身是一个开放的交流平台，为了增进大家的交流，就必须加快和简化发布，时刻让主分支保持最新 为了给大家共同开发提供条件，发明了merge request，如果被采纳，需要尽快的合并到主分支上 托管的项目大部分是小型项目，没有开发计划和排期要求，所以就很难有如此明确的版本，所以基本上是每个特性都会有一个发布，也就没有必要整一套严格的审查制度 这个比较适合网站这类的开发，当完成新特性后，马上就可以展示给用户，并不需要卡时间点。 目前状况 目前大家一般都是敏捷开发，最长一个月，最短2个星期就会有一个新版本 每一期的新特性多，但是功能点却非常细小，而且会有很多的优化 bug修改完以后一般不会立刻发小版本来专门修复bug，一般会在下一个版本中修复 所以git flow对于现在的情况来说太慢了，而且导致分支间切换太频繁。但是其他几种又不能很好的区分版本，所以我们需要自己的工作流程。 1234567891011121314151617181920 master ---------------- * / | v1.0 | | ------- * * / | / | bugfix |feature-x * | | | * * | * * / * \\ * ---- / | * v1.1 | test * | | \\ | | -----------+-- * release | * * / | test * | \\ | - * release 每个版本都从master上拉一个版本分支，此版本的所有改动都在这个分支上进行，此时这个分支就像是github flow的master，保持持续集成，如果功能点比较大，可以考虑在版本分支上拉功能分支进行开发。 bugfix一般直接修改在版本分支上，也可以从master上拉分支，最后合并到版本分支上，这样做是考虑到版本交替的时候可以方便处理bug。 测试和打包都在版本分支上，发布以后合并到master 这样看上去似乎比其他几个复杂，但是实践下来应该说更加简单。 我们很少存在并行开发的情况，所以每个版本几乎都是串行排列的，很少出现交叉的情况 我们的功能点很小的时候没有必要拉一个新的分支，可以直接修改到版本分支上，不需要专人合并 feture分支一般为个人开发分支，一个人来维护合并和删除，也会简单很多 这样每个版本的代码分支完全独立开来，更直观的区分不同版本间的代码进度 减少了日常工作中需要频繁切换分支的状况 可以让CI系统直接对接版本分支，大家可以第一时间得到该版本的最新包 所以正常的使用中，可见的分支为master和版本分支，会比上图简单很多。 但是这样做的缺点是无法明确的区分feature，如果需要去掉某一个功能的时候会比较麻烦，基于每次的迭代都是相对明确，不太可能出现功能回退的情况，所以不存在这种问题。 总的来说，适合的才是最好的。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://djs66256.github.io/tags/git/"}]},{"title":"自己写的一个埋点管理小工具","date":"2017-04-09T09:29:23.000Z","path":"2017/04/09/2017-04-09-自己写的一个埋点管理小工具/","text":"前言在很多项目中，埋点数据使用表格来统计的，随着项目的进行，数据量越来越复杂，越来越难以维护。所以很多公司都已经开发了一整套系统，从埋点的录入到代码的输出。由于很多时候一套系统对于一个小项目来说太过于复杂了，所以这里我做了一个轻量级的本地管理客户端。https://github.com/djs66256/lily Star 功能简介启动由于我们实现的是一套本地管理的系统，所以我把程序系统和数据分开了，所以启动的时候需要选择对应的数据目录，比如本项目目录下的/demo-data/，以微信为例。关于目录下文件功能格式会在之后说明。 主界面启动之后，我们可以看到我们的埋点数据界面，这里我根据我们的需求把数据分为3类： 事件-数据点 页面 具体参数 数据点包含所有埋点信息，参数是由参数列表选择，可以查看历史和进行编辑。 页面包含了我们的所有页面id，因为一个普通的App拥有的页面不会有太多，所以页面的分级可以少一点。 参数包含了我们埋点过程中所有遇到的参数，考虑到我们项目中所涉及到的参数比较统一，所以就没有进行分类 每行数据的每次改动都会形成一条记录保存在本地，这样我们就可以追溯历史变更了。这里还把所有参数都列了出来，而不是主页面精简后的了。由于性能问题，这里暂时只显示了最近50条记录。 以上所有列表的数据项都是动态可配的。在设计之初，考虑到数据内容可能会根据需要动态调整，所以把所有内容都设计为动态可配的了，又为了在磁盘上的数据的可读性，把所有数据都采用文本json保存，这样也兼容了动态的数据，具体实现后面会详细讲解。 当选择了一个目录后，点击导航栏的创建可以创建一条新的数据，数据格式内容根据根目录属性配置。 点击一行列表后的编辑按钮进入编辑页面，每次保存都会产生一条修改记录。 可选的参数为在根目录为参数内的所有内容，这样设计的原因是为了未来可能对埋点数据的自动化验证，从而需要一个格式化的参数列表，而不是一段文字描述。 为了可以对埋点的整理归类，所以做了简单的搜索功能，可搜索字段也是根据事件目录的配置。 所有搜索字段都是使用正则表达式完成，所以如果需要更复杂精确的匹配，这里也可以输入一段正则来匹配。 点击编译，会把所有事件和页面数据自动生成一份代码，这里是根据需要定制的，所以我只做了iOS的一个样例格式。这里我们从老数据转化过来的时候有重复埋点，所以在转化的逻辑中加入了去重，关于自定义和接入编译系统之后会详细描述。 进阶–配置参数以demo-data数据配置为例。 数据分类在所有的数据中，概念都是节点Node，根据功能分为两类： 目录节点DirNode，负责分级和归类。 数据节点StatNode，负责记录每个数据的具体内容。 文件持久化实现所有数据持久化通过json格式保存为文本文件，所以可以直接查看文件内容。 按照层级结构创建一样的目录层级结构，每个DirNode下面都有一个config.json文件，包含该节点信息。 在最底层每个StatNode会产生一个目录，目录下会根据历史生成1.json，2.json，3.json名字依次递增的文件，保存每次修改后的数据。这里目录名字使用id来命名是为了解决数据埋点id可能存在重名的问题。 只能在目录的最底层可以创建数据，这是为了解决展示时候的难以同时展示数据和目录的问题。 文件持久化格式每个文件中都需要具备一些基础属性： name外部显示的名字，对于目录节点则是目录名字 id要求唯一的id，由于DirNode个数比较少，而且固定，所以没有设计创建的功能，自己修改时需要保证唯一。数据节点则会生成一个MD5来填充。 isDirectory表示是否是DirNode 目录节点格式包含一个columns数组，这是一个非常重要的配置，除了基础属性，所有StatNode里的数据项都是根据该字段动态生成。 这里是一个事件节点例子： 123456789101112131415161718192021222324[ &#123; &quot;type&quot;: &quot;text&quot;, // 字段类型（暂时只支持text和param） &quot;required&quot;: false, // 是否必填 &quot;title&quot;: &quot;描述&quot;, // 展示的列名 &quot;key&quot;: &quot;description&quot;, // 对应于json中的key值 &quot;visible&quot;: true, // 在主界面是否隐藏 &quot;editable&quot;: true, // 是否可编辑，在编辑和创建界面是否可见 &quot;searchable&quot;: true // 是否可以作为搜索参数，影响搜索界面 &#125;, &#123; &quot;type&quot;: &quot;params&quot;, &quot;paramsKey&quot;: &quot;params&quot;, // 如果是param类型，需要指定`DirNode`的id &quot;required&quot;: false, &quot;title&quot;: &quot;参数&quot;, &quot;dataIndex&quot;: &quot;params&quot;, &quot;key&quot;: &quot;params&quot;, &quot;visible&quot;: true, &quot;editable&quot;: true, &quot;searchable&quot;: false &#125;] 可以动态增加或者修改数据项，这样会非常灵活而且可以不通过修改代码就配置数据内容。 节点间的columns是可以被继承的，也就是说子目录的columns必定包含父目录的所有数据内容。可惜目前的使用场景并没有这个要求。 所有其他目录的配置都是类似的。 数据节点格式同样看一个例子 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;点赞&quot;, &quot;statId&quot;: &quot;onPraise&quot;, &quot;description&quot;: &quot;包括3D touch页面&quot;, &quot;version_iOS&quot;: &quot;1.0&quot;, &quot;version_Android&quot;: &quot;1.1&quot;, &quot;createTime&quot;: &quot;2017-04-03T12:22:38.372Z&quot;, &quot;params&quot;: [ &#123; &quot;name&quot;: &quot;用户ID&quot;, &quot;description&quot;: &quot;&quot;, &quot;createTime&quot;: &quot;2017-04-03T11:59:13.467Z&quot;, &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;814db1c837ac436ebb569d3554b51fb1&quot;, &quot;paramId&quot;: &quot;userId&quot; &#125;, &#123; &quot;name&quot;: &quot;朋友圈状态&quot;, &quot;createTime&quot;: &quot;2017-04-03T12:14:06.676Z&quot;, &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;866982e498224b15aa4602f2893f7995&quot;, &quot;paramId&quot;: &quot;timelineId&quot; &#125; ], &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;9b538d5bee1c40ed979e5a38143a9829&quot;&#125; 所有数据都是根据上述配置生成，其中param比较特殊，是把选择的数据节点直接拷贝了一份，这样做的原因是怕其他地方修改或者删除了导致数据不一致的问题，这样做更符合埋点这个需求。 接入编译系统目前编译系统还是做在了代码中，由于系统本身是有NodeJS实现的，所以要动态配置编译系统还是非常简单的。 编译系统比较开放，这样可以开放更多的功能，但同时也引入了数据风险，之后需要改进下，让编译系统可以动态接入，并且屏蔽内部数据和编译系统的直接联系。 目前代码放在/script目录下。 开发者这里对整个系统的代码逻辑进行说明。 设计理念 最基本的功能，需要能够在团队内共享数据，其中最方便的就是利用git系统了，所以在每次修改数据的时候除了本地持久化以外，会自动同步git上的数据文件，这也是为什么要数据分离的一个原因。 如果能够接上埋点系统，那么可以通过该系统去分析结果，这个工作量可能会比较大，是一个设想。 如果能够接上自动化测试或者设备，就能够验证埋点数据是否正确，这个的工作量也可能会比较大。 目前完成了最基础的管理埋点和生成代码功能。 运行环境nodejs Mac可以通过brew install nodejs来安装 需要electron和webpack 1npm install -g electron webpack 运行代码首先npm install 然后需要链接本地库 1234cd dd-statnpm linkcd ../statnpm link dd-stat 最后 12npm run dev #开启webpack -wnpm run app #启动应用 代码简介dd-stat是系统的数据层，包含了数据结构和持久化。 stat是界面层，为了实现简单，目前所有逻辑都是在渲染层做的，因为我们的数据量按照我们的需求是不太可能达到如此大的数目，是不太可能出现性能问题的。 stat依赖支付宝的ant design框架来搭建，最初是用redux来组织(/lib)，后来发现太过于复杂，应用本身就是个简单的场景，所以后来改为react-router来组织(/lib2)。 /script是数据编译的代码，是导出编译后代码或者导出其他格式的一个出口，可以根据需要扩展。 TODOgit接入最初的想法是让程序来自动同步git，因为应用的使用场景比较简单，不太可能出现多人同时编辑同一个数据的问题，所以让程序来自动同步数据是最好的，由于时间问题，暂时没有加入。 编译系统完善现在编译系统是和应用代码捆绑在一起的，最好能够脱离代码，并且可以动态配置编译模板。 更多可配的数据类型增加对bool，枚举单选，枚举多选，时间等的支持，项目暂时还没有这样的需求。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"埋点","slug":"埋点","permalink":"http://djs66256.github.io/tags/%E5%9F%8B%E7%82%B9/"},{"name":"工具","slug":"工具","permalink":"http://djs66256.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"美学的表现层组件化之路","date":"2017-04-09T09:21:49.000Z","path":"2017/04/09/2017-04-09-美学的表现层组件化之路/","text":"在很多以内容为主的应用中，比如考拉、严选，以及我们美学，界面内容通常比较复杂丰富，一个页面通常分为多个模块，各个模块之间独立性强，这样势必一个controller里面会有很多很多代码与逻辑来处理模块组合，导致代码日益膨胀。 这是一个表现层模块化组件，按照页面视觉结构，将一个页面划分为多个模块，然后通过模块间的简单组合，来实现复杂页面。并且将部分逻辑功能放到了对应组件，以达到复用与使用简单的效果。 目前，我们大部分展示型页面controller只有请求相关代码，基本能够控制在200行左右。 后来发现IGListKit和我们的思想非常类似。IGListKit简析与DDComponent 背景：由于我们的项目处于一个比较早期的阶段，所以我们需要很多的尝试来改良我们的方案。所以在这期间的页面结构极不稳定，内容以及位置顺序等，都可能会发生较大变化。事实上，在1.0之后的3个版本中，每个版本的首页都在大改。 如下我们的一个首页版本，模块非常明显，并且在其他页面也会使用到类似模块。 用户内容的高自由性，大部分内容为用户选填，如果内容缺省，需要删掉该行，所以需要动态计算布局也是非常麻烦。如下除了用户和产品，都是可选内容，不可控因素太多。 可以看出，我们的内容可能会达到一个非常大的级别，此时性能也会是一个问题，必须采用视图重用才可以避免内存问题。 同时，不同模块的加载可能是异步的，返回结果也可能不同，需要部分显示空态、错误等提示，这样又进一步导致了页面的复杂性。 接下来，我们一个个的解决这样的问题。 方案布局选型与重用问题：一种是tableView来实现这些类似于列表的功能，另外一种是使用CollectionView来实现同样的功能。 虽然分别实现了这两种对应方案，但是最终使用最多的还是CollectionView，有几个原因： CollectionView的布局是一次性算出来的，会有缓存，相当于性能优化 模块间的间距控制，CollectionView更加灵活，不需要调整cell就可以改变间距 可以看到我们的模块并不一定一行只有一个元素（比如首页），也不一定一个模块只有固定行数（比如上图的标签模块），如果使用tableView，还是会需要复杂的计算，而使用CollectionView，我们可以控制每个cell为最小的单位。 组件间组合与顺序问题有需求是服务器控制组合与顺序，所以这是我们首先需要解决的问题。所以这里引入两个概念： 1，视图组件： 只负责视图展示，比如一个包含小列表的模块，或者仅仅只有一个元素的模块。只负责职责内的视图展示。2，容器组件： 只负责组件间的组合，比如按照顺序或者空态等组合模式，当然最顶层的一个组件也是一个容器类组件。 这里容器类组件可以包含任意视图组件及容器类组件，而视图组件不能作为组合使用（这里有个特例HeaderFooterSectionComponent，其实提供了部分容器的概念，可以配置header和footer，一个细化）。 职责明确之后，我们就可以通过这种从属关系来任意组合我们的组件，如果不需要显示该视图，可以从容器组件中移除该组件或者将numberOf返回0个。 空态页、错误页等有了上一个的两个概念，处理这两个问题就变得简单了。抽象的来说，就是组件依据不同状态，而分别展示不同的子组件。相当于增加一层组件，该组件的功能是控制展示当前子组件。 那么设计一个状态与组件间对应的字典，在需要的时候切换该状态就行了，这就是后来增加的StatusComponent。 布局的多样化可能有些页面需要内容元素需要居中显示，或者FlowLayout默认的居左显示（多行的时候，除最后一行外为两端对齐模式），又或者需要永远居左显示（比如我们的标签）。 当选择了CollectionView作为方案时，这个问题就很好解决了，不需要改动component代码，只需要创建的时候输入自定义的Layout就可以轻松改变布局了。 实现按照以上的分析结果，最终实现了一套组件化实现方案（TableView结构类似，这里不做说明），源码大家自己看吧，就不介绍了： 上图蓝色的是视图组件，黄色的是容器组件。Group类型为顺序组合，Status组件为状态型组合。 请不要问我组件该怎么写，和写一个只有该模块内容的CollectionView一模一样，不会请参考苹果官方事例吧~ 使用流程 其中红色部分为日常开发需要真正关心的，可能需要写代码的部分，其他均由组件化解决，减少了开发一个新页面的成本。 Demo以我们的首页推荐为例，虽然我们的首页内容多而且复杂，但是Controller代码也在200行左右。下面来看看一个主要流程： 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // 外层容器结构 self.sectionGroupComponent = [DDCollectionViewSectionGroupComponent new]; self.statusComponent = [MZCollectionViewStatusComponent defaultComponent]; self.statusComponent.normalComponent = self.sectionGroupComponent; self.componentArray = @[self.statusComponent];&#125;MZHomeRecommendRequest *request = [[MZHomeRecommendRequest alloc] init];[request startWithBlock:^(MZHomeRecommendRequest *request, NSError *error) &#123; // 网络请求回来后首先判断状态，来切换空态页或者错误页，其实这里还可以加入loading页 if (!error) &#123; if (request.response.banners.count &gt; 0 &amp;&amp; request.response.groups.count &gt; 0) &#123; self.statusComponent.currentState = MZCollectionViewStateNormal; // 正常数据会根据数据来生成对应的component self.sectionGroupComponent.subComponents = [self componentFromData:request.response.groups]; &#125; else &#123; self.statusComponent.currentState = MZCollectionViewStateNoData; &#125; &#125; else &#123; self.statusComponent.currentState = MZCollectionViewStateError; self.statusComponent.errorComponent.title = error.localizedDescription; self.statusComponent.errorComponent.delegate = self; // 这里点击重新加载 &#125; [self.collectionView reloadData]; &#125;]; 再来看看单个component的结构，和一个单一元素的collectionView非常相似。1234567891011121314151617181920212223242526272829303132333435- (void)prepareCollectionView &#123; [super prepareCollectionView]; // 由于依赖collectionView，所以还是需要注册 [self.collectionView registerClass:MZRepoNormalStyleCollectionViewCell.class forCellWithReuseIdentifier:NSStringFromClass(MZRepoNormalStyleCollectionViewCell.class)];&#125;#pragma mark - UICollectionView- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return 1;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return self.repos.count;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; MZRepoNormalStyleCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass(MZRepoNormalStyleCollectionViewCell.class) forIndexPath:indexPath]; // config... return cell;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath &#123; return size;&#125;- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; [collectionView deselectItemAtIndexPath:indexPath animated:YES]; // push detail view controller&#125; 如何控制组件的顺序以及显示特性呢？ [self componentFromData:request.response.groups]，在我们组装视图组件时，可以随意调整组件的顺序，控制组件的显示，而无需关系兄弟组件的情况。 123456789- (NSArray *)componentFromData:(NSArray *)data &#123; NSMutibleArray *retArray; forEach switch (data[index].type) &#123; case type1: // add to array ... case type2: // add to array ... &#125;&#125; 扩展性在一些场景下，我们需要额外的delegate方法来满足我们的需求，比如我们的居左对齐和左划删除，需要把这些事件传入最终的视图component也很简单，只要扩展上面几个容器类组件的方法即可： 1234567891011@protocol MZRepoAlignLeftCollectionFlowLayoutDelegate &lt;UICollectionViewDelegateFlowLayout&gt;@interface DDCollectionViewSectionGroupComponent (MZRepoAlignLeftCollectionFlowLayout) &lt;MZRepoAlignLeftCollectionFlowLayoutDelegate&gt;- (BOOL)collectionView:(UICollectionView *)collectionView shouldAlignLeftAtSection:(NSInteger)section &#123; DDCollectionViewBaseComponent *comp = [self componentAtSection:section]; if ([comp respondsToSelector:@selector(collectionView:shouldAlignLeftAtSection:)]) &#123; return [(id&lt;MZRepoAlignLeftCollectionFlowLayoutDelegate&gt;)comp collectionView:collectionView shouldAlignLeftAtSection:section]; &#125; return NO;&#125; 按照这样的思想，就具有了高度的可扩展性。 一个对比 Facebook ComponentsKitFacebook 优点： 完全实现了自己的一套布局系统，粗略的看了下，反正没看懂(⊙﹏⊙) 能够很好的实现流式布局，类似于iOS的stack，或者说更像网页的flex布局（视图重用性应该不好） 缺点： 完全颠覆了原生的布局方式和代码习惯，学习成本高 C++编写而成，所以需要Objective-C++来编写，必须承认C++还是很难掌握的 美学 优点： 和原生CollectionView代码保持一致，学习成本低 从以前代码的转换成本低，我们也是一步步从原来的代码转到组件化的 缺点： 刷新数据需要重新计算整个Layout，此时会有性能损耗（这个要看数据量和视图复杂度，通常发生在页面切换，请求回来的时候，其实此时用户感知不到） 需要按照CollectionView的写法来组建，因此部分接口需要暴露indexPath，如果乱用，可能会导致崩溃 目前到目前为止，美学大部分页面，都是采用组件化组合而成，随意数数，已经有超过100个组件了，接下来可能需要整理下组件，增加单个组件的复用性了。 历经几个版本，组件化目前已经是比较完善和稳定的一个版本了，也满足了目前所有的需求和日常开发，期间也接受了各种奇怪的需求，目前来看扩展性还是可以的，有疑问可以直接私密我。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"全局数据同步（二）UI篇","date":"2017-04-09T09:10:32.000Z","path":"2017/04/09/2017-04-09-全局数据同步（二）UI篇/","text":"上次讨论了如何让数据全局同步，但是在同步到UI层的时候还是有些麻烦。现在来解决UI层的问题。 之前的方案有两种： 在viewWillAppear的时候，reloadData，缺点是如果需要reload的数据太多，大量计算会导致阻塞主线程，虽然可能没有那么严重，但是有些时候还是能够感知出来。 使用KVO来监听变化，缺点是代码侵入性太强，而且严重影响了一些代码的统一性。 下面是使用KVO的一个例子： 123456789101112131415161718192021@weakify(self);[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(praiseCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.praiseCount = object.praiseCount;&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(praised)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); [self.recordTabbar setPraised:object.isPraised animated:self.view.window != nil];&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(collected)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); [self.recordTabbar setCollected:object.collected animated:self.view.window != nil];&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(collectCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.collectCount = object.collectCount;&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(commentCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.commentCount = object.commentCount;&#125;]; 上面是我们为了同步3个按钮的状态的代码，我们使用了一个第三方库来简化KVO的编写，但还是非常的冗余。 为此，开始思考有什么更简单的方法。 开始我们想要封装KVO，直接绑定数据和UI，但是很多数据并不是一一对应的，比如数字，状态，是需要转化的，而且状态变更很多情况下是需要动效的，所以无论如何都不免不了监听和转换这两个东西。 后来想，既然数据可以做全局同步，那么是否可以把视图也看作一种类型的资源，也自动同步该状态属性呢？按照这种思路，将视图改写支持这种方式来同步。 12345678@interface UIView (MZChannel) &lt;MZChannelProtocol&gt;// 我们需要在创建的时候就确定类型，而且不能修改，防止意料之外的情况- (instancetype)initWithFrame:(CGRect)frame channelType:(NSInteger)channelType;// 加入数据池中，并且内部增加了lock，保证线程安全- (void)bindId:(NSString *)id;// 为了避免与view自身属性冲突，增加了一个白名单配置- (NSArray&lt;NSString *&gt; *)channelWhiteList;@end 查看一下我们修改之后的状态 12345678910111213// RecordTabbar// 新增这两个方法，由于之前设计中的接口与该keyPath统一，所以其他内容不需要修改- (NSInteger)channelType &#123; return MZResourceTypeNote;&#125;- (NSArray&lt;NSString *&gt; *)channelWhiteList &#123; return @[NSStringFromSelector(@selector(praised)), NSStringFromSelector(@selector(praiseCount)), NSStringFromSelector(@selector(collected)), NSStringFromSelector(@selector(collectCount)), NSStringFromSelector(@selector(commentCount))];&#125; 12345678910111213141516171819// 部分对应的setter方法- (void)setPraised:(BOOL)praised &#123; _praised = praised; [self.praiseButton setPraised:praised animated:self.window != nil];&#125;- (void)setPraised:(BOOL)praised animated:(BOOL)animated &#123; _praised = praised; [self.praiseButton setPraised:praised animated:animated];&#125;- (void)setPraiseCount:(NSInteger)praiseCount &#123; _praiseCount = praiseCount; self.praiseButton.praiseCount = praiseCount;&#125;- (void)setCollected:(BOOL)collected &#123; [self setCollected:collected animated:self.window != nil];&#125; 由于该页面资源id并不会变化，所以只需要在初始化的时候绑定一次id就可以了。 1[self.recordTabbar bindId:self.record.id]; 这样我们的后半部分流程（从数据到显示）也完整了，整个流程都依赖于MZChannel进行。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"数据同步","slug":"数据同步","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"}]},{"title":"客户端全局数据同步方案(一)","date":"2017-04-02T13:14:27.000Z","path":"2017/04/02/2017-04-09-客户端全局数据同步方案一/","text":"很多时候产品们都有一些奇奇怪怪的想法和要求，这里我们就有一个需求，要求我们应用里面所有的用户行为数，比如阅读数、点赞数、评论数和关注、点赞状态等全局同步，一旦有变更要求全局更新显示。 准备开始我们考虑了一种方案，创建一个池子，所有同一类型的Model都存放在池子里面，使用时优先在池子里面取，不存在时创建并加入池子。这样我们就能够确保我们应用里面的所有“同一对象”，是真正的同一个对象。 但是这样做也存在很多问题： 当这个需求提出来开始做的时候我们的应用已经基本成型，很多接口和model并没有统一，如果要采用这种方案必然需要大改。 这样做势必会导致model的冗余属性。 接口有些时候放回相同字段，但是意义不一致。 第三方库的支持。比如YYModel的解析需要修改很多地方才能使用。 所以考虑了以下的方案。 方案思路保持一致，将需要同步的对象加入全局的池子。但是各自创建各自的对象，在需要全局同步的时候，提交该对应的keyPath，然后更新池子中拥有相同类的成员。在view层，使用KVO监听变化。 缺点： 由于根据了类名来作为判断该对象是否属于同一对象，所以继承或者拥有不同类名的“同一对象”并不能被识别为相同的。 在我们已经比较完善的项目中，要做这样的统一，几乎是不可能的，所以特例化了部分场景，来满足我们当前的需求。 方案优化版 我分析了我们应用中需要使用到全局同步的对象，可以分为几种类型（比如动态、评论等），并不会存在特别复杂的类型。而且每种类型必定会存在一个唯一的ID，所以觉得可以通过type和ID来唯一确定是“同一个对象”。 所以将结构修改为下，所有需要支持全局同步的类都需要实现下面的协议。 12345678910@protocol MZChannelProtocol &lt;NSObject&gt;@property (readonly, nonatomic) NSString *id;@property (readonly, nonatomic) NSInteger channelType;@optional// 提供一个keyPath转换的方法- (NSString *)translateKeyPath:(NSString *)keyPath;@end 接口设计如下 12345678910@interface MZChannel : NSObject+ (instancetype)sharedChannel;// 需要在类创建完之后加入池子，一般在init方法中- (void)addObject:(id&lt;MZChannelProtocol&gt;)obj;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value;@end 同时在使用KeyPath的过程中需要判断是否合法，防止某些对象不存在该成员而crash。 1234567891011121314151617181920212223242526// 这里使用set方法来判断是否可以同步，所以实际上只要实现了对应的set方法就可以了，并不需要实际的property。- (BOOL)canPerformKeyPath:(NSString *)keyPath newKeyPath:(out NSString **)aKeyPath &#123; if ([self conformsToProtocol:@protocol(MZChannelProtocol)] &amp;&amp; keyPath.length &gt; 0) &#123; id&lt;MZChannelProtocol&gt; cself = (id&lt;MZChannelProtocol&gt;)self; if ([cself channelType] &lt;= 0) &#123; return NO; &#125; NSString *selectorStr = [NSString stringWithFormat:@&quot;set%@%@:&quot;, keyPath.firstLetter.uppercaseString, [keyPath substringFromIndex:1]]; if ([self respondsToSelector:NSSelectorFromString(selectorStr)]) &#123; return YES; &#125; else if ([cself respondsToSelector:@selector(translateKeyPath:)]) &#123; NSString *transKeyPath = [cself translateKeyPath:keyPath]; if (transKeyPath) &#123; if (transKeyPath.length &gt; 0) &#123; selectorStr = [NSString stringWithFormat:@&quot;set%@%@:&quot;, transKeyPath.firstLetter.uppercaseString, [transKeyPath substringFromIndex:1]]; if ([self respondsToSelector:NSSelectorFromString(selectorStr)]) &#123; if (aKeyPath) *aKeyPath = selectorStr; return YES; &#125; &#125; &#125; &#125; &#125; return NO;&#125; 池子的实现，把整个池子分为若干桶，每个桶的key为相应的type，桶使用weak类型的hashTable来实现存储。 这里需要注意的是一些多线程可能导致的问题，所以在更新操作中使用了锁。由于我们应用内“同一对象”和“同类型对象”的数目预估应该存在不超过1000个，所以不需要考虑性能问题，也就可以在主线程中同步数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@interface MZChannelObject : NSObject@property (assign, nonatomic) NSInteger type;@property (strong, nonatomic) NSHashTable&lt;id&lt;MZChannelProtocol&gt;&gt; *hashTable;@property (strong, nonatomic) NSLock *lock;- (void)addObject:(id&lt;MZChannelProtocol&gt;)object;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value;@end@implementation MZChannelObject- (instancetype)init&#123; self = [super init]; if (self) &#123; _hashTable = [[NSHashTable alloc] initWithOptions:NSPointerFunctionsWeakMemory capacity:0]; _lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)addObject:(id&lt;MZChannelProtocol&gt;)object &#123; [self.lock lock]; [_hashTable addObject:object]; [self.lock unlock];&#125;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value &#123; if (type == self.type) &#123; [self.lock lock]; for (NSObject&lt;MZChannelProtocol&gt; *obj in _hashTable) &#123; NSString *aKeyPath = nil; if ([obj.id isEqualToString:id] &amp;&amp; [obj canPerformKeyPath:keyPath newKeyPath:&amp;aKeyPath]) &#123; dispatch_block_t updateValue =^() &#123; if (aKeyPath) &#123; [obj setValue:value forKey:aKeyPath]; &#125; else &#123; [obj setValue:value forKey:keyPath]; &#125; &#125;; if ([NSThread currentThread].isMainThread) &#123; updateValue(); &#125; else &#123; // 防止KVO刷新页面的时候的子线程操作UI dispatch_sync(dispatch_get_main_queue(), updateValue); &#125; &#125; &#125; [self.lock unlock]; &#125;&#125;@end 使用12345678910111213141516171819@interface MZUser : NSObject &lt;MZChannelProtocol&gt;@property (strong, nonatomic) NSString *id;@end@implementation MZUser- (instancetype)init&#123; self = [super init]; if (self) &#123; [[MZChannel sharedChannel] addObject:self]; &#125; return self;&#125;- (NSInteger)channelType &#123; return MZResourceTypeUser;&#125;@end 在请求关注或者取消关注的时候触发同步 123[user emitKeyPath:NSStringFromSelector(@selector(followed)) forValue:@(YES)];或者[[MZChannel sharedChannel] emitType:MZResourceTypeUser id:user.id keyPath:NSStringFromSelector(@selector(followed)) forValue:@(YES)]; 然后使用KVO来观察对象变化 123[self.KVOController observe:_user keyPath:NSStringFromSelector(@selector(followed)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZUser *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; // update UI ... &#125;]; 缺点虽然实现了全局同步，但是由于使用了统一的池子，会导致DEBUG困难。 需要实现人工判断更新的内容。 KVO不能判断该更新是用户操作引起的，还是由其他对象变更引起的。这里可能涉及到行为动画，但是我们的业务场景不可能一个页面出现两个相同的内容，所以并没有什么影响。 虽然可以使用KVO来实现同步UI的更新，但并没有做到和MVVM一样的同步更新，还是需要人工处理更新逻辑。 有一定的代码侵入性，需要继承协议，并且在初始化的时候加入池子。 总结这里限制了一部分的使用场景，来满足了特定环境下的需求，希望能给其他需要同步数据的场景一个方法。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"数据同步","slug":"数据同步","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"}]},{"title":"最近一年总结","date":"2017-04-01T13:14:27.000Z","path":"2017/04/01/2017-04-01-最近一年总结/","text":"2016年，加入了网易一个半创业项目。为什么会说是半创业项目呢？首先，这是一个从0开始的项目，网易内部也没有类似的产品线。但是依靠着丁磊爸爸，不像其他创业项目一样，至少不愁吃喝。 从最开始的4个人，现在已经发展到产品团队已经达到50人左右的规模了。期间也出现了很多创业团队类似的问题和弯路，到现在也算是平稳的发展了。 由于之前一直处于鸡血状态，最近才开始稍微闲下来，可以开始写一些东西，所以打算先把最近一年的事情慢慢总结一下。 工作方面跟随着项目进行，亲自从0开始构建一款应用，一步步探索，小心翼翼的技术选型，然后又进行了多次的重构。第一次能够从一个真正的创作者身份来看待很多问题，当自己的身份发生改变之后，自己的一些视野和观点也产生了一些变化。 技术技术很重要，一个厉害的程序员，真的有时候能顶好几个人，而且前期架构好的东西，到后期维护的成本就会很低，但是前期就是临时方案的东西，到后面维护成本会非常高。 专业的人做专业的事。虽然现在很流行全栈工程师，的确全栈的人可以是一个很厉害的程序员，但我还是推荐做自己擅长的事情。毕竟人的精力有限，一个经验丰富的普通程序员，会更适合，经验还是能够决定很多事情的。 想法，新的项目需要新的想法和创新，老的东西虽然可靠，但不一定合适，而且你要考虑到整个团队的接受程度，不能单纯的从自己的经验出发，每个人的想法都是有利弊的，除非你有自信自己的水平能够高几个等级。 重构，项目需要持续的重构，在不停的堆叠功能的时候，就会有很多的临时或者兼容方案，当这样的方案在你能够控制的时候，需要及时的进行重构，不然很快你就会陷入项目的泥潭。这需要领导者有足够的眼光和开发者有足够的魄力。我做的部分重构甚至不是在工作时间做的。 统一，每个开发组的成员需要尽可能的统一。老生常谈的命名，代码习惯，以及一些设计方案，如果能够在整个组的角度去做的统一，那么每个人的效率和提高很多，沟通成本也会降低很多。 理解力，一定要去看对方的代码！需要去了解同组其他人的一些习惯和风格，去理解其他人的想法。很多时候当看完了别人的代码才能知道别人设计的精妙以及其中存在的一些坑，这样才能在自己使用的时候不会出现什么问题。 管理需要一个有话语权的领导者，能够把当前的一些情况真实的反馈给上层，“翻译”基层员工的一些想法和困难。只是报喜不报忧，或者只会把压力转移到下级的都不会给项目带来好的影响。 领导者还需要引领团队，但需要考虑到整个团队的情况，不能仅仅按照自己的想法进行，因材施教，分别对待才是一个优秀领导者所具备的。 管理是一个非常大的话题，很多时候不同岗位之间出现的矛盾需要管理者能够很好的协调，不论哪一方拿自己的需求来说事，都是有很坏的影响的，解决这类问题才是管理者所需要做的。 生活方面越来越觉得自己的身体素质在逐渐的下降，感觉已经不能像以前那么的拼了。养了一只猫，希望能够有一间自己的房子。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"社会化分享组件封装","date":"2016-07-03T13:14:27.000Z","path":"2016/07/03/2016-07-03-she-hui-hua-fen-xiang-zu-jian-feng-zhuang/","text":"社会化分享是大部分应用都会集成的模块，现在市场上也有很多的商业产品（友盟，shareSDK），但是很多时候我们还是需要自己的分享组件，同时也要支持第三方登录。 分享内容如果需要统一接口，必须首先统一分享内容，把几种比较常见的和共有的分享内容合并。以下是几种各个平台都比较统一的结构。构造分享内容的时候尽量填满所有的类型，来满足各个平台的不同需求。 12345678910111213141516171819typedef NS_ENUM (NSInteger, MZShareType) &#123; MZShareTypeUndefined = 0, MZShareTypeURL, MZShareTypeText, MZShareTypeImage&#125;;@property (assign, nonatomic) NSInteger shareType;@property (strong, nonatomic) NSString *title;@property (strong, nonatomic) NSString *detail;@property (strong, nonatomic) NSURL *URL;@property (strong, nonatomic) UIImage *image;@property (strong, nonatomic) UIImage *thumbImage;@property (strong, readonly, nonatomic) NSData *imageData; // &lt; 5M@property (strong, readonly, nonatomic) NSData *thumbImageData; 因为很多平台对缩略图有要求，而且大小不一致，这里我们可以在不影响质量的情况下取最小值。 12345678910111213141516- (UIImage *)thumbImageWithImage:(UIImage *)image maxPixelSize:(NSInteger)size forceCreated:(BOOL)forceCreated &#123; CFStringRef thumbnailCreatedKey = forceCreated ? kCGImageSourceCreateThumbnailFromImageAlways:kCGImageSourceCreateThumbnailFromImageIfAbsent; NSDictionary *options = @&#123;(__bridge NSString *)kCGImageSourceThumbnailMaxPixelSize: @(size), (__bridge NSString *)thumbnailCreatedKey : @YES&#125;; CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)UIImagePNGRepresentation(image), (__bridge CFDictionaryRef)options); CGImageRef thumbImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, (__bridge CFDictionaryRef)options); UIImage *UIThumbImage = [UIImage imageWithCGImage:thumbImage];CLEAR: CGImageRelease(thumbImage); if (imageSource) &#123; CFRelease(imageSource); &#125; return UIThumbImage;&#125; 第三方认证数据大部分都会有token和expireDate这两个参数，同样，也建立一个类来保存用户认证信息。 12@property (strong, nonatomic) NSString *token;@property (strong, nonatomic) NSDate *expireDate; 分享外观Manager这里我们采用尽可能的去分享的原则来处理。只要支持这种类型，并且安装了app的就显示分享。 1234567891011+ (BOOL)openURL:(NSURL *)url;// 所有对该分享对象可用的分享类型+ (NSArray&lt;ShareInterface *&gt; *)avaliableInterfacesForShareItem:(ShareItem *)item;+ (void)share:(ShareItem *)item delegate:(id&lt;ShareDelegate&gt;)delegate;// 所有可用的认证类型+ (NSArray&lt;AuthInterface *&gt; *)avaliableInterfacesForAuthentication;+ (void)authWithInterface:(AuthInterface *)interface delegate:(id&lt;ShareDelegate&gt;)delegate;+ (void)logout; // 注销所有的认证账号 分享接口我们需要统一不同类型的分享 12345678910111213141516171819+ (BOOL)canShareItem:(MZShareItem *)item; + (BOOL)canShareText;+ (BOOL)canShareImage;+ (BOOL)canShareURL;+ (BOOL)supportAppInnerShare;+ (BOOL)requiresAuthentication;+ (BOOL)isLogin;+ (BOOL)needLocalApplication;+ (BOOL)isApplicationInstall;- (BOOL)openURL:(NSURL *)URL;- (instancetype)initWithItem:(MZShareItem *)shareItem;- (void)send;- (void)notifySuccess;- (void)notifyFailureWithMessage:(NSString *)error; 123// Delegate- (void)shareDidSucceed:(MZShareInterface *)interface;- (void)shareDidFail:(MZShareInterface *)interface error:(NSError *)error; 认证接口注意事项这里最大的注意事项是，我们不能确保整个流程是否能够完全的走完。当跳转到其他应用的时候，用户并不一定回调回来，可能关闭或者做其他事情去了，这时候我们要在应用再次被唤起的时候，把当前的状态重置。由于这里我们不知道最终结构，所以我只能作为失败来处理。 123456789[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidBecomeActiveNotification:) name:UIApplicationDidBecomeActiveNotification object:nil];- (void)applicationDidBecomeActiveNotification:(NSNotification *)noti &#123; if (_status == MZShareInterfaceStatePendingShare) &#123; [self notifyFailureWithMessage:@&quot;分享失败&quot;]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"},{"name":"社会化分享","slug":"社会化分享","permalink":"http://djs66256.github.io/tags/%E7%A4%BE%E4%BC%9A%E5%8C%96%E5%88%86%E4%BA%AB/"}]},{"title":"从UITextView看文字绘制优化","date":"2016-06-23T01:39:50.000Z","path":"2016/06/23/2016-06-23-cong-uitextviewkan-wen-zi-hui-zhi-you-hua/","text":"最近有一个地方需要自定义文字编辑器，所以使用了iOS7开始支持的UITextKit来绘制，同时也遇到不少的坑，这里来说说我遇到的几个坑，以及解决方案。源码在Github。 UITextView 分段绘制原理分析首先，我们来看下NSLayoutManager里面的几个方法： 123456789- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin;- (void)invalidateDisplayForCharacterRange:(NSRange)charRange;- (void)invalidateDisplayForGlyphRange:(NSRange)glyphRange;- (void)ensureGlyphsForCharacterRange:(NSRange)charRange;- (void)ensureGlyphsForGlyphRange:(NSRange)glyphRange;- (void)ensureLayoutForCharacterRange:(NSRange)charRange;- (void)ensureLayoutForGlyphRange:(NSRange)glyphRange; 可以看出来，无论是绘制方法，还是布局方法，都是有个范围选择，由此可以知道，UITextView的绘制过程绝对不是一次性绘制（对比YYText)。重写该方法也可以看出来UITextView是分多段绘制的。 现在我们来简单的做几个实验： 重写- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin;,并使用该LayoutManager创建UITextView： 12345678DDAttachmentLayoutManager *layoutManager = [[DDAttachmentLayoutManager alloc] init];NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:CGSizeMake(frame.size.width, CGFLOAT_MAX)];textContainer.widthTracksTextView = YES;[layoutManager addTextContainer:textContainer];NSTextStorage *textStorage = [[NSTextStorage alloc] initWithString:@&quot;&quot;];[textStorage addLayoutManager:layoutManager];UITextView *textView = [[UITextView alloc] initWithFrame:frame textContainer:textContainer]; 放入一段足够长的文字，在我们滑动的过程中，UITextView会分多次调用draw方法，这样显著降低了损耗和提升了性能，把多次绘制过程分散到滑动的过程中。 以上是纯文本的结果，那如果我们放入其他类型的数据呢？在这里，我放入多个NSTextAttachment自定义类型的数据。重复以上的测试。 结果是，当缓慢下拉的时候，同样是分段载入的，而且attachment往往作为单独的一段来绘制。但是有个不同的地方就是，可以看到contentSize在变化，而且可以看到右边的进度条在接近底部的时候忽然间回到上面，并且变短了。 由此可知在开始的时候，UITextView会拥有一个预期的大小，在加载过程中如果碰到attachment导致这个大小不符合，就会将下面一段内容加入计算，重新得出contentSize。这样会给我们带来一些麻烦，不能准确的获得contentSize，导致一些bug，解决方案很简单，我们先看下面另一个问题。 如果我们进入的时候是在最后一行呢。同样也是有这样的逻辑，这样的逻辑对于自定义的AttachmentView来说会有很多的问题，最大的问题就是在contentSize变化的时候，subview位置错误。 如何解决这样的问题，只要我们强制让UITextView布局整个的富文本就行了。 1[self.textView.layoutManager ensureLayoutForCharacterRange:NSMakeRange(0, self.textView.textStorage.length)]; 自定义富文本编辑器首先我们需要实现自己的Attachment，主要功能是实现占位符的大小。 12345678910@interface DDTextAttachment : NSTextAttachment@property (copy, nonatomic) NSString *placeholderString;@property (strong, nonatomic) id data;@property (assign, nonatomic) BOOL fillWidth;@property (assign, nonatomic) UIEdgeInsets contentInset;@property (assign, nonatomic) CGSize size;@end 然后重写DDAttachmentLayoutManager 12- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin 在这里把需要展示的视图，按照位置贴到父视图上。 这样就是整个方案的思路，具体实现可以参考Github 内存优化方案最开始，我采用的是把所有的attachment view都实例化出来，再贴到textView上，但是当整个文章比较长，并且结构复杂的时候，会发现占用很多的内存，联想到苹果的分段绘制和tableView的reuse，我决定把整个框架改写为可重用的模式。 首先，我们模仿tableView定义接口。 12- (void)registerClass:(Class)cls forAttachmentViewWithReuseIdentifier:(NSString *)identifier;- (__kindof DDAttachmentReusableView *)dequeueReusableAttachmentViewWithIdentifier:(NSString *)identifier; 12// protocol- (DDAttachmentReusableView *)textView:(DDAttachmentTextView *)textView attachmentViewWithAttachment:(DDTextAttachment *)attachment; 然后，重写AttachmentLayoutManager绘制方法，在需要绘制的时候再去生成视图。 12345678910111213141516171819202122232425262728- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin&#123; [super drawGlyphsForGlyphRange:glyphsToShow atPoint:origin]; NSUInteger start = [self characterIndexForGlyphAtIndex:glyphsToShow.location]; NSUInteger end = [self characterIndexForGlyphAtIndex:glyphsToShow.location + glyphsToShow.length]; [self.textStorage enumerateAttribute:NSAttachmentAttributeName inRange:NSMakeRange(start, end - start) options:NSAttributedStringEnumerationLongestEffectiveRangeNotRequired | NSAttributedStringEnumerationReverse usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123; DDTextAttachment *attachment = (DDTextAttachment *)value; if ([attachment isKindOfClass:[DDTextAttachment class]]) &#123; NSUInteger glyphIndex = [self glyphIndexForCharacterAtIndex:range.location]; CGRect rect = [self boundingRectForGlyphRange:NSMakeRange(glyphIndex, 1) inTextContainer:[self textContainerForGlyphAtIndex:glyphIndex effectiveRange:NULL]]; // 这里才去生成视图 UIView *attachmentView = [self.attachmentDelegate attachmentLayoutManager:self viewForAttachment:attachment]; attachmentView.frame = CGRectMake(origin.x + rect.origin.x + attachment.contentInset.left, origin.y + rect.origin.y + attachment.contentInset.top, rect.size.width - attachment.contentInset.left - attachment.contentInset.right, attachment.size.height); attachmentView.hidden = NO; &#125; &#125;];&#125; 然后，重写contentOffset，在其变化的时候检测是否有视图需要显示，或者是否有视图已经移出屏幕。 123456789101112131415161718192021222324252627282930- (void)setContentOffset:(CGPoint)contentOffset &#123; [super setContentOffset:contentOffset]; CGFloat visiblePadding = 10; // 让他稍微大一点，可以早一点载入 CGRect visibleRect = CGRectOffset((CGRect)&#123;0, -visiblePadding, self.frame.size.width, self.frame.size.height+2 * visiblePadding&#125;, self.contentOffset.x, self.contentOffset.y); for (DDAttachmentReusableView *view in _attachmentViews) &#123; if (view.superview) &#123; // [1] if (!CGRectIntersectsRect(visibleRect, view.frame)) &#123; [view removeFromSuperview]; &#125; &#125; &#125; NSRange range = [self.layoutManager glyphRangeForBoundingRect:CGRectMake(0, visibleRect.origin.y+self.textContainerInset.top, visibleRect.size.width, visibleRect.size.height) inTextContainer:self.textContainer]; NSRange charRage = [self.layoutManager characterRangeForGlyphRange:range actualGlyphRange:nil]; [self.textStorage enumerateAttribute:NSAttachmentAttributeName inRange:charRage options:0 usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123; if ([value isKindOfClass:[DDTextAttachment class]]) &#123; for (DDAttachmentReusableView *view in _attachmentViews) &#123; // [2] if (view.superview &amp;&amp; view.attachment == value) &#123; return ; &#125; &#125; // [3] [self.layoutManager invalidateDisplayForCharacterRange:range]; &#125; &#125;];&#125; [1] 当视图不在屏幕显示区域内的时候，移出父视图 [2] 当视图在显示区域并且没有变化的时候不需要重用操作。 [3] 重用视图，要求重绘这个占位符。 这样，又会转移到绘制的地方，最终会调用reuse的代码。经过实验测试，原来可能实例化的很多视图，现在同时存在的一般维持在2个左右，大大降低了内存占用。 这样的做法对性能的影响： 在我使用UIImageView的时候，完全感觉不出来。 在我使用UICollectionView的时候，在iPhone 4s手机上会有一点点的感觉，但是几乎难以察觉。 所以对这次的优化还是非常满意的。 ios8 deleteBackward这是应该是苹果的一个bug，从iOS8.0-8.3系统，重写UITextView，UIInput协议的deleteBackward的时候，发现删除的时候不能被触发，而且仅仅只在这几个系统下才有这样的问题。stackoverflow上提出的解决方案是重写一个私有api，这个不会被苹果AppStore拒绝。 1234567891011121314151617181920- (BOOL)keyboardInputShouldDelete:(TextField *)textField &#123; BOOL shouldDelete = YES; if ([TextField instancesRespondToSelector:_cmd]) &#123; BOOL (*keyboardInputShouldDelete)(id, SEL, UITextField *) = (BOOL (*)(id, SEL, UITextField *))[UITextField instanceMethodForSelector:_cmd]; if (keyboardInputShouldDelete) &#123; shouldDelete = keyboardInputShouldDelete(self, _cmd, textField); &#125; &#125; BOOL isIos8 = ([[[UIDevice currentDevice] systemVersion] intValue] == 8); BOOL isLessThanIos8_3 = ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 8.3f); if (![textField.text length] &amp;&amp; isIos8 &amp;&amp; isLessThanIos8_3) &#123; [self deleteBackward]; &#125; return shouldDelete;&#125; ios7 boudingRect在iOS7上，要计算文字的高度，被换成了新的方法boudingRect，但是在iOS7的系统上，还是会有错误的。 如果你是UILabel，那么没有问题，但是，如果你使用的是UITextView，那么，两者的实际高度为不一致的，可以看的出来，在iOS7上，Label的绘制方式和UITextView还是不一样的。 要解决这个问题，只能实例化一个UITextView对象了： 123456if ([[UIDevice currentDevice].systemVersion integerValue] == 7) &#123; UITextView *textView = self.templateRepoEditorTextView; textView.attributedText = [[NSAttributedString alloc] initWithString:realText attributes:attributes]; return [textView sizeThatFits:CGSizeMake(width, CGFLOAT_MAX)].height + paragraphSpacing;&#125; 在某些场合，为了避免频繁的动态生成，可以使用NSCache做一层缓存。 12345678910111213- (UITextView *)templateRepoEditorTextView &#123; static NSString * const key = @&quot;templateRepoEditorTextView&quot;; UITextView *textView = [_cache objectForKey:key]; if (textView == nil) &#123; textView = [[UITextView alloc] init]; textView.textContainer.widthTracksTextView = YES; textView.textContainer.lineFragmentPadding = 0; textView.textContainerInset = UIEdgeInsetsZero; [_cache setObject:textView forKey:key]; &#125; return textView;&#125; NSTextAlignmentJustified 两端对齐在UITextView和UILabel的对齐样式属性里面，虽然没有说明禁止使用两端对齐的方式，但是其实是不支持的，如果需要支持，需要使用NSAttributedString来设置，而且只设置了对齐方式还是不能对齐的，还需要一个下划线的属性（这可能也是一个系统缺陷）。 123456789101112NSMutableParagraphStyle *paragraph = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];paragraph.lineSpacing = 5;paragraph.paragraphSpacing = 15;paragraph.lineBreakMode = NSLineBreakByWordWrapping;paragraph.alignment = NSTextAlignmentJustified;NSDictionary *attribute = @&#123; NSFontAttributeName: [UIFont fontWithName:@&quot;Helvetica&quot; size:17], NSParagraphStyleAttributeName: paragraph, NSForegroundColorAttributeName: RGB(60, 60, 0), NSUnderlineStyleAttributeName: @0&#125;;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"UITextKit","slug":"UITextKit","permalink":"http://djs66256.github.io/tags/UITextKit/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://djs66256.github.io/tags/NSAttributedString/"}]},{"title":"讨论TDD为什么很少在项目中应用","date":"2016-06-03T09:44:09.000Z","path":"2016/06/03/2016-06-03-tao-lun-tddwei-shi-yao-hen-shao-zai-xiang-mu-zhong-ying-yong/","text":"测试驱动开发，一直以来都是很热门的讨论，但是在国内互联网行业中，大部分的项目还是拒绝使用TDD。我自己尝试了下TDD这种开发模式，感受到为什么大家虽然觉得他很好，但使用的人很少的部分原因了。 TDD 测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。 测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。 正面评价 可以有效的避免过度设计带来的浪费。但是也有人强调在开发前需要有完整的设计再实施可以有效的避免重构带来的浪费。 可以让开发者在开发中拥有更全面的视角。 负面评价 开发者可能只完成满足了测试的代码，而忽略了对实际需求的实现。有实践者认为用结对编程的方式可以有效的避免这个问题。 会放慢开发实际代码的速度，特别对于要求开发速度的原型开发造成不利。这里需要考虑开发速度需要包含功能和品质两个方面，单纯的代码速度可能不能完全代表开发速度。 对于GUI,资料库和Web应用而言。构造单元测试比较困难，如果强行构造单元测试，反而给维护带来额外的工作量。有开发者认为这个是由于设计方法，而不是开发方法造成的困难。 使得开发更为关注用例和测试案例，而不是设计本身。目前，对于这个观点有较多的争议。 测试驱动开发会导致单元测试的覆盖度不够，比如可能缺乏边界测试。在实际的操作中，和非测试驱动开发一样，当代码完成以后还是需要补充单元测试，提高测试的覆盖度。 以上是维基百科上面的解释。 从我个人的使用上来看，测试驱动开发虽然说是一种敏捷开发的终极形态，但是从某些角度上来看，更像是瀑布型和敏捷的一种妥协。更像是每个小迭代都是严格的瀑布型。 在瀑布型里，需求是确定的，在确定的需求下，开发和测试可以并行进行，从而保证最终的质量。在敏捷里面，需求是变更的，很多时候需要根据市场反馈进行调整，甚至在同一个开发周期内都可能发生变更，当敏捷里面使用测试驱动开发的时候，必定会浪费更多的时间在写测试上面，并且在需求变更的时候，不仅仅代码需要修改，测试代码也同时需要修改，这也有点违背了这个模式的初衷了。 现在大部分需要敏捷开发的都是业务型的产品，从我的了解，很多著名产品，都是没有白盒测试的，特别是客户端，主要进行黑盒测试。从这里面可以看出来，对测试的投入想必是非常庞大的，一般来说，测试和开发应该需要1:1的比例，但是在当前的互联网环境下，拥有如此庞大复杂的体系肯定不是一个能够快速反应的团队，也就不具备了在互联网行业的竞争优势。 在我的了解，大家叫好不叫卖的原因主要有如下几个： 本身白盒测试就是一个非常耗时耗资源的东西，很多情况下不可能投入如此多的资源在这上面。 黑盒测试已经能够满足90%的需求了，投入产出比不好看 产品是业务型的，对质量的要求并没有那么的高 缺陷的影响或者修复成本低 当然，我们要讨论的不是测试驱动开发的优劣，而是应该考虑如何利用他的优点，同时又避免他的缺点。 核心部分，重要部分，可以尝试使用测试驱动开发，特别是可能会用很长时间的，同时也方便未来可能的重构。 对于业务以及一些变动大的内容，尽量避免使用，以免未来代码改了，测试代码没有变 为了保证质量，除了更详细的黑盒测试以外，需要加入很多其他的措施，比如用户的反馈，奔溃异常日志的收集与统计，对于客户端产品，可能需要动态修复，来确保质量 在我自己的感觉上来说，写测试的时候的确会想到很多开发时候可能没有注意到的问题，但是在开发的时候也会感到测试没有覆盖到一些情况，这可能也是因为两种思维不停的切换吧，所以最好还是完全分开来做，不要写一块做一块。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://djs66256.github.io/tags/TDD/"},{"name":"测试驱动开发","slug":"测试驱动开发","permalink":"http://djs66256.github.io/tags/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"C方法的Method Swizzling","date":"2016-05-17T11:04:20.000Z","path":"2016/05/17/2016-05-17-cfang-fa-de-method-swizzling/","text":"不久前，Facebook开源了一个c方法的替换库fishhook，我好奇的去研究了下。 只需要很简单的一个方法调用就可以实现替换。 1234567rebind_symbols( (struct rebinding[2])&#123; &#123;&quot;close&quot;, my_close, (void *)&amp;orig_close&#125;, &#123;&quot;open&quot;, my_open, (void *)&amp;orig_open&#125; &#125;, 2); 根据官方的解释是， 当我们去链接动态链接库的时候，我们替换了重定向表里面的函数指针，使其指向我们想要替换的方法，所以调用的时候，自然调用到我们替换的方法中去了。 说起来简单，但还需要了解很多的东西。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"hook","slug":"hook","permalink":"http://djs66256.github.io/tags/hook/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"http://djs66256.github.io/tags/Method-Swizzling/"}]},{"title":"express+react解决方案 （三）","date":"2016-05-15T16:51:38.000Z","path":"2016/05/16/2016-05-15-express-plus-reactjie-jue-fang-an-3/","text":"React WEB 客户端实现。 React 语法这个网上的资料很多，使用也很简单，JSX 的语法也非常方便，和 HTML 差别不大，这里就不多做介绍。主要看看 React 项目里面一些技术和方案。 FluxReact 仅仅只是一套页面的解决方案，并不包含数据以及各个页面之间的交互，所以还需要一套业务框架。Facebook官方开源的是Flux，其他还有一套Redux，原理和结构大致都一样，我这里使用Flux。 上面是著名的flux架构关系图。里面主要由Action, dispatcher, store三个部分组成，数据流向单一，`view -&gt; action -&gt; dispatcher -&gt; store -&gt; view’，与一些双向绑定的框架来说，简单不少。 Webpack这里，还需要一个打包工具，我选择了webpack，由于配置比较麻烦，直接套用了别人的配置React-Starter。 12345678&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev-server&quot;: &quot;webpack-dev-server --config webpack-dev-server.config.js --progress --colors --port 2992 --inline&quot;, &quot;hot-dev-server&quot;: &quot;webpack-dev-server --config webpack-hot-dev-server.config.js --hot --progress --colors --port 2992 --inline&quot;, &quot;build&quot;: &quot;webpack --config webpack-production.config.js --progress --profile --colors&quot;, &quot;start-dev&quot;: &quot;node lib/server-development&quot;, &quot;start&quot;: &quot;node lib/server-production&quot;&#125; 查看React-Starter的包文件，可以看到除了开发服务器以外，还有一个实时监控文件变化的编译系统。这个配置已经比较完整，大部分功能都有了，但是还不是特别适合，比如实时debug等。 SEOReact比较困难的是做SEO，因为页面都是动态生成，所以被爬虫的时候并不能展现所有的页面，所以需要服务器渲染。 React只做服务端渲染，或者只做客户端渲染都比较简单，但是如果要两种都支持就比较麻烦。虽然React-Starter给与了我们预渲染的功能，但不太实用，所以我这里做了一套新的。 superagent因为有很多页面的数据都是需要请求Rest接口的，所以我选用了superagent这个服务器和客户端都支持的开源组件，作为请求数据的组件。 请求分类这里采用和express一样的方法，在路由里面做判断。如果命中，则获取数据并使用预渲染的方法，如果没有命中，则返回最原始的HTML。 123routes.get(&#x27;/*&#x27;, function (params) &#123; // get rest data&#125; 这部分的代码实现还比较混乱，还需要再优化和重构。Github","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"react","slug":"react","permalink":"http://djs66256.github.io/tags/react/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ES6","slug":"ES6","permalink":"http://djs66256.github.io/tags/ES6/"},{"name":"服务器","slug":"服务器","permalink":"http://djs66256.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"express+react解决方案 （二）","date":"2016-05-14T16:51:38.000Z","path":"2016/05/15/2016-05-15-express-plus-reactjie-jue-fang-an-2/","text":"这里来谈谈rest api服务构建。 ExpressExpress是node做http服务最有名的一个框架了，具体如何安装使用我不做介绍了，大家可以参考官方网站。 ES6由于ES6的新特性实在是太棒了，所以我选择使用ES6。可是node目前版本v6.0.0对ES6的支持还不够好。还好有babel这个开源库。ES6 语法可以参考阮一峰的这本书 &gt;&gt; 可以直接全局安装 npm install -g babel-cli ，启动时候把node替换为babel-node，就可以完全支持ES6了。 我为了调试方便，所以在代码中启用支持。 首先安装babel依赖库。 12345&quot;dependencies&quot;: &#123; &quot;babel-core&quot;: &quot;~6.5.2&quot;, &quot;babel-polyfill&quot;: &quot;~6.0.0&quot;, &quot;babel-preset-es2015&quot;: &quot;~6.0.0&quot;,&#125; 然后在app启动的时候导入 ES6 运行环境。 12345678require(&quot;babel-core&quot;);require(&#x27;babel-core/register&#x27;)(&#123; presets: [&quot;es2015&quot;], ignore: [&quot;node_modules/&quot;, &quot;app.js&quot;], extensions: [&quot;.js&quot;], cache: true&#125;);require(&#x27;babel-polyfill&#x27;); 启动参数可以加上方法缓存 BABEL_CACHE_PATH=./xxx。 好了我们的项目已经支持 ES6 了，只是启动的时候会有点慢，如果node能直接支持就好了，不过我相信很快就可以了。 MySql支持 ES6 以后，我们需要添加数据库层，首先安装依赖组件。 12&quot;mysql&quot;: &quot;~2.10.2&quot;,&quot;sequelize&quot;: &quot;~3.0&quot;, 这里我经过比较采用了 sequelize 这个ORM。 在添加配置文件 ./bin/config.js。最好的做法需要配置正式、开发等多套环境，这里我只做一套配置。 123456789const mysql = &#123; host: &quot;localhost&quot;, port: 3306, database: &quot;db&quot;, user: &quot;root&quot;, password: &quot;&quot; &#125;,export default mysql; 配置 sequelize 1234567891011121314151617import Sequelize from &#x27;sequelize&#x27;;import &#123;mysql as config&#125; from &#x27;../bin/config&#x27;;var sequelize = new Sequelize(config.database, config.user, config.password, &#123; host: config.host, port: config.port, dialect: &#x27;mysql&#x27;, freezeTableName: true, pool: &#123; max: 5, min: 0, idle: 10000 &#125;&#125;);export default sequelize; 好了，我们的数据库服务配置完成。 Redis同样，首先需要配置文件。这里我配置了2个分别作为数据缓存和 http 缓存使用。 123456789101112131415161718192021redisCache = &#123; host: &quot;localhost&quot;, port: 6379, user: &quot;&quot;, password: &quot;&quot;, db: 2, prefix: &quot;redis&quot;, expire: 60*60&#125;,httpCache = &#123; host: &quot;localhost&quot;, port: 6379, user: &quot;&quot;, password: &quot;&quot;, db: 3, prefix: &quot;redis&quot;, expire: 60*60&#125;;export &#123;redisCache, httpCache&#125;; 对数据缓存做一个简单的封装。使其支持key-value和key-hashtable这两种格式就够用了。在设置完后需要设置缓存时间expire。用于缓存token和验证码等服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Redis &#123; constructor(config) &#123; this._client = redis.createClient(config); this._expire = config.expire || 60; &#125; expire(key, expire = this._expire) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.expire(key, expire, (err) =&gt; &#123; if (err) reject(err); else resolve(); &#125;) &#125;) &#125; // set a hash table hset(key, value = &#123;&#125;, &#123;expire=this._expire&#125;) &#123; let _client = this._client; let _expire = this.expire; return new Promise((resolve, reject) =&gt; &#123; let arr = []; for (let [k, v] of value) &#123; arr.push(k, v); &#125; if (arr.length == 0) &#123; reject(new Error(&quot;value is empty&quot;)); &#125; _client.hset(key, arr, (err) =&gt; &#123; if (err) reject(err); else _expire(key, expire).then(resolve).catch(reject) &#125;); &#125;); &#125; // get a hash table hget(key) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.hgetall(key, (err, res) =&gt; &#123; if (err) reject(err); else resolve(res); &#125;) &#125;) &#125; set(key, value, &#123;expire=this.expire&#125;) &#123; let _client = this._client; let _expire = this.expire; return new Promise((resolve, reject) =&gt; &#123; _client.set(key, value, (err) =&gt; &#123; if (err) reject(err); else _expire(key, expire).then(resolve).catch(reject) &#125;) &#125;) &#125; get(key) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.get(key, (err) =&gt; &#123; if (err) reject(err); else resolve(); &#125;) &#125;) &#125;&#125;export default Redis; 使用时只要创建一个具体对象就可以了。 另外，再创建一个http缓存的中间件，用来缓存一些接口变化比较缓慢，实时性要求不高，但需要大量计算的数据。 12345678910111213141516171819202122232425262728293031323334export default function(&#123; expire=config.expire, getKey=(req)=&gt;&#123; req.originalUrl &#125;&#125; = &#123;&#125;) &#123; return function (req, res, next) &#123; let key = getKey(req); new Promise((resolve, reject) =&gt; &#123; redis.hget(key).then((data) =&gt; &#123; if (data &amp;&amp; data.length &gt; 0) &#123; // TODO: set header &#x27;Content-Type&#x27; ect. //res.setHeader() res.setHeader(&#x27;Content-Length&#x27;, data.body.length); res.send(data.body); resolve(); &#125; else &#123; reject(); &#125; &#125;).catch(reject); &#125;).catch(() =&gt; &#123; // there is no cache next(); if (res.statusCode == 200 &amp;&amp; res.body.length &gt; 0) &#123; // add body to cache // TODO: validate res.body redis.hset(key, &#123; &#x27;Content-Type&#x27;: res.getHeader(&#x27;Content-Type&#x27;), body: res.body &#125;); &#125; &#125;); &#125;&#125; 这是一个比较简单的实现，key默认使用url。当然也可以自定义。使用场景： 12345678router.get(&#x27;/:id&#x27;, httpCache(&#123; expire:60, getKey(req) &#123; return &quot;POST:&quot; + req.path; &#125; &#125;), (req, res, next) =&gt; &#123; ......&#125;); 这样，我们的数据层都已经配置完毕，接下来需要开始进入实践。 结构目录结构： 123456|\\| \\model // 数据结构相关|\\| \\controller // 真正的业务处理层，像Spring里的service层|\\| \\routes // 路由控制，缓存以及行为控制 这里我为了简化，只把服务分为这些，来减少复杂度，同时又相对解耦。 首先看看model层，这里定义了整个表的结构和数据模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let User = sequelize.define(&#x27;user&#x27;, &#123; // name: Sequelize.STRING, password: &#123; type: Sequelize.STRING &#125;, salt: &#123; type: Sequelize.STRING(16) &#125;, nickName: &#123; type: Sequelize.STRING, field: &#x27;nick_name&#x27; &#125;, email: &#123; type: Sequelize.STRING, validate: &#123; isEmail: true &#125; &#125;, birthday: Sequelize.DATE, gender: Sequelize.INTEGER(8), createTime: &#123; type: Sequelize.DATE, defaultValue: Sequelize.NOW(), field: &#x27;nick_name&#x27; &#125;, updateTime: &#123; type: Sequelize.DATE, field: &#x27;update_time&#x27; &#125;, loginTime: &#123; type: Sequelize.DATE, field: &#x27;login_time&#x27; &#125;&#125;, &#123; timestamps: false, freezeTableName: true, defaultScope: &#123; attributes: [&#x27;nickName&#x27;,&#x27;email&#x27;,&#x27;birthday&#x27;,&#x27;gender&#x27;,&#x27;createTime&#x27;,&#x27;updateTime&#x27;] &#125;&#125;);// 这里提供给外部可以编辑的属性配置User.editableAttribute = [&#x27;nickName&#x27;, &#x27;birthday&#x27;, &#x27;gender&#x27;];// 这里我们可以选择让 sequelize 来建表if (process.env.SYNC_DATABASE) &#123; User.sync();&#125;export default User; controller定义所有的逻辑操作，提供包括验证的，但是独立的功能服务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let Controller = &#123; create(&#123;email=null, password=null&#125; = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; if (email &amp;&amp; password) &#123; validatePassword(password).then(() =&gt; &#123; User.findOne(&#123;email: email&#125;).then((user) =&gt; &#123; if (user) return reject(&quot;您已经注册,请直接登录&quot;); else &#123; let salt = salt(email); let encryptPassword = encryptPassword(password, salt); User.create(&#123; email: email, password:encryptPassword, salt: salt &#125;).then(resolve).catch(reject(err)); &#125; &#125;).catch(reject); &#125;).catch(reject); &#125; else &#123; reject(new Error(&quot;用户名或密码为空&quot;)); &#125; &#125;); &#125;, update(user) &#123; return new Promise((resolve, reject) =&gt; &#123; if (user.id) &#123; return reject(new Error(&quot;用户ID为空&quot;)); &#125; if (user.password &amp;&amp; user.salt) &#123; return reject(new Error(&quot;参数非法&quot;)); &#125; User.update(filterValidateKey(user, User.editableAttribute), &#123; where: &#123; id: user.id &#125; &#125;).then(resolve).catch(reject); &#125;) &#125;, findByIds(ids = []) &#123; return new Promise((resolve, reject) =&gt; &#123; User.findAll(&#123; where: &#123; id: &#123; $in: ids &#125; &#125;, include: &#123; model: Tag, as: &#x27;tags&#x27; &#125; &#125;).then(resolve).catch(reject) &#125;) &#125;, addTags(tagIds = []) &#123; &#125;&#125;export default Controller; 最后，路由来组合其中不同的业务逻辑。 123456789101112131415161718router.get(&#x27;/:id&#x27;, (req, res, next) =&gt; &#123; let id = req.params.id; if (id) &#123; UserController.findByIds([id]).then((users) =&gt; &#123; if (users.length &gt; 0) &#123; res.send(Success(users[0])); &#125; else &#123; res.send(Fail(&#x27;用户不存在&#x27;)); &#125; &#125;).catch((err) =&gt; &#123; res.send(Fail(err.message)); &#125;) &#125; else &#123; res.send(Fail(&quot;参数错误&quot;)); &#125;&#125;); 其他很多场景，我们需要判断用户登录情况以及一些其他情况，如果在每个请求里面去做判断会是一种非常麻烦的事情，而且也会导致代码冗余和复杂性，这些功能可以做成中间件形式，使用时也会方便很多。 123456789101112131415// NeedLogin 伪代码function NeedLogin() &#123; return function(req, res, next) &#123; if (req.isLogin()) &#123; next(); &#125; else &#123; res.send(Fail(&#x27;need login&#x27;); &#125; &#125;;&#125;;router.get(&#x27;/:id&#x27;, NeedLogin(), (req, res, next) =&gt; &#123; ......&#125;) 测试等待加入该模块 下一篇，我们来看看react来构建web应用的框架。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ES6","slug":"ES6","permalink":"http://djs66256.github.io/tags/ES6/"},{"name":"mysql","slug":"mysql","permalink":"http://djs66256.github.io/tags/mysql/"},{"name":"redis","slug":"redis","permalink":"http://djs66256.github.io/tags/redis/"},{"name":"sequelize","slug":"sequelize","permalink":"http://djs66256.github.io/tags/sequelize/"},{"name":"服务器","slug":"服务器","permalink":"http://djs66256.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"express+react解决方案 (一)","date":"2016-05-13T16:51:38.000Z","path":"2016/05/14/2016-05-14-express-plus-reactjie-jue-fang-an-1/","text":"经常我们需要一个非常轻量级的框架，来满足我们很多非常简单的需求，同时又要求一定的扩展性、灵活性和松散性，要求快速开发，又有一定的承载能力，这里设计了一种简单的解决方案。 数据服务框架 &gt;&gt; Github 结构123456789|----------------------------------------|| web/HTML5 | mobile | ect. |-----------------------------------------|| React/Flux/React Native | ^ |-----------------------------------------|| rest api/node/express | socket.io || -----------------------------|| | database/redis/storage ||----------------------------------------| 为了更明晰的分层，这里分为多个服务，因为都是基于nodejs，所以要整合在一起也是非常简单。 Rest Api，提供基础数据服务，采用http协议，由node/express组成。 socket，提供长连接服务，采用socket.io，可以直接连接数据层，也可以通过http协议连接数据层。 表现层，React作为基础页面构建方法，结合原生方法，来构建具体应用，或者应用的一部分。 数据层这里我选择MySql作为基础数据存储格式，redis作为缓存。 大部分时候我们还是需要传统的关系型数据结构，MySql是最佳的选择，同时PostgreSQL, MariaDB也是一种选择。 作为NoSql的其中之一，mongoDB，也是非常热门，但是由于资源占用太高，不太适合小型项目。 Node为什么会选择node作为基础语言来构建整个框架呢？首先让我们比较比较其他几种语言。 JAVA / Spring现在最火热的spring架构，几乎所有大型企业的首选框架。优点多的不用说明了，但是作为我们需要快速开发以及快速上手的框架并不友好，有太多的坑，而且JAVA作为一门强类型的语言，太过于繁琐。分层明确(Model, DAO, Service, Controller)的同时，也降低了开发速度。 另外一个让我放弃Spring的原因在于资源占用太高，JAVA的运行环境就需要非常大的内存，如果你的开发机器上需要运行MySql, redis, IDE, tomcat等等，还是有一点压力的。 Python / django也是一个比较热门的开发框架，也有挺多的成熟应用，算是一个Ruby On Rail的Python版本。但是毕竟Python并不是专门为服务器开发出来的语言，而且和C语言有着一些联系，所以感觉并不太适合现在的时代，目前开源社区的支持也在逐渐下降。 django自己有一套ORM的系统，但是并不够灵活。 我比较喜欢的是Python的修饰方法，可以非常灵活的配置一些方法的过滤器。(听说ES7里也要有统一的特性？) PHP感觉PHP是专门为了WEB而设计的语言，虽然有一些像think php这样mvc的框架，但是感觉作为一个中间层还是不太稳定。 Node.jsNode是一个处理IO密集型业务非常好的选择，通常我们的中间层不会有大量的计算，多数为读取写入数据，其他的框架都是选择等待事务完成，而且每个请求会生成一个进程，导致一台机器的并发数直接由内存决定，Node在这方面可以使用更少的资源来获得同样的效果。 Node目前非常的火爆，开源社区也非常活跃，很多应用或框架都已经在node上面开发，而且开源模块非常完善，npm也非常好用。比如我在上层采用的React。 同时Javascript作为一门前端语言，简单易学，可以有很多前端开发人员进入。 在公布了ES6以后，Javascript感觉已经摆脱了脚本语言这一不太好的特性，更像一门专业面向对象语言。不过可惜的是，到目前为止，虽然v8已经基本支持了所有ES6特性，但是最新的node v6并没有完全支持，加上--harmony也只能支持一小部分，目前我们还需要借助第三方库。 只能说，感谢v8! 同时，可以看出这个框架的大部分都是由js来组成，所以选择Node来作为中间层的开发也是很理所应当的。 下一步整个中间层的构建。请见下一篇。 后记关于Node服务的效率问题，虽然官方说明以及很多自来水的吹捧，感觉非常的优秀，但是实际项目中还是需要根据实际情况来做判断。 不过如果遇到了效率问题，Node还是可以很方便的和其他语言混编的，找出最消耗时间的地方，用C/C++改写也是非常快速的。 稳定性是Node比较弱的一个方面。一个线程容易因为一个小错误而使整个服务崩溃，所以除了需要更仔细的错误处理，还需要均衡与热备来确保服务质量。 由于Node的异步语法会导致更多的嵌套关系，使用泛滥会导致代码难以理解，所以需要统一整个项目的规范与习惯。（比如使用Promise代替callback函数）","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"react","slug":"react","permalink":"http://djs66256.github.io/tags/react/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"谈谈传统型互联网公司","date":"2016-04-26T16:48:20.000Z","path":"2016/04/27/2016-04-27-tan-tan-chuan-tong-xing-hu-lian-wang-gong-si/","text":"&nbsp;&nbsp;&nbsp;&nbsp;在最近的一段时间，接触了不少公司，都有一些传统公司的影子，在进军互联网方面或多或少都表现出了同样缺少的部分。 S网&nbsp;&nbsp;&nbsp;&nbsp;S网是一个招聘类网站，概念比较新颖，利用各种资源获得了一笔投资。然后开始各种宣传、推广，为了下一轮的融资。 &nbsp;&nbsp;&nbsp;&nbsp;但是，他们的宣传主要以企业形象宣传为主，推广的内容第一条必定是公司的形象工程。不惜花重金参加各类活动，在各大平台曝光。 &nbsp;&nbsp;&nbsp;&nbsp;然而，作为一个互联网公司，他们还没有一个真正属于自己的招聘平台，用户和职位也是屈指可数，运营推广也是最普通的提供职位资源。也没有想要组建属于自己的开发团队，做的产品完全依照老板的想法，没有用户调研，总是想要把自己能想到的所有功能一次性做出来才满意。 &nbsp;&nbsp;&nbsp;&nbsp;这是一个非常典型的传统型创业公司。虽然在创业初期，独权主义在公司的效率和团结上会有一定帮助，但是并不是所有的东西都要亲力亲为。老板如果不是产品运营开发这方面的全能型人物，很容易导致产品开发的整个流程被打断。需求朝令夕改，偶尔推倒重来，一次性开发太久等等这些产品开发最忌讳的事情。最后出来一个满是沧桑的老板满意的产品，用户需求没有了，早已经远离了初衷。 &nbsp;&nbsp;&nbsp;&nbsp;为什么现在创业项目并不被看好，除了资本寒冬的原因外，也有一部分是被中国创业的环境破坏了，所谓创业，在一部分人的眼里，仅仅只是获得一部分融资，做一个名头响亮的空头公司，玩转所谓的资本运作。或许在早几年，很多人会被骗，现在也有很多人傻傻的投钱，但是经过这一轮经济衰退，中国的投资者们已经开始意识到投资的风险了，慢慢的他们已经开始了解移动互联网的运作方式，开始聘用专业人士。同时互联网与移动互联网的巨头已经基本瓜分完市场，已经很难在这个鱼塘里面摸鱼了。 &nbsp;&nbsp;&nbsp;&nbsp;互联网本身并不能像传统行业那样，买点东西，有点品牌就能卖得好，卖得贵，目前的盈利方式主要是靠广告、服务、与传统行业对接等，靠导入流量来赚钱，既然如此，流量就是最重要的，所以为什么互联网公司都在强调自己的用户量、日活这些数字。那么，为了获得用户，自然靠的是你的服务和产品，而不是你的品牌与口碑。这也是互联网吸引人的地方，也是一个草根也能超越一个集团的地方。 &nbsp;&nbsp;&nbsp;&nbsp;所以既然要做互联网，那就按照一个互联网的规则来玩，真正做好自己的产品和服务，提升自己的用户量为首要目标，真正的去了解用户，贴近用户，这才是最重要的。 W公司&nbsp;&nbsp;&nbsp;&nbsp;这是一家传统的房子租赁公司，在这个行业也算是打下了一片天地。在链家全国性的铺开的时候，这块的竞争进入了一个白热化的程度。 &nbsp;&nbsp;&nbsp;&nbsp;我尝试了他们的应用，也了解了一些他们的未来打算。目前他们主要对租赁和过程进行互联网化，简单的来说，就是把线下的租赁活动转移到了线上。这是一个最初级的互联网化的过程，效果应该是最明显的一步吧。总的来说他们的这一步并不差，但是想要以此来对抗链家以及其他同类型的公司，还是差了很多。当我问他们未来的打算与发展的时候，他们并没有给出我觉得满意的答案。他们后续的打算仅仅是优化加强这个工具的实用性和功能，以及增加其他的实用性工具。我不知道他们的产品经理是怎么打算的，但是这样的回答让我很失望。 &nbsp;&nbsp;&nbsp;&nbsp;一个工具仅仅是一个工具，做的再好也不能够盈利。该公司真正有价值的是他的服务，但是他的服务是一种短暂性的，一次性的服务，虽然单次服务的价值很高，但是却没有抓住用户。作为互联网行业最重要的资源，仅仅走了个流水，多么可惜。所以我认为他们的下一步应该增加他们的后续服务，以及一些绑定用户的产品与服务。这个方法有很多，比如合同期内的服务，第二次服务咨询优惠，租赁论坛交流群等等，依靠一些长期的服务以及交流平台等绑定用户。这样才是他们下一步最需要的。 &nbsp;&nbsp;&nbsp;&nbsp;我了解到另外一家公司目前就在尝试这方面，但是他们的服务是要收费的，而且服务内容并不吸引人，而且强行绑定了用户，必须接受这个服务。虽然这么做并不好，但是也算是一种尝试。 &nbsp;&nbsp;&nbsp;&nbsp;在互联网化的时候，创造一个用户粘性强的平台是最急迫的，也是最长远的一种打算。 B公司&nbsp;&nbsp;&nbsp;&nbsp;他是一个比较成功的创业公司，也拥有了很多的用户，可以说完全已经占领了视频领率的一方垂直天地。 &nbsp;&nbsp;&nbsp;&nbsp;B公司没有上面我所说的问题，就是一个以用户为中心，组建了一个用户粘性非常强的平台。但是该公司在初期为了加强自己的技术以及管理能力，空降了一大批中层领导和技术人员。他们对这方面并不是很擅长，但是依靠以前的经验，开始了绩效目标等等。 &nbsp;&nbsp;&nbsp;&nbsp;他们的加入导致了原有员工的隔离，这个平台开始转向以营利为主的方向上。这本身并没有什么错误，但是营利的项目开始侵占原有的业务。所有的其他业务都要退让，导致最核心最重要，也是吸引用户的地方被迫退居2线。我觉得如果不是boss在这里，原有的业务可能已经被做成装饰了吧。 &nbsp;&nbsp;&nbsp;&nbsp;在整个平台需要盈利的时候，我觉得需要特别慎重，盈利必定会破坏原来的关系链，如果这个关系被破坏的太多，是否对原有的业务产生不好的影响。而且，需要好好考虑是否已经是盈利的时机了，因为资源总是有限，在视屏这个竞争也是非常激烈的领域，其他大平台已经慢慢开始扩充他们的领域，已经逐渐形成一个垄断的形式，但这同时也是一个机会，一个扩张自己领域的机会。 &nbsp;&nbsp;&nbsp;&nbsp;在选择盈利点和时机的时机的时候要特别注意，不要太过于挤压原有业务的空间，思考吸引用户的核心价值是什么，不要到最后用户流失导致双双死亡的结局。 &nbsp;&nbsp;&nbsp;&nbsp;做为一个互联网公司，必须以产品为中心，以用户为中心，创造一个用户粘性强的平台，而不是一个功能型应用，在不影响原有核心价值的时候慢慢导向盈利。这才是我心目中的一个比较正常发展互联网公司。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"公司","slug":"公司","permalink":"http://djs66256.github.io/tags/%E5%85%AC%E5%8F%B8/"},{"name":"互联网","slug":"互联网","permalink":"http://djs66256.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"运营","slug":"运营","permalink":"http://djs66256.github.io/tags/%E8%BF%90%E8%90%A5/"},{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"传统","slug":"传统","permalink":"http://djs66256.github.io/tags/%E4%BC%A0%E7%BB%9F/"}]},{"title":"关于产品经理需要的知识","date":"2016-04-26T13:29:44.000Z","path":"2016/04/26/2016-04-26-guan-yu-chan-pin-jing-li-xu-yao-de-zhi-shi/","text":"&nbsp;&nbsp;&nbsp;&nbsp;经常看到有人在网上讨论产品经理需不需要懂技术，然后各有各的说法，这里我说说我认为的一个好的产品所具备的一些知识。 技术&nbsp;&nbsp;&nbsp;&nbsp;产品需不需要懂技术，这个争论很久的话题。我认为产品一定要懂技术，但是可以不懂写代码。作为一个产品经理，并不是只需要知道做出什么东西来就完成了，还需要知道做的过程，所要付出的代价，以及最基本的可行性，这里并不是要由产品来决定这些东西，但是一个不懂技术的产品只会与最后的产品渐行渐远。 &nbsp;&nbsp;&nbsp;&nbsp;产品经理需要了解的并不是如何写代码，或者这个是如何实现的这么详细的点，更多的是理解工程师们可以实现的，以及愿意去攻破的，那些毫无头绪的想法还是老老实实问问开发人员吧，他们可能也需要很久的时间去考虑。 &nbsp;&nbsp;&nbsp;&nbsp;如果产品只是按照自己的想法一味的强加需求，而且对开发人员反映的种种问题视而不见。就像有些老板那样，总觉得是开发人员懒惰、在推卸责任，只要能想出来的，他们肯定能够实现。最后他们的确实现了，可是呢？第一，开发与产品方面产生了很大的隔阂与矛盾，同时也导致了整个团队的不稳定；第二，开发失去了一个比较主动的地位，整个团队的氛围变得更加的沉闷，对于一些产品经理看不到的优化、细节也得不到实施，导致产品的质量越来越差。 &nbsp;&nbsp;&nbsp;&nbsp;所以我认为产品一定要懂技术，不需要像开发人员一样去了解如何实现，但要知道能够实现到什么地步，需要什么样的代价。 心理学&nbsp;&nbsp;&nbsp;&nbsp;为什么我会提这个呢，因为开发人员很多都是有完美主义的，越优秀的开发越追求极致，有些时候甚至可能会觉得有些歇斯底里。所以如果不懂得一些性格学，心理学，傻乎乎的跑去找程序员改需求真有可能被砍。 &nbsp;&nbsp;&nbsp;&nbsp;开发是一个及其需要精神集中的工作，因为需要一步一步整理自己的思路，可能因为你2分钟的打断，别人2个小时的努力要重新开始。就像作家一样，在写作的时候不讨厌别人打断。当然也有必不可少的时候，肯定会有矛盾，这里就需要情商来安抚他们。 &nbsp;&nbsp;&nbsp;&nbsp;同样，了解用户心理对于产品来说也是一件非常好的事情。 &nbsp;&nbsp;&nbsp;&nbsp;所以懂一些心理知识是不是很重要？产品经理和开发之间的关系会直接影响开发效率和技术创新，最终也会影响产品。 项目管理&nbsp;&nbsp;&nbsp;&nbsp;很多时候，产品经理也是兼任项目经理的，就算没有兼任，也需要知道项目管理。软件开发已经有一套非常成熟的流程了，如果产品经理不是很懂项目管理和软件开发流程，只会让一个项目变成一个无尽的泥潭。 &nbsp;&nbsp;&nbsp;&nbsp;就像《人月神话》里面说的，为了赶进度而增加人手，增加工作时间，这些差的方法只会让一个项目越来越不可操作，最终陷入一个无尽的泥潭，从而导致项目失败。虽然平时开发一个功能的时候并不会暴露出这么严重的问题，但是多次的累积，终有一天会发现项目已经成为一个庞然大物，从而越来越难以维护和开发。 &nbsp;&nbsp;&nbsp;&nbsp;所以项目管理也是产品经理必备的技能，不需要项目经理控制的那么精细，但是整个流程需要知道，以及不要用打断这个流程来弥补自己的错误。 &nbsp;&nbsp;&nbsp;&nbsp;以上这些看似和产品经理毫无关系的，但是我认为一个好的产品经理必须具备的，当然最重要的是对产品的理解了。 &nbsp;&nbsp;&nbsp;&nbsp;另外，对于老板，首先需要成为一个产品经理，才能做好一个决策者。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"产品经理","slug":"产品经理","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"管理","slug":"管理","permalink":"http://djs66256.github.io/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"运营之道-买买菌模式","date":"2016-04-14T14:04:43.000Z","path":"2016/04/14/2016-04-14-yun-ying-zhi-dao-mai-mai-jun-mo-shi/","text":"前几天，有幸听到买买菌分享他们是如何在微博环境已经趋于没落，甚至饱和的情况下，用两年时间快速成长为一个拥有200万真实粉丝的博主。相比于现在很多的推广运营，形成鲜明的对比，也是我之前为什么会把公司归为传统型和互联网型的一个原因。这是对于目前我经历的一些思考。 现在很多的推广和运营的内容都相当的生硬，很多都类似这样： 啪啦啪啦，这个东西超好啦，超实惠啦，大家来花钱啊~ 打折啦，全场5折，买一送一啦~ 概括起来： 表现自己的产品，自己的服务很好，对用户有什么用处，可以从各个角度去描述美化，来吸引用户。 表明自己给与的优惠等，让用户感到占了便宜。 但是这样推广也有很多问题： 对于这类的宣传，需要： 产品或者服务真的很好 非常切合用户，属于刚需 问题： 容易被复制，对于竞争对手没有抵抗能力 用户没有粘滞性，用户使用以后并没有特别的再次使用的动力，完全依靠产品或服务来带动。 这种靠口碑和形象的推广，在这方面一旦受到损害，将导致非常严重的后果，比如聚美等。 如果企业是一个非常有实力，处于行业大哥位置，我认为这样做是一个比较快捷的方式，通过最简单的方式告诉大家自己的产品。 又或者是自己的产品属于一个比较新的领域，还没有特别多的竞争对手，可以满足用户的刚需，这样做也是非常省力的一种方式。 但是在一个竞争非常激烈的环境，有着众多的竞争对手和可选择余地的时候，这样的推广就会让人感觉很无力，每个人都在说自己的产品好，不管说的多好，大家总是保持者怀疑的态度。 所以我认为这是一种非常传统的推广方式，在新兴互联网，拥有众多选择余地的时候，效果可能并不好。 给与用户一些优惠政策，比如打折，礼品，包邮，积分等等 承受这样带来的经济消耗，甚至可能会导致价格战，比如打车行业 吸引力仅限于活动期间，用户没有粘滞性 如果这是一个新产品，需要吸引眼球或者仅仅需要带动销量，这是一个快捷的方式，可以一下子把东西暴露给大家。 但是如果把这个作为一个长远的推广计划就不太合适，同样对于用户没有任何的吸引力。就如每天给乞丐一个面包，只要你某一天没给他，他便会责怪你一样。 在互联网行业，需要考虑的是长远打算，在使用这种方式的时候必须在后续的时候加入其它方面的带动，才能让用户留住。 买买菌给我的一种启发是，内容才是王道，不断地鼓吹自己和给与利益都不是一个长久之道。大部分用户可能都不会消费一次产品，但是对于内容却大部分都会喜欢，而且不是短时间性的。所以必须不断的生成用户会喜欢的有价值的内容，才可以保证用户的留存。 内容的质量是非常重要的，一篇都是淘宝的图片和链接只能是一篇广告，没有人会看这样的东西，内容需要真实，可靠，对用户有帮助。 同时内容对应什么样的人群，就需要什么样的文章，让一个70岁国学大师写一篇小女生服装推广就不合适。需要作者能够真正理解用户的心理和需求。 但是仅仅有内容还是不够的，内容是留住用户的基础，现在的互联网还需要传播性。好的内容自然会让人去转发传播，但还是需要把用户往这方面引导，像买买菌采用的方式就是塑造一个贴近生活的形象，用一个活生生的人的形象来引起人们的共鸣。至于怎么做，会有很多方法，传播性是一个至关重要的运营点。 导流是运营的目的，不管是导向消费，还是用户导向，需要注意的是这样做的时候不能犯和内容同样的错误，看着就像广告，避免用户的流失。这是一个需要权衡的东西，毕竟这才是盈利的方法。 只有形成了一个以内容为中心，用户自行传播为途径这样一个生态圈，才会让一个互联网产品非常良性的发展。用传统方式去运营，虽然看似起效很快，但消耗和用户的忠诚度却不能完全保证。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"运营","slug":"运营","permalink":"http://djs66256.github.io/tags/%E8%BF%90%E8%90%A5/"},{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"买买菌","slug":"买买菌","permalink":"http://djs66256.github.io/tags/%E4%B9%B0%E4%B9%B0%E8%8F%8C/"},{"name":"模式","slug":"模式","permalink":"http://djs66256.github.io/tags/%E6%A8%A1%E5%BC%8F/"}]},{"title":"公司与产品的一些想法","date":"2016-04-04T21:43:11.000Z","path":"2016/04/05/2016-04-05-gong-si-yu-chan-pin-de-yi-xie-xiang-fa/","text":"这里是我关于目前公司与产品的一些体会。 公司很久以前可以说软件公司，但现在已经几乎不存在这样的说法，我更倾向于把目前的互联网公司分为传统的互联网公司和纯粹的互联网公司。 传统互联网公司这些公司基本上是由为了适应新的互联网环境而成功转型的传统行业公司，包括目前非常火热的金融、房地产、车子等，这些公司的特点是拥有原有或者成型的业务模式，互联网仅仅作为一个工具而使用，仅仅为了满足他们现在的业务需求，提高效率或者压缩成本，他们的产品往往以业务为中心，从一个生产者的视角去审视这些需求。 这些公司的优点十分明显，有着固定的盈利模式，甚至在传统行业里面已经有非常雄厚的经济积累，因此一般是非常稳定的产品走向，也是非常明确的功能需求。显然，缺点也十分明显，产品的目的是服务于传统的业务，对真正互联网产品的发展、运营并不友好，而且也不会真正重视这一块的未来潜力，或者对这一块的潜力评估并不准确。 这类公司容易导致产品部门的地位低下，产品部门并不能掌控产品的真正走向，如果没有一个足够强力的人来掌控，很容易导致产品走向失败，或者走向一个死板的局面。而且容易导致产品部门会受到其他部门或者上司的越权干涉。同时产品部门内部会陷入无穷无尽的业务需求。 纯粹的互联网公司这些公司很多是由之前的软件公司转型过来，其特点是拥有大量的普通用户，同时用户群比较杂，各种各样的用户在这个平台上享受某种服务而形成一个特殊的群体，这些产品没有明确的盈利点，也没有固定的发展方向和产品走向，是一种完全根据用户和市场走向来决定产品走向的形态。 这类公司目前面临的最大的挑战是盈利，如何把他们的现有的服务和用户转化为盈利，如果做的不好，可能会因此而失去大量的用户。现在他们总是小心翼翼的在尝试，但这是一个漫长而严峻的挑战。 在这样的公司，产品永远是第一的，用户永远是第一的，他们服务的永远是用户，而不是其他部门或者老板。这样会形成一个非常完整统一、团结的局面，可以牵引出一个产品的巨大潜力。内部消耗也会相应的减少。 当然，这是对于只有一个产品的公司而言，航空母舰型的公司就相当于他们的一个事业部。 这些公司各有各的优劣，而且现在很多公司其实已经开始融合这两方面，对于未来的良好发展，这两者都必不可少。 产品对于产品，我更喜欢把他们分为业务型、用户型和平台型。 业务型产品 这类产品仅仅为业务服务，他们并不关心用户，也不是从用户角度来设计的产品，往往是根据现有业务来设计的产品。这样的产品发展的潜力并不高，增加用户量和传播都不占优势。他们过于依赖于现有的业务，一旦现有的业务出现什么问题，产品就会收到巨大的影响。 他们的当务之急应该是改变现有的观点，更加的从用户的角度去思考问题，去建立一个良好的生态圈，而不是固守于原来的业务。这么做的效果可能不会很明显，效益转换不能马上得到兑现，但是对未来市场的动荡和变革都作了足够的缓冲，以便有足够的时间来反应。 用户型产品他们往往先考虑用户量，再考虑盈利的问题。他们的优势是用户，拥有一个非常良好的用户群体，产品完全以用户为中心，非常的符合用户的需求。但是可能会遇到盈利的问题，不良的转化很可能导致用户的大量流失，需要寻找一个良性的平衡点。 平台型产品他们的大多数实际产品并不是自己开发的，他们仅仅提供了一个平台，第三方在这个平台上做二次开发和运营，是一个非常有高度的产品，盈利和潜在用户都不是问题，但是非常难以成型，需要一个巨大的实力背景和较长的时间来运营。 我认为，平台型产品才是现在互联网产品的最终发展形态，这样才能良性的发展，同时也会减少开发成本，让用户去获取新用户才是最廉价的推广途径。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"公司","slug":"公司","permalink":"http://djs66256.github.io/tags/%E5%85%AC%E5%8F%B8/"},{"name":"传统型","slug":"传统型","permalink":"http://djs66256.github.io/tags/%E4%BC%A0%E7%BB%9F%E5%9E%8B/"},{"name":"互联网","slug":"互联网","permalink":"http://djs66256.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"一个自娱自乐的小项目","date":"2016-03-28T11:13:43.000Z","path":"2016/03/28/2016-03-28-yi-ge-zi-yu-zi-le-de-xiao-xiang-mu/","text":"最近自己做了一个小项目，功能很简单，自己完成前后端的开发，还是有一些感受。 后端是由spring+nodejs来构成的。在此我不考虑执行效率等因素，快速开发才是我的目的。 SpringHTTP接口部分由spring mvc + hibernate，这样做的主要原因是开发简单快速，不用太过于注重数据结构。 由于自己做的项目，很多地方的考虑并没有那么周全，很多东西都没有那么确定，功能流程都是一个模糊的概念，所以数据结构这块的改动是非常大的，hibernate自己管理数据库和model以及之间的映射，这对于结构经常变更的情景实在是太符合了。至少从头到尾我都没怎么关心过数据库方面的事情。 但是spring最大的缺点就是内存占用，由于是java的项目，这也办法避免，对于小型项目来说这个的资源使用率就比较差了。我部署完观察看到spring的占用始终在几百M，加上其他一些服务，服务器要求还是需要配置挺好的，对于自己玩玩的小项目来说，有点利用率太低了。 spring作为快速开发还是非常好的，同时作为一门强类型语言，出错率也比较低，一些新手也很很好的参与。但是我应该不会再考虑作为我自己个人开发的语言了。 nodenode部分主要用作web服务和socket服务。 由于socket服务占用资源的问题，我决定使用node来做socket服务器，而且还有socket.io这个开源长连接库。这样也省去了很多协议和底层代码。 用这个写的一个即时聊天消息服务器用的代码也没有超过1k行，还是非常简单的。 node的具体性能怎么样我没有实际去测试过，但相比于其他创建进程的方式应该会优秀一些吧。作为自己的一个小项目来说也已经足够了。 现在总结起来，在做一个项目之前的准备实在是太不够充分了，而且现在也很难一个人来开发一个项目了。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://djs66256.github.io/tags/spring/"},{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"}]},{"title":"swift使用小结","date":"2016-03-28T11:13:17.000Z","path":"2016/03/28/2016-03-28-swiftshi-yong-zong-jie/","text":"目前为止swift已经到2.0版本了，使用swift来开发移动端项目已经成熟，现在很多的开源项目已经放弃Objective-C，转向swift，所以我也使用swift来做了一个新的小项目。现在来谈谈使用swift的感受。 语法swift不仅仅比OC更加的简洁，而且更加的容易看懂，同时在错误的控制上更加严谨，可以说是一门非常优秀的强类型面向对象语言。同时也比较类似Python，拥有脚本语言的部分特性。 同时api和OC几乎完全一样，这样也减少了很多学习的成本，当然一些新的思想还是要重新学习。 swift和OC混编也非常的简单，只要没有使用一些特殊方法的类库都可以无缝混编。(比如JSONObject这个类库使用了动态获取属性名，导致不能判断swift的属性) 新特性这里稍微列几个，如果你了解一些其他语言，那么你会感到非常的亲切。 空判断swift里面对象的类型可以分为Object和Optional&lt;Object&gt;两种类型，这样可以明确知道对象是否可以为空，同时使用?来处理Optional类型的调用，这样我们就不需要经常的使用if和断言了。 强类型swift强制类型比OC更加的严格，类型判断用is，类型转换使用as。 泛型也算是强类型的一部分，这样我们终于不用猜测Array和Dictionary里面存的对象是什么类型的了。 操作符重载从某些特定的角度看，这是一个非常有用的特性，但过度使用也会让代码更加难以理解。String终于支持+的操作了，终于告别OC里面让人奔溃的字符串连接。 enumswift允许枚举类型的对象“携带”其他的数据，这在某些情境下是非常便利的一个特性，但也让人一下子难以理解。 闭包相对应于OC里面的block，闭包更加的简洁与好用，有些时候不仅可以使用简化的闭包，甚至简单到省略了()和参数。 12345678910111213141516171819exe &#123; show($0)&#125;exe() &#123; show($0)&#125;exe(&#123; show($0)&#125;)exe(&#123; a in show(a)&#125;)exe(&#123; (a:String)-&gt;Void in show(a)&#125;) 以上的表述都是完全一样的。 defer &amp; guard算是一个锦上添花的东西吧，defer是函数返回前的调用，guard和if的作用是相同的，仅仅作为语义区分吧。 1234let x = open(&quot;file&quot;)defer &#123; close(x)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"swift","slug":"iOS/swift","permalink":"http://djs66256.github.io/categories/iOS/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"}]},{"title":"2013学年总结之语言篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之编程语言篇/","text":"本篇为总结之前了解的一些语言与特性，当然，我并不是语言专家，大部分都是走马观花，难免有纰漏之处。 java作为一个纯粹的面向对象语言，java应该是非常的典型的，而且不像c/c++，也不像Objective-c一样需要我们手动管理内存，这大大降低了我们学习和使用成本。同时有大量的完整的类库和跨平台的能力，所以Google选择java作为android的语言实在是完美。 先说说特性，因为所有类型都是对象，所以基本类型还是具有自动装箱拆箱的功能。最有意思的是java的内部类，它提供了另外一种回调的方式。 但是java也有很大的缺陷，最大的缺陷是性能，如果Google能够推广最新的JIT技术，那这个问题会减轻很多。同时，java也是一种非常啰嗦的语言，甚至比Objective-c还要啰嗦，OC只是名字比较啰嗦而已。 cppc++怎么说呢，本来就不是纯粹的面向对象语言，为了兼容c，在一些方面不得不做一些让步。但是也有很多有意思的特性，比如操作符重载，隐式转化，智能指针等等。同时c++强大的模板和模板元编程，又让c++成为了更加强大而有技巧的语言。当然，这也大大增加了学习成本和难度，同时写法上也不够简明易懂。 Sql这个什么都不用说了吧，应该算是基本技能。概括起来： 123456CREATE TABLESELECTINSERTDELETEUPDATEALTER lua这是一门特别轻量级的语言，以及及其简单的语法和数据结构，所有数据都是字典类型，同时又有一定的面向对象的能力。当然，缺点也是非常明显的，作为一门独立的语言，功能还是太弱，也缺少相应的类库，所以只能嵌入程序中使用。 虽然说是一门脚本语言，据说效率很高，至于它很快的原因，是否使用了JIT技术，这个还可以继续研究下。 javascript怎么说，最常见的脚本语言，大家都熟悉，语法上像极了java，所以用起来也可以说是得心应手，但是要用到javascript的面向对象却非常复杂，javascript是基于原型来描述面向对象的，所以javascript里面没有class，所有的class都是实例对象，导致看起来总感觉怪怪的。 javascript最好用的地方莫过于他的函数式编程了，可以说闭包和函数式编程才是javascript吸引人的地方。 Node.jsNode可以说是javascript服务端(也是本地)的实现，而且使用了V8引擎，不过这个标准目前还不那么稳定，不过他在服务器端优秀的表现，绝对是有值得了解的必要。 python这是我非常想学的语言，并不是说Python有多么完美，而是Python既拥有脚本语言的特性，又能够很容易的使用面向对象。他避免了shell脚本晦涩难懂的语句，同时增强了字符串等操作，所以完全可以使用Python来替代shell脚本，而Python一般是linux和unix的标配，所以应用也很广泛。 Python能够很好的支持面向对象，而且语法简单，所以除了做shell脚本外还能支持大型项目。完善的包管理机制也同样提供了很多方便。可以说在这方面Python完全可以代替java，但是由于Python是一门弱类型语言，所以在一些调试和代码检查方面可能会差一点。 Python中比较有意思的一个是函数装饰器，像@static_method，这个思想倒是值得我们借鉴。另外还有with的语法也比try...catch...简洁很多。可以说Python非常适合做模型。 Liquid这是一门模板语言，目前github上的page就是用jykell+liquid完成的，而且它还和django的模板语言特别相似。当然，模板语言的弱点十分明显，可以说都算不上一门语言。除此之外还有很多模板语言，使用也非常简单。 HTML/CSS/Less对于想了解网页方面知识，这个应该是基础的基础，作为标签语言，也非常简单，没有什么特别的技巧，但是对于布局却是一个启发，像android那样的布局，对多尺寸适配会方便很多。 Less作为对css的一个补充，还是非常不错的，可以减少很多的工作，还能编译完再发布。 Markdown作为一种简化版的富文本编辑方式，非常简单易懂，比使用html更简单，也比使用word之类的更灵活，还能直接转换为html，程序员必备。 django &amp; express这两个分别是基于Python和Node的一套网站框架，django比较成熟，已经有很多的人在使用，基本功能都已经包含。express比较新，一些功能可以通过包来安装。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://djs66256.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"总结","slug":"总结","permalink":"http://djs66256.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2013学年总结之iOS篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之iOS篇/","text":"这里并不是高深的ios的研究或者教程，相信这些东西查阅官方资料才是最靠谱的，仅仅只是对一些基本技能的总结和概括 Core Graphios绘图基本方法，遗憾的是该api是c的，不过api简单易懂，非常容易使用。除了在draw方法里面使用外，还可以使用UIGraphicsBeginImageContext生成一个图片的上下文，通过代码来获取一些图片，而不再需要UI提供图片。 基本使用方式，注意记得保存和恢复上下文即可: 1234CGContextSaveGState(ctx);[color set];CGContextDraw...CGContextRestoreGState(ctx); 有一个非常有意思的贝塞尔曲线，具体算法我还没怎么搞明白，不过只要有这个，可以说，我们可以画出任意的图形了！ 说到绘图，这里不仅仅能绘制和填充简单的线条、图片外，还能绘制PDF，但是在手机设备上必须放到异步绘制，可以有两种做法： 1. 异步绘制到ImageContext上，以图片的形式展现 2. 使用CATiledLayer，这个属于Core Animation部分了 Core Animation以CA开头的类很多，虽然看名字这个是一个动画的框架，但是不仅仅如此，所有的图层都属于该框架。 说到动画，不得不说不总结下几类动画的实现方式： 1. 基于UIView的动画，所有方法定义在UIView(UIViewAnimation)，这个是最简单，最常用的方法。 2. 基于CALayer的动画，基于UIView的动画还是有不少局限，只能实现比较简单的移动旋转等，当我们需要一些复杂的动画或者无限循环的动画时，就需要基于CALayer的动画 3. 基于定时器的自定义动画，值得注意的是，这里的定时器最好是使用CADisplayLink，这个才是真正基于帧的定时器 core animation是基于keyPath实现的，写法上有些怪异，但是仅仅比基于UIView的动画稍多一点工作量，但绝对物超所值。 123456789[UIView animateWithDuration:2 animations:^&#123; CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; anim.fromValue = [NSValue valueWithCGPoint:position1]; anim.toValue = [NSValue valueWithCGPoint:position2]; anim.duration = 3; anim.cumulative = YES; anim.repeatCount = HUGE_VAL; [view.layer addAnimation:anim forKey:@&quot;ps&quot;];&#125;]; 还有一个比较有意思的图层：CAShapeLayer；使用这个能够完成你意想不到的一些效果，专门为动画而生的图层！ Core Text苹果超级强大的文字绘制框架。core text绘制使用的是AttributeString，遗憾的是这个类在ios6以后才比较实用，很多属性是后面才加进来的，不过这以没什么关系。 首先我们来划分一下core text： 1. 绘制内容，即AttributeString 2. 布局系统，core text除了内容外大部分都是布局系统 3. 绘制系统，这个需要到最后一步才会真正的绘制到画布上，即`CTFrameDraw` 这里最有趣最值得研究的是布局系统，我们可以设置文字绘制的位置范围，还可以通过kCTRunDelegateAttributeName来实现图文混排，还能计算文字绘制完毕后所占用的大小，api比较多，但是实现起来确实非常简单。 123CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(attributeStr);CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), pathref, NULL);CTFrameDraw(frame, ctx); Core ImageCIImage的使用也是非常的简单，只是系统提供了很多的滤镜，要一个个的了解过来还是需要很多的时间。平时如果不需要有图片编辑功能，我们还真用不到。这个是在GPU的内存空间中转换的，如果你从用户内存空间拷贝到GPU内存，再做渲染，再拷回用户内存，这样的开销其实也很大。网上也有基于此的开源项目GPUImage。 1234CIFilter *filter = [CIFilter filterWithName:@&quot;CISepiaTone&quot;];[filter setValue:image forKey:kCIInputImageKey];[filter setValue:@0.8f forKey:kCIInputIntensityKey]; CIImage *result = [filter valueForKey:kCIOutputImageKey]; Core Data又是一个非常庞大而复杂的框架，如果要真正理解这个框架还真要费很大力气，毕竟官方教程就快上1k页了。除此之外还要了解一些keyPath、predicate表达式等等。但是学会使用确实非常简单。core data毕竟不是SQL，它还需要支持xml等格式，所以一些复杂的搜索逻辑或者优化分表什么的就不行了，如果你不需要如此复杂的功能，并且也不准备维护SQL语句，使用core data当然是没得选了。 说到数据库，core data是根据对象为单位的，而我们自己使用的时候却没有这个限制，在这个问题上，我更倾向于根据对象来操作，这样不仅能统一接口，还能避免很多错误和后期维护工作，我们大可不必担心那么点的性能损耗。 Image IO又是一个很有意思的接口，当我们从网络下载大图片的时候，是等我们下完再展现还是，下多少展现多少，这个接口正好适合你！它能够拼装不完整的图片，除此之外还能创建缩略图等等。 多线程说到多线程，我们可以总结下ios里面的几种实现方式： 1. Unix接口，pthread，这个我觉得除非是移植代码，应该没人使用吧 2. NSThread，相当于pthread的OC版，但是不仅仅如此 3. RunLoop，这个应该不算是多线程的实现方式，类似于轮询或者多路复用的结果，但从结果上来看是异步的 RunLoop一般与NSThread配合使用，需要一个事件源(NSPort)，这部分还是挺有意思的 4. GCD，可以说是系统级的线程池，除了单纯的多线程外，还能提供监听句柄(如file，socket)的状态变更（一种多路复用？） 但是GCD一旦触发，便不能取消，这也是值得注意的地方，而且Block的使用也存在一些自身的问题，使用不当可能造成线程的疯狂创建而崩溃。 在这方面还需要再多研究研究 Runtime在Objc Runtime中对我们比较有用的两条是： 1. objc_setAssociatedObject和objc_getAssociatedObject，可以给一个已存在的对象（比如我们无法修改的系统类和第三方库类），动态增加成员 2. method_exchangeImplementations，置换方法，比如置换系统方法，增加我们自定义的功能逻辑。这个方法虽然有些时候很方便，但是也会带来不必要的一些麻烦，而且改变的是全局的方法，所以也有一定的风险。 NSPredicate苹果有一个非常强大的匹配语言，就是谓词表达式，他甚至可以说是正则表达式的超集，缺点就是只能返回bool值。 它也是基于keyPath，不仅仅能匹配普通的正则表达式，还能够过滤数组等集合。 比如： 1234// 正则表达式SELF MATCHES ...// 对象是否是以下几个对象之中@&quot;SELF IN %@&quot;, @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;] 代码显得非常简洁易懂，所以在大部分时候我们都可以使用这个来代替复杂的编码 Blockblock是一种实现闭包的方式，但是并不完美，特别是内存泄露问题，使用不当非常容易造成内存泄露。 block主要分为： 1. 栈上的Block 2. 数据区的Block 3. 堆上的Block 如果你对这3种情况不是很了解的话，最好不要使用太多的block。 一般来说，block使用场景为明确知道结束点的逻辑中，比如GCD，alertView，http请求等等，这些具有明确结束点，而且回调内容也不可能很复杂，所以非常适合block的发挥，但比如不同的controller间，如果采用block，可能就会导致循环引用，因为block在没有被释放或者被执行过之前，block内所持有的对象就不会被释放。 block的使用需要特别小心，我们在页面编程中尽量不要选择block来回调。 NSFormatterNSDateFormatter是我们使用最多的格式化类，但是注意，创建这个比较损耗资源，所以尽量不要在循环中创建，有人甚至直接做一个单例来使用。 另外一个不常用但非常强大的格式化类是NSNumberFormatter 另外，我们可以自定义一些formatter，比如时间格式化为“今天”，“一周前”，“几个月前”等等之类的，还是比较符合理解和规范的。 NSScanner遍历字符串的一种方法，是实现词法分析等功能的基础。这个也能解析一些数字，不仅仅是10进制。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"core graph","slug":"core-graph","permalink":"http://djs66256.github.io/tags/core-graph/"},{"name":"core animation","slug":"core-animation","permalink":"http://djs66256.github.io/tags/core-animation/"},{"name":"core image","slug":"core-image","permalink":"http://djs66256.github.io/tags/core-image/"},{"name":"image IO","slug":"image-IO","permalink":"http://djs66256.github.io/tags/image-IO/"},{"name":"runtime","slug":"runtime","permalink":"http://djs66256.github.io/tags/runtime/"},{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"}]},{"title":"2013学年总结之工具篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之工具篇/","text":"####git/svn &amp; markdown &amp; vim &amp; dash/zeal Git/Svn在软件开发和很多场景下，我们都需要版本管理工具，现在最流行的就有svn和git，svn使用非常简单，最常用的命令如下： 1234svn checkoutsvn updatesvn commitsvn log 同时svn也拥有很多的图形客户端，对那些不是开发人员的人也比较友好。但是svn有个致命的弱点，就是不能脱离服务器，对于平时使用时还是有很多不便。而且svn对于分支开发支持也不太友好。 还好，我们有git来解决svn的问题。git的使用稍微比svn麻烦一些，需要了解一些分支等的概念，但是作为日常使用也和svn差不多，比较常用的命令有： 123456789git initgit clonegit checkoutgit addgit commitgit fetch/pullgit pushgit rebase / mergegit log 总体使用上感觉如果是一些比较复杂的需要多人开发的，而且项目比较大型，周期比较长，或者需要并行开发的都适合使用git。这是一个非常有用的工具。 git的图形软件有： 12SourceTreegithub Markdown作为富文本文件格式，markdown比word更加简单轻便，而且适用场景多，可以直接翻译为html，特别适合网络文档，同时对代码的支持也比较好。甚至可以直接支持html，对普通的文档博客来说已经足够了。 客户端程序有： 1haroopad/Mou VIM这个是UNIX环境必备的编辑工具，而且使用起来也不必使用鼠标慢。 VIMDIFF这个diff工具非常强大，但是全部使用键盘，感觉没有使用鼠标舒服，但是偶尔用用还是非常不错的 123]c / [cdp / dozo / zc 配合git的difftool和mergetool，还是不错的。 Dash/Zeal说到官方文档，mac下面有个非常好用的工具Dash，但是一直遗憾win和linux环境下一直没有一个适合的工具，直到有个开源项目的开始Zeal，现在Zeal已经比较完善了，几乎可以媲美Dash了。Zeal在github上有托管。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://djs66256.github.io/tags/git/"},{"name":"svn","slug":"svn","permalink":"http://djs66256.github.io/tags/svn/"},{"name":"markdown","slug":"markdown","permalink":"http://djs66256.github.io/tags/markdown/"},{"name":"vim","slug":"vim","permalink":"http://djs66256.github.io/tags/vim/"},{"name":"vimdiff","slug":"vimdiff","permalink":"http://djs66256.github.io/tags/vimdiff/"},{"name":"dash","slug":"dash","permalink":"http://djs66256.github.io/tags/dash/"}]},{"title":"2013学年总结之设计模式篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之设计模式篇/","text":"总结一下了解的设计模式 工厂方法和抽象工厂这个是我们用的最多的设计模式也是最简单的设计模式，可能大家平时都用了。 需要注意的是，抽象工厂如果需要运行时类型判断的话，最好还是重新看下自己的设计，毕竟运行时类型是逼不得已的手段。 生成器 (Build)生成器主要用于拼装数据，典型的比如网络请求数据，二进制数据等，和工厂方法不一样的地方是可以慢慢瓶装。 生成器在我们需要比较复杂的数据而不想暴露数据结构和实现的时候比较适合。 原型 (prototype)原型模式其实OC这门语言可以说是基于原型的，还有一门非常典型的语言javascript，原型主要靠拷贝原型来实例化对象，实际应用中比较少。 单例 (singleton)这个是常见的不能再常见的模式，但是单例的缺陷也很大，首先是初始化循环问题，还有内存问题，破坏封装等等。由于单例就相当于全局变量，在不必要的地方最好不要使用单例。 适配器 (adapter) / 桥接 (bridge)适配器和桥接都是接口的适配，但是作用有些不一样。 适配器可以分为继承适配器和成员适配器，两者各有各的应用场景，主要是做接口的适配 桥接做了接口适配，但主要目的是为了动态配置和复用其他接口代码。 组合 (composite) / 响应链 (responder)组合和响应链可以说是天生的一对，组合模式是自顶向下的，比如UIView的结构，一层一层往下，而响应链刚好相反，是从最底层发起，一直把事件往上抛，直到有人能处理为止，比如touch事件。 装饰 (decorator) / 策略 (strategy)装饰和策略的目的都是一样的，都是改变一个对象的行为，比如给数据流加上缓存功能，给请求加上加密。 装饰主要是修饰一个方法或者一个类来改变行为，主要是添加一些其他行为，比如缓存等。这样既能保持原来的接口和代码，又能增加修饰。 而策略主要是配置不同的行为，比如不同的加密方式，一般策略是作为一个成员来控制行为，这样既能保证封装，又能在有限的范围内添加行为。 外观 (facade)外观非常简单，主要是为了提供给外部一个统一的接口，而隐藏内部实现。主要应用在类库中。 享元 (flyweight)享元主要是为了使用共享内存，比如字体等比较耗内存的地方。 命令 (command)命令模式主要把行为封装，可以动态的配置行为，这个用已有的多自己写比较少 解释器 (interpreter)这个主要用在解释语言上，比较少见 迭代器 (iterator)非常常见的模式，隐藏了内部实现来解决遍历问题。 中介者 (mediator)在很多场景下，我们并不能整理出层次关系，或者模块间本来就很独立，这样相互交互导致了网状结构，从而一片混乱。中介者把网状结构改变为星型结构，所有模块都与中介者交互，这样能够独立模块，减少耦合度。但同时也有个问题，就是中介者有可能成为一个很复杂的模块。 备忘录 (memento)这个相当于undo manager，一般用的比较少，往往和命令模式一起使用，只是命令中除了行为外还需要取消行为的方法，这是实现撤销功能的一种方法。 观察者 (observer)这个在ios中也非常常见，主要应用场景是接受者未知，而且数量未知。 状态 (state)这是个封装一般性行为的模式，比如网络连接，中间有很多状态，但连接、重连、断开行为都是一样的，使用状态模式来封装这些行为，而连接失败等业务行为放在子类中实现，从而避免了网络行为中参杂一些其他逻辑。 模板 (template)这个典型的时UIApplication和UIViewController，把公共的方法提取到父类，具体业务放到子类，相当于抽象类的作用 访问者 (visitor)访问者和迭代器在功能上很类似，但是从设计上很不同，迭代器如果遍历不同对象时，必须要用到运行时类型检查，从而导致一个问题，在对象类型越来越多的情况下，这里会越来越复杂，而且增加一种类型每个这种地方都要修改。visitor模式能够封装这些类型，如果增加一种类型，只要修改visitor类就可以了。好处显而易见，但坏处也是有的，增加了封装，导致更加抽象，对于一些不熟悉的人来说可能会有些麻烦。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂方法","slug":"工厂方法","permalink":"http://djs66256.github.io/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"},{"name":"生成器","slug":"生成器","permalink":"http://djs66256.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"单例","slug":"单例","permalink":"http://djs66256.github.io/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"UIScrollView动画效果模拟","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-17-UIScrollView动画效果模拟/","text":"当年苹果手机发布的时候，大家都惊叹于流畅的滑动效果，也就是UIScrollView的效果。现在由于工作中有个需要，能够模拟系统的滑动效果，因此开始了研究。目前代码托管在github上。 首先这里肯定不是CAAnimation的效果，那么我们使用CADisplayLink来实现这个效果。 ##弹性效果 当我们拉出边界的时候，会有一个弹性的回弹效果。看系统的效果，应该是一个时间固定的动画效果。开始我想可能是模拟摩擦力的效果，demo中使用的也是摩擦力效果，但实际上和系统的效果做比较后发现有些细微的区别，系统可能使用的是双曲线的模型。但也有点像模像样了。 ##惯性效果 在我们拖动停止的时候，我们还有个惯性效果，同样的我们这里使用摩擦的效果。和系统对比后发现系统比摩擦效果更加的圆滑，系统应该用的还是双曲线效果。 还有惯性结束后的碰撞效果我也是模拟摩擦力，不过系统好像也是双曲线模型，感觉系统的效果更加的平滑，不过和系统的scrollView效果比起来也可以看看了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"scrollView","slug":"scrollView","permalink":"http://djs66256.github.io/tags/scrollView/"}]},{"title":"code-snapshot","date":"2012-08-19T10:50:34.000Z","path":"2012/08/19/code-snapshot/","text":"Jailbroken123456789101112131415161718192021222324252627282930313233343536373839+ (BOOL)isJailBroken&#123; static const char * __jb_apps[] = &#123; &quot;/Application/Cydia.app&quot;, &quot;/Application/limera1n.app&quot;, &quot;/Application/greenpois0n.app&quot;, &quot;/Application/blackra1n.app&quot;, &quot;/Application/blacksn0w.app&quot;, &quot;/Application/redsn0w.app&quot;, NULL &#125;; __jb_app = NULL; // method 1 for ( int i = 0; __jb_apps[i]; ++i ) &#123; if ( [[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:__jb_apps[i]]] ) &#123; __jb_app = __jb_apps[i]; return YES; &#125; &#125; // method 2 if ( [[NSFileManager defaultManager] fileExistsAtPath:@&quot;/private/var/lib/apt/&quot;] ) &#123; return YES; &#125; // method 3 if ( 0 == system(&quot;ls&quot;) ) &#123; return YES; &#125; return NO;&#125; Color darkness or lightnesshttps://www.w3.org/WAI/ER/WD-AERT/#color-contrast ((Red value X 299) + (Green value X 587) + (Blue value X 114)) / 1000Note: This algorithm is taken from a formula for converting RGB values to YIQ values. This brightness value gives a perceived brightness for a color.","categories":[{"name":"temp","slug":"temp","permalink":"http://djs66256.github.io/categories/temp/"}],"tags":[]},{"title":"我的项目","date":"2012-08-05T15:23:44.000Z","path":"2012/08/05/my-project/","text":"我的 Github 项目，欢迎给我提意见。 DDComponent Star一个和IGList类似拆分CollectionView的扩展 相关介绍可见： 美学的表现层组件化之路 IGListKit简析与DDComponent DDSkin Star一个自认为相比于目前其他框架更好的实现方式 相关介绍可见： DDSkin做更好的换肤框架 DDKeyPathChannel Star自动同步不同对象间的属性值，也可以用作同步UI属性 相关介绍可见： 客户端全局数据同步方案(一) 全局数据同步（二）UI篇 全局数据同步（三）终极方案 ExDebug Star一个客户端debug扩展工具，你可以在pc端远程的查看log与设备状况了。 相关介绍可见： 疯狂日志系统 DDAttachmentTextView Star可自定义组件的富文本编辑器 相关介绍可见： 从UITextView看文字绘制优化 lily Star一个埋点管理系统 相关介绍可见： 自己写的一个埋点管理小工具 UIView-RelativeLayout Star在AutoLayout还没有普及的时候，可以利用这个进行陈述式布局，减轻布局复杂度。","categories":[{"name":"我的项目","slug":"我的项目","permalink":"http://djs66256.github.io/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"开源项目列表-iOS & mac","date":"2012-07-16T17:57:37.000Z","path":"2012/07/17/project/","text":"收藏的开源项目以及部分分析。 AVPlayer ZFPlayer 3566 Stars Objective-C 功能比较完善的一个视频播放及界面，但是实现较为一般。 StreamingKit 1641 Stars Objective-C 基于流来构建音频播放，是一个思路，但可能不能满足特殊情景。 LFLiveKit 2677 Stars Objective-C 利用GPUImage做滤镜的一个直播录制系统，功能比较完善，可以作为参考。 TTAVPlayer 84 Stars Objective-C 比较简单的基于AVPlayerLayer的一个实现。 CTVideoPlayerView 499 Stars Objective-C 没太大参考意义。 EZAudio 4070 Stars Objective-C 音频的波形分析和展示，利用了accelerate，比较全面。 Cache YYCache 1490 Stars Objective-C 使用了LRU策略 内存缓存使用了线性链表+NSDictionary来实现，由于LRU的特性，插入永远在开始，而删除永远在结尾，所以拥有较高的性能。但是查找还是依赖于hash表来实现。 磁盘缓存使用了sqlite来保存文件缓存信息（filename, last_modify_time)，所以在读写小数据的时候（20KB）会直接在sqlite中读写，而不会生成一个独立的文件。所以在小文件和未命中的情况下效率会高很多。而读写大文件时，效率会降低一些，考虑到sqlite的缓存和执行，并不会降低太多。由于sqlite对时间创建了索引，所以在缓存过期查找上面会优秀一些。这种设计解决了小文件和未命中的效率问题，但是并不能实现高并发读写文件。 PINCache 1759 Stars Objective-C 使用了大量的Lock来处理读写，拥有异步读写接口，没有太多的特别优化。 磁盘缓存单纯使用了文件缓存，在初始化的时候就把整个目录及其元素的属性读到内存，来提高效率，但是使用的是数组存储，效率一般。 SPTPersistentCache 1139 Stars Objective-C 利用CRC32来校验文件，据说速度较快。 他将数据信息通过memory map的方式写到了文件头部，说是为了并发读写，但这也时每次更新updateTime需要写整个文件，这样必定会导致性能降低。个人建议还是把文件信息写到另一个文件中，方便内存缓存。 OSCache 184 Stars Objective-C 一个模仿NSCache的实现，内部使用NSDictionary。 Haneke 1775 Stars Objective-C 他和SDWebImage非常相似，个人看来，这个的代码及其结构会比SD好一些，但是功能太有限，就像作者自己说的是一个轻量级的实现。 SDWebImage 18607 Stars Objective-C 实现功能非常完善，是目前最好用的一个图片缓存库了。但是也有几个小问题。 图片读取全部在一个子线程中进行，在高并发读取的时候会阻塞线程，同样下载和解码也会有类似的问题。 图片的二次处理能力不够（比如手动加圆角，裁剪，滤镜），好在目前大部分工作CDN都会帮我们做掉。 预加载图片无法和正常加载使用同一套机制，预加载和正常加载如果同时触发会加载2次。 在扩展方法的时候，直接在UI组件上添加方法，这就导致了每次引入新特性的时候都需要增加一个系统类的扩展（比如UIImage），更好的方式应该是暴露一个代理对象： 123[view sd_setImageUrl:url];// 改为这样会更好一点[view.sd setImageUrl:url]; FastImageCache 7547 Stars Objective-C 该作者认为效率问题主要出现在图片从磁盘读取到内存，再进行解压，以及渲染前的内存拷贝。解决这类问题的最好方法就是进行memory map，作者也指出了这种方式会导致一张高压缩率的图片，进行内存映射后会变得很大这一非常大的缺陷。 123void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);int msync(void *addr, size_t len, int flags)int munmap(void *start, size_t length); 作者将图片按照图片size，rgba等信息进行分类，分别存储于不同的image table里面，同一个table里面会依次写入多张图片信息。但是这样会导致一个table过于庞大，而作者也没有给出非常好的过期策略以及删除部分缓存的策略。 作者将图片元信息metadata存储于另一个文件中，可惜的是使用了json序列化，导致每次更新必须全量更新，在数据量庞大的时候可能会产生性能问题吧。 这并不适用于大量图片以及图片尺寸较多的场景，但是可以用于部分频繁设置image的场景。 Component HubFramework 1746 Stars Objective-C 也是一款拆分CollectionView的设计，个人认为拆分的太细了，导致整个系统过于复杂，学习成本太高。 BeeHive 2236 Stars Objective-C 将客户端的架构和服务端service结合，从而实现整个app的组件化。本身服务端和客户端在很多方面就不一样，需要更多的情景考虑。他的实现在有些场景还是不够的灵活，但是其思想可以借鉴下。 IGListKit 6775 Stars Objective-C 事件驱动的collectionView组件化封装。具体参考IGListKit简析与DDComponent componentkit 4062 Stars Objective-C++ 类似于React方式，使用component来布局UI。完全颠覆了传统的架构和编码方式，学习成本高。项目复杂，由objective-C++编写，利用了大量隐式转换的特性，所以不适用于swift。 Crash Report KSCrash 1732 Stars Objective-C Encrypt MIHCrypto 272 Stars Objective-C 非常全面的加密库。 Markdown CocoaMarkdown 936 Stars Objective-C MMMarkdown 1083 Stars Objective-C macdown 6323 Stars Objective-C Kit AppDevKit 1317 Stars Objective-C 一些扩展，用处不大。 YYKit 10852 Stars Objective-C 包含了很多util方法，以及cache，image，text，json2model方面的类库。 EasyIOS 824 Stars Objective-C 没有参考价值 BlocksKit 可以将他的功能归为两类： 1, sequence，swift中自带的概念，和reactive的概念一致，是一种流式的写法。2, 动态delegate，实现动态delegate的转换，从而实现了大量UI层的回调简化。 功能比较多，除了sequence和UI层的事件外，还有associate object、perform以及KVO（和KVOController类似）。如果是objc开发，可以考虑使用。 Bolts-ObjC 5180 Stars Objective-C 主要提供了两个工具： 1, Task，类似于promise，以及reactive，个人觉得不如另外两者。2, AppLink，一种多平台兼容的跳转方案，同时兼容native和web等，应用面会比MGJRouter这种广一点，但实现上不是非常的完善和通用。 QMUI_iOS 1687 Stars Objective-C 一套非常完善的UI组件库，设计也比较精美，出自腾讯团队。本人认为他也有几个的缺点，那就是利用了大量的Runtime特性，导致很多系统方法都被hook了，这可能会带来某些隐患。由于很多方法都是在系统类上加的，所以api并不是很美观，总是有qmui_这样的前缀。同时hook了UI层的东西，所以如果使用原生的组件也势必会带上一些QMUI的东西。 NavigationBar交互动画的修正采用的是在controller.view上加上一个只设置了背景的navigationBar，同时隐藏原生的navigationBar来实现。相比于另一种使用navigationController再套一层每个controller，从而让每个controller的navigationBar相互独立，本人认为QMUI的方式更加优秀，影响面更加小，毕竟不会影响到整个controller的栈结构。 Util YOLOKit 628 Stars Objective-C 一个类似于reactive中sequence的工具类，建议直接使用Reactive。 libextobjc 3682 Stars Objective-C 非常有名的几个宏定义的出处，对宏的理解和运用都非常厉害，但是平常经常使用的也就那么几个。 123@strongify()@weakify()@onExit&#123;&#125; Data json-framework 3799 Stars Objective-C 原来的SBJson，建议使用系统方法。 jsonmodel 6307 Stars Objective-C JSON转model，缺点是必须继承于JSONModel基类。 ReactiveViewModel 1727 Stars Objective-C 增加了active事件，没什么用。 RestKit 10154 Stars Objective-C 包括了网络请求，json转model，以及到core data，如果有这些方面的需求可以尝试下。 JSONKit 6136 Stars Objective-C 建议使用系统方法。 Mantle 10744 Stars Objective-C JSON转model，但是要继承于基类。 Doppelganger 660 Stars Objective-C 一个diff工具，用于CollectionView的reload。 Diff.swift 794 Stars Swift 也是一个CollectionView reload的diff工具。 OrderedDictionary 253 Stars Objective-C 有序字典，意义是？ FastCoding 883 Stars C 自动NSCoding，还不是特别通用。 AutoCoding 969 Stars Objective-C 利用获取property来自动NSCoding。 KVO RZDataBinding 445 Stars Objective-C 对象绑定思想也是使用associate object，同时也hook了dealloc。但是很多地方使用了assign而不是weak。不推荐使用 他提出一个事务的概念，将众多变更一次性提交，但好像没什么太大的意义。 KVOController 5977 Stars Objective-C FB出品，使用associate object管理内存和负责移除KVO，非常良好的实现方式，推荐使用这个。 HTBKVObservation hook dealloc来负责移除，需要自己来保证observation的生命周期，使用上不如FB的方便。 MAKVONotificationCenter hook dealloc来负责移除监听。 DB YTKKeyValueStore 1759 Stars Objective-C 利用sqlite做的一个简单的KV存储。 YapDatabase 2919 Stars Objective-C 利用sqlite做的一个KV存储，会保存数据元信息和对象间的关系，优化了多线程读写。 realm-cocoa 11297 Stars Objective-C 和sqlite一样，也是一种关系型数据库（这里讨论本地的realm）。 数据保存方式为内存映射，按照realm的说法是sqlite在读取保存数据时候会产生内存拷贝而影响性能。 数据按照列（column）来保存，每一列的数据格式是固定的，在查找效率上也会提升。同时列拥有不同的chunk来同步到磁盘，这样在读写的时候可以只锁定目标chunk而达到高并发读写。 数据结构实现为B+树，与sqlite使用的B树不同，B+树保证了叶子节点存储的连续性。 CoreObject 280 Stars Objective-C ensembles 1536 Stars Objective-C MagicalRecord 10498 Stars Objective-C fmdb 11935 Stars Objective-C sqlite的轻量级封装，缺少ORM，但是也非常简单，容易debug。在少量场景的情况下推荐使用。 sequelpro 3695 Stars Objective-C GYDataCenter 608 Stars Objective-C sqlcipher 2505 Stars C SQLCipher is an SQLite extension that provides 256 bit AES encryption of database files. wcdb 4079 Stars C 微信封装的sqlite ORM。支持多线程和数据修复，支持数据加密，用接口的方式强制格式化sql语句，功能比较强大，缺点是必须使用c++来实现其model，实现也较为复杂。如果在这方面需求量不大的情况下，没有必要迁移。 其sql拼装是字符串累加，而不是从语法树生成，所以必须依赖底层sqlite的存储方式。 rocksdb 8645 Stars C++ 基于leveldb，对齐进行了多线程以及ssd的优化。 leveldb 10957 Stars C++ 是基于Google的big data实现的一套KV存储，原理简单的说就是每次操作（增删改），都是生成一条数据，存入文件，在一定的条件下，会对这些文件进行merge操作，来保证文件的大小。这种方案解决了高并发写的问题，但是增加了读的开销，是一种折中方案。在移动端的场景下好像没有这么高的并发写场景，应该没有必要使用。 数据结构使用跳跃链表（skip list）来实现，他比B/B+数的实现简单，同时也有不错的性能。 Notes iOS-Source-Code-Analyze 源码分析笔记，有些地方过于详细了。 trip-to-iOS 7187 Stars Objective-C 一些资源以及博客等整理，比较老了，偏向新手。 ParseSourceCodeStudy 2506 Stars Objective-C Parse的一些列分析文章。 iOSInterviewQuestions 5883 Stars Objective-C iOS面试题集锦 iOSBlogCN 4391 Stars Python iOS博客集合。 TomatoRead 458 Stars Objective-C iOS博客集合。 idev-recipes 3003 Stars Objective-C IosHackStudy IOS安全学习资料汇总 The-Art-Of-Programming-By-July 11813 Stars C Apple-OfficialTranslation-SourceAnnotation Halfrost-Field 592 Stars Objective-C Network AFNetworking 30057 Stars Objective-C NSURLProtocol-WebKitSupport WebViewProxy 793 Stars Objective-C MMLanScan 207 Stars Objective-C 网络质量检测 DFImageManager 1220 Stars Objective-C Nuke 2370 Stars Swift swift of DFImageManager OHHTTPStubs 3383 Stars Objective-C RTNetworking 1097 Stars Objective-C CocoaSPDY 2342 Stars Objective-C RealReachability 2399 Stars Objective-C XMNetworking 705 Stars Objective-C fastsocket 3466 Stars C In-App Purchase CargoBay 1772 Stars Objective-C Objc Runtime jrswizzle 2062 Stars Objective-C Method swizzling MAZeroingWeakRef 336 Stars Objective-C MRC时代的weak实现，可以作为参考。 Aspects 5436 Stars Objective-C 一个比较全面的hook库，一般用于测试。 DLIntrospection 587 Stars Objective-C runtime方法的objc封装。 fishhook 1999 Stars C 用来hook C方法。 JSPatch 10076 Stars C 非常有名的利用js来动态hook的库。主要通过将:转换为_来实现函数签名的通用，同时格式化js代码，使.调用变为.__c()的方法调用。 和其他（react-native等）的思想不同，不会收集oc的方法签名，然后转到js中生成函数，使用的是修改js代码的方式，但会让debug变得困难，个人更倾向于react-native这种方式。 Socket CocoaAsyncSocket 9204 Stars Objective-C Web Socket SocketRocket 7190 Stars Objective-C AZSocketIO 274 Stars Objective-C Template GRMustache 1318 Stars Objective-C CoreParse 358 Stars Objective-C Theme DKNightVersion 2809 Stars Objective-C 一种换肤框架实现，缺点也非常多，支持的属性也比较少，本人实现了一个更加简单完善的版本DDSkin Tweaks 4622 Stars Objective-C Util NSDate-TimeAgo 1681 Stars Objective-C NSDate的Helper类，比较简单。 DateTools 5763 Stars Objective-C NSDate的Helper类，比较全面。 Router routable-ios 1600 Stars Objective-C HHRouter 1393 Stars Objective-C这两个都是类似的实现，比较简单。 JLRoutes脱离UIKit，非常好用的一个实现，据说性较低，没有实际验证过。 MGJRouter 1040 Stars Objective-C蘑菇街的实现，算法经过优化的JLRoutes，实际没有验证过。 CTMediator 1212 Stars Objective-C使用中间人来解决路由系统，使用target-action方式注册行为， Hybrid Framework7 一款模仿ios和android原生特性的h5组件库，效果来看很不错，可以使用vue和react，如果是写纯网页应用可以考虑使用这个。 react-native 53996 Stars JavaScript 1.4k贡献者，社区非常活跃，目前最热门的方案。拥有非常完善的debug方式以及各种工具，同时React的发展也特别的好。可以完成整个app的功能，也可以作为app的一部分嵌入使用。首推。 大部分组件可以支持iOS和Android，也有很多定制化的组件，所以有些时候需要区分平台来写，也不能无缝降级h5。 incubator-weex 5496 Stars JavaScript 和react-native竞争的产品，由阿里出品。框架会比react-native小一点，但功能也会少很多，排版是受阉割的flex，和官方所说的无缝降级h5有出入。一份代码能够同时在iOS和Android上运行，但为了统一也失去了很多的系统特性，感觉没有官方吹的那样厉害。 [PhoneGap]cordova的商业版 WebViewJavascriptBridge 9454 Stars Objective-C webView中js与native交互的库。一种简单的实现，如果需要更复杂的实现可以使用cordova。 ng-cordova 3629 Stars JavaScript 利用webview js和native的通信实现web端调用native方法。 原理和JSWebviewBridge类似，利用的都是iframe和messageQueue，require组件是直接在head中插入script实现，不知道在组件变多的情况下是否会影响性能，考虑到lazy load的情况，可能会好一点。 组件需要自己根据需要添加，组件比较全面，该有的都有。 但是iOS端是基于UIWebView实现的，不知什么时候能够替换成WKWebView，来提升性能。 code-push 2993 Stars TypeScript 基于cordova和react的云端服务 BeeFramework 3378 Stars Objective-C 利用xml来实现布局，目前已经废弃。 samurai-native 2280 Stars HTML 利用css和html来实现布局和事件绑定，但是实现还是需要原生代码，所以不能独立的去实现一个页面的功能。 VasSonic 5742 Stars Java 腾讯的加速web载入速度的库，原理其实就是客户端增加native缓存管理，减少获取某些静态文件的请求时间。 iOS版依赖于NSURLProtocol，是基于UIWebView实现的，不能支持WKWebView。 其中获取js运行上下文用了黑科技。 1[self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; ionicframework 基于cordova的一款h5组件库，效果很不错，增加完善了很多native组件，使用的是Angular mobileangularui 也是一个UI组件库 Tangram-iOS 758 Stars Objective-C 阿里首页的实现方式，可以认为是一种模板技术，需要客户端开发业务模板，用在业务比较稳定的场景，局限性较大，但是版本更新成本较低，维护成本低。平时设计接口的时候可以参照这种模板方式来配置。 JASONETTE-iOS 4786 Stars Objective-C 可以认为是一种完整的DSL，功能还是挺强大的，列表使用UITableView，布局系统使用UIStackView，因此也有很大的局限性。 同时编辑JSON文件也是非常麻烦的事情，没有很好的工具可以支持。不太推荐使用，除非支持更灵活的布局和编辑。 UIImage GPUImage 16408 Stars Objective-C 是目前最好用的一个GPU计算的框架。利用OpenGL来处理图片，需要对OpenGL比较熟悉，会写GLSL，熟悉图片处理才能创建自己的filter。 架构是流式结构，filter也是流的一部分，既是input也是output 当存在多个filter的时候，优化工作也比较难以进行。比如scale和rotate可以合并为transform。 由于是顺序结构的方案，所以就不能采用多线程多render buffer来优化cpu部分的性能，如下。 123456CPU: filter1 | idle | filter2 | idle |GPU: idle | filter1 | idle | filter2 |优化：CPU: filter1 | filter2 | idle |GPU: idle | filter1 | filter2 | animation Keyframes 4632 Stars JavaScript 功能类似于Lottie。 lottie-ios 10787 Stars Objective-C 利用AE生成JSON文件来简化交互动画的编写。 AHEasing 989 Stars Objective-C 多种时间函数实现。 popping 5272 Stars Objective-C 依靠CADisplayLink来达到高帧率的动画效果。但是太依赖CPU，所以性能不一定比CA优秀。一般情况下感觉不太需要他来做动画。 RBBAnimation 1945 Stars Objective-C 一种动画的封装，意义不大。 Canvas 5233 Stars Objective-C 将动画集成到了View中，感觉没什么必要。 YapAnimator 1697 Stars Swift 和popping原理类似，使用CADisplayLink，实时去修改视图属性。12345YapAnimator(initialValue: square.frame, willBegin: &#123; [unowned self] in return self.square.frame&#125;, eachFrame: &#123; [unowned self] (animator) in self.square.frame = animator.current.value&#125;)看似比popping简单点，但是popping是模仿CoreAnimation做的，所以没有可比性。建议使用popping。 CRAnimation 306 Stars Objective-C 一系列的动画效果。 ActionSheet &amp; Menu JGActionSheet 865 Stars Objective-C JTSActionSheet 339 Stars Objective-C AHKActionSheet 1189 Stars Objective-C AMPopTip 1913 Stars Swift MMPopLabel 556 Stars Objective-C FTPopOverMenu 619 Stars Objective-C CMPopTipView 2612 Stars Objective-C CRToast 3942 Stars Objective-C GHContextMenu 520 Stars Objective-C path style menu AwesomeMenu 5125 Stars Objective-C path style menu Animation 各种动画 CBStoreHouseRefreshControl 3948 Stars Objective-C ZLSwipeableView 2620 Stars Objective-C YLLongTapShare 472 Stars Objective-C VBFJellyView 659 Stars Objective-C TinderSimpleSwipeCards CrossNavigation 353 Stars Objective-C 不同方向的转场动画 FastAnimationWithPOP 459 Stars Objective-C CXCardView ICGTransitionAnimation 347 Stars Objective-C ZFDragableModalTransition 2290 Stars Objective-C ESConveyorBelt 188 Stars Objective-C 开机启动画面方案，有点像ppt的动画方案 EAIntroView 3477 Stars Objective-C 启动引导页方案，样式比较固定 URBMediaFocusViewController 1009 Stars Objective-C 一个图片全屏展示的方案，问题多多。 RQShineLabel 1674 Stars Objective-C AMWaveTransition 2329 Stars Objective-C SCSiriWaveformView 830 Stars Objective-C AnimatedTransitionGallery 2220 Stars Objective-C 大量页面切换的动效。 MDCSwipeToChoose 2465 Stars Objective-C RPSlidingMenu 893 Stars Objective-C BRFlabbyTable 830 Stars Objective-C SVGKit 2866 Stars Objective-C web svg在iOS端的实现，挺有意思。 KMCGeigerCounter 1864 Stars Objective-C 一个点击音效。 POP-MCAnimate 948 Stars Objective-C 基于POP的动画扩展。 Button DownloadButton 1239 Stars Objective-C IGLDropDownMenu 1087 Stars Objective-C 可展开按钮集合 VBFPopFlatButton 2859 Stars Objective-C 有动效。 AYVibrantButton 1171 Stars Objective-C BFPaperButton 825 Stars Objective-C FRDLivelyButton 1317 Stars Objective-C Calendar &amp; DatePicker FSCalendar 5156 Stars Objective-C THCalendarDatePicker 630 Stars Objective-C SACalendar 228 Stars Objective-C MGConferenceDatePicker 391 Stars Objective-C FFCalendar 554 Stars Objective-C CollectionView LxGridView 777 Stars Objective-C 一个模仿iOS删除app界面，一个demo。 MGBoxKit 1855 Stars Objective-C 相当于flexbox的一个子实现，建议直接使用flex库，比如yoga。 CSStickyHeaderFlowLayout 4771 Stars Objective-C 粘性header footer，实现不好，比较卡。 CHTCollectionViewWaterfallLayout 3425 Stars Objective-C 一种瀑布流实现。 RACollectionViewReorderableTripletLayout 1389 Stars Objective-C 一个排序CollectionViewLayout实现，实现比较好可以作为参考。 MJParallaxCollectionView 1279 Stars Objective-C 图片列表，没什么参考意义。 DZNEmptyDataSet 9249 Stars Objective-C swizzle了reload方法来检测是否为空列表，从而来显示空状态。由于使用了黑科技，可能会对其他内容会有未知影响。 CCFoldCell 327 Stars Objective-C 折叠动画 Color Chameleon 9998 Stars Objective-C 扁平化颜色集合。 color 544 Stars Objective-C UIColor扩展。 Colours 2913 Stars Objective-C 一种比较漂亮的颜色集合，以及一些颜色转换方法。 UIController FDFullscreenPopGesture 4379 Stars Objective-C 全屏手势返回。通过KVC获取target，然后设置为第三方gesture的target，从而实现gesture替换的效果。 PKRevealController 3950 Stars Objective-C ECSlidingViewController 4447 Stars Objective-C Android风格侧滑抽屉 SWRevealViewController 4295 Stars Objective-C BTSimpleSideMenu 406 Stars Objective-C RESideMenu 7037 Stars Objective-C CYLTabBarController 3688 Stars Objective-C 利用KVC修改系统tabbar，由于是私有api，可能不安全，不是特别建议。 TLYShyNavBar 3373 Stars Objective-C AXWebViewController 220 Stars Objective-C VCTransitionsLibrary 4203 Stars Objective-C 多种页面切换动画。 PYSearch 2452 Stars Objective-C Chart iOS-Echarts 1306 Stars Objective-C YKLineChartView 611 Stars Objective-C 分时k线图 ANDLineChartView 410 Stars Objective-C BEMSimpleLineGraph 2631 Stars Objective-C PNChart 8828 Stars Objective-C JSQMessagesViewController 10786 Stars Objective-C Chat ChatKit-OC 1797 Stars Objective-C iosMath 661 Stars Objective-C 数学公式 Atlas-iOS 3672 Stars Objective-C ChatSecure-iOS 2462 Stars Objective-C Messenger 2819 Stars Objective-C JBChartView 3721 Stars Objective-C FishChat 715 Stars Objective-C LLWeChat 924 Stars Objective-C ImagePicker TZImagePickerController 3779 Stars Objective-C PYPhotoBrowser 1569 Stars Objective-C ZLPhotoBrowser 1239 Stars Objective-C MWPhotoBrowser 7740 Stars Objective-C RSKImageCropper 1835 Stars Objective-C UzysAssetsPickerController 747 Stars Objective-C DBCamera 1268 Stars Objective-C PhotoZoom TKImageView 261 Stars Objective-C 图片裁剪 ImageView FLAnimatedImage 6081 Stars Objective-C YLGIFImage 1676 Stars Objective-C Layout iCarousel 9837 Stars Objective-C MyLinearLayout 2373 Stars Objective-C OAStackView SDAutoLayout 4755 Stars Objective-C PureLayout 6640 Stars Objective-C Masonry 15454 Stars Objective-C FDStackView 2310 Stars Objective-C FlexBoxLayout 134 Stars C yoga 8424 Stars JavaScript layout 1029 Stars Swift Layout-DSL VKCssProtocol 64 Stars Objective-C Keyboard IHKeyboardAvoiding 1002 Stars Swift IQKeyboardManager 9988 Stars Objective-C CYRKeyboardButton 333 Stars Objective-C Map FBAnnotationClustering 730 Stars Objective-C NavigationBar BMYScrollableNavigationBar 642 Stars Objective-C 修改NavigationBar的frame来达到和滚动行为同步，没有参考价值。 KMNavigationBarTransition 2144 Stars Objective-C 将真正的NavigationBar的背景等转移到fake bar上，fake bar加在controller.view上，来达到这种效果。微信的实现 RTRootNavigationController 895 Stars Objective-C 使用UINavigationController包裹一层，从而达到每个controller的NavigationBar是独立的。云音乐的实现。 JZNavigationExtension 1194 Stars Objective-C 和KMNavigationBarTransition类似，只是并不是直接使用UINavigationBar来做fake bar，而是采用截屏+addLayer来做。 News TTNews 635 Stars Objective-C 一个demo性质的东西。 bilibili-mac-client 2954 Stars Objective-C Password SmileTouchID 513 Stars Objective-C 一个登录界面实现。 VENTouchLock 983 Stars Objective-C Touch ID和key chain共同实现验证的功能。 LTHPasscodeViewController 593 Stars Objective-C 密码及界面 onepassword-app-extension PDF GreatReader 542 Stars Objective-C 一个功能完善的PDF阅读器，但是有些小问题。 Reader 3907 Stars Objective-C 一个比较完善的PDF组件，包含图片、链接。利用了CATiledLayer来分块绘制，优化性能。 UXReader-iOS 同Reader，但是是基于PDFium的实现。 Progress MBProgressHUD 13760 Stars Objective-C 非常有名的loading。 SVProgressHUD 10193 Stars Objective-C 非常有名的loading。 SV与MB，MB功能更加多一些，SV设计上更好一点，各有优势。 MRProgress 2580 Stars Objective-C 多种样式loading。 JGProgressHUD 1911 Stars Objective-C NJKWebViewProgress 3733 Stars Objective-C M13ProgressSuite 3582 Stars Objective-C 非常丰富的多样式loading以及progress。 UAProgressView 971 Stars Objective-C MRCircularProgressView 113 Stars Objective-C ASProgressPopUpView 1124 Stars Objective-C ASValueTrackingSlider 1716 Stars Objective-C YLProgressBar 1041 Stars Objective-C Push Knuff 3875 Stars Objective-C 工具：The debug application for Apple Push Notification Service (APNs). Refresh MJRefresh 10994 Stars Objective-C INSPullToRefresh 846 Stars Objective-C UzysAnimatedGifPullToRefresh 1404 Stars Objective-C XHRefreshControl 700 Stars Objective-C EGOTableViewPullRefresh 3347 Stars Objective-C ScrollView SDCycleScrollView 4297 Stars Objective-C LazyScrollView 1089 Stars Objective-C CustomScrollView 135 Stars Objective-C TextView SlackTextViewController 7991 Stars Objective-C KIInPlaceEdit 124 Stars Objective-C ARAutocompleteTextView 259 Stars Objective-C HTAutocompleteTextField 1068 Stars Objective-C JVFloatLabeledTextField 6473 Stars Objective-C YetiCharacterLabelExample 361 Stars Objective-C AnimatedTextInput 481 Stars Swift ZSSRichTextEditor 2592 Stars Objective-C TTTAttributedLabel 7779 Stars Objective-C dynamiccharts 213 Stars Objective-C DTCoreText 5127 Stars Objective-C TableView UITableView-FDTemplateLayoutCell 8118 Stars Objective-C 利用[view sizeFittingSize:UILayoutFittingCompressedSize]来计算最小高度。 MGSwipeTableCell 5765 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 SWRevealTableViewCell 440 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 SWTableViewCell 6901 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 FXForms 3020 Stars Objective-C 利用model直接布局tableView的方案，比如登录、注册这种页面，难以定制化。 Label UICountingLabel 1223 Stars Objective-C KILabel 412 Stars Objective-C 一个比较好用的扩展UILabel富文本支持，但是也有一些bug没有修复。 Other timeLineiOS 616 Stars Objective-C 时间线 DGCuteHelper 32 Stars Objective-C 粘性效果 MotionBlur 1481 Stars Objective-C 快速移动时候的模糊效果。利用了CoreImage的自定义Filter，利用了Core Image Kernel Language，有点像OpenGL的GLSL。 StackBluriOS 565 Stars Objective-C 近似高斯模糊算法 FXBlurView 4984 Stars Objective-C 利用vImage进行模糊。 AsyncDisplayKit Texture 2004 Stars Objective-C 就是AsyncDisplayKit KZLineDrawer 利用cocos2d来手指画图，达到流畅的效果。 UberSignature 337 Stars Objective-C 一种签名实现。 XXNibBridge 486 Stars Objective-C 一种在nib中动态load另一个nib中的内容的实现。 Debug FLEX 8426 Stars Objective-C 一款非常完善的内置debug工具。包含视图查看、log、查看沙盒数据等等功能。 RHObjectiveBeagle 已被删除 CocoaLumberjack 9483 Stars Objective-C 非常有名的log工具 BugshotKit 1369 Stars Objective-C bug反馈，截屏功能。 Clue 238 Stars Objective-C 在一个bug反馈前，收集用户信息，包括录制视频。 MLeaksFinder 依赖FBRetainCycleDetector来做的内存泄露分析。 GYBootingProtection 673 Stars Objective-C 开机启动自修复，判定开机崩溃，进入修复流程。微信就有这样的功能。 DBDebugToolkit 560 Stars Objective-C 一个比较完善的debug工具集。 IPAPatch 2003 Stars Objective-C 不需要越狱注入其他app的工具。 NetworkEye 1005 Stars Objective-C 利用NSURLProtocol来观察网络请求状况，是一个内置的查看工具。 FBSimulatorControl 2078 Stars Objective-C 多模拟器选择。 LifetimeTracker 621 Stars Swift 利用了associate object来监测对象生命周期，局限性太大。不过可能会持续更新 FBMemoryProfiler 2757 Stars Objective-C 利用FBRetainCycleDetector和FBAllocationTracker做的一款工具，增加UI界面。 FBRetainCycleDetector 2633 Stars Objective-C++ 利用objc的特性，利用Object、block等的属性布局收集强引用信息。 FBAllocationTracker 792 Stars Objective-C++ hook了+alloc和-dealloc来统计objc对象使用情况。 iOS-Hierarchy-Viewer 1305 Stars C iOS视图结构查看器，需要通过http查看，还包括core data查看。 libimobiledevice 1602 Stars C 和设备通信的类库。 Test ocmock 1558 Stars Objective-C 使用NSProxy对象替代原本的对象，在response和forward中记录和处理、转发消息来实现，是非常好用的mock类库。由于完全依赖oc的动态特性，所以对swift类无效。 OCMockito 类似于ocmock，关注度不高。 KIF 5049 Stars Objective-C 利用了私有方法，在非UI Unit test中进行UI测试。 expecta 1406 Stars Objective-C specta 2058 Stars Objective-C cedar 1141 Stars Objective-C++ Kiwi 3671 Stars Objective-C 以上几种都是BDD方式的封装。 OCHamcrest 638 Stars Objective-C 可以认为是一些语法糖 Nocilla 1789 Stars Objective-C hook http请求 Nimble 2403 Stars Swift 知名度比较高的测试断言库。 Quick 6876 Stars Swift 知名度比较高的BDD。 React react-native-maps 5462 Stars Objective-C Other MonkeyDev 847 Stars Objective-C CYLTabBarController 3688 Stars Objective-C detect.location 821 Stars Objective-C WeChatTweak-macOS 1165 Stars Objective-C FlatUIKit 7648 Stars Objective-C JLPermissions 403 Stars Objective-C 应用权限 ZXingObjC 2497 Stars Objective-C 二维码 SAMKeychain 4556 Stars Objective-C SimulateIDFA 229 Stars Objective-C ohana-ios 341 Stars Objective-C 通讯录 class-dump 1727 Stars Objective-C DarkLightning 168 Stars Swift 雷电口传输数据 peertalk 2042 Stars Objective-C USB数据传输 MMWormhole 3296 Stars Objective-C app和extension的数据传输 MALoggingViewController 51 Stars Objective-C ios-simulator-app-installer 238 Stars Objective-C KZPlayground Playground for Objective-C PunchClock 1707 Stars Objective-C PonyDebugger 5462 Stars Objective-C 使用Chrome来debug view MLPNeuralNet 917 Stars Objective-C GCDWebServer 3568 Stars Objective-C CocoaHTTPServer 4297 Stars Objective-C radiant-player-mac 3006 Stars Objective-C 音乐播放器for mac ARAnalytics 1674 Stars Objective-C Onboard 5774 Stars Objective-C electrino 2601 Stars Objective-C","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://djs66256.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"开源项目列表-C++","date":"2012-07-16T17:57:36.000Z","path":"2012/07/17/project2/","text":"收藏的开源项目以及部分分析。C++相关部分。 protobuf 20416 Stars C++ Protocol Buffers - Google’s data interchange format 以一种流的形式编码数据，来达到更高的压缩率和更高的解码效率。通过.proto文件，严格约束各端的数据结构，并且生成代码，减少了各端的实现成本。其中也包含了rpc相关的实现。 grpc 13827 Stars C++ The C based gRPC (C++, Python, Ruby, Objective-C, PHP, C#) 利用protobuf实现的rpc通信，简单且通用。 folly 9279 Stars C++ An open-source C++ library developed and used at Facebook.","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://djs66256.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[]}]