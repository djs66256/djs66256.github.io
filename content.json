[{"title":"提升 App 的音频录制功能","date":"2025-06-10T07:57:13.000Z","path":"2025/06/10/2025-06-10-wwdc2025_251/","text":"了解如何提升 app 的音频录制功能。探索如何通过 ios 和 ipados 26 上的输入选择器交互来灵活地选择音频设备。了解有哪些 api 可帮助你通过 airpods 进行高质量录音。我们还将介绍空间音频录制和编辑功能，这些功能可让你隔离语音和环境背景音，所有这些功能均可使用 audiotoolbox、avfoundation 和 cinematic 框架实现。 视频地址 iOS 26 音频录制新功能全解析：从设备选择到空间音频引言在 iOS 和 iPadOS 26 中，Apple 为开发者带来了一系列强大的音频录制新功能。无论您是想在应用中实现专业的设备切换功能，还是希望集成 AirPods 的高质量录音，甚至是探索空间音频的创作可能，这些新 API 都能满足您的需求。本文将详细介绍这些功能及其实现方式。 输入设备选择器：应用内无缝切换新特性概述iOS 26 引入了全新的输入设备选择 API，允许用户直接在应用内切换音频输入源，无需跳转到系统设置。这对于内容创作类应用特别有价值。 实现代码123456789101112131415161718import AVKitclass AppViewController &#123; // 配置音频会话 // AVInputPickerInteraction 是展示输入选择器的 NSObject 子类 let inputPickerInteraction = AVInputPickerInteraction() inputPickerInteraction.delegate = self // 将选择器关联到 UI 元素（如按钮） @IBOutlet weak var selectMicButton: UIButton! self.selectMicButton.addInteraction(self.inputPickerInteraction) // 按钮回调：展示输入选择器 @IBAction func handleSelectMicButton(_ sender: UIButton) &#123; inputPickerInteraction.present() &#125;&#125; AirPods 高质量录音模式开启方式iOS 26 为 AirPods 提供了专为内容创作优化的高质量录音模式，其效果可媲美专业领夹麦克风。 配置方法12345// AVAudioSession 启用方式 - 会话分类选项AVAudioSessionCategoryOptions.bluetoothHighQualityRecording// AVCaptureSession 启用方式 - 捕获会话属性session.configuresApplicationAudioSessionForBluetoothHighQualityRecording = true 空间音频录制与编辑技术原理空间音频采用第一阶 Ambisonics (FOA) 格式，包含： 1 个全向分量 3 个正交分量 (X/Y/Z 轴方向) 音频混音功能iOS 26 新增了音频混音 API，可以调节人声与环境音的平衡： 123456789101112131415import Cinematic// 混音参数（建议通过 UI 元素调节）var intensity: Float32 = 0.5 // 0.0 到 1.0 之间var style = CNSpatialAudioRenderingStyle.cinematic// 异步初始化 CNAssetAudioInfolet audioInfo = try await CNAssetSpatialAudioInfo(asset: myAVAsset) // 生成带效果的 AVAudioMixlet newAudioMix: AVAudioMix = audioInfo.audioMix(effectIntensity: intensity, renderingStyle: style)// 应用于 AVPlayerItemmyAVPlayerItem.audioMix = newAudioMix 升级路线图建议开发者按照以下步骤升级应用： 添加 AVInputPickerInteraction 实现原生设备切换 启用 AirPods 高质量录音选项 结合 MovieFileOutput 和 AudioDataOutput 实现灵活处理 用 AVAssetWriter 集成空间音频采集 在回放时应用音频混音 API 相关视频 利用拍摄控件提升你的相机体验 在你的 App 中录制电影效果视频 文档 AVFoundation Cinematic TN3177: Understanding alternate audio track groups in movie files 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"了解 Apple 沉浸视频技术","date":"2025-06-10T07:55:16.000Z","path":"2025/06/10/2025-06-10-wwdc2025_403/","text":"探索 apple 沉浸视频和 apple 空间音频格式技术的功能，以打造真正的沉浸式体验。了解新的 immersivemediasupport 框架，该框架可读取和写入必要的元数据来实现 apple 沉浸视频。了解在单独的文件中编码和发布 apple 沉浸视频内容以通过 hls 进行播放或流媒体播放时应遵循的准则。 为了充分从这个讲座中获益，建议你先观看“探索 visionos 的视频体验”。 视频地址 全面解析 Apple 沉浸式视频与空间音频技术引言随着 Apple Vision Pro 的推出，Apple 为开发者带来了全新的沉浸式视频与音频体验。本文将深入探讨 Apple 沉浸式视频（Apple Immersive Video）和 Apple 空间音频格式（ASAF）的技术细节，帮助开发者了解如何创建、处理并发布高质量的沉浸式内容。 Apple 沉浸式视频核心技术基本概念与特性Apple 沉浸式视频是 Apple Vision Pro 上最高品质的视频播放体验，具有以下特点： 使用高保真视频和全沉浸式音频 需要专用摄像机拍摄（如 Blackmagic URSA Cine Immersive） 支持参数化投影类型 采用 4320×4320 单眼分辨率 最高支持 90 帧/秒 使用 P3-D65-PQ 色域 元数据处理沉浸式视频的核心是它的元数据系统，主要包括两个关键组件： VenueDescriptor 包含场景中所有摄像机的组合信息 存储为 AIMEData（Apple Immersive Media Embedded Data） 支持添加/删除摄像机 可以保存到 URL PresentationCommand 表示动态元数据指令 支持”shot flop”（镜像翻转）等特效 可以处理动态渲染的淡入淡出效果 开发工具与APIImmersive Media Support 框架macOS 和 visionOS 26 引入了全新的 Immersive Media Support 框架，提供了以下能力： 读写 Apple 沉浸式视频的核心元数据 支持内容预览功能 为视频制作管线提供支持 AVFoundation 扩展AVFoundation 新增了 API 用于处理沉浸式视频： 12345678910// 从 AIVU 文件读取 VenueDescriptorfunc readAIMEData(from aivuFile: URL) async throws -&gt; VenueDescriptor? &#123; let avAsset = AVURLAsset(url: aivuFile) let metadata = try await avAsset.load(.metadata) let aimeData = metadata.filter(&#123; $0.identifier == .quickTimeMetadataAIMEData &#125;).first if let dataValue = try await aimeData.load(.value) as? NSData &#123; return try await VenueDescriptor(aimeData: dataValue as Data) &#125; return nil&#125; 文件格式与工作流AIVU 文件格式Apple Immersive Video Universal (AIVU) 是包含完整元数据的容器文件，包含： 输出视频 PresentationDescriptor VenueDescriptor 元数据 文件验证可以使用 AIVUValidator 验证文件有效性： 123func validAIVU(file aivuFile: URL) async throws -&gt; Bool &#123; return try await AIVUValidator.validate(url: aivuFile)&#125; 内容发布规范HLS 流媒体要求发布 Apple 沉浸式视频内容时需注意： 推荐分段码率范围：平均 25-100 Mbps，峰值 50-150 Mbps HLS 播放列表需包含版本12以上 需指向 AIME 文件的场馆描述数据ID 声明完全沉浸式内容类型 视频布局必须为立体视频 空间音频技术Apple 空间音频格式 (ASAF) 特性： 使用 Apple 位置音频编解码器 (APAC) 支持多点声源 支持高阶 Ambisonics 完全适配对象与听者的位置方向变化 通过广播 Wave 文件承载 结语Apple 的沉浸式视频和空间音频技术为开发者提供了创建真正沉浸式体验的强大工具。通过掌握这些核心技术，开发者可以为 Apple Vision Pro 打造引人入胜的沉浸式内容。建议进一步探索相关文档和示例代码，以充分利用这些创新技术。 相关视频 了解 Apple Projected Media Profile 探索 visionOS 的视频体验 支持 visionOS App 播放沉浸视频 空间网页的新功能 文档 AVFoundation AVPlayerItemMetadataOutput Core Media HTTP Live Streaming (HLS) authoring specification for Apple devices Immersive Media Support What’s new in HTTP Live Streaming 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"探索 visionOS 的视频体验","date":"2025-06-10T07:55:11.000Z","path":"2025/06/10/2025-06-10-wwdc2025_304/","text":"了解在你的 app 中创建和呈现沉浸视频体验的不同方式。我们将探索 visionos 26 中提供的多种媒体类型 (包括 180°、360°和宽视野视频的配置文件)、用来创建和播放 apple 沉浸视频的选项，以及适用于 2d、3d 和空间视频的扩展功能。探索哪些配置文件最适合你的 app 和内容。 视频地址 VisionOS 视频体验全解析：从 2D 到沉浸式引言VisionOS 26 为开发者带来了丰富的视频呈现方式，从传统的 2D/3D 视频到全新的 180°、360°、宽视野和 Apple 沉浸视频。本文将详细介绍这些媒体类型的特点、适用场景以及实现方式，帮助你为应用选择最合适的视频配置方案。 基础视频类型2D 与 3D 视频Vision Pro 支持在应用 UI 中内联播放 2D 视频，也可以展示 3D 立体内容： 2D 视频可以自由嵌入 UI 界面 3D 视频在扩展播放模式下才能展现立体效果 支持在虚拟环境中停靠播放 visionOS 26 新增动态帧调整功能 空间视频空间视频是 visionOS 的特色功能： 可通过 iPhone 15 Pro/16 或佳能相机拍摄 提供窗口模式和沉浸模式两种播放方式 visionOS 26 全媒体框架支持空间视频播放 专业工作流支持 Final Cut Pro 等编辑工具 沉浸式视频体验180°、360°与宽视野视频visionOS 26 原生支持三种非直线投影媒体： 180°视频：投影到前方半球 360°视频：通过等距柱状投影完全包裹观众 宽视野视频：专为运动相机优化，消除畸变 这些格式采用先进的 MV-HEVC 编码技术，基于 Apple Projected Media Profile 规范。 Apple 沉浸视频专业级沉浸视频体验： 使用 Blackmagic URSA Cine 设备拍摄 单眼分辨率高达 8160×7200 210°超广视野 完整的工作流支持 开发者可定制工具链 配置方案选择指南关键决策因素 格式类型 适用场景 特点 2D/3D 视频 平面内容 传统播放方式 空间视频 个人记忆 真实尺寸沉浸 180°/360° 虚拟旅游 半球/球面投影 宽视野 运动拍摄 消除畸变 沉浸视频 专业制作 超高分辨率 结论visionOS 26 提供了从基础到专业的完整视频体验解决方案。开发者可以根据应用场景和设备条件，选择合适的视频格式。建议下载官方示例项目，体验不同格式的实际效果。 相关视频 了解 Apple 沉浸视频技术 了解 Apple Projected Media Profile 支持 visionOS App 播放沉浸视频 文档 Apple Movie Profiles for Spatial and Immersive Media Creating spatial photos and videos with spatial metadata 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"支持 visionOS App 播放沉浸视频","date":"2025-06-10T07:55:09.000Z","path":"2025/06/10/2025-06-10-wwdc2025_296/","text":"了解如何在 visionos app 中播放沉浸视频。我们将介绍各种沉浸感十足的渲染模式、查看支持这些模式的框架，并讲解如何在你的 app 中渲染沉浸视频。为了充分利用好本次视频，我们建议你先观看 wwdc25 讲座“探索 visionos 的视频体验”。 视频地址 在 visionOS 应用中实现沉浸式视频播放的完整指南引言随着 visionOS 26 的推出，开发者现在可以在应用中实现更丰富的沉浸式视频播放体验。本文将详细介绍如何在 visionOS 应用中支持各种沉浸式视频格式，包括 2D、3D、180 度、360 度以及广视角视频。 visionOS 26 支持的视频格式visionOS 26 引入了多种新的视频配置文件： 2D 和 3D 视频：传统的平面和立体视频 空间视频：提供立体感的沉浸内容 Apple 投影媒体配置文件 (APMP)：包括 180 度、360 度和广视角视频 Apple 沉浸式视频：最顶级的沉浸体验 开发者可以根据应用需求选择合适的视频格式，每种格式都能带来不同的视觉体验。 开发框架选择visionOS 提供了多个框架来支持不同级别的视频播放需求： Quick Look：最简单快捷的实现方式，适合快速集成 AVKit：提供跨平台一致性的播放体验 RealityKit：适合需要高度自定义的游戏或特殊应用场景 网页内容：适用于网页应用 Quick Look 实现方案Quick Look 提供了两种主要 API： 12345// 跨进程媒体呈现PreviewApplication// 应用内媒体呈现QLPreviewController 在 visionOS 26 中，这两个 API 都得到了增强，能够自动处理新视频格式的呈现和转场效果，开发者几乎无需额外工作就能获得沉浸式体验。 AVKit 高级配置AVKit 在 visionOS 26 中引入了全新的 AVExperienceController，提供了更精细的控制： 12345// Expanded 配置示例experienceController.configuration.expanded.automaticTransitionToImmersive = .none// Immersive 体验配置experienceController.configuration.placement = .over(scene: myScene) 开发者可以通过 AVExperienceController.Delegate 协议监控三种状态变化： 可用体验变化 转场准备状态 转场完成状态 RealityKit 自定义实现对于需要高度定制的应用，RealityKit 是最佳选择： 12345// 设置渐进沉浸模式videoPlayerComponent.desiredImmersiveViewingMode = .progressive// 设置空间视频模式videoPlayerComponent.desiredSpatialVideoMode = .spatial RealityKit 还支持舒适性缓解检测，当系统检测到可能导致用户不适的剧烈运动时，会自动调整沉浸级别。 SwiftUI 集成最佳实践与 SwiftUI 集成时，建议： 使用 GeometryReader3D 调整视频尺寸 添加 ModelSortGroupComponent 解决 UI 排序问题 确保 ImmersionStyle 与 desiredImmersiveViewingMode 匹配 结语visionOS 26 为开发者提供了强大的工具来创建沉浸式视频体验。无论是简单的 Quick Look 集成，还是高度定制的 RealityKit 实现，都能满足不同应用场景的需求。建议开发者根据应用的具体需求选择合适的实现方案。 相关视频 了解 Apple 沉浸视频技术 了解 Apple Projected Media Profile 探索 visionOS 的视频体验 空间网页的新功能 深入探究空间容器和沉浸式空间 使用 RealityKit 增强你的空间计算 App 文档 AVFoundation 文档 AVKit 文档 HTTP Live Streaming 示例 RealityKit 文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"与附近用户共享 visionOS 体验","date":"2025-06-10T07:54:14.000Z","path":"2025/06/10/2025-06-10-wwdc2025_318/","text":"了解如何为同一房间内佩戴 apple vision pro 的用户打造共享体验。我们将展示如何在你的 app 中整合同播共享并充分利用 arkit，介绍与附近 facetime 通话参与者共享窗口的流程有哪些更新，并介绍旨在实现流畅协作的全新 api。探索相关最佳实践，了解如何为身处同一空间的用户打造别具特色、易于发现且引人入胜的协作功能。 视频地址 在 visionOS 中实现同空间共享体验的完整指南引言苹果 visionOS 26 引入了一项令人振奋的新功能——同空间共享体验。这项技术允许在同一物理空间内的多个 Vision Pro 用户共享应用内容，共同观看、聆听或协作使用应用。无论是家庭娱乐还是团队协作，这都将带来前所未有的沉浸式互动体验。 基础概念：附近共享机制visionOS 26 重新设计了应用共享流程，使其更加直观： 每个窗口右侧新增分享按钮 点击后会显示附近用户列表 共享窗口会精确出现在所有参与者的视野中同一位置 窗口栏变为绿色表示正在共享状态 系统确保所有参与者看到的窗口位置和尺寸完全同步，移动或调整窗口时会实时更新。 SharePlay 框架整合要实现交互式共享体验（而不仅仅是查看），需要使用 SharePlay 框架： 1234// 创建群组活动示例struct BoardGameActivity: GroupActivity, Transferable &#123; var metadata = GroupActivityMetadata(title: &quot;一起玩&quot;)&#125; 沉浸式空间应用开发者需要注意： 保持非沉浸模式作为共享入口 待所有人加入后再切换至沉浸模式 可以使用自定义按钮触发 activate() 方法呼出共享菜单 高级功能实现识别附近参与者通过 GroupSession 的 activeParticipants 属性，结合 isNearbyWithLocalParticipant 标志： 12345func observeParticipants(session: GroupSession&lt;BoardGameActivity&gt;) async &#123; for await activeParticipants in session.$activeParticipants.values &#123; let nearbyPlayers = activeParticipants.filter &#123; $0.isNearbyWithLocalParticipant &#125; &#125;&#125; 基于位置的内容布局使用 ParticipantState.pose 属性获取参与者在沉浸式空间中的位置信息，实现更智能的内容放置。 媒体同步播放visionOS 26 中 AVPlayer 新增了对同空间用户的精准同步支持： 1234WindowGroup(id: &quot;教学视频&quot;) &#123; InstructionalVideoView() .groupActivityAssociation(.primary(&quot;教学视频&quot;))&#125; ARKit 共享锚点ARKit 新增的共享世界锚点允许将虚拟内容固定在物理空间中的同一位置： 1WorldAnchor(originFromAnchorTransform: transform, sharedWithNearbyParticipants: true) 使用前需要检查 worldAnchorSharingAvailability 状态。 设计建议 确保应用支持新的共享菜单 设计时要兼顾附近与远程用户 充分利用物理空间特性 考虑使用非沉浸模式作为共享入口 相关视频 了解面向空间商务 App 的增强功能 自定支持同播共享的空间自影像模板 打造出色的空间播放体验 构建空间同播共享体验 文档资源 AVPlaybackCoordinator Configure your visionOS app for sharing with people nearby groupActivityAssociation(_:)) 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"打造丝滑的多画面播放体验","date":"2025-06-10T07:53:59.000Z","path":"2025/06/10/2025-06-10-wwdc2025_302/","text":"了解如何在你的 app 中打造高级的多画面播放体验。我们将介绍如何跨多个播放器实现播放同步、通过隔空播放的无缝整合提升多画面播放效果，同时优化播放质量，以便提供引人入胜的多画面播放体验。 视频地址 构建专业级多视角播放体验的技术指南引言在现代多媒体应用中，多视角播放功能正变得越来越重要。无论是体育赛事的多个机位画面，还是演讲活动的主画面与手语翻译画面，为用户提供同步的多视角观看体验都能显著提升应用价值。本文将详细介绍如何利用苹果的AVFoundation框架构建专业级的多视角播放系统。 多视角播放的核心挑战多视角播放面临三大主要技术挑战： 播放同步：确保多个播放器保持精准同步 隔空播放支持：处理投屏时的智能路由 质量优化：合理分配网络资源保证关键流的播放质量 播放同步解决方案：AVPlaybackCoordinationMedium对于需要严格同步的场景（如体育赛事的多机位画面），AVPlaybackCoordinationMedium组件提供了完美的解决方案。它能自动处理： 播放速率变化 跳转操作 卡顿恢复 中断事件 初始同步 实现代码非常简单：123let coordinationMedium = AVPlaybackCoordinationMedium()try player1.playbackCoordinator.coordinate(using: coordinationMedium)try player2.playbackCoordinator.coordinate(using: coordinationMedium) 隔空播放支持：AVRoutingPlaybackArbiter当用户使用隔空播放功能时，AVRoutingPlaybackArbiter组件可以智能地处理路由： 视频优先投送至Apple TV（仅支持单流） 音频优先路由至HomePod 配置示例：123let arbiter = AVRoutingPlaybackArbiter.shared()arbiter.preferredParticipantForExternalPlayback = birdsEyePlayerarbiter.preferredParticipantForNonMixableAudioRoutes = birdsEyePlayer 质量优化：网络资源优先级在多视角播放中，不同流的重要性不同。通过设置networkResourcePriority参数，可以优化网络资源分配： .high：关键流媒体（如主赛场画面） .low：次要内容（如观众镜头） 优先级设置示例：12mainViewPlayer.networkResourcePriority = .highcrowdViewPlayer.networkResourcePriority = .low 应用场景这项技术适用于多种专业场景： 体育赛事的多机位直播 会议活动的主画面与手语翻译流 媒体监看的多频道同步播放 音乐会/演出的多视角体验 结论通过组合使用AVPlaybackCoordinationMedium、AVRoutingPlaybackArbiter和网络资源优先级设置，开发者可以构建专业级的、具有沉浸式体验的多视角播放应用。这些技术不仅能确保播放同步，还能优化用户体验和资源分配。 相关视频 使用群组活动协调媒体体验 文档 AVFoundation AVRouting 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"通行密钥的新功能","date":"2025-06-10T07:53:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_279/","text":"了解 ios、ipados、macos 和 visionos 26 在通行密钥方面的增强功能。我们将探索的重要更新包括：简化注册流程的全新账户创建 api、确保通行密钥保持最新的措施、通过自动通行密钥升级和通行密钥管理端点驱动通行密钥升级的新方式，以及通行密钥的安全导入/导出。了解这些改进如何提升用户体验和安全性，以及如何在 app 中实施这些更新以便提供更流畅、更安全的身份验证体验。为了充分从这个讲座中获益，请先观看 wwdc22 讲座“通行密钥简介”。 视频地址 iOS 通行密钥全面升级：五大新功能深度解析引言密码时代正在终结！苹果在 iOS、iPadOS、macOS 和 visionOS 26 中为通行密钥带来五大创新功能，彻底重塑数字身份验证体验。本文将详解这些改变游戏规则的技术革新，从一键注册到安全迁移，带您全面了解如何打造更流畅、更安全的无密码未来。 核心功能解析1. 闪电注册：账户创建 API 革新传统密码注册流程繁琐： 填写邮箱/姓名表单 设置复杂密码（或使用自动强密码） 完成验证步骤 新方案实现质的飞跃： 预填可编辑的个人信息 Face ID 瞬间完成认证 全自动通行密钥生成 技术实现关键点：12345678let provider = ASAuthorizationAccountCreationProvider()let request = provider.createPlatformPublicKeyCredentialRegistrationRequest( acceptedContactIdentifiers: [.email, .phoneNumber], shouldRequestName: true, relyingPartyIdentifier: &quot;example.com&quot;, challenge: try await fetchChallenge(), userID: try await fetchUserID()) 2. 实时同步：通行密钥更新机制当用户变更账户信息时，新的 Signal API 确保： 邮箱/用户名变更实时同步 被撤销的通行密钥立即失效 密码应用永远显示准确信息 开发者需实现的三种关键操作：12345678// 更新用户名.reportPublicKeyCredentialUpdate(...)// 撤销凭证.reportAllAcceptedPublicKeyCredentials(...)// 移除密码.reportUnusedPasswordCredential(...) 3. 无缝升级：自动通行密钥转换密码用户升级路径优化： 登录后自动创建通行密钥 零摩擦用户体验 后台静默处理失败情况 核心代码示例：123456let request = provider.createCredentialRegistrationRequest( challenge: try await fetchChallenge(), name: accountDetails.userName, userID: accountDetails.userID, requestStyle: .conditional // 关键参数) 4. 可视化管理：通行密钥端点通过标准化 well-known URL 实现： 直接跳转管理页面 必须支持未经认证的访问 JSON 响应格式要求：1234&#123; &quot;enroll&quot;: &quot;https://example.com/add-passkey&quot;, &quot;manage&quot;: &quot;https://example.com/manage-passkeys&quot;&#125; 5. 安全迁移：导入导出功能突破性进步体现在： 应用间直接传输 强制本地生物认证 FIDO Alliance 标准化格式 彻底避免凭证文件泄露 实施路线图 优先采用账户创建 API 优化新用户注册 集成 Signal API 保持凭证信息准确 为密码用户启用自动升级通道 部署 well-known URL 提升管理可见性 教育用户使用安全迁移功能 行业数据印证 69% 用户已拥有至少一个通行密钥（FIDO Alliance 2025） 通行密钥登录成功率高达 97%（TikTok 实测） 比传统密码成功率高 4 倍（Google 数据） 结语通行密钥正在重塑数字身份验证的格局。通过实施这五大创新功能，开发者不仅能提供远超密码的安全保障，还能创造令人愉悦的用户体验。现在是时候全面拥抱无密码未来，让每一次登录都变得快速、简单且牢不可破。 相关视频 利用通行密钥升级和凭证管理器简化登录体验 通行密钥简介 文档资源 ASCredentialExportManager 文档 ASCredentialProviderViewController 文档 快速账户创建指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"将隐私保护融入开发流程","date":"2025-06-10T07:53:21.000Z","path":"2025/06/10/2025-06-10-wwdc2025_246/","text":"从规划阶段到部署，了解如何在你的 app 中内置隐私保护功能。我们会介绍在开发生命周期各个阶段整合隐私保护功能的实用方法，重点关注数据最小化、设备端处理以及透明度和控制权。探索如何使用 apple 丰富的工具和框架来保护用户数据，打造尊重隐私的 app 体验。 视频地址 从开发伊始构建隐私保护：Apple隐私工程师的实践指南引言在当今数据驱动的数字世界，隐私保护已成为应用开发的核心议题。Apple隐私工程师Joey Tyson通过这篇技术指南，系统性地介绍了如何在整个应用开发生命周期中集成隐私保护设计。本文将带你了解Apple的四大隐私支柱，并展示如何利用Apple平台工具实现真正的隐私友好型应用开发。 Apple的隐私哲学定义隐私的本质Steve Jobs曾将隐私定义为”用简单语言反复告知用户他们正在同意什么”。这一理念体现了Apple对隐私的三层理解： 隐私关乎人与技术的交互关系 核心是用户数据的处理方式 必须考虑数据主体的期望与使用背景 四大隐私支柱Apple将隐私理念转化为可执行的工程原则： 数据最小化：只收集必要数据 设备端处理：尽可能在本地完成数据处理 透明度与控制：让用户知情并掌握选择权 安全保护：通过技术手段保障数据安全 开发全周期的隐私实践规划阶段：定义隐私保证在项目初期就需要确立清晰的隐私承诺，例如： “搜索功能不会永久存储用户位置” “照片分析仅在使用改进功能选项时上传” “聊天内容采用端到端加密架构” 这些高层声明将指导后续的技术实现和用户沟通。 设计阶段：构建信任体验优秀的设计能让隐私保护无缝融入用户体验： 首次启动时展示隐私摘要（如Apple原生应用） 实时显示敏感权限使用状态（如麦克风激活指示器） 上下文敏感的权限请求（仅在需要时申请网络权限） 参考《人机界面指南》获取详细设计规范。 开发阶段：技术实现方案隐私友好型UI组件Apple提供了多种开箱即用的隐私控件： 照片选择器（避免全库访问）12345678PhotosPicker( selection: $viewModel.selection, matching: .images, preferredItemEncoding: .current, photoLibrary: .shared()) &#123; Text(&quot;选择照片&quot;)&#125; 定位按钮（明确用户意图）123LocationButton(LocationButton.Title.currentLocation) &#123; manager.startUpdatingLocation()&#125; 安全数据交互架构 CloudKit端到端加密： 1myRecord.encryptedValues[&quot;encryptedStringField&quot;] = &quot;敏感值&quot; 同态加密：实现私有信息检索(PIR) Private Access Tokens：设备验证替代用户识别 AdAttributionKit：隐私安全的广告效果衡量 本地化处理能力 Core ML框架支持完全设备端的机器学习 App Group容器实现安全数据共享 严格管理第三方SDK的隐私清单审查 测试与部署构建测试金字塔 单元测试验证隐私控制逻辑 集成测试检查跨系统数据流 UI测试确认设置变更的实际影响 使用iOS 15.2+的”App隐私报告”进行最终审查 App Store上架要求 准确的隐私标签（数据类型与用途） 完整的隐私政策文档 可操作的数据管理入口 Xcode生成的隐私清单合规报告 结论将隐私保护融入开发流程不是额外负担，而是构建用户信任的基础。通过Apple提供的丰富工具链和清晰的指导原则，开发者可以创造出既功能强大又尊重用户隐私的优秀应用。从规划阶段的隐私保证定义，到部署阶段的合规审查，每个环节都是展示对用户承诺的机会。 相关视频 AdAttributionKit的新功能 了解AdAttributionKit 利用Core ML在设备端部署机器学习和AI模型 将机器学习和AI模型移植到Apple芯片 隐私保护新功能 文档 AdAttributionKit 配置应用组 隐私设计的人机界面指南 隐私清单文件 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"借助 Wi-Fi Aware 增强设备连接性能","date":"2025-06-10T07:52:59.000Z","path":"2025/06/10/2025-06-10-wwdc2025_228/","text":"了解如何使用 wi-fi aware 建立对等网络连接。我们还将介绍如何以带宽更高、延迟更低的网络连接性能实时共享视频、传输大文件，以及操控配件。此外，你将了解如何借助 devicediscoveryui、accessorysetupkit 和 network 框架，在自己的 app 中使用 wi-fi aware。 视频地址 使用 Wi-Fi Aware 实现高效设备点对点连接引言在当今互联设备激增的时代，Wi-Fi Aware 技术为开发者提供了一种创新的点对点连接解决方案。这项技术允许设备直接通信，无需依赖传统路由器或中心服务器，特别适合需要高带宽、低延迟的应用场景。本文将全面介绍如何在 iOS 应用中集成 Wi-Fi Aware 功能，从基础概念到实际实现。 Wi-Fi Aware 技术概览Wi-Fi Aware 实现了设备间的直接通信，具有以下核心优势： 动态连接建立：设备在运行时相互发现并形成安全链接 并行工作能力：可与常规 Wi-Fi 连接同时使用 全球标准：由 Wi-Fi 联盟维护，确保跨平台互操作性 典型应用场景包括： 高速文件传输 实时媒体流传输 配件控制 屏幕共享 实现 Wi-Fi Aware 的核心概念服务配置Wi-Fi Aware 使用”服务”概念来发现和连接设备： 服务名称规范： 仅含字母、数字和短划线 不超过15个字符 建议在 IANA 注册以避免命名冲突 服务角色： 发布者（服务器角色） 订阅者（客户端角色） 在 Info.plist 中的配置示例：123456789101112131415&lt;key&gt;WiFiAwareServices&lt;/key&gt;&lt;dict&gt; &lt;key&gt;com.example.fileservice&lt;/key&gt; &lt;dict&gt; &lt;key&gt;WAPublishable&lt;/key&gt; &lt;true/&gt; &lt;key&gt;WASubscribable&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;com.example.drone&lt;/key&gt; &lt;dict&gt; &lt;key&gt;WASubscribable&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt;&lt;/dict&gt; 设备兼容性检查：12345import WiFiAwareguard WACapabilities.supportedFeatures.contains(.wifiAware) else &#123; // 处理设备不支持情况 return &#125; 设备配对流程Wi-Fi Aware 提供两种配对框架： DeviceDiscoveryUI： 适用于应用间或应用对设备连接 支持 Apple 和第三方设备 AccessorySetupKit： 专为配件制造商设计 推荐用于多传输配件 使用 DeviceDiscoveryUI 的代码示例发布方代码：1234567let pairingView = DevicePairingView( configuration: DevicePairingConfiguration( serviceIdentifier: &quot;com.example.fileservice&quot;, deviceName: &quot;My Device&quot; ))// 显示配对界面 订阅方代码：123456let picker = DevicePicker( configuration: DevicePickerConfiguration( serviceIdentifier: &quot;com.example.fileservice&quot; ))// 显示设备选择界面 建立连接连接建立的三个关键步骤： 设备筛选： 使用谓词筛选目标设备1let predicate = NSPredicate(format: &quot;name BEGINSWITH &#x27;iPhone&#x27;&quot;) 创建监听器/浏览器： 1234let listener = try NetworkListener( service: &quot;com.example.fileservice_tcp&quot;, devicePredicate: predicate) 启动连接： 12listener.start(queue: .main)// 处理连接请求 性能优化技巧 调整性能模式： 批量模式：节能但延迟较高 实时模式：低延迟但耗电较高 设置服务等级： 尽力服务(Best Effort) 交互式视频(Interactive Video) 语音(Voice) 性能监控示例：12connection.currentPath?.performanceReport?.throughputconnection.currentPath?.performanceReport?.latency 结论Wi-Fi Aware 为开发者提供了强大的点对点连接能力，特别适合需要高带宽、低延迟的应用场景。通过合理配置服务和优化连接参数，您可以打造出色的用户体验。建议参考官方文档和示例代码进一步探索这项技术的潜力。 相关视频 了解 AccessorySetupKit 文档 Wi-Fi Aware 官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"visionOS 26 的新功能","date":"2025-06-10T07:52:54.000Z","path":"2025/06/10/2025-06-10-wwdc2025_317/","text":"探索 visionos 26 中精彩的新功能。了解增强版视体 api，以及如何综合利用 swiftui、realitykit、arkit 的强大功能。探索如何利用更快的手部跟踪和空间配件输入，构建更加引人入胜的 app 和游戏。抢先预览同播共享、compositor services、沉浸式媒体、空间网页、企业 api 等方面的更新。 视频地址 visionOS 26 新特性全解析：从空间计算到企业应用引言Apple Vision Pro 自发布以来，开发者们已经在这个平台上创造了无数惊艳的作品。今年，visionOS 26 带来了更多突破性功能。本文将全面介绍 visionOS 26 的新特性，包括增强的空间计算 API、系统优化、游戏开发工具、共享体验以及企业级功能。 空间计算功能升级SwiftUI 依然是构建 Apple Vision Pro 应用的理想选择。visionOS 26 新增了多项空间计算功能： 深度对齐：通过 depthAlignment 修饰符实现 3D 元素的智能布局 1234VStackLayout().depthAlignment(.front) &#123; ResizableLandmarkModel() LandmarkNameCard()&#125; 3D 旋转支持：使用 rotation3DLayout 让物体在空间中自然转动 动态边界限制：应用内容能与现实环境无缝融合 1.preferredWindowClippingMargins(.all, 400) 对象操控 API：只需添加 manipulable() 修饰符，用户就能像摆弄真实物体一样旋转 3D 模型 系统功能增强visionOS 26 在系统层面也带来了多项革新： Apple 智能功能：设备端大语言模型通过 Foundation Models 框架开放访问 图乐园增强：新增油画/矢量画风格，支持 ChatGPT 生成图像 语音转文本：全新 SpeechAnalyzer API 提供更快速精准的转录服务 空间持久化：窗口和内容现在会记住位置，重启后自动恢复 小组件进化：新增细节层级控制 levelOfDetail 和材质调节 widgetTexture API 游戏开发新工具游戏开发者将获得多项强大工具： 3倍速手部追踪：提升竞技类游戏响应速度 PS VR2 控制器支持：六自由度追踪+触觉反馈 内存限制提升：可移植更高端的 iPad 游戏 Metal 渲染增强：新增悬停效果与动态渲染质量调控 此外，macOS 空间渲染功能允许开发者借助 Mac 的算力在 Vision Pro 上呈现高品质内容，TabletopKit 则简化了多人游戏的网络同步实现。 共享与媒体体验visionOS 26 在共享体验方面也有重大突破： 就近窗口共享：同处一室的多人协同功能 空间自画像优化：提升毛发质感与表情真实度 180°/360°视频支持：新增 Apple Projected Media Profile (APMP) 标准 Safari 空间浏览：3D 模型直嵌网页，支持拖拽至现实空间 企业级功能针对企业场景，visionOS 26 新增了多项专属功能： 主摄像头访问：ARKit 新增 CameraRegionProvider 稳定拍摄区域 内容保护：Protected Content API 防止敏感信息截屏 窗口跟随模式：应用界面实时追踪用户移动 快速设备移交：通过 Apple 商务管理实现安全的多用户切换 总结visionOS 26 带来了全方位的功能升级，从开发者工具到用户体验，再到企业级应用场景，都有了显著的提升。这些新功能将为开发者创造更丰富、更具沉浸感的应用程序提供强大支持。 相关视频 与附近用户共享 visionOS 体验 了解 Apple 沉浸视频技术 探索 visionOS 上的空间配件输入 RealityKit 的新功能 文档资源 TabletopKit 开发文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"音频和视频","slug":"音频和视频","permalink":"http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"}]},{"title":"UIKit 的新功能","date":"2025-06-10T07:52:49.000Z","path":"2025/06/10/2025-06-10-wwdc2025_243/","text":"借助 uikit 最新推出的多种 api，对你的 app 进行现代化改造，这些更新包括增强的菜单栏支持、自动观察跟踪、全新 ui 更新方法，以及动画效果改进。我们还将介绍如何在 uikitapp 中包含 swiftui 场景，并探讨 sf symbols、hdr 颜色选择器等内容。 视频地址 深入解析UIKit新特性：从菜单栏到SwiftUI整合引言UIKit作为苹果生态系统的核心开发框架，在iOS 26中迎来了一系列重大更新。无论是增强的菜单栏支持、自动观察追踪机制，还是与SwiftUI的深度整合，这些新特性都将为开发者带来更强大的工具和更流畅的开发体验。本文将全面解析这些创新功能，帮助您快速掌握UIKit的最新进展。 全新设计系统带来的视觉革新iOS 26引入了名为”液态玻璃”的突破性材质设计，具有以下显著特点： 半透明特性与动态视觉效果完美结合 支持镜面高光和折射等高级渲染效果 导航栏、搜索框等标准组件全面升级 开发适配建议： 使用背景扩展视图实现边栏玻璃面板的优雅显示 为自定义控件应用玻璃材质提升专业质感 启用滚动边缘特效增强导航元素可视性 容器与布局的增强UISplitViewController在iOS 26中获得重大改进：123// 检查器支持示例let splitVC = UISplitViewController(style: .tripleColumn)splitVC.showsSecondaryOnlyButton = true // 显示次级视图切换按钮新特性包括： 一流的检查器支持，可显示选中内容的详细信息 支持通过拖拽调整分屏控制器栏宽 指针形状自动变化提示可调整方向 菜单栏的跨平台进化iPadOS现在支持完整的macOS风格菜单栏，关键特性包括： 从屏幕顶部轻扫即可调出应用菜单 支持全部菜单功能（图像、子菜单、复选标记等） 保持不可用命令可见但禁用状态 配置主菜单系统的新API：1234var config = UIMainMenuSystem.Configuration()config.printingPreference = .included // 包含打印命令config.inspectorPreference = .removed // 移除检查器命令config.findingConfiguration.style = .search // 整合查找功能 架构层面的现代化改进iOS 26为UIKit带来了多项底层革新： 自动观察追踪：在layoutSubviews()等方法中自动追踪Observable对象 updateProperties()：新增的独立属性更新机制 SwiftUI整合：通过UIHostingSceneDelegate嵌入SwiftUI场景 HDR色彩：UIColor支持SDR基色和曝光值指定 强类型通知：NSNotification进化为类型安全的NotificationCenter.Message 重要迁移提示：从iOS 26开始，使用最新SDK构建的UIKit应用必须采用UIScene生命周期。 SF Symbols 7的动画增强最新版SF Symbols引入三种新动画模式： Draw On/Off：通过绘制动作显示/隐藏符号 Variable Draw：沿路径绘制变量值（如进度指示） 魔术替换过渡：特定符号间的特殊绘制动画 UIButton新增专用API简化集成：12var configuration = UIButton.Configuration.plain()configuration.symbolContentTransition = UISymbolContentTransition(.replace) 总结与行动指南要充分利用UIKit新特性，建议采取以下步骤： 立即使用iOS 26 SDK编译您的应用 评估应用在新设计系统中的视觉表现 采用UISplitViewController等标准容器 重构应用菜单系统以利用新API 通过updateProperties优化代码结构 相关视频 了解全新设计系统 使用全新设计系统构建UIKit App 提升iPad App设计 让你的UIKit App更加灵活 SF Symbols 7的新功能 文档资源 人机界面指南 UIKit更新日志 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"隐私与安全","slug":"隐私与安全","permalink":"http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"}]},{"title":"让所有人都能更方便地使用你的 Mac App","date":"2025-06-10T07:52:37.000Z","path":"2025/06/10/2025-06-10-wwdc2025_229/","text":"了解如何整合那些可充分利用 macos 强大功能和灵活性的辅助功能。深入探索如何支持“旁白”和“语音控制”，如何改进视图的布局，以及辅助技术如何导航你的内容，等等。 视频地址 打造无障碍的 macOS 应用：SwiftUI 实践指南引言在当今数字时代，构建无障碍应用已成为开发者不可忽视的责任。通过支持旁白、语音控制等辅助技术，我们可以让视力障碍、运动障碍等用户群体也能顺畅使用我们的应用。本文将深入探讨如何利用 SwiftUI 优化 macOS 应用的无障碍体验。 布局优化策略无障碍元素容器化SwiftUI 会将构成应用的各个视图自动呈现为无障碍元素。关键在于如何合理组织这些元素，就像视觉上精心设计界面一样。 123456// 视图分组示例VStack &#123; FirstView() SecondView()&#125;.accessibilityElement(children: .contain) .contain 行为将子视图包含在无障碍容器中，而 .combine 会将子视图合并为一个无障碍元素，.ignore 则会隐藏子视图的无障碍元素。 调整阅读顺序通过 accessibilitySortPriority 修饰符，我们可以优化旁白朗读顺序： 12Text(book.title) .accessibilitySortPriority(1) // 优先朗读书名 导航加速技巧旋钮功能实现为书签页面添加无障碍旋钮，让旁白用户能快速跳转： 1234567.accessibilityRotor(&quot;Bookmarks&quot;) &#123; ForEach(pages) &#123; page in if page.isBookmarked &#123; AccessibilityRotorEntry(page.title, id: page.id) &#125; &#125;&#125; 设置默认焦点在 macOS 26 中，可以使用无障碍默认焦点修饰符： 1.accessibilityDefaultFocus($focusedForVoiceOver, true) 交互无障碍设计替代悬停交互对于需要悬停或触控板手势的交互，应提供替代方式： 123.accessibilityAction(named: page.isBookmarked ? &quot;移除书签&quot; : &quot;添加书签&quot;) &#123; page.isBookmarked.toggle()&#125; 快捷键的重要性添加快捷键不仅能提升效率，对无法使用鼠标的用户也至关重要。 测试与评估建议开发者： 使用旁白测试每个新功能 优化容器结构，避免过度嵌套 探索添加自定义旋钮的可能性 通过无障碍营养标签展示应用特性 结论构建无障碍的 macOS 应用不仅是一种责任，更能扩大用户群体。通过 SwiftUI 提供的强大工具，我们可以轻松实现出色的无障碍体验。从优化布局到加速导航，再到改进交互方式，每一步都能让应用更加包容。 相关视频 了解 SwiftUI 中的辅助功能 SwiftUI 辅助功能：超越基础功能 文档 Accessibility Human Interface Guidelines: Accessibility 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"针对辅助功能标签评估你的 App","date":"2025-06-10T07:52:28.000Z","path":"2025/06/10/2025-06-10-wwdc2025_224/","text":"在你的 app store 产品页面上使用辅助功能标签，以突出展示你的 app 支持的辅助功能。你将了解如何评估 app 的辅助功能 (如“旁白”、“更大字体”、“字幕”等)，并选择准确且描述性的辅助功能标签。你还将了解如何在整个设计阶段解决辅助功能问题。 视频地址 为应用评估辅助功能标签：让科技惠及每个人引言在App Store上，辅助功能标签就像应用的无障碍”营养标签”，帮助用户了解应用是否满足他们的特殊需求。本文将带你系统评估应用的辅助功能支持情况，从设计原则到具体测试方法，教你如何准确标注这些关键信息。 认识辅助功能营养标签辅助功能营养标签是App Store展示应用无障碍特性的标准化方式。要正确标注： 明确核心任务：用户下载应用的主要目的（如登录、购买等） 全流程测试：用每项辅助功能验证所有核心任务 多设备覆盖：包括iPhone、iPad、Mac等平台 如实标注：仅声明完全支持的功能，无关功能不必标注 “没有我们的参与，就不要做关于我们的决定”——这是残障社群的核心信条。 功能评估实战（以地标应用Landmarks为例）视觉相关功能 色彩对比 要求：前景/背景色有足够对比度（含深色模式） 案例：专门设计高对比配色，但需适配”增强对比度”设置 深色模式 验证智能反转颜色下的表现 大字号支持 最低要求：支持200%放大（理想情况更大） 问题发现：集合描述截断，文本框未动态扩展→暂不标注 交互设计原则 非色彩区分 禁止仅用颜色传达状态（如红/绿），需结合图标/文本 解决方案：为删除按钮等添加彩色图标 减弱动态效果 移除可能引发眩晕的动画/转场 辅助技术支持 语音控制 关键：为所有可操作元素添加accessibilityLabel 测试：用纯语音命令完成核心流程 旁白（VoiceOver） 与视障用户共同测试导航结构 优化点：集合编辑界面的交互流程 媒体内容 无视频/音频内容的应用无需标注字幕/音频描述支持 标注与发布在App Store Connect中： 勾选已验证支持的功能（如深色模式、语音控制） 暂不标注未达标功能（如大字号） 关联详细说明页面 Landmarks最终标注支持：✅ 色彩对比 ✅ 深色模式 ✅ 非色彩区分✅ 减弱动态效果 ✅ 语音控制 ✅ 旁白 结语真正的无障碍设计需要： 早期规划：从设计阶段考虑不同能力用户需求 真实测试：邀请残障用户直接参与验证 持续优化：通过营养标签透明展示进展 相关视频 动态字体体验入门 文档 SwiftUI无障碍支持 人机界面指南：无障碍 辅助功能营养标签概述 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"针对 visionOS 优化你的自定环境","date":"2025-06-10T07:52:15.000Z","path":"2025/06/10/2025-06-10-wwdc2025_305/","text":"探索如何使用程序化工具为你的 visionos app 或游戏创建精美的沉浸式环境。我们将分享创建高质量环境的构建要素，然后深入探讨优化流程。了解如何使用 apple 针对 houdini 提供的一整套流程，减少场景的多边形数量、进行几何清理、打包 uv 贴图，并创建 usd 素材以便导入到 reality composer pro 或你选择的游戏引擎中。 视频地址 为 visionOS 优化 3D 环境的完整工作流解析引言在 Apple Vision Pro 平台上打造沉浸式环境时，开发者面临一个关键挑战：如何在保持电影级视觉效果的同时满足实时渲染的性能要求？本文将深入解析一套完整的程序化优化工作流，从几何精简到纹理烘焙，助你突破技术限制，创造惊艳的 visionOS 体验。 沉浸式环境的独特挑战Vision Pro 的全沉浸模式需要渲染每个像素，这对性能提出了极高要求。关键在于利用”沉浸边界”概念——用户可移动的固定空间范围（通常数米）。通过精准定位用户视线和移动范围，开发者可以： 仅对关键区域保持全精度渲染 采用梯度式优化策略 实现艺术表现与技术约束的完美平衡 几何优化三重奏1. 自适应多边形精简通过 Houdini 的 Adaptive Reduce HDA 工具： 基于观测点对每个三角形智能优化 热力图可视化显示密度分布（红=高密度，蓝=简化区） 保留边缘轮廓的同时减少总三角形数案例效果：部分岩石模型精简后保持锐利边缘，而远景自动降低细节 2. 几何体广告牌技术针对1-3公里外的对象： 使用 Vista Billboard HDA 生成简化网格 远距深度感知极限允许用平面图像替代3D几何 月球场景中使多边形从数百万骤降至数千 3. 遮挡剔除优化两步高效剔除方案： 背向面剔除：移除始终不可见的背面多边形 全遮挡剔除：通过射线投射检测隐藏几何实际效果：月球场景共移除17万三角形，最终降至18万 UV与纹理的智能压缩多角度投影UV布局突破单视角局限： Mesh Partition HDA 分割最小可见单元 Multi-Projection HDA 从最佳观测点投射UV 边界内使用面积缩放，边界外采用屏幕空间缩放成果：数公里地形压缩至两张纹理贴图 高模到低模烘焙创新合成技术： 球面投影映射结合直接表面投影 确保预渲染细节完整转移到优化UV 纹理内存从数十GB压缩至不足200MB USD场景配置技巧最终优化阶段： Boundary Partition HDA 处理边界内密集几何 Frustum Partition HDA 渐进分块边界外网格 属性传递实现高效视锥剔除性能数据：单帧绘制调用通常少于100次 实战成果月球场景优化对比： 多边形：1亿 → 20万（视锥剔除后单屏约10万） 纹理内存：数十GB → 250MB 实体数量：控制在200以内 结语这套Houdini工具链展示了程序化工作流的强大之处——通过智能算法而非手工劳动，开发者可以在保持视觉质量的同时突破性能瓶颈。随附的14个HDA工具已开放下载，为各种沉浸式场景提供了灵活解决方案。正如早期游戏开发者用创意突破硬件限制，现在你也可以用这些工具重新定义visionOS的体验边界。 相关视频 为你的沉浸式 visionOS App 创建自定环境 为空间计算优化 3D 素材资源 在自定环境中提升媒体观赏体验的沉浸度 探索 USD 生态系统 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"针对辅助访问自定 App","date":"2025-06-10T07:52:12.000Z","path":"2025/06/10/2025-06-10-wwdc2025_238/","text":"辅助访问是一种独具特色、突出重点的 ios 体验，让有认知障碍的用户可以更轻松地独立使用 iphone 和 ipad。在 ios 和 ipados 26 中，你可以对 app 在辅助访问模式下的运行效果进行自定，为用户提供更大的便利性和独立性。了解如何使用 assistiveaccess swiftui 场景类型来定制你的 app，并探索可以帮助你为每一个人打造高质量辅助触控体验的关键设计原则。 视频地址 为认知障碍用户优化应用体验：辅助访问功能详解引言辅助访问（Assistive Access）是苹果为认知障碍用户量身打造的特殊模式，它能简化iOS和iPadOS的交互方式，让这些用户也能独立使用设备。本文将详细介绍如何通过SwiftUI为您的应用添加辅助访问支持，以及优化用户体验的关键设计原则。 什么是辅助访问？辅助访问是iOS/iPadOS 17引入的一项无障碍功能，它通过以下方式降低用户认知负荷： 超大控件设计：让所有操作元素更易于识别和点击 精简界面：去除不必要的功能和视觉干扰 视觉化替代文本：用图形辅助理解 全屏模式支持对于已经为认知障碍用户优化的应用（如辅助沟通应用），可以通过在Info.plist中设置UISupportsFullScreenInAssistiveAccess来启用全屏显示。开发者还可以使用SwiftUI或UIKit API来检测当前是否处于辅助访问模式。 实现辅助访问场景在iOS/iPadOS 26中，未专门优化的应用可以通过创建辅助访问场景来提供定制体验。与全屏模式不同，场景模式会自动采用系统标准的醒目控件风格。 配置步骤 在Info.plist中添加UISupportsAssistiveAccess键并设为true 使用SwiftUI添加场景声明： 1234567891011@mainstruct MyApp: App &#123; var body: some Scene &#123; WindowGroup &#123; MainContentView() &#125; AssistiveAccess &#123; // 辅助访问场景 SimplifiedView() &#125; &#125;&#125; 使用.assistiveAccess预览特性测试布局 对于UIKit应用，可以通过场景代理桥接到SwiftUI场景： 12345class MySceneDelegate: UIHostingSceneDelegate &#123; static var rootScene: some Scene &#123; AssistiveAccess &#123; SimplifiedView() &#125; &#125;&#125; 设计优化原则为辅助访问设计时需要遵循以下核心原则： 功能聚焦保留1-2个核心功能，移除非必要功能 交互简化 减少同时显示的选项 避免复杂手势和嵌套UI 禁用自动超时交互 采用分步引导流程 安全设计 移除不可逆操作 高风险操作需要双重确认 多模态呈现 控件同时包含图标和文字 使用系统提供的导航栏图标修饰符： 12.navigationTitle(&quot;绘图&quot;).assistiveAccessNavigationIcon(systemImage: &quot;paintbrush.fill&quot;) 实际应用案例以一个绘图应用为例，优化颜色选择功能： 将复杂取色器简化为6种预选颜色 将颜色选择作为独立步骤 移除”撤销”功能避免混淆 相关视频 SwiftUI的新功能 了解Assistive Access 文档资源 AssistiveAccess文档 人机界面指南：无障碍功能 UISupportsFullScreenInAssistiveAccess 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"包容性 App 设计的原则","date":"2025-06-10T07:52:01.000Z","path":"2025/06/10/2025-06-10-wwdc2025_316/","text":"探索了解残障人士的需求如何有助于你打造出人人都能方便使用的更出色 app。了解如何通过支持多种类型的交互、提供自定功能以及采用各种辅助功能 api，让你的 app 更具包容性。 视频地址 构建包容性应用：从残障视角出发的设计实践引言在数字时代，应用设计不应仅服务于”标准用户”。全球约七分之一人群存在不同形式的残障，而每个人在生命不同阶段都可能面临暂时性或永久性的能力局限。本文将从专业视角，为您拆解如何通过四项核心策略（多感官交互、自定义选项、辅助API、债务追踪）打造真正包容的应用程序。 理解残障的连续性残障不是非此即彼的二元状态，而是存在于连续谱系中。以视力为例： 法定失明者可能保留色彩感知能力 黄斑变性患者可能仅中央视力模糊 弱光环境下任何人都可能面临视觉挑战 这种连续性的认知，将彻底改变您的设计思路。 四大设计策略精解1. 多感官交互设计关键原则：信息应通过多通道冗余传递 视觉通道：为音频内容添加字幕（服务于听障用户/静音场景） 听觉通道：为视觉内容提供语音描述（服务于视障用户/多任务场景） 触觉反馈：增强操作确认（如振动提示） 典型案例：Crouton食谱应用的”免提模式”通过语音交互解放用户双手 2. 深度自定义体系构建灵活的UI调整层： 文本可调：字号、字距、行高、字体（特别推荐旧金山字体） 色彩方案：高对比度模式、色盲优化配色 布局选择：从信息密集到极简视图（参考Carrot Weather） 设计箴言：”应用适应用户，而非用户适应应用” 3. 辅助API整合必须集成的三大基础API： VoiceOver：屏幕阅读器兼容性测试 Switch Control：替代触控的交互支持 Dynamic Type：系统级文字缩放适配 游戏案例：Blackbox通过VoiceOver+触觉反馈让视障玩家享受解谜乐趣 4. 包容性债务管理建立迭代优化机制： 定期进行辅助功能审计 建立残障用户测试小组 制定渐进式改进路线图 技术债务类比：将未解决的包容性问题视为需要偿还的”债务” 实践工具与资源立即行动的三步曲： 启用Xcode辅助功能检查器 体验VoiceOver的开发者模式 参考App Store新推出的无障碍特性展示规范 结语包容性设计不是额外负担，而是创新催化剂。从路缘坡道到语音助手，历史上许多全民性创新都源于残障需求。当您下次设计功能时，不妨自问：”这个交互方式，能否覆盖更广泛的能力谱系？” 答案或许就是下一个突破性创新的起点。 相关视频 针对辅助功能标签评估你的 App 包容性设计实践 包容性设计过程 文档 人机界面指南：辅助功能 人机界面指南：包容性 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"辅助功能和包容性","slug":"辅助功能和包容性","permalink":"http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"}]},{"title":"借助 SwiftUI 在 visionOS 中设置场景","date":"2025-06-10T07:50:59.000Z","path":"2025/06/10/2025-06-10-wwdc2025_290/","text":"探索精彩的全新 api，为你的 visionos app 打造更出色的窗口、空间容器和沉浸式空间。微调场景在重新启动或固定位置时的行为。通过裁剪边缘和对齐，根据周边环境来调整空间容器。将流媒体格式的沉浸式内容从 mac 传输到 apple vision pro。借助空间容器和沉浸式空间，让基于 uikit 的现有 app 更上一层楼。 视频地址 探索 visionOS 26 全新场景 API：打造沉浸式空间体验引言随着 visionOS 26 的发布，Apple 为开发者带来了全新的场景构建能力。无论是窗口、空间容器还是沉浸式空间，现在都能通过创新的 API 实现更精细的控制和更自然的交互体验。本文将深入解析这些新特性，助你为 Apple Vision Pro 打造更出色的应用。 场景生命周期管理恢复与锁定功能visionOS 26 引入了场景恢复功能，用户可以将窗口或空间容器锁定到特定物理位置。当用户返回该空间时，系统会自动恢复所有锁定内容。 对于需要禁用恢复的场景（如临时窗口），SwiftUI 开发者可以使用：1234WindowGroup(&quot;Tools&quot;) &#123; ToolView()&#125;.restorationBehavior(.disabled) UIKit 开发者则可通过 destructionConditions API 实现相同效果。 动态启动控制visionOS 26 允许开发者根据应用状态动态控制启动场景：1234WindowGroup(&quot;Welcome&quot;, id: &quot;welcome&quot;) &#123; WelcomeView()&#125;.defaultLaunchBehavior(isFirstLaunch ? .presented : .automatic) 空间容器增强功能表面吸附技术现在用户可以将窗口吸附到墙面或桌面等物理表面。开发者可以通过 SurfaceSnappingInfo API 获取吸附状态：12345678@Environment(\\.surfaceSnappingInfo) private var snappingInfoRealityView().onChange(of: snappingInfo) &#123; if snappingInfo.isSnapped &#123; // 处理吸附状态 &#125;&#125; 边缘裁剪支持新增的裁剪边距功能允许内容超出场景边界显示：1.preferredWindowClippingMargins(.bottom, maxWaterfallHeight * pointsPerMeter) 沉浸式空间创新重定位事件处理当用户重新定位虚拟环境时，可以通过回调更新内容位置：12RealityView().onWorldRecenter &#123; recomputePositions() &#125; 远程沉浸空间macOS 应用现在可以流式传输沉浸式内容到 Vision Pro：123RemoteImmersiveSpace(id: &quot;preview&quot;) &#123; CompositorLayer(configuration: config)&#125; 场景桥接技术UIKit 应用现在可以无缝集成 SwiftUI 的空间体验：12345678class MyHostingSceneDelegate: NSObject, UIHostingSceneDelegate &#123; static var rootScene: some Scene &#123; WindowGroup(id: &quot;volume&quot;) &#123; ContentView() &#125; .windowStyle(.volumetric) &#125;&#125; 结语visionOS 26 的场景 API 为开发者提供了前所未有的控制力和灵活性。无论是优化现有应用还是创造全新体验，这些工具都能帮助你打造更加自然、沉浸的虚拟现实应用。 立即开始探索这些新功能，为你的用户带来令人惊叹的空间体验吧！ 相关视频 小组件的新功能 搭配使用更出色：SwiftUI 和 RealityKit 用于打造沉浸式 App 的 Metal 渲染的新功能 文档 Adopting best practices for persistent UI 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"探索设备端基础模型的提示设计和安全","date":"2025-06-10T07:50:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_248/","text":"设计充分发挥 foundation models 框架优势的生成式 ai 体验。首先我们将展示如何为 apple 智能核心的设备端大语言模型设计提示。然后，我们将介绍 ai 安全方面的关键理念，并提供切实可行的具体策略来助你打造安全、可靠且令人愉悦的生成式 ai 功能。 视频地址 设备端基础模型实战：提示设计与安全防护指南引言随着Apple智能核心的设备端大语言模型(LLM)推出，开发者迎来构建生成式AI功能的新机遇。本文将深入解析两大核心议题：如何通过专业提示设计充分发挥30亿参数设备端模型的潜力，以及构建符合AI安全标准的应用实践。无论您是应用设计师还是工程师，这份指南都将成为您的实战手册。 设备端LLM特性与设计策略模型能力边界解析Apple设备端LLM作为30亿参数的优化模型，具有以下典型特征： 优势领域：文本摘要、内容分类、多轮对话、创作修订 能力局限： 复杂任务需拆解为分步提示 数学计算可靠性低于传统代码 未针对代码生成专项优化 知识截止日期后的事件不可知 引导生成技术通过基础模型框架的Guided Generation功能，开发者可以： 精确控制输出格式（字符串/数字/数组） 定义自定义数据结构 降低模型”幻觉”风险 提示工程最佳实践核心技巧四要素 内容量控制 限定句式：”用三句话总结” 扩展指令：”详细描述其特征” 风格角色设定 1&quot;以专业美食评论家的语气描述这道菜&quot; 训练特性适配 使用明确命令句式 提供3-5个示例（直接嵌入提示） 全大写禁止指令：”DO NOT生成暴力内容” 开发工具链Xcode Playground支持实时预览模型响应，只需添加#Playground标签 指令系统深度应用全局指令示例：“作为儿童教育助手，所有输出需符合PG-13评级标准”该设置将影响后续所有交互的基调和内容过滤。 AI安全防护体系四层防御架构 核心层 输入/输出双向内容过滤 自动拦截暴力、歧视性内容 指令层 1&quot;遇到敏感话题时转向积极讨论&quot; 输入控制层 禁止用户输入直接作为系统指令 采用预制提示+用户输入的混合模式 场景化防护层 食品类应用添加过敏原提示 教育应用设置知识可信度标识 质量评估体系测试框架搭建要点 数据集构建 覆盖80%主流使用场景 包含20%压力测试案例 自动化工具链 开发专用CLI测试工具 结合LLM自动评分系统 异常处理验证 测试安全拦截时的用户体验 建立错误代码对应方案 持续改进机制 通过Feedback Assistant提交问题 用户反馈需明确数据使用政策 设计自查清单应用上线前必查项：✅ 模型错误处理流程完备性✅ 安全指令与业务场景匹配度✅ 用户输入过滤机制有效性✅ 高风险场景专项防护措施✅ 自动化测试覆盖率≥70% 开发资源推荐 实验工具：Xcode行内Playground 设计规范：《生成式AI设计指南》最新版 安全理念：machinelearning.apple.com责任AI专题 相关文档人机界面指南：生成式AI人机界面指南：机器学习提升生成模型输出的安全性 提示：设备端模型开发需特别注意内存占用优化，建议参考WWDC性能优化专题演讲获取专项技巧。此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"了解 SwiftUI 空间布局","date":"2025-06-10T07:50:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_273/","text":"探索使用 swiftui 开发空间体验的新工具。了解 visionos 上 3d swiftui 视图的基本知识，借助深度对齐功能来自定现有布局，并使用修饰符在空间中旋转和放置视图。探索如何使用空间容器在同一 3d 空间中对齐视图，打造更沉浸、更引人入胜的 app。 视频地址 探索 SwiftUI 空间布局：打造沉浸式 3D 应用体验引言随着 visionOS 的推出，SwiftUI 迎来了全新的空间布局功能，让开发者能够轻松构建沉浸式的 3D 应用体验。本文将带你深入探索这些创新工具，从基础概念到高级应用，帮助你掌握 SwiftUI 在三维空间中的布局能力。 3D 视图基础在 visionOS 中，SwiftUI 视图从二维扩展到了三维空间。布局系统现在不仅计算宽度、高度和 X/Y 位置，还增加了深度维度： 12// 可视化 3D 框架的调试工具Model3D(named: &quot;Robot&quot;).debugBorder3D(.red) 值得注意的是： 像 Model3D 这样的视图具有固定的三维尺寸 传统 2D 视图（如 Image 和 Text）深度为零 RealityView 和可调整大小的 Model3D 会占据所有可用深度空间 深度对齐：定制 3D 布局深度对齐是 SwiftUI 为 3D 视图提供的新布局工具，类似于传统的垂直或水平对齐： 12345// 设置前对齐的 VStackVStackLayout().depthAlignment(.front) &#123; ResizableRobotView(asset: robot.model3DAsset) RobotNameCard(robot: robot)&#125;.frame(width: 300) 你还可以创建自定义深度对齐指南，实现更复杂的布局效果： 123456// 自定义深度对齐struct DepthPodiumAlignment: DepthAlignmentID &#123; static func defaultValue(in context: ViewDimensions3D) -&gt; CGFloat &#123; context[.front] &#125;&#125; 旋转布局：改变视图框架新的 rotation3DLayout 修饰符不同于视觉效果的旋转，它实际上会改变视图在布局系统中的框架： 123// 绕 Z 轴旋转 45 度Model3D(named: &quot;ToyRocket&quot;) .rotation3DLayout(.degrees(isRotated ? 45 : 0), axis: .z) 这个功能特别适合创建轮播视图等复杂的 3D 布局。 空间容器：精确对齐对于需要精确对齐的场景，SwiftUI 提供了两个强大工具： 12345// 使用 spatialOverlay 添加选中状态高亮环ResizableRobotView(asset: robot.model3DAsset) .spatialOverlay(alignment: .bottom) &#123; if isSelected &#123; ResizableSelectionRingModel() &#125; &#125; SpatialContainer 则允许将多个视图对齐到同一 3D 空间，就像俄罗斯套娃一样精确嵌套。 结语SwiftUI 的空间布局功能为 visionOS 应用开发带来了全新可能性。从基本的 3D 视图到复杂的深度对齐和旋转布局，这些工具让开发者能够轻松创建沉浸式体验。虽然某些高级场景仍需结合 RealityKit，但 SwiftUI 已经为大多数 3D 应用需求提供了完整的解决方案。 相关视频搭配使用更出色：SwiftUI 和 RealityKit使用 SwiftUI 构建自定布局利用 SwiftUI 构建自定视图 文档人机界面指南：visionOS 设计 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"通过小小文字改动让 App 变得大不同","date":"2025-06-10T07:50:38.000Z","path":"2025/06/10/2025-06-10-wwdc2025_404/","text":"随着新的设计系统在各平台之间实现统一，现在是时候重新审视一下 ui 中的文字表述了。了解一些小的改动 (例如移除重复内容并突出优势) 如何快速提升 app 的可用性和清晰度。 视频地址 通过细微文案调整提升应用用户体验引言在苹果新设计系统实现跨平台统一的背景下，优化应用界面的文案同样重要。本文分享四个简单有效的文案技巧，帮助开发者通过微小改动显著提升应用的可用性和清晰度。 1. 删除填充词用户体验文案不需要过多的修饰词。常见填充词包括： 副词和形容词：如”轻松地”、”快速地”、”简单的”等 感叹词：如”哎呀”、”糟糕”等 客套话：如”抱歉”、”谢谢”等 案例：原文案：”糟糕！我们要迟到了。很抱歉，您的配送员无法准时抵达，只需再等短短的10分钟！请查看应用追踪位置。”优化后：”配送延迟10分钟。请查看应用追踪配送员位置。” 2. 避免重复表达重复相同内容会降低文案效率。应确保关键信息只表述一次。 案例：原文案：”我们要迟到了。您的配送员无法准时抵达，10分钟后到达。”优化后：”配送延迟10分钟。” 3. 价值先行将行动带来的利益放在前面，能更有效地吸引用户。 案例：原文案：”输入电话号码获取预订更新。”优化后：”为获取预订更新，请输入电话号码。” 4. 建立词表词表能确保应用内术语的一致性，建议包含： 规范用词 禁用同义词 简要解释 案例：在游戏中统一使用”别名”而非”用户名”或”称号”来指代玩家ID。 综合案例：AirPods Pro听力测试 删除填充词：标题直接使用”测试听力” 价值先行：强调”听力损失普遍存在且可能恶化” 一致性：所有步骤页统一使用”下一步”按钮 避免重复：标题和说明提供互补而非重复信息 总结通过这四项技巧，开发者可以快速提升应用文案质量。建议预留1-2小时实践这些方法，并大声朗读文案以识别冗余内容。 相关文档人机界面指南：文案写作 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"使用全新设计系统构建 UIKit App","date":"2025-06-10T07:50:36.000Z","path":"2025/06/10/2025-06-10-wwdc2025_284/","text":"更新你的 uikit app，以便充分利用全新设计系统。我们将深入探索标签视图、分屏浏览、栏、演示文稿、搜索和控制项等方面的主要变化，并向你展示如何在自定 ui 中使用 liquid glass。为了充分从这个视频中获益，建议你先观看“了解全新设计系统”以获取一般性设计指导。 视频地址 使用全新设计系统升级 UIKit 应用：液态玻璃效果实践指南引言随着 iOS 26 的发布，Apple 推出了全新的视觉设计系统，其中最引人注目的是液态玻璃（Liquid Glass）材质。这种创新的设计语言不仅改变了系统控件的外观，更为开发者提供了构建现代、沉浸式应用的新工具。本文将详细介绍如何在 UIKit 应用中应用这些设计变革。 核心设计变革1. 标签视图与分屏浏览的优化 悬浮式标签栏：iPhone 上的标签栏现在悬浮于内容上方，支持滚动时自动最小化 补充视图支持：可在标签栏上方添加自定义视图（如音乐播放器），并自动适应布局变化 iPad边栏扩展效果：允许背景内容穿透边栏显示，创造更沉浸的视觉体验 1234567// 标签栏滚动行为设置tabBarController.tabBarMinimizeBehavior = .onScrollDown// 添加底部补充视图let nowPlayingView = NowPlayingView()let accessory = UITabAccessory(contentView: nowPlayingView)tabBarController.bottomAccessory = accessory 2. 导航栏与工具栏的透明化设计 自动按钮分组：系统会根据按钮类型自动分组，保持视觉一致性 新增副标题API：为导航栏添加更多信息层次 边缘交互效果：支持自定义容器与滚动视图的交互 1234567// 导航栏副标题设置navigationItem.subtitle = &quot;49 未读&quot;navigationItem.largeSubtitleView = filterButton// 工具栏按钮均匀分布let flexibleSpace = UIBarButtonItem.flexibleSpace()toolbarItems = [flexibleSpace, cameraButton, flexibleSpace] 3. 呈现效果的升级 变形动画：菜单和弹出框现在支持来源按钮的平滑变形过渡 动态表单：操作表单高度可动态调整，在iPad上始终锚定源视图 12// 弹出框变形动画设置viewController.popoverPresentationController?.sourceItem = barButtonItem 液态玻璃效果实践控件更新 玻璃质感按钮：新增两种玻璃样式按钮配置 增强型滑块：支持刻度线显示和中性值设定 12345678910// 玻璃质感按钮配置button.configuration = .glass()tintedButton.configuration = .prominentGlass()// 带刻度的滑块设置slider.trackConfiguration = .init( allowsTickValuesOnly: true, neutralValue: 0.2, numberOfTicks: 5) 自定义视图应用液态玻璃效果特别适合用于悬浮交互层，实现方法如下： 12345678// 基本玻璃效果应用let glassEffect = UIGlassEffect()UIView.animate &#123; effectView.effect = glassEffect &#125;// 高级容器效果let container = UIGlassContainerEffect()containerView.effect = containercontainerView.contentView.addSubview(glassView1) 实施建议 优先使用系统组件：替换自定义控件为已优化的系统版本 渐进式更新：从关键交互元素开始应用新设计 保持视觉层次：确保液态玻璃效果不会影响内容可读性 相关视频 了解液态玻璃 了解全新设计系统 让你的 UIKit 应用更加灵活 文档资源 采用液态玻璃 人机界面指南 通过合理应用这些设计变革，您的UIKit应用将获得更现代、更一致的视觉体验，同时保持苹果生态系统特有的精致感和可用性。 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"搭配使用更出色：SwiftUI 和 RealityKit","date":"2025-06-10T07:50:33.000Z","path":"2025/06/10/2025-06-10-wwdc2025_274/","text":"了解如何在 visionos 26 中无缝整合 swiftui 和 realitykit 的强大功能。我们将探索 model3d 的增强功能 (包括动画和 configurationcatalog 支持)，并展示如何顺利过渡到 realityview。你将了解如何借助 swiftui 动画实现 realitykit 组件更改、实现交互式操控、使用新增 swiftui 组件打造更丰富的互动体验，以及从 swiftui 代码中观察 realitykit 的变化。我们还将介绍如何利用统一坐标转换进行跨框架坐标变换。 视频地址 SwiftUI与RealityKit的完美融合：visionOS 26新特性详解引言在visionOS 26中，Apple为开发者带来了SwiftUI与RealityKit深度融合的全新体验。这两个强大的框架如今能够无缝协作，让开发者轻松构建融合传统UI与交互式3D内容的应用程序。本文将详细介绍这些激动人心的新特性。 Model3D增强功能Model3D现在支持两大关键功能： 动画支持 通过Model3DAsset加载3D模型并控制动画 使用selectedAnimation选择特定动画片段 通过AnimationPlaybackController控制播放进度 ConfigurationCatalog 轻松切换模型的多个预置配置版本 艺术家可以直接准备不同造型配置 平滑过渡到RealityView当需要更多高级功能时，可以无缝切换到RealityView： 布局模式选择： .flexible：填充可用空间 .centered：内容居中显示 .fixedSize：精确匹配模型边界 粒子系统集成： 创建不可见实体作为容器 添加ParticleEmitterComponent 调整发射方向 实现丰富的视觉效果 对象操控新体验visionOS 26引入了全新的Object Manipulation API： 12Model3D(...) .manipulable([.move, .rotate], inertia: .high) 自动添加碰撞、输入目标和悬停特效组件 支持订阅操控事件(开始/停止/传递) 可自定义交互反馈效果 SwiftUI组件深度整合三大新型组件架起桥梁： ViewAttachmentComponent - 将SwiftUI视图绑定到实体 GestureComponent - 让实体响应手势 PresentationComponent - 从实体触发SwiftUI弹窗 双向数据流RealityKit实体现在可以作为可观察对象： 监听变换属性(位置/旋转/缩放) 追踪组件变化 驱动SwiftUI视图更新 注意避免在update闭包中修改观察属性 统一坐标转换新的CoordinateSpace3D协议消除了框架间的坐标壁垒： 获取Model3D的坐标空间 转换为RealityKit实体坐标 实现精确的空间计算 SwiftUI动画驱动通过animate闭包可以： 驱动实体变换动画 控制音频/模型/灯光属性过渡 结合操控API实现弹性效果 两种实现方式：123456789// 方式一content.animate &#123; entity.position.x = newValue&#125;// 方式二entity.animate(with: .bouncy) &#123; $0.transform = .identity&#125; 结论visionOS 26为SwiftUI和RealityKit的协同工作带来了革命性的改进。从简单的3D模型展示到复杂的交互式体验，开发者现在拥有了更强大、更灵活的工具集。期待看到开发者们利用这些新特性创造出令人惊叹的空间计算应用！ 相关视频 在Reality Composer Pro中编写交互式3D内容 探索SwiftUI中的观察 深入了解RealityKit 2 SwiftUI中的数据要素 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"使用全新设计系统构建 SwiftUI App","date":"2025-06-10T07:50:28.000Z","path":"2025/06/10/2025-06-10-wwdc2025_323/","text":"探索 liquid glass 为 app 的外观和风格带来了哪些颠覆性的改变。了解这个亮眼的新材质如何提升不同平台上工具栏、控制项和 app 结构的视觉效果，从而带来引人入胜的交互体验并将你的 app 与系统无缝整合在一起。了解如何采用新的 api 来帮助你充分利用 liquid glass。 视频地址 运用 Liquid Glass 设计系统打造惊艳 SwiftUI 应用引言iOS 26 和 macOS Tahoe 带来了名为 Liquid Glass 的革命性设计系统，这种自适应材质将玻璃的光学特性与液体流动感完美结合，为应用界面带来前所未有的视觉效果。本文将带您了解如何利用这一设计系统为您的 SwiftUI 应用注入全新活力。 Liquid Glass 核心特性Liquid Glass 是一种应用于控件和导航元素的自适应材质，具有以下特点： 智能调节透明度：根据背景内容自动调整，从浅色过渡到深色 动态交互效果：开关、分段选择器和滑块等组件在操作时呈现流动玻璃质感 跨平台一致性：优化适用于所有 Apple 平台 应用框架革新NavigationSplitView 和 TabView 等结构化组件已全面升级： NavigationSplitView 侧边栏悬浮于内容之上并采用 Liquid Glass 材质 新的 backgroundExtensionEffect 修饰符允许视图安全扩展到区域外 检查器面板采用更多 Liquid Glass 效果 123456NavigationSplitView &#123; // 侧边栏内容&#125; detail: &#123; // 详情视图&#125;.backgroundExtensionEffect() TabView iPhone 标签栏悬浮于内容上方 支持滚动时自动最小化（通过 tabBarMinimizeBehavior 修饰符配置） tabViewBottomAccessory 修饰符可在标签栏上方添加视图 1234TabView &#123; // 各个标签页&#125;.tabBarMinimizeBehavior(.onScrollDown) 工具栏优化新工具栏设计提供了更优雅的操作布局： 工具栏项目置于悬浮的 Liquid Glass 表面 ToolbarSpacer API 实现项目分组和间距控制 单色图标减少视觉干扰，突出应用内容 轻松添加通知标识（通过 badge 修饰符） 12345678.toolbar &#123; ToolbarItem(placement: .primaryAction) &#123; Button(action: &#123;&#125;) &#123; Image(systemName: &quot;heart&quot;) &#125; .badge(5) &#125;&#125; 搜索体验升级两大搜索模式获得显著改进： 工具栏搜索： 自动适应设备位置（iPhone底部/iPad&amp;Mac右上角） 可通过 searchToolbarBehavior 修饰符控制最小化行为 多标签页搜索： 作为独立页面呈现 在 TabView 添加 searchable 修饰符实现 1234NavigationStack &#123; // 内容&#125;.searchable(text: $searchText) 控件焕新主要控件获得统一家族化特征： 按钮默认采用胶囊形状 滑块新增刻度标记支持 菜单跨平台布局更统一 新增超大按钮样式支持重要操作 1234Button(&quot;重要操作&quot;) &#123; // 操作代码&#125;.buttonStyle(.largeProminent) 自定义 Liquid Glass 元素创建自定义特效的四个步骤： 添加 glassEffect 修饰符创建玻璃背景 添加 interactive 修饰符实现交互响应 使用 GlassEffectContainer 确保视觉一致性 添加 glassEffectID 修饰符实现流体变形过渡 1234CustomBadgeView() .glassEffect() .interactive() .glassEffectID(&quot;badge&quot;) 开始实践立即使用 Xcode 26 构建您的应用： 优化表单和工具栏布局 运用 Liquid Glass 创造特色组件 体验全新的设计系统优势 相关视频 了解全新设计系统 文档资料 Adopting Liquid Glass Applying Liquid Glass to custom views 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"Xcode 的新功能","date":"2025-06-10T07:50:16.000Z","path":"2025/06/10/2025-06-10-wwdc2025_247/","text":"了解 xcode 26 中最新的效率和性能改进。了解如何在开发流程中充分利用大语言模型。探索编辑和调试方面的增强功能、性能和测试工具的改进，以及 xcode 使用的开源构建系统引擎 swift build。 视频地址 Xcode 26 新特性全解析：从智能编程到性能优化引言Xcode 26 带来了革命性的开发体验提升。作为苹果官方集成开发环境的最新版本，它不仅优化了基础性能，更深度整合了大语言模型等前沿技术。本文将带您全面了解 Xcode 26 的每一项重要改进。 性能与安装优化Xcode 26 在安装包体积上实现了显著缩减： 整体体积减少 24% 默认移除 Intel 架构模拟器支持 可选下载 Metal 工具链 实际使用体验也获得提升： 文本输入延迟降低最高 50% 大型项目工作区加载速度提升 40% 编辑器与工作区增强源代码编辑器迎来多项改进： 标签页管理：支持类似 Safari 的起始页设计 多词搜索：智能查找词语组合，支持跨行匹配 语音编程：通过自然语音完成代码编写与导航 12// 示例：语音编写 Swift 代码&quot;if let continent 等于 landmark.continent 左括号&quot; 代码迭代新方式 Playground 宏：实时显示代码执行结果 快速调试：通过正则表达式即时修正坐标解析问题 开源支持：跨平台 Swift 开发能力 设计与本地化工具 Icon Composer：一站式多平台图标设计工具 String Catalogs： 类型安全 Swift 符号 自动生成翻译上下文 智能使用场景分析 智能编程功能Xcode 26 深度整合大语言模型： 通用 Swift 问题解答 基于上下文的项目专属问题解决 @引用精准定位 修改历史追溯与回滚 支持多种模型接入方式： ChatGPT API 本地模型 可配置偏好设置 调试与性能工具Swift 并发调试 跨线程异步函数追踪 任务 ID 可视化 清晰的并发类型信息 处理器追踪（M4/iPhone16专属） 全线程函数调用记录 比采样分析更高的保真度 SwiftUI 性能分析 视图更新因果链 更新频率统计 卡顿检测 功耗分析 有线/无线记录模式 能源子组件可视化 Organizer 新增趋势分析 构建系统革新 显式构建模块： 分阶段编译流程 提升构建效率 加速调试过程 Swift Build 开源： 统一 Xcode 与 SPM 体验 扩展跨平台支持 欢迎社区贡献 应用安全增强： Enhanced Security 功能 指针验证等高级保护 建议社交/通讯类应用启用 测试体系升级UI 测试 增强版自动化录制 交互操作转代码 多标识符元素选择 测试报告集成视频回放 性能测试 XCTHitchMetric 卡顿检测 主线程违规检测 运行时 API 检查 结语Xcode 26 通过全方位的改进，为开发者提供了更智能、高效的开发环境。从代码编写到性能优化，每个环节都获得了显著提升。建议开发者立即体验这些新特性，将您的开发效率提升到新高度。 相关视频 了解焕然一新的 App 图标 使用 Icon Composer 构建图标 分析并优化 App 的功耗 Swift 的新功能 相关文档 使用 Processor Trace 分析 CPU 使用率 为应用启用增强安全 Xcode 更新日志 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"设计","slug":"设计","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"针对 CarPlay 车载优化你的 App","date":"2025-06-10T07:49:31.000Z","path":"2025/06/10/2025-06-10-wwdc2025_216/","text":"了解如何将实时活动和小组件引入 carplay 车载和 carplay 车载 ultra，以便用户查看活动进度并一目了然地掌握相关信息。探索所有 carplay 车载 app 均可使用的新增模板选项，并了解导航类 app 如何提供逐向导航元数据，以便显示在车载仪表盘或 hud 上。 视频地址 123456789101112131415161718192021222324# iOS 26 CarPlay 开发指南：如何为车载场景优化你的应用## 引言CarPlay 作为 iPhone 车载延伸体验的核心系统，在 iOS 26 中迎来重大升级。本文将详解如何通过实时活动、小组件和增强框架 API，让你的应用更好地服务于驾驶场景，涵盖从界面适配到性能优化的全流程技术要点。## 一、CarPlay 基础架构升级### 1.1 显示适配新特性- **智能显示缩放**：支持驾驶员调整屏幕比例，应用自动响应布局变化- **视觉自适应**：系统自动为应用应用新的视觉风格，无需开发者额外配置### 1.2 CarPlay Ultra 支持新一代 CarPlay 架构提供：- 全显示屏统一体验- 现有 CarPlay 应用的平滑兼容- 扩展的开发者 API 套件## 二、小组件车载集成方案### 2.1 实现要点```swift// 声明支持 systemSmall 尺寸WidgetConfiguration() .supportedFamilies([.systemSmall]) 2.2 场景优化策略 使用 disfavoredLocations 排除不适用场景 遵循内容边距规范 设置 containerBackgroundRemovable 提升可读性 不推荐场景示例： 游戏类交互组件 依赖复杂手势的操作 需要访问相册等保护数据的组件 三、实时活动车载适配3.1 显示规则 自动同步 iPhone 活动状态 仪表盘优先显示 activityFamilySmall 尺寸 动态岛视图作为降级方案 3.2 设计规范 仅展示核心状态信息 禁止交互控件 支持专注模式过滤 四、CarPlay 框架深度解析4.1 模板系统增强CPListTemplate 新型元素： 卡片元素 (CPListImageRowItem) 紧凑元素 (带圆形图标) 网格元素 (全图展示) 置顶元素 (headerGridButtons) 4.2 音频专项优化123456// 体育赛事直播元数据配置let mode = CPNowPlayingModeSports( teams: [homeTeam, awayTeam], score: &quot;3-2&quot;, clock: gameClock) 关键改进： 自动时钟计数 时间偏移同步 空间音频支持 五、导航应用高级功能5.1 元数据工作流 创建含 54 种机动类型的 CPManeuver 实现 mapTemplateShouldProvideNavigationMetadata 动态更新 CPRouteInformation 5.2 性能优化技巧 设备温度敏感型渲染降级 CADisplayLink 自适应帧率 中控屏与仪表盘差异渲染 开发工具推荐 CarPlay 模拟器 (包含于 Xcode 附加工具包) Instruments 性能分析 多车型真机测试 结语iOS 26 为 CarPlay 开发带来前所未有的可能性。通过合理运用小组件、实时活动和增强框架，开发者可以创造更安全、更高效的车载体验。建议从仪表盘小组件入手，逐步扩展至全功能集成。 相关视频 小组件的新功能 通过 Instruments 优化 CPU 性能 了解新一代 CarPlay 车载架构 文档 为小组件添加待机和 CarPlay 支持` 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"完成后台任务","date":"2025-06-10T07:49:27.000Z","path":"2025/06/10/2025-06-10-wwdc2025_227/","text":"探索后台任务执行方面的最新进展，并了解系统如何进行运行时调度。我们将讨论如何充分利用后台运行时，让你的 app 既能在后台提供功能，又能保持出色的前台体验。我们还将介绍各种 api 如何为你的 app 提供后台运行时环境，以及每个 api 是怎样针对不同用例量身定制的 — 其中包括 ios 和 ipados 26 中的新 api，这些 api 让你的 app 能够在从前台过渡到后台时顺利完成任务。 视频地址 iOS后台任务处理全指南：从基础到持续处理任务引言在iOS应用开发中，后台任务处理一直是开发者需要重点关注的技术点。合理利用后台运行时可以让应用体验更流畅，同时又能保护电池寿命和系统性能。本文将系统介绍iOS后台任务处理的各个方面，包括基础概念、行为规范、常用API以及iOS 26中新增的持续处理任务。 基础概念前台与后台状态iOS应用主要有两种运行状态： 前台状态：应用界面占据设备焦点，可以自由使用系统资源 后台状态：用户离开应用但进程仍存活，默认会被挂起以节省资源 系统会在以下情况分配后台运行时间： 完成关键工作（如保存数据） 执行预加载或同步任务 处理用户触发的长时间操作 后台任务的行为规范系统约束条件iOS系统对后台任务有严格限制，主要考虑以下因素： 电池寿命：系统会合并任务，减少不必要的后台活动 资源分配：内存、CPU、网络带宽等资源优先分配给前台应用 用户控制：用户可以通过设置调节后台行为 设计原则优秀后台任务应遵循以下原则： 高效性：任务应轻量且目的明确 原子性：将工作分解为独立单元 弹性：支持断点续传 礼貌性：尊重用户设置和偏好 自适应性：根据系统状况调整行为 后台任务API详解1. BGAppRefreshTask适用于从服务器静默获取内容的场景：1234567891011121314import BackgroundTasksimport SwiftUI@mainstruct ColorFeed: App &#123; var body: some Scene &#123; WindowGroup &#123; // ... &#125; .backgroundTask(.appRefresh(&quot;com.colorfeed.wwdc25.appRefresh&quot;)) &#123; await self.handleAppRefreshTask() &#125; &#125;&#125; 2. BGProcessingTask适用于数据处理、数据库维护等场景：12345678910111213import BackgroundTasksimport UIKitclass AppDelegate: UIResponder, UIApplicationDelegate &#123; func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; BGTaskScheduler.shared.register( forTaskWithIdentifier: &quot;com.example.apple-samplecode.ColorFeed.db_cleaning&quot;, using: nil ) &#123; task in self.handleAppRefresh(task: task as! BGProcessingTask) &#125; &#125;&#125; 3. 传统后台任务API适用于完成关键不可中断的工作：1234567891011121314151617181920import UIKit@mainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; var backgroundTaskID: UIBackgroundTaskIdentifier = .invalid func saveState() &#123; /* ... */ &#125; func handlePersistence() &#123; let app = UIApplication.shared guard backgroundTaskID != .invalid else &#123; return &#125; backgroundTaskID = app.beginBackgroundTask(withName: &quot;Finish Export&quot;) &#123; app.endBackgroundTask(self.backgroundTaskID) self.backgroundTaskID = .invalid &#125; self.saveState() app.endBackgroundTask(backgroundTaskID) backgroundTaskID = .invalid &#125;&#125; iOS 26新增：持续处理任务适用场景持续处理任务(BGContinuedProcessingTask)专门用于处理用户明确触发的长时间操作，如： 文件导出 社交媒体内容发布 配件固件更新 实现步骤 在Info.plist中添加任务ID 注册任务处理程序 提交任务请求 123456789101112131415161718192021222324252627282930import BackgroundTasksfunc handleDialogConfirmation() &#123; BGTaskScheduler.shared.register(&quot;com.colorfeed.wwdc25.userTask&quot;) &#123; task in let task = task as! BGContinuedProcessingTask var shouldContinue = true task.expirationHandler = &#123; shouldContinue = false &#125; task.progress.totalUnitCount = 100 task.progress.completedUnitCount = 0 while shouldContinue &#123; // 执行工作 task.progress.completedUnitCount += 1 &#125; task.setTaskCompleted(success: true) &#125;&#125;func submitContinuedProcessingTaskRequest() &#123; let request = BGContinuedProcessingTaskRequest( identifier: &quot;com.colorfeed.wwdc25.userTask&quot;, title: &quot;简明标题&quot;, subtitle: &quot;实用且信息丰富的副标题&quot; ) request.strategy = .fail BGTaskScheduler.shared.submit(request)!&#125; 关键特性 进度反馈：必须及时汇报工作进度 终止处理：提供优雅终止任务的机制 GPU支持：在支持设备上可获取后台GPU访问权限 用户控制：用户可随时查看进度或取消任务 最佳实践总结 明确任务类型：区分是用户触发还是系统触发 控制任务时长：短任务优先，长任务分解 优先用户价值：后台任务应带来明显用户体验提升 尊重系统限制：适应电池、网络等条件变化 测试各种场景：包括低电量模式、弱网环境等 相关文档 后台任务官方文档 iOS和iPadOS上的长时任务处理 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"将结构化并发代码与 Network 框架搭配使用","date":"2025-06-10T07:48:41.000Z","path":"2025/06/10/2025-06-10-wwdc2025_250/","text":"network 框架是在 apple 平台上建立底层网络连接的最佳方式，而在 ios、ipados、和 macos 26 上，它非常适合与你的结构化并发代码搭配使用。我们将探索如何建立连接、发送和接收数据与分帧处理的信息、监听传入连接以及浏览网络上的服务。在此期间，我们还将介绍一些关键的最佳做法。 视频地址 结构化并发中的 Network 框架实践指南引言在 iOS/macOS 应用开发中，网络连接是实现现代应用功能的核心组件。随着 iOS 和 macOS 26 系统的发布，Network 框架与 Swift 结构化并发特性的深度整合，为开发者带来了全新的网络编程体验。本文将系统性地介绍如何利用这些改进来创建更高效、安全的网络连接。 连接建立新范式Network 框架彻底重构了传统的网络连接方式： 智能地址解析：”Connect by Name”功能自动处理域名解析 动态路由优化：”Happy Eyeballs”算法自动选择最优网络路径 原生安全协议：内置 TLS 支持，无需依赖第三方库 网络适应性：自动处理网络接口切换和代理配置 1234// 建立TLS连接的现代写法let connection = NetworkConnection(to: .hostPort(host: &quot;www.example.com&quot;, port: 1029)) &#123; TLS()&#125; 数据收发最佳实践Network 框架提供了多种数据交换方式： 基础收发12345// 发送数据try await connection.send(outgoingData)// 精确接收指定字节数let incomingData = try await connection.receive(exactly: 98).content 流式处理对于未知长度的数据（如媒体文件），可采用渐进式接收策略：1234while remaining &gt; 0 &#123; let chunk = try await connection.receive(atLeast: 1, atMost: remaining).content // 处理数据块&#125; 结构化消息传输iOS 26 引入的 TLV（类型-长度-值）分帧器简化了协议设计：12345678// 定义消息类型enum GameMessage: Int &#123; case selectedCharacter = 0 case move = 1&#125;// 发送带类型的消息try await connection.send(characterData, type: GameMessage.selectedCharacter.rawValue) 高级网络功能入站连接处理NetworkListener 提供了简洁的服务器端实现：12345NetworkListener &#123; TLS()&#125;.run &#123; connection in // 处理每个入站连接&#125; 设备发现iOS 26 新增的 NetworkBrowser 支持 Wi-Fi Aware 点对点发现：123let endpoint = try await NetworkBrowser(for: .wifiAware(...)).run &#123; .finish($0.first!) &#125; 协议选择建议 第三方服务：遵循行业标准协议 自有设备：优先使用 Codable over TLS/QUIC 现有应用：URLSession 用户可保持现状 总结iOS/macOS 26 的 Network 框架三大核心改进： NetworkConnection：支持现代传输协议和结构化数据 NetworkListener：简化服务器实现 NetworkBrowser：增强设备发现能力 这些改进使得网络代码更简洁、更安全，同时完全兼容结构化并发范式。 相关视频 借助 Wi-Fi Aware 增强设备连接性能 采用 Swift 并发 Introducing Network.framework: A modern alternative to Sockets 文档 Network 框架文档 NetworkBrowser NetworkConnection NetworkListener 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"在你的 App 中录制电影效果视频","date":"2025-06-10T07:48:35.000Z","path":"2025/06/10/2025-06-10-wwdc2025_319/","text":"了解如何使用 cinematic video api，让你的 app 轻松拍摄大片感满屏的精彩视频。我们将介绍如何配置电影效果拍摄会话，并讲解构建视频拍摄 ui 的基本知识。我们还将探索高级电影效果功能，例如应用景深效果来实现动态跟踪拍摄和巧妙的焦点切换。 视频地址 使用 Cinematic Video API 打造电影级视频拍摄体验引言电影效果视频是 iPhone 13 系列引入的突破性功能，它通过智能算法实现了专业电影中常见的焦点追踪和浅景深效果。如今，开发者可以通过全新的 Cinematic Video API 将这些强大的电影拍摄能力集成到自己的应用中，为用户带来专业级的视频创作体验。 电影效果视频的核心技术电影效果视频的核心在于模拟传统电影的叙事工具： 定点对焦：将观众注意力集中到关键主体 追踪对焦：当主体移动时保持焦点清晰 智能切换：当主体移出画面时自动切换焦点 这些原本需要专业跟焦员操作的技术，现在通过 Cinematic Video API 可以轻松实现。系统会自动检测画面主体，智能决定对焦策略，大幅降低了电影级视频的拍摄门槛。 配置电影效果拍摄会话在 iOS 26 中，启用电影效果视频拍摄变得异常简单： 12345let videoInput = try! AVCaptureDeviceInput(device: camera)captureSession.addInput(videoInput)if videoInput.isCinematicVideoCaptureSupported &#123; videoInput.isCinematicVideoCaptureEnabled = true&#125; 只需将 isCinematicVideoCaptureEnabled 设置为 true，系统就会自动配置以下输出： 电影文件输出：生成包含视差数据和元数据的 Cinematic 文件 视频数据输出：提供带有浅景深效果的帧数据 预览层：实时渲染虚化效果，构建取景器 构建完整的拍摄体验我们通过 SwiftUI 构建了一个完整的电影效果拍摄界面： 123456789@MainActorstruct CameraView: View &#123; var body: some View &#123; ZStack &#123; CameraPreviewView() CameraControlsView() &#125; &#125;&#125; 关键功能实现 设备与格式选择：选取支持电影效果的相机设备和格式 音频配置：启用空间音频增强体验 视频防抖：使用电影级增强防抖模式 元数据处理：获取人脸检测等元数据并可视化 高级控制功能API 提供了丰富的焦点控制方式： 12345678// 追踪特定对象open func setCinematicVideoTrackingFocus(detectedObjectID: Int, focusMode: AVCaptureDevice.CinematicVideoFocusMode)// 追踪画面位置open func setCinematicVideoTrackingFocus(at point: CGPoint, focusMode: AVCaptureDevice.CinematicVideoFocusMode)// 固定焦点位置open func setCinematicVideoFixedFocus(at point: CGPoint, focusMode: AVCaptureDevice.CinematicVideoFocusMode) 此外，开发者还可以： 调整虚化强度 检测光线不足场景 获取拍摄状态监控 结语Cinematic Video API 将专业电影拍摄技术带到了移动应用开发中。通过简单的 API 调用，开发者就能为用户提供媲美专业电影制作的视频拍摄体验。期待看到更多应用利用这些功能，创造出令人惊艳的电影级视频作品。 相关视频 利用拍摄控件提升你的相机体验 打造出色的锁定屏幕相机拍摄体验 在 iPadOS App 中支持外部摄像头 打造更流畅的相机体验 探索 tvOS 连续互通相机 文档 AVFoundation Cinematic 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"借助 NetworkExtension 优化网络流量过滤和隧道","date":"2025-06-10T07:48:34.000Z","path":"2025/06/10/2025-06-10-wwdc2025_234/","text":"了解 networkextension 框架中提供的 api，这些 api 让你的 app 能够灵活地扩展系统的核心网络功能 — 例如实现网络内容过滤器、创建和管理 vpn 配置等。在 ios、ipados 和 macos 26 中，你现在可以构建更为强大的内容过滤器，让它根据整个 url (而不仅是主机名) 来做出流量决策，同时确保隐私和安全丝毫不受影响。我们将首先简要介绍 networkextension 框架的一些主要用例，包括网络中继和 vpn。然后，我们将深入探讨这一全新的 url 过滤器 api 及其关键组件，包括 private information retrieval、privacy pass 等。 视频地址 深入解析 NetworkExtension：网络流量过滤与隧道技术完全指南简介NetworkExtension 是苹果平台强大的网络扩展框架，它允许开发者构建能够扩展系统核心网络功能的应用。无论是在 iOS、iPadOS 还是 macOS 上，NetworkExtension 都能为你的应用提供灵活的网络控制能力。本文将全面介绍 NetworkExtension 的主要功能，重点讲解最新 URL 过滤器 API 及其实现原理。 NetworkExtension 功能概览NetworkExtension 框架支持多种网络定制和扩展方式： Wi-Fi 管理与热点在 iOS 上，开发者可以使用 Wi-Fi 管理和热点 API 来： 配置 Wi-Fi 设置 与热点进行交互 利用 iOS 26 新增的 NEHotspotHelper 扩展 API 本地推送 API适用于特殊网络环境（如邮轮或医院）的应用场景，支持： 受限网络中的短信发送 VoIP 通话等功能 DNS 配置与代理构建安全应用来保护 DNS 流量： 安装 DNS 配置 使用内置加密 DNS 协议 通过自有安全通道代理 DNS 流量 透明代理（仅 Mac） 将特定网站流量重定向至云端安全服务 进行认证授权处理 安全远程访问解决方案NetworkExtension 提供两种主要远程访问方案： 网络中继适合隧道传输 TCP 或 UDP 流量以访问特定应用： 使用 MASQUE 协议提供安全代理 性能优化且易于集成到现代云环境 平台内置支持，无需自建扩展 基于 IP 的 VPN适合需要隧道传输 IP 流量的场景： 企业网络扩展 个人隐私保护 网络安全政策严格的受监管机构 创建 IP 型 VPN 隧道时，开发者可选择： 使用 NEVPNManager API 内置协议（IKEv2 或 IPsec） 使用 NEPacketTunnelProvider 实现自定义隧道协议 内容过滤技术NetworkExtension 提供强大的内容过滤 API，主要用途包括： 个人防火墙 企业流量监控应用 家长控制应用 传统内容过滤器基于流量级信息（如 HTTPS 请求的主机和端口）做决策 新型 URL 过滤器（iOS 26+）基于完整 URL 进行系统级 HTTP/HTTPS 请求过滤 URL 过滤器工作原理URL 过滤器采用创新隐私保护技术，确保： 应用无法获取 URL 内容 所有后端服务器查询均匿名化 整个后端链都无法访问内容与身份信息 核心技术组件 Bloom 过滤器：快速预过滤设备端数据 私有信息检索（PIR）：加密查询服务器数据库 Privacy Pass：服务器匿名认证 Oblivious HTTP 中继：隐私保护代理 工作流程 浏览器发起 URL 请求 系统用 Bloom 过滤器检查 阳性匹配时系统向 PIR 服务器发送加密查询 服务器执行加密数据库查询并返回结果 系统解密响应并决定是否拒绝请求 实现 URL 过滤器开发者可以通过以下步骤创建 URL 过滤器： 1. 设置 PIR 服务器使用示例代码快速搭建服务器 2. 构建 Bloom 过滤器根据数据集动态性决定交付方式： 静态数据集：包含在应用包中 动态数据集：从服务器定期更新 3. 构建 URL 过滤器应用添加必要的权限和配置：123456789101112131415161718import NetworkExtensionlet manager = NEURLFilterManager.sharedtry await manager.loadFromPreferences()try manager.setConfiguration( pirServerURL: URL(string:&quot;https://pir.example.com&quot;)!, pirPrivacyPassIssuerURL: URL(string:&quot;https://privacypass.example.com&quot;)!, pirAuthenticationToken: &quot;1234&quot;, controlProviderBundleIdentifier: &quot;com.example.myURLFilter.extension&quot;)manager.prefilterFetchInterval = 86400 // 每日获取一次manager.shouldFailClosed = falsemanager.localizedDescription = &quot;Alice的URL过滤器&quot;manager.isEnabled = truetry await manager.saveToPreferences() 4. 企业级部署通过 MDM 推送包含 URL 过滤器参数的配置描述文件 5. 构建应用扩展使用 Xcode 新模板实现 NEURLFilterControlProvider 协议 最佳实践建议 使用网络中继安全远程访问 TCP/UDP 流量 用 NetworkExtension 构建 VPN 解决方案 通过 URL 过滤器 API 创建内容过滤器 避免使用 Packet Filter 或直接修改路由表 相关视频 将隐私保护融入开发流程 适用于现代 Mac 的网络扩展 文档资源 通过URL过滤流量 NEHotspotManager Network Extension NEURLFilterManager 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"开始使用量子安全加密技术","date":"2025-06-10T07:48:31.000Z","path":"2025/06/10/2025-06-10-wwdc2025_314/","text":"了解如何通过抵御量子计算这一新兴威胁来保护 app 的敏感用户数据，并了解如何保护用户隐私。我们将探索不同类型的量子攻击、它们对现有加密协议的影响，以及如何使用量子安全加密技术来抵御这些攻击。你将了解如何使用量子安全 tls 来保护网络数据，以及如何使用 cryptokit 的量子安全 api 来保护应用程序数据。 视频地址 量子安全加密技术：保护你的应用免受未来威胁引言随着量子计算的快速发展，传统的加密技术正面临前所未有的挑战。本指南将带你了解如何通过量子安全加密技术保护应用中的敏感数据，抵御量子计算带来的新型威胁。 量子攻击威胁解析当今应用处理的健康数据、地理位置和照片等敏感信息都依赖加密技术保护。但量子计算机的出现可能破解现有加密体系。 主要威胁包括： “现在收割，未来解密”攻击：攻击者现在截获加密数据，待量子计算机成熟后再解密 身份伪造攻击：利用量子计算机破解签名算法，伪造用户身份 量子安全加密解决方案密码学界已研发出能同时抵御经典和量子计算机攻击的新型算法： 公钥密码学升级 采用”后量子混合公钥加密”(Post-quantum HPKE) 使用”后量子混合签名” 需要同时攻破两种算法才能破解 对称密钥密码学优化 仅需将密钥长度加倍即可实现量子安全 例如从AES-128升级到AES-256 网络数据保护方案大多数网络数据通过TLS保护，最新TLS 1.3已实现量子安全升级： iOS 26后，URLSession等网络API将默认启用量子安全TLS 开发者应逐步弃用旧API 服务器端需要相应升级 自定义协议保护方案如果你的应用使用自定义加密协议，升级步骤如下： 识别现有加密方案中的薄弱环节 制定升级计划改用量子安全算法 使用CryptoKit新API实现安全升级 1234// 使用CryptoKit的量子安全API示例let ciphersuite = HPKE.Ciphersuite.XWingMLKEM768X25519_SHA256_AES_GCM_256let privateKey = try XWingMLKEM768X25519.PrivateKey.generate()let publicKey = privateKey.publicKey 立即行动量子安全升级刻不容缓，建议： 确保网络数据使用量子安全TLS 升级服务器配置 自定义协议改用CryptoKit量子安全API 优先采用Post-quantum HPKE 相关文档 Apple CryptoKit PQ3消息协议：大规模量子安全通信的新标杆 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 EnergyKit 优化家庭用电量","date":"2025-06-10T07:48:03.000Z","path":"2025/06/10/2025-06-10-wwdc2025_257/","text":"了解如何在你的 app 中支持 energykit，以便用户可以优化家庭用电量。这可以帮助用户在电力更清洁、更便宜的时段运行电器或为电动汽车充电。详细了解如何进行设置，如何生成充电计划，以及如何通过用电量反馈向用户提供能耗洞察信息等详情。 视频地址 使用 EnergyKit 优化家庭用电量简介EnergyKit 是一个全新的开发框架，旨在帮助住宅类应用开发者整合电网洞察功能，让用户能够在电力更清洁、更便宜的时段运行电器或为电动汽车充电。通过本文，你将了解如何设置 EnergyKit、生成充电计划，以及如何利用用电量反馈为用户提供有价值的能耗洞察。 启用 EnergyKit要使用 EnergyKit，用户需要先选择加入清洁能源充电计划，并为每个充电位置进行设置。在我们的示例中，充电位置列表代表电动汽车的不同充电地点。 关键步骤 添加开关选项让用户可以启用清洁能源充电 EnergyVenue 代表设备从电网取电的物理场所 用户需要通过家庭应用或 EnergyKit 启用流程建立”家” 保存场所与充电位置的映射关系 1234567891011121314// Retrieve an EnergyVenueimport EnergyKitimport Foundation@Observable final class EnergyVenueManager &#123; let venue: EnergyVenue init?(venueID: UUID) async &#123; guard let energyVenue = await EnergyVenue.venue(for: venueID) else &#123; return nil &#125; venue = energyVenue &#125;&#125; 生成充电计划确认用户启用清洁能源充电并选择 EnergyVenue 后，下一步是生成清洁能源充电计划。 用电指导类型 减少：适用于智能恒温器等可降低用电量的设备 转移：适用于电动汽车等可以调整用电时段但总用电量不变的设备 123456789101112131415161718192021// Fetch ElectricityGuidanceimport EnergyKitimport Foundation@Observable final class EnergyVenueManager &#123; var guidance: ElectricityGuidance? fileprivate func streamGuidance( venueID: UUID, update: (_ guidance: ElectricityGuidance) -&gt; Void ) async throws &#123; let query = ElectricityGuidance.Query(suggestedAction: .shift) for try await currentGuidance in ElectricityGuidance.sharedService.guidance( using: query, at: venueID ) &#123; update(currentGuidance) break &#125; &#125;&#125; 洞察分析EnergyKit 提供易用的用电信息格式，帮助开发者向用户展示： 车辆充电时段中使用清洁电力的比例 基于电价时段的用电分类（五类） 提交 LoadEvents 反馈应在充电过程中定期创建事件： 充电开始时记录初始状态 充电期间每15分钟记录稳态充电 遇到特殊事件时额外记录 充电结束时提交最终状态 12345678910111213141516171819202122// Update charging measurementsimport EnergyKit@Observable class ElectricVehicleController &#123; fileprivate func chargingMeasurement() -&gt; ElectricVehicleLoadEvent.ElectricalMeasurement &#123; let stateOfCharge = Int(configuration.state.stateOfCharge.rounded(.down)) let power = Measurement&lt;UnitPower&gt;( value: configuration.properties.chargingPower * 1000000, unit: .milliwatts ) let energy = Measurement&lt;UnitEnergy&gt;( value: configuration.state.cummulativeEnergy * 1000000, unit: .EnergyKit.milliwattHours ) return ElectricVehicleLoadEvent.ElectricalMeasurement( stateOfCharge: stateOfCharge, direction: .imported, power: power, energy: energy ) &#125;&#125; 结论通过 EnergyKit，开发者可以轻松为应用添加智能用电功能，帮助用户节省开支并减少碳排放。我们介绍了核心功能包括场所设置、充电计划生成和用电洞察分析。现在就开始使用 EnergyKit，为用户创造更智能、更环保的应用体验吧！ 相关视频 完成后台任务 探索 SwiftUI 中的并发机制 文档 Apple 2030 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"分析并优化 App 的功耗","date":"2025-06-10T07:47:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_226/","text":"了解如何优化你的 app，以充分延长电池续航时间。探索如何查明 app 功耗问题的根本原因，无论是在连接到 xcode 时还是出行期间遇到这类问题，都可以查明。了解如何测量功耗，以便你可以就新功能做出更明智的决策，并主动构建更高效的 app。 视频地址 应用功耗分析与优化指南：让你的应用更省电引言开发高性能且节能的应用是每位开发者的追求。用户期望全天候可靠的应用体验，而优秀的电池续航能力是关键。本指南将带你了解如何分析应用功耗问题，优化代码实现，最终构建出高效节能的优质应用。 调试可复现的功耗问题使用Power Profiler工具当在Xcode中观察到高能耗警告时，Instruments中的Power Profiler是理想的诊断工具。它能： 记录应用运行的功耗轨迹 可视化分析功耗数据 识别问题子系统 案例演示：在Destination Video应用中，Library面板打开时出现卡顿。通过Power Profiler发现： 系统功耗平均值达10.5%/小时 CPU功耗峰值从1飙升至21 Time Profiler定位到VideoCardView消耗过多CPU时间 问题根源与解决方案分析发现LibraryThumbnailView使用VStack一次性加载所有视频缩略图，导致不必要的资源消耗。 优化方案：12345678910111213// 替换前：VStack &#123; ForEach(videos) &#123; video in VideoCardView(video: video) &#125;&#125;// 优化后：LazyVStack &#123; ForEach(videos) &#123; video in VideoCardView(video: video) &#125;&#125;优化后CPU功耗平均值从21降至4.3，性能显著提升。 发现并解决隐藏的功耗问题设备端功耗分析对于难以在开发环境复现的问题，可以使用设备端Power Profiler： 开启开发者模式 在Performance Trace中启用Power Profiler 从控制中心开始/停止录制 分享轨迹文件分析 真实案例：用户反馈Destination Video耗电严重，分析轨迹发现： CPU呈现周期性高低变化 videoSuggestionsForLocation函数频繁执行 每次位置变化都重新解析JSON规则文件 优化方案：采用懒加载和缓存机制，避免重复文件I/O和JSON解析。 功耗比较与主动优化方案对比测试开发新功能时，可以使用Power Profiler： 对每个实现方案分别测试 多次测试取平均值 综合评估对电池寿命的影响 主动优化策略 开发阶段： 使用Xcode能源仪表盘 Instruments深入分析 XCTest自动化测试 发布后： Xcode Organizer监控 MetricKit收集数据 App Store Connect API分析 结论通过合理使用Power Profiler等工具，开发者可以： 精准定位功耗问题 验证优化效果 构建高效节能的应用 现在就尝试采集你的应用功耗数据，开启优化之旅吧！ 相关视频 通过 Instruments 优化 CPU 性能 文档 使用 Power Profiler 测量应用功耗 性能与指标 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"在你的 App 中提供适龄体验","date":"2025-06-10T07:47:41.000Z","path":"2025/06/10/2025-06-10-wwdc2025_299/","text":"了解如何使用全新的 declared age range api 在你的 app 中提供适龄体验。我们将介绍家长如何允许孩子与 app 共享年龄范围，以确保在保护隐私的情况下提供安全体验。我们还将探索此框架如何帮助你根据用户的年龄来定制你的 app 内容和功能，并展示如何实施年龄限制、理解缓存机制并尊重用户隐私，同时营造更安全、更有趣的体验。 视频地址 如何在应用中为不同年龄用户提供个性化体验引言随着数字产品使用越来越低龄化，如何为不同年龄段的用户提供安全且合适的应用体验变得尤为重要。苹果最新推出的「声明年龄范围API」为开发者提供了一套完整的解决方案，既能保护儿童隐私，又能实现精准的适龄内容展示。本文将详细介绍这一框架的工作原理和实现方法。 为什么需要适龄体验儿童上网安全的重要性苹果始终将用户隐私和安全放在首位，特别是对儿童用户的保护。2025年发布的《保护儿童上网安全》白皮书强调了数字环境中保护儿童的必要性。不同年龄段的孩子面临不同的网络风险，需要针对性的保护措施。 苹果的改进措施 简化的儿童账户设置流程 家长可随时修正孩子账户的年龄信息 App Store采用更细化的全球年龄评级体系（4+、9+、13+、16+、18+） 推出全新的「声明年龄范围API」 声明年龄范围框架详解工作原理该框架让应用可以请求用户的年龄范围，而不是具体生日。系统会根据用户年龄返回一个年龄区间（如13-15岁），应用据此调整内容和功能。 主要特点 隐私保护：只提供必要的年龄区间信息 灵活设置：家长有三种管理选项： 始终共享 每次询问 永不共享 智能缓存：系统会缓存年龄信息，每年用户生日时自动更新 年龄区间设置开发者最多可以设置3个年龄阈值，系统会自动生成4个区间： 12岁及以下 13-15岁 16-17岁 18岁及以上 每个区间跨度至少两年，确保隐私保护。 实现步骤1. 添加框架能力在Xcode项目的「Signing and Capabilities」选项卡中添加Declared Age Range能力。 2. 代码实现import SwiftUI import DeclaredAgeRange struct ContentView: View &#123; @State var featureEnabled = false @Environment(\\.requestAgeRange) var requestAgeRange func checkAge() async &#123; do &#123; let response = try await requestAgeRange(ageGates: 16) switch response &#123; case let .sharing(range): if let lowerBound = range.lowerBound, lowerBound &gt;= 16 &#123; featureEnabled = true &#125; case .declinedSharing: print(\"用户拒绝共享年龄信息\") &#125; &#125; catch &#123; print(\"请求出错：\", error) &#125; &#125; &#125; 3. 检查家长控制还可以检查家长是否启用了通信限制： if range.activeParentalControls.contains(.communicationLimits) &#123; // 处理通信受限的情况 &#125; 其他儿童安全功能 敏感内容分析API：自动检测不适当内容 屏幕时间框架：帮助家长管理使用时间 家庭控制：全面的家长控制工具 结论通过「声明年龄范围API」，开发者可以轻松构建尊重隐私的适龄体验。建议所有面向儿童或青少年的应用都应考虑集成这一功能。 相关视频 使用 PermissionKit 增强儿童安全保护 文档 DeclaredAgeRange官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"系统服务","slug":"系统服务","permalink":"http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"针对 visionOS 设计小组件","date":"2025-06-10T07:46:41.000Z","path":"2025/06/10/2025-06-10-wwdc2025_255/","text":"了解如何为 visionos 26 设计美观的小组件，确保完美融入用户周围的环境。了解如何在小组件设计中添加深度，并为空间计算自定材质、尺寸和风格。我们将介绍如何针对 visionos 调整你现有的小组件，或设计出类似真实物体的全新小组件。 视频地址 为 visionOS 设计空间感知小组件：四大核心原则解析引言在 visionOS 的沉浸式环境中，小组件已从二维界面元素进化为三维空间对象。本文将深入解析 visionOS 小组件设计的四大核心原则——持久性、固定尺寸、个性化定制和距离感知，帮助开发者创建与环境完美融合的数字体验。 持久性：成为空间的一部分visionOS 小组件的标志性特征是其跨会话的持久存在能力。用户添加的小组件会： 固定在指定位置（桌面/墙面） 支持多实例同时显示（自动网格对齐） 保持虚拟与现实的层级关系（始终显示在虚拟内容后方） 设计要点： 桌面放置时呈现5°倾斜提升可读性 墙面放置时采用画框式平贴设计 强制边框设计强化环境关联性 固定尺寸：真实世界的比例感visionOS 提供物理空间映射的尺寸模板体系： 使用场景 典型尺寸 缩放范围 桌面效率工具 Small (10x10cm) 75%-125% 墙面艺术展示 Extra Large (60x60cm) 需高分辨率资源 深度个性化设计visionOS 提供双层美学系统： 材质选择 纸张风格：模拟实体印刷品质感 玻璃风格：通过分层创造视觉深度 配色方案 14种系统预设配色（7亮/7暗） 支持内容主题色衍生（如音乐专辑封面取色） 悬挂样式 凸起式：画框突出效果 凹入式：窗景深度效果（仅垂直面） 智能距离感知视觉响应系统包含两个设计阈值： 默认视图（&lt;2米） 显示完整内容和交互元素 文本最小字号24pt保证可读性 简化视图（≥2米） 保留核心视觉元素 自动调整布局密度 交互热区保持44x44pt最小尺寸 迁移与原生开发策略现有小组件迁移： 启用兼容模式自动获得3D呈现 保持原有功能同时增加空间布置能力 原生visionOS小组件： 利用平台专属尺寸模板 深度整合材质系统 实现完全的距离响应式设计 结语visionOS 为小组件设计开启了空间计算的新纪元。通过把握持久存在、真实比例、深度个性化和智能响应这四大原则，开发者可以创造出既实用又与环境和谐共生的数字对象。建议从您现有的iPad小组件开始尝试迁移，逐步探索原生visionOS小组件的独特可能性。 文档为 visionOS 更新小组件 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"空间网页的新功能","date":"2025-06-10T07:46:33.000Z","path":"2025/06/10/2025-06-10-wwdc2025_237/","text":"了解 visionos 26 上适用于网页的最新空间功能。我们将介绍如何使用全新的 html 模型元素来显示内联 3d 模型。我们还将分享模型照明、交互和动画等强大功能。了解如何在你的网站上嵌入新支持的沉浸式媒体，例如 360 度视频和 apple 沉浸视频。另外，你还将抢先体验如何在网页中添加自定环境。 视频地址 探索 visionOS 26：网页端空间计算新特性全面解析引言随着 visionOS 26 的发布，网页开发迎来了空间计算的新纪元。苹果为 Safari 浏览器带来了一系列突破性的功能，包括 3D 模型嵌入、沉浸式媒体支持以及自定义环境体验。本文将深入解析这些激动人心的新特性，帮助开发者打造下一代空间网页体验。 嵌入 3D 模型：HTML模型元素的革命基础语法与优势全新的 &lt;model&gt; 元素让网页3D内容变得前所未有的简单：123456789101112131415161718192021222324252627282930313233&lt;model src=&quot;teapot.usdz&quot;&gt;&lt;/model&gt;``` 与传统3D渲染库相比，该元素原生支持立体渲染，用户能自然感知深度并环绕观察模型。### 资产准备与优化 支持USDZ格式的多种获取方式： - 实景捕捉（iPhone Reality Composer） - 格式转换（macOS预览工具） - 专业建模软件导出 优化建议： - 使用macOS预览工具压缩纹理 - 服务器需配置正确MIME类型 - 大型文件(&gt;10MB)应添加加载指示器 ### 进阶功能详解 **光照控制**：```html&lt;model src=&quot;camera.usdz&quot; environmentmap=&quot;sunset.exr&quot;&gt;&lt;/model&gt;``` 支持OpenEXR/HDR环境贴图，实现更真实的反射效果。**交互与动画**： - 内置拖拽分享功能 - 通过JavaScript精确控制模型位姿 - 类似视频API的动画控制 **动态生成示例**：```javascriptconst bytes = await new USDZExporter().parseAsync(scene);mymodel.src = URL.createObjectURL(new Blob([bytes])); 沉浸式媒体体验升级visionOS新增支持： iPhone 15 Pro拍摄的空间视频 180°/360°/广角视频 Apple沉浸视频 标准嵌入方式： &lt;video src=\"360_video.m3u8\" controls&gt;&lt;/video&gt; 全屏播放时自动切换沉浸模式，全景图支持新增controls属性。 自定义环境体验（开发者预览）通过简单标记指定虚拟环境： &lt;link rel=\"spatial-backdrop\" href=\"office.usdz\" environmentmap=\"lighting.hdr\"&gt; 用户可调节沉浸程度，需在Safari设置中启用功能标志。 结语visionOS 26为网页开发者打开了空间计算的大门。从3D模型到沉浸式媒体，再到自定义环境，这些新特性将彻底改变用户的网页浏览体验。建议开发者立即开始尝试这些功能，为即将到来的空间互联网时代做好准备。 相关视频 了解 Apple Projected Media Profile 探索 visionOS 的视频体验 支持 visionOS App 播放沉浸视频 Safari 浏览器和 WebKit 的新功能 为你的沉浸式 visionOS App 创建自定环境 探索 USD 生态系统 认识 Reality Composer Pro 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"了解 Apple Projected Media Profile","date":"2025-06-10T07:46:30.000Z","path":"2025/06/10/2025-06-10-wwdc2025_297/","text":"深入了解 apple projected media profile (apmp)，并探索 apmp 如何通过视频扩展使用信号技术在 quicktime 和 mp4 文件中实现 180º/360º 和宽视角投影。我们将针对如何使用 os 提供的框架和工具对包含 apmp 的媒体进行转换、读/写、编辑和编码提供相关指导。我们还将介绍 apple positional 音频编解码器 (apac) 的功能，这些功能可用于创建和交付空间音频内容，从而打造出极具沉浸感的体验。 视频地址 全面解析 Apple 投影媒体配置文件（APMP）技术引言随着沉浸式媒体技术的快速发展，Apple 推出的投影媒体配置文件（APMP）为开发者提供了处理 180º/360º 视频及宽视角投影的全新解决方案。本文将深入探讨 APMP 的核心技术原理、工作流程以及配套的 Apple 方位音频编解码器（APAC），帮助开发者充分利用苹果生态系统的强大能力。 APMP 技术基础投影类型解析APMP 支持多种非矩形视频投影类型： 矩形投影：传统 2D/3D 视频和空间视频使用的标准投影 半等距柱面投影：专为 180 度视频设计 等距柱面投影：360 度全景视频的标准格式 参数化沉浸投影：针对广角/鱼眼镜头优化，包含镜头畸变参数 等距柱面投影（Equirectangular Projection）通过将球面坐标转换为经纬度角度，均匀映射到矩形视频帧。水平轴代表经度（-180 至 +180 度），垂直轴代表纬度（-90 至 +90 度）。 技术实现细节APMP 通过 QuickTime/MP4 文件结构实现信号传递，利用： Video Extended Usage（vexu）扩展盒：包含投影类型信息 镜头参数集合：描述广角镜头的特性 视场包装信息：处理立体视频内容 开发工作流详解内容采集与处理支持 APMP 的主流设备包括： 佳能 EOS VR 系统（立体 180 视频） GoPro MAX/Insta360 X5（360 视频） 新款运动相机（广角视频） 推荐工作流： 使用 HEVC/RAW/ProRes 编解码器采集原始素材 以 ProRes 格式进行编辑处理 最终通过 MV-HEVC 编解码器发布成品 格式转换工具对于不支持 APMP 的相机素材，开发者可以使用： avconvert 命令行工具转换球形元数据 ImmersiveMediaSupport 框架的 ParametricImmersiveAssetInfo 自动生成视频格式描述 123// 示例：检查投影类型let playbackAssistant = AVAssetPlaybackAssistant(asset: asset)let projectionType = playbackAssistant.projectionType 视频处理技术栈核心框架支持苹果生态系统提供了全面的 APMP 支持： CoreMedia：底层媒体处理 AVFoundation：高级媒体操作接口 Video Toolbox：硬件加速编解码 立体视频编辑处理立体视频时的关键步骤： 使用 AVVideoComposition 创建视频合成 通过 CMTaggedDynamicBuffer 处理左右眼缓冲器 提交标记缓冲器时指定正确的 buffer 描述 发布规范与优化视频编码建议针对 visionOS 的优化参数： 编码格式：HEVC Main/Main 10 分辨率： 单视场：7680x3840（10bit） 立体：4320x4320/每眼 帧率：推荐 30fps（8K 单视场或 4K 立体） 峰值码率：不超过 150Mbps 质量评估工具利用高级视频质量工具（AVQT）进行沉浸格式评估，确保最终输出质量符合标准。 Apple 方位音频编解码器（APAC）APAC 为沉浸式体验提供关键音频支持： 支持 1-3 阶 Ambisonic 编码（4-16 通道） 不依赖特定扬声器布局 推荐码率： 1 阶：384kbps 3 阶：768kbps 通过 AVAssetWriter 可直接输出 APAC 编码音频，与 APMP 视频完美同步。 结论APMP 和 APAC 技术共同构成了苹果生态系统的沉浸式媒体解决方案，为开发者提供了从采集到发布的完整工具链。无论是相机厂商、视频编辑软件开发者，还是希望尝试新型媒体格式的应用开发者，都可以充分利用这些技术创造引人入胜的沉浸式体验。 相关视频了解 Apple 沉浸视频技术探索 visionOS 的视频体验支持 visionOS App 播放沉浸视频空间网页的新功能AVQT 的新功能使用高级视频质量工具评估视频 文档Apple HEVC 立体视频互操作性配置文件AVFoundationCore MediaHTTP 直播流Apple 设备的 HLS 创作规范QuickTime 和 ISO 基础媒体文件格式及空间沉浸媒体使用 Apple 的 HLS 工具 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"借助 MLX 在 Apple 芯片上探索大语言模型","date":"2025-06-10T07:45:43.000Z","path":"2025/06/10/2025-06-10-wwdc2025_298/","text":"了解 mlx lm，这款工具专为在 apple 芯片上轻松高效地处理大语言模型而设计。我们将介绍如何在 mac 上微调先进的大语言模型并以此运行推理，以及如何将这些模型无缝整合到基于 swift 的应用程序和项目中。 视频地址 利用 MLX 在 Apple 芯片上高效运行大语言模型引言随着大语言模型(LLM)的快速发展，如何在本地设备上高效运行这些模型成为开发者关注的重点。Apple 芯片凭借其强大的性能和统一内存架构，为本地部署大语言模型提供了理想平台。本文将介绍专为 Apple 芯片优化的 MLX 框架及其 MLX LM 工具集，帮助开发者轻松实现大语言模型在 Mac 设备上的推理和微调。 MLX 框架概述MLX 是一个专为 Apple 芯片机器学习打造的开源库，具有以下核心特性： Metal 加速：充分利用 Apple 芯片的 GPU 性能 统一内存架构：CPU 和 GPU 可以直接访问相同数据，无需数据拷贝 多语言支持：提供 Python、Swift、C++ 和 C 等多种 API 高效推理：支持数百亿参数模型的流畅交互 安装 MLX LM使用 pip 即可轻松安装 MLX LM 工具集： 1pip install mlx-lm 文本生成实践命令行方式最简单的文本生成方式是通过命令行： 12mlx_lm.generate --model &quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot; \\ --prompt &quot;用 Swift 实现快速排序&quot; Python API更灵活的生成方式是通过 Python API： 12345from mlx_lm import load, generatemodel, tokenizer = load(&quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot;)prompt = tokenizer.apply_chat_template([&#123;&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:&quot;Swift快速排序&quot;&#125;], True)text = generate(model, tokenizer, prompt=prompt, verbose=True) 模型量化技术量化是减小模型体积、提升推理速度的有效方法： 123mlx_lm.convert --hf-path &quot;mistralai/Mistral-7B-Instruct-v0.3&quot; \\ --mlx-path &quot;./mistral-7b-v0.3-4bit&quot; \\ --quantize --q-bits 4 --q-group-size 64 还可以实现混合精度量化： 12345def mixed_quantization(layer_path, layer, model_config): if &quot;lm_head&quot; in layer_path: return &#123;&quot;bits&quot;:6, &quot;group_size&quot;:64&#125; return &#123;&quot;bits&quot;:4, &quot;group_size&quot;:64&#125; if hasattr(layer,&quot;to_quantized&quot;) else Falseconvert(hf_path=&quot;mistralai/Mistral-7B-v0.3&quot;, quant_predicate=mixed_quantization) 模型微调方法MLX LM 支持两种微调模式： 全参数微调（资源需求较高） 低秩适配器(LoRA)训练（仅训练新增参数） LoRA 训练示例12mlx_lm.lora --model &quot;mlx-community/Mistral-7B-Instruct-v0.3-4bit&quot; \\ --train --data ./data --iters 300 适配器融合训练完成后可以将适配器融合回原模型： 123mlx_lm.fuse --model &quot;./mistral-7b-v0.3-4bit&quot; \\ --adapter_path &quot;adapters&quot; \\ --save_path &quot;fused-mistral-7b&quot; Swift 集成MLX 提供了简洁的 Swift API，28 行代码即可实现完整推理流程： 123456789import MLXLLMlet model = try await LLMModelFactory.shared.loadContainer(configuration: .init(id:&quot;mlx-community/Mistral-7B-4bit&quot;))try await model.perform &#123; context in let input = try await context.processor.prepare(input: .init(prompt:&quot;Swift快速排序&quot;)) for await part in generate(input: input, context: context) &#123; print(part.chunk ?? &quot;&quot;, terminator:&quot;&quot;) &#125;&#125; 添加 KV 缓存支持仅需额外一行： 12let cache = context.model.newCache(parameters: .init())let tokenIter = try TokenIterator(input: input, model: context.model, cache: cache) 结论MLX 框架为 Apple 芯片上的大语言模型应用提供了完整的解决方案，从模型加载、量化、微调到 Swift 应用集成，覆盖了开发全流程。借助 MLX 的高效实现，开发者可以在 Mac 设备上运行数十亿参数的大模型，为本地 AI 应用开发开辟了新的可能性。 相关视频开始使用适用于 Apple 芯片的 MLX 文档资源MLXMLX LM - Python APIMLX Explore - Python APIMLX FrameworkMLX Llama InferenceMLX Swift 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"为 visionOS 设计悬停交互","date":"2025-06-10T07:45:30.000Z","path":"2025/06/10/2025-06-10-wwdc2025_303/","text":"了解如何为你的 visionos app 创建高级交互。我们将探索如何设计引人入胜的自定悬停效果和动画，如何避免常见错误，如何充分利用 look to scroll 等交互方式，以及如何使用持久化效果来构建直观的媒体控制项。 视频地址 为 visionOS 设计自然流畅的悬停交互体验引言在 visionOS 平台中，悬停交互通过人眼注视实现了一种近乎意念控制的全新用户体验。作为设计师与开发者，理解如何设计出色的悬停交互至关重要。本文将深入探讨 visionOS 悬停交互的设计原理、实现方法及最佳实践。 基础设计原则visionOS 的交互基于眼动追踪和手势配合，遵循以下核心原则： 界面布局：将核心内容置于用户正前方，便于查看和操作 形状优化：优先采用圆形、胶囊形或圆角矩形等柔和形状，更容易吸引视线聚焦 尺寸规范：确保交互元素保留至少60点空间（约2.5度视角） 视觉反馈：所有交互元素都应应用高光效果，自定义组件需手动添加匹配形状的高光 自定义悬停效果设计visionOS 允许开发者创建三种类型的自定义悬停动画： 即时动画：注视瞬间触发，适合显示情境化信息 延迟动画：短时延迟后显示，平衡响应速度与稳定性 渐进动画：结合缓入和弹性效果，提供流畅的过渡体验 设计最佳实践： 保留视觉锚点维持上下文 确保效果源自可见元素 保持效果精炼微妙 避免意外动效干扰用户 必须进行实机测试验证 注视滚动功能注视滚动让用户仅用视线即可控制内容滚动，特别适合： 阅读浏览类视图 应用主内容区 保持一致性体验的场景 实现注意事项： 确保滚动视图边界清晰 维持标准滚动速率 避免在设置类列表中使用 持久化控件设计智能的控件显示逻辑可显著提升体验： 标准视频播放器自动支持注视保持功能 自定义控件需手动实现持久化行为 适用于各种具有延时隐藏功能的界面 总结visionOS 的悬停交互为应用带来了全新的可能性。通过： 精心设计的自定义悬停效果 自然流畅的注视滚动功能 智能的持久化控件行为 开发者可以创建更加自然、直观的沉浸式体验。建议开发者大胆尝试不同方案，并通过实机测试不断优化交互细节。 相关资源 2023年”空间输入设计”专题演讲 2024年相关专题演讲(实现技巧) visionOS开发文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"空间计算","slug":"空间计算","permalink":"http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"}]},{"title":"利用拍摄控件提升你的相机体验","date":"2025-06-10T07:45:28.000Z","path":"2025/06/10/2025-06-10-wwdc2025_253/","text":"了解如何为你的相机体验自定拍摄控件。我们将向你展示如何使用各种实体拍摄控件 (包括新增的 airpods 支持) 拍摄照片，以及如何使用相机控制来调整设置。 视频地址 通过拍摄控件优化相机交互体验前言在现代移动应用中，相机功能的交互体验至关重要。本次我们将深入探讨如何利用物理拍摄控件和AirPods远程控制来提升应用的相机体验，让用户获得与原生iOS相机一致的便捷操作。 核心概念解析物理拍摄控件基础这个API允许开发者将音量键、操作键等物理按键映射为相机操作： 音量增键：次要操作（如拍照） 音量减键/操作键：主要操作（如视频录制） 支持单击和长按两种触发方式 事件处理机制每次按键操作会触发三个阶段的事件通知： began：按键按下瞬间 cancelled：操作中断时 ended：按键释放时（实际触发操作的最佳时机） 实现步骤详解基础SwiftUI相机应用首先构建简单相机界面： 12345678struct PhotoCapture: View &#123; var body: some View &#123; VStack &#123; CameraPreviewView() Button(&quot;拍摄照片&quot;) &#123; /* 拍摄逻辑 */ &#125; &#125; &#125;&#125; 添加物理按键支持通过.onCameraCaptureEvent修饰符快速集成： 12345.onCameraCaptureEvent &#123; event in if event.phase == .ended &#123; cameraModel.capturePhoto() &#125;&#125; iOS 16新特性AirPods远程控制配备H2芯片的AirPods现在支持： 通过耳柄点击触发拍摄 自动兼容现有物理按键API 可自定义音频反馈（如关闭默认提示音或使用相机快门声） 音频反馈控制1event.play(.cameraShutter) // 播放自定义快门声 iPhone相机控制功能三大核心功能 快速启动：点击直接进入相机应用 硬件快门：与物理按键相同的拍摄体验 设置调整：通过滑动/点击快速修改参数 控制类型对比 类型 适用场景 示例 连续滑块 无级调整 变焦控制 离散滑块 固定步长 曝光补偿 选择器 模式切换 闪光灯设置 最佳实践建议 必处理所有事件：覆盖物理按键后必须完整处理事件链 音频反馈：远程操作时提供声音提示 控件数量：注意系统对最大控件数的限制 后台处理：应用进入后台时会自动取消事件 总结通过本文介绍的技术，您可以为应用添加： 物理按键拍摄支持 AirPods远程控制 专业的相机参数调整控件 这些功能将显著提升用户的操作体验，特别适合需要快速抓拍或专业拍摄的场景。 相关视频 打造出色的锁定屏幕相机拍摄体验 在 iPadOS App 中支持外部摄像头 探索 tvOS 连续互通相机 文档资源 AVFoundation框架文档 相机控制人机交互指南 锁定屏幕相机扩展开发指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"使用基于机器学习的视频效果增强你的 App","date":"2025-06-10T07:44:57.000Z","path":"2025/06/10/2025-06-10-wwdc2025_300/","text":"了解如何添加帧率转换、超高分辨率和噪声过滤等效果来改善视频编辑与直播体验。我们将探索 video toolbox 框架中专为 apple 芯片优化的基于 ml 的视频处理算法。了解如何将这些效果整合起来，以增强 app 在真实用例中的功能。 视频地址 使用机器学习增强视频效果：Video Toolbox VTFrameProcessor 全解析简介Video Toolbox作为Apple平台的核心视频处理框架，在macOS 15.4和iOS 26中迎来了重大升级——VTFrameProcessor API。这个基于机器学习的新接口专为Apple Silicon优化，为开发者带来了帧率转换、超分辨率等专业级视频效果处理能力。本文将详细介绍这些效果的技术实现和应用场景。 六大视频增强效果详解1. 帧率转换 应用场景：体育赛事慢动作、电影特效 技术特点：通过智能插帧实现流畅的帧率转换 示例效果：足球运动员庆祝动作被完美放慢，细节更丰富 2. 超分辨率缩放 应用场景：老旧视频修复、照片增强 技术亮点：显著提升视频分辨率，还原丢失细节 效果对比：处理后视频中的船只纹理更清晰可见 3. 动态模糊 影视级效果：模拟专业摄影中的运动模糊 参数可控：模糊强度可灵活调整 实用案例：骑行视频经处理后运动更自然流畅 4. 时域降噪 智能去噪：基于运动估计消除压缩伪影 效果展示：树木视频中的色噪被有效去除 5. 低延迟帧插值 实时处理：提升视频流畅度的同时保持低延迟 会议优化：改善网络不佳时的视频通话体验 6. 低延迟超分辨率 轻量化设计：专为实时视频优化 边缘增强：锐化面部特征等关键细节 技术集成指南基础集成步骤 导入Video Toolbox框架 创建处理会话（VTFrameProcessor） 配置效果参数 逐帧处理视频数据 帧率转换代码示例1234567891011// 配置帧率转换参数let processor = VTFrameProcessor()guard let configuration = VTFrameRateConversionConfiguration( frameWidth: width, frameHeight: height, usePrecomputedFlow: false, qualityPrioritization: .normal, revision: .revision1) else &#123; throw Fault.failedToCreateFRCConfiguration &#125;try processor.startSession(configuration: configuration) 动态模糊实现12345678910111213// 动态模糊参数设置guard let parameters = VTMotionBlurParameters( sourceFrame: currentFrame, nextFrame: nextFrame, previousFrame: previousFrame, nextOpticalFlow: nil, previousOpticalFlow: nil, motionBlurStrength: strength, submissionMode: .sequential, destinationFrame: destinationFrame) else &#123; throw Fault.failedToCreateMotionBlurParameters &#125;try await processor.process(parameters: parameters) 实际应用案例视频编辑场景 慢动作特效：突出舞蹈动作细节 电影感处理：为延时视频添加动态模糊 实时视频优化 视频会议：超分辨率提升画质 直播推流：帧插值改善卡顿问题 总结与展望VTFrameProcessor API的推出，让开发者能够轻松为应用添加专业级视频效果。无论是提升视频编辑品质，还是优化实时视频体验，这些基于机器学习的技术都将为用户带来显著改进。期待看到开发者们利用这些工具创造出更出色的视频应用！ 相关文档 Frame processing Video Toolbox 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"照片和相机","slug":"照片和相机","permalink":"http://djs66256.github.io/tags/%E7%85%A7%E7%89%87%E5%92%8C%E7%9B%B8%E6%9C%BA/"}]},{"title":"深入了解 Foundation Models 框架","date":"2025-06-10T07:44:51.000Z","path":"2025/06/10/2025-06-10-wwdc2025_301/","text":"使用 foundation models 框架提升性能。深入了解引导式生成的工作方式，并使用指南、正则表达式和生成方案来获取自定的结构化响应。我们将向你展示如何使用工具调用让模型自动访问外部信息并执行操作，从而实现个性化体验。 为了充分从这个视频中获益，建议你先观看“了解 foundation models 框架”。 视频地址 掌握 Foundation Models 框架：从文本生成到工具调用引言Foundation Models 框架为开发者提供了在 Apple 生态系统中集成大型语言模型(LLM)的强大工具。通过设备端运行和简洁的 Swift API，该框架支持 macOS、iPadOS、iOS 和 visionOS 平台，无需复杂配置即可直接使用。本文将深入解析框架的核心功能，包括会话机制、结构化输出生成以及工具调用等关键技术。 会话机制详解会话是 Foundation Models 框架的基础交互方式，特别适合构建对话式应用场景： 1234567891011import FoundationModelsfunc respond(userInput: String) async throws -&gt; String &#123; let session = LanguageModelSession(instructions: &quot;&quot;&quot; 你是一个像素世界里的友善咖啡师。 请回答玩家的问题。 &quot;&quot;&quot; ) let response = try await session.respond(to: userInput) return response.content&#125; 关键技术解析 Token处理机制：模型将输入转换为token序列处理，每个token都会增加处理延迟 状态保持：会话自动记录所有交互历史，但需注意上下文窗口限制 采样控制：提供多种响应生成模式，从确定性输出到高创造性输出 结构化数据生成：Generable 技术Generable 宏解决了从LLM获取结构化数据的难题： 12345678910111213@Generablestruct NPC &#123; let name: String let coffeeOrder: String&#125;func makeNPC() async throws -&gt; NPC &#123; let session = LanguageModelSession(instructions: ...) let response = try await session.respond(generating: NPC.self) &#123; &quot;生成一个点咖啡的角色。&quot; &#125; return response.content&#125; 高级功能 枚举支持：处理复杂场景分支 Guide约束：精确控制输出范围、格式和质量 正则表达式：确保字符串字段符合特定模式 动态模式：运行时定义的Schema对于需要动态结构的场景，可以使用GenerationSchema： 123456789let schema = try GenerationSchema( root: riddleDynamicSchema, dependencies: [answerDynamicSchema])let response = try await session.respond( to: &quot;生成一个关于咖啡的有趣谜题&quot;, schema: schema) 工具调用：扩展模型能力通过Tool协议，模型可以执行自定义操作： 123456789101112131415161718192021struct FindContactTool: Tool &#123; let name = &quot;findContact&quot; let description = &quot;从指定年龄段查找联系人&quot; @Generable struct Arguments &#123; let generation: Generation enum Generation &#123; case babyBoomers case genX case millennial case genZ &#125; &#125; func call(arguments: Arguments) async throws -&gt; ToolOutput &#123; // 实现具体功能 return ToolOutput(contact.givenName) &#125;&#125; 工具调用流程 注册工具实例 模型自动分析需求并生成参数 执行工具函数 将结果整合到响应中 最佳实践建议 上下文管理：合理处理会话长度，避免超出限制 错误处理：准备好应对语言不支持等特殊情况 隐私保护：利用设备端处理的优势保护用户数据 相关视频了解 Foundation Models 框架探索 Apple 平台上的机器学习和 AI 框架跟着视频学编程：使用 Foundation Models 框架将设备端 AI 引入你的 App 文档资源人机界面指南：生成式AI 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"跟着视频学编程：使用 Foundation Models 框架将设备端 AI 引入你的 App","date":"2025-06-10T07:44:49.000Z","path":"2025/06/10/2025-06-10-wwdc2025_259/","text":"使用 foundation models 框架为你的 swiftui app 开发生成式 ai 功能。首先，应用这个框架的基本要素来创建一个出色的功能。然后，观看一些分步示例以了解如何使用你构建的工具来完善模型、流式传输结果，并进行进一步优化以提升性能。 视频地址 在 SwiftUI 应用中集成设备端 AI：Foundation Models 框架实践指南引言在当今移动应用开发中，集成人工智能功能已成为提升用户体验的重要方式。Apple 推出的 Foundation Models 框架为开发者提供了直接在设备端运行大型语言模型的能力，既保证了用户数据隐私，又无需增加应用体积。本文将带你从零开始，在 SwiftUI 应用中实现一个智能旅行规划功能，涵盖从基础实现到高级优化的完整流程。 核心概念：Foundation Models 框架Foundation Models 框架允许开发者调用 Apple 设备端预置的大型语言模型，具有以下显著优势： 隐私保护：所有计算在设备端完成，用户数据永不离开设备 离线运行：模型已内置在操作系统中，无需网络连接 跨平台支持：兼容 macOS、iPadOS、iOS 和 visionOS 轻量化：不会增加应用安装包体积 开发实战：打造智能旅行规划应用1. 提示词工程优化12345678// 初始简单提示let prompt = &quot;创建行程&quot;// 优化后的结构化提示let optimizedPrompt = &quot;&quot;&quot;为坐标(34.01,-116.16)附近的约书亚树国家公园创建3天行程，包含每日活动和推荐景点，格式需匹配Itinerary结构体&quot;&quot;&quot; 关键技巧： 使用 Xcode Playground 实时调试提示词 提供明确的位置信息和格式要求 通过 @Generable 标注数据结构，让模型生成结构化响应 2. 工具调用集成12345678910struct LandmarkTool: FoundationModels.Tool &#123; let name = &quot;landmark_search&quot; let description = &quot;搜索指定坐标附近的景点&quot; func call(_ input: LandmarkRequest) async throws -&gt; LandmarkResponse &#123; // 使用MapKit实现具体搜索逻辑 let landmarks = MKLocalSearch(...).start() return LandmarkResponse(results: landmarks) &#125;&#125; 实现要点： 定义符合 Tool 协议的工具类型 提供清晰的名称和自然语言描述 确保输入输出类型都标记为 @Generable 3. 流式输出实现12345678910// 改造响应处理为流式for await partialResult in try await session.respond(to: prompt) &#123; // 处理部分生成的PartiallyGenerated结构体 if let title = partialResult.title &#123; itineraryView.updateTitle(title) &#125; if let days = partialResult.days &#123; itineraryView.updateDays(days) &#125;&#125; 用户体验优化： 逐步显示生成结果，减少等待感 配合动画效果提升流畅度 优先显示关键信息（如标题） 性能调优实战1. 预加载策略12345678// 用户点击地标时预加载模型Button(action: &#123; Task &#123; // 提前加载模型 try await ModelLoader.shared.prepare(model: .itineraryPlanner) // 同时让用户阅读地标描述 &#125;&#125;) &#123; ... &#125; 2. 架构传输优化1234let options = GenerationOptions( includeSchemaInPrompt: false, // 禁用重复的结构描述 tools: [LandmarkTool()]) 优化效果： 输入令牌数减少40% 总响应时间缩短35% 首次请求延迟降低60% 异常处理与兼容性123456789// 检查设备支持状态switch FoundationModelsAvailability.current &#123;case .supportedAndEnabled: // 显示生成按钮case .supportedButNotEnabled: // 提示用户启用case .notSupported: // 隐藏相关功能&#125; 注意事项： 使用 Xcode 方案设置测试不同可用性场景 提供优雅降级方案 明确告知用户功能限制 结语通过 Foundation Models 框架，我们成功构建了一个隐私安全、高效智能的旅行规划应用。设备端 AI 为应用开发开辟了新的可能性，既保障了用户隐私，又提供了实时响应能力。建议开发者深入研究相关文档和视频资源，掌握更多高级功能。 相关视频 了解 Foundation Models 框架 探索 Apple 平台上的机器学习和 AI 框架 探索设备端基础模型的提示设计和安全 深入了解 Foundation Models 框架 文档 使用 Foundation Models 生成内容和执行任务 人机界面指南：生成式 AI 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"探索 App Intents 中的最新改进","date":"2025-06-10T07:43:56.000Z","path":"2025/06/10/2025-06-10-wwdc2025_275/","text":"探索今年发布的 app intents 框架新推出的所有增强功能。了解助力日常开发工作的诸多改进 (如延迟属性)、一系列新功能 (如交互式 app intents 摘要片段、实体视图注释)，以及如何整合视觉智能等。我们将一起探索让 app intents 比以往更具表现力、更加流畅易用的各项更新。我们还将介绍今年 app intents 激动人心的新增支持 (如支持“聚焦”和视觉智能)，并讲解如何编写完美适配这些场景的 app intents。 视频地址 App Intents 框架最新进展全面解析引言App Intents 框架让您的应用功能能够深度集成到系统各处，包括快捷指令、聚焦搜索和视觉智能等场景。本文将详细介绍该框架的最新改进，包括交互式片段、系统集成新特性、用户体验优化和开发便捷 API 等多项内容。 交互式片段增强片段功能现在升级为交互式体验，允许应用在运行 App Intent 时展示定制化视图。 核心特性 可视化操作结果或请求确认 支持实时更新和状态反馈 可关联任意 App Intent 操作 实现原理通过新的 SnippetIntent 协议实现，系统会： 用指定值填充片段意图参数 通过查询获取应用实体 运行 perform 方法渲染视图 代码示例12345678910struct ClosestLandmarkIntent: AppIntent &#123; func perform() async throws -&gt; some ReturnsValue&lt;LandmarkEntity&gt; &amp; ShowsSnippetIntent &amp; ProvidesDialog &#123; let landmark = await self.findClosestLandmark() return .result( value: landmark, dialog: &quot;最近的地标是\\(landmark.name)。&quot;, snippetIntent: LandmarkSnippetIntent(landmark: landmark) ) &#125;&#125; 系统集成新特性图像搜索iOS 26 新增功能允许用户通过相机拍摄或截图直接搜索应用内容。 实现要点： 创建符合 IntentValueQuery 协议的查询结构体 处理 SemanticContentDescriptor 输入 返回匹配的实体数组 屏幕实体关联通过 NSUserActivity 将视图内容与实体关联，实现智能问答功能。 用户体验优化撤销支持通过 UndoableIntent 协议轻松实现操作撤销：1234567struct DeleteCollectionIntent: UndoableIntent &#123; func perform() async throws -&gt; some IntentResult &#123; await undoManager?.registerUndo(withTarget: modelData) &#123; $0.restore(collection) &#125; &#125;&#125; 多选项 API提供替代操作选项，增强用户选择灵活性。 开发便捷 API延迟属性使用 @DeferredProperty 按需执行耗时操作：1234@DeferredPropertyvar crowdStatus: Int &#123; get async throws &#123; await modelData.getCrowdStatus(self) &#125;&#125; Swift Packages 支持现在可将 App Intents 代码放入 Swift Packages 和静态库中。 结语App Intents 框架通过这一系列新功能和改进，为开发者提供了更强大的系统集成能力和更流畅的用户体验实现方案。建议开发者尝试交互式片段、屏幕实体关联等新特性，并参考官方文档和示例项目。 相关视频 了解 App Intents 使用 App Intents 针对”快捷指令”和”聚焦”进行开发 设计交互式摘要卡片 文档 App Intents App Shortcuts Creating your first app intent 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"设计交互式摘要卡片","date":"2025-06-10T07:43:46.000Z","path":"2025/06/10/2025-06-10-wwdc2025_281/","text":"摘要卡片是一种通过 app intents 调用的简洁视图，用于显示相应 app 内的信息。现在，你可以为摘要卡片添加增强意图交互性的按钮和状态信息，以便搭配 siri、“聚焦”以及“快捷指令”app 实现更多功能。在本次讲座中，你将了解设计摘要卡片的最佳实践，包括布局、字体、交互操作和意图类型方面的指导。 视频地址 设计交互式摘要卡片：提升App Intents用户体验引言在iOS生态系统中，摘要卡片(AppIntents Snippets)作为轻量级交互界面发挥着重要作用。它们通过紧凑的视图展示关键信息，并直接集成在Siri、”聚焦”和”快捷指令”等系统功能中。本文将深入解析如何设计高效、美观且交互性强的摘要卡片。 摘要卡片的视觉设计字体与布局优化摘要卡片采用比系统默认更大的字体尺寸，确保信息在第一时间被用户注意到。关键设计原则包括： 保持340点高度限制，避免强制滚动 使用ContainerRelativeShape API实现响应式边距 维持元素间充足间距，避免视觉混乱 色彩与对比度鲜艳的背景色能帮助卡片脱颖而出，但需特别注意： 增强内容与背景的对比度 测试远距离阅读体验 平衡品牌识别与可读性 增强交互体验按钮设计策略通过添加操作按钮，摘要卡片从被动展示转变为主动工具： “添加水份”等简单动词按钮提升可操作性 成功操作后即时更新数据并伴随视觉反馈 支持多按钮组合（如音频均衡器预设） 状态实时更新卡片能动态反映应用最新状态： 数据变化时使用缩放/模糊动画 通过即时反馈建立用户信任 保持轻量化同时提供实用功能 摘要卡片类型解析结果型卡片适用于展示最终信息： 订单状态查询等完成态场景 底部仅保留”完成”按钮 无需后续用户操作 确认型卡片需要用户先执行操作： 咖啡订单等需要确认的场景 使用”下单”等明确动作动词 可自定义动词或使用预设选项 多模态体验设计语音与视觉协同 Siri语音播报补充屏幕信息 确保卡片不依赖语音也能独立理解 特别优化AirPods等纯音频场景 结语设计优秀的摘要卡片需要平衡视觉清晰度、交互效率和情境适应性。通过合理运用结果型/确认型模板、精心设计的按钮交互和实时状态反馈，开发者可以创建真正提升用户体验的系统级快捷入口。 延伸学习推荐继续了解App Intents的深度整合： 在”聚焦”和”快捷指令”中的创新应用 探索最新的App Intents功能演进 文档静态与交互式摘要卡片开发指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"开始使用适用于 Apple 芯片的 MLX","date":"2025-06-10T07:43:14.000Z","path":"2025/06/10/2025-06-10-wwdc2025_315/","text":"mlx 是一个灵活高效的阵列框架，适用于 apple 芯片上的数字计算和机器学习。我们将探索统一内存、懒性计算和函数转换等基本功能。我们还将了解一些有关使用 swift 和 python api 来构建和加速支持不同 apple 平台的机器学习模型的更高级技巧。 视频地址 在 Apple 芯片上使用 MLX 加速机器学习简介MLX 是一个专为 Apple 芯片优化的高性能阵列框架，适用于从基础数值计算到大规模机器学习模型的各类任务。本文将带您了解 MLX 的核心特性、性能优化技巧以及如何在 Swift 和 Python 中使用 MLX 来加速您的机器学习工作流程。 MLX 概览MLX 专为 Apple Silicon 设计，具有以下特点： 可在 CPU 或 GPU 加速模式下运行 核心 API 与 NumPy 高度兼容 提供完整的机器学习工具链，包括自动微分和高级库 高级 API 设计类似 PyTorch 和 JAX，易于上手 安装 MLX 非常简单，只需在终端执行：1pip3 install mlx 基础使用示例：12345import mlx.core as mxa = mx.array([1, 2, 3])b = mx.array([4, 5, 6])c = a + b 核心特性统一内存架构MLX 充分利用 Apple Silicon 的 CPU/GPU 共享内存架构：1234# GPU执行c = mx.add(a, b, stream=mx.gpu) # CPU执行d = mx.multiply(a, b, stream=mx.cpu) 惰性计算MLX 采用计算图而非立即执行的模式：123c = a + b # 构建计算图print(c) # 触发实际计算mx.eval(c) # 显式求值 函数转换支持自动微分等高级功能：12dfdx = mx.grad(mx.sin) # 求导函数d2fdx2 = mx.grad(mx.grad(mx.sin)) # 二阶导 高级神经网络包mlx.nn 提供模块化网络构建：123456789class MLP(nn.Module): def __init__(self, dim, h_dim): super().__init__() self.linear1 = nn.Linear(dim, h_dim) self.linear2 = nn.Linear(h_dim, dim) def __call__(self, x): x = nn.relu(self.linear1(x)) return self.linear2(x) 性能优化技巧函数编译使用 `@mx.compile` 装饰器优化性能：123@mx.compiledef gelu(x): return x * (1 + mx.erf(x/math.sqrt(2))) / 2 高性能算子mx.fast 提供优化实现：1mx.fast.rms_norm(x, weight) # 比原生实现快10倍 量化压缩降低精度节省资源：12quantized_w, scales, biases = mx.quantize(weight, bits=4)nn.quantize(model, bits=4) # 整模型量化 MLX SwiftSwift API 与 Python 保持一致：123let a = MLXArray([1, 2, 3])let c = a + bprint(c.shape) 结论MLX 为 Apple 芯片提供了强大的机器学习加速能力，通过统一内存、惰性计算等创新设计，结合丰富的优化工具，让开发者能够在 Mac 设备上高效运行各类机器学习任务。无论您是使用 Python 进行快速原型开发，还是通过 Swift 构建高性能应用，MLX 都能提供出色的支持。 相关视频 借助 MLX 在 Apple 芯片上探索大语言模型 文档资源 MLX 官网 MLX LM - Python API MLX 核心库 MLX 框架文档 Llama 推理示例 MLX Swift 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"使用 App Intents 针对“快捷指令”和“聚焦”进行开发","date":"2025-06-10T07:43:06.000Z","path":"2025/06/10/2025-06-10-wwdc2025_260/","text":"了解如何构建 app intents，以使操作在 mac 上的“快捷指令”和“聚焦”中可用，并能够与这两个 app 中的新功能实现完美搭配。我们将介绍你的操作如何与“快捷指令”app 中提供的新 apple 智能操作相结合并产生令人惊叹的效果。我们将深入探讨全新“使用模型”操作的工作方式，以及它如何与 app 的实体进行交互。我们还将讨论如何使用 app intents api 让你的操作在“聚焦”中可用。 视频地址 通过 App Intents 扩展应用能力：深度集成”快捷指令”与”聚焦”引言作为开发者，我们一直在寻找提升应用交互性和实用性的方法。App Intents 框架提供了一个绝佳机会，让您的应用功能能够无缝集成到 macOS 的”快捷指令”和”聚焦”中。这不仅增加了应用的曝光度，也为用户提供了更高效的使用体验。 全新”使用模型”操作解析今年”快捷指令”引入了多项革命性的智能操作，其中最引人注目的是”使用模型”操作。这个功能允许用户： 选择设备端模型进行离线处理 使用 Private Cloud Compute 处理复杂请求 接入 ChatGPT 获取广泛知识 实际应用场景示例：12345// 示例代码：模型筛选相关笔记let relevantNotes = notes.filter &#123; note in let answer = model.query(&quot;此笔记是否与&#x27;快捷指令&#x27;App功能开发相关?&quot;) return answer == &quot;是&quot;&#125; 模型输出的三种衔接方式 富文本支持：使用 AttributedString 类型保留文本格式 结构化数据：字典格式处理多段数据 应用实体：通过 JSON 表示传递实体信息 “聚焦”搜索的深度集成优化”聚焦”显示的三个关键点 确保参数摘要完整 检查 discoverability 设置 确认意图具有 perform 方法 性能优化建议： 对频繁访问的数据实现 SuggestedEntities 小型数据集使用 allEntities 通过 NSUserActivity 标记当前内容 Mac 自动化新机遇Mac 版自动化现在支持： 文件夹/外接硬盘触发 传统时间/蓝牙触发 示例应用：123456// 文件夹自动化示例folderObserver.startMonitoring &#123; newFiles in if newFiles.contains(where: &#123; $0.isInvoice &#125;) &#123; runInvoiceProcessingShortcut() &#125;&#125; 实现建议与最佳实践 实体公开： 提供高效的查找操作 暴露关键推理属性 文本处理： 全面支持 AttributedString 保留模型输出的富文本格式 聚焦优化： 提供智能建议 支持深度搜索 结语通过 App Intents 框架，您不仅能让应用功能在更多场景中可用，还能为用户创造更智能、更高效的体验。现在是时候重新审视您的应用架构，思考如何更好地与系统集成。 相关视频 为聚焦设计快捷指令 使用 App 快捷指令突出你的 App 文档 App Intents 官方文档 App Shortcuts 开发指南 Shortcuts 捐赠指南 人机界面指南：App Shortcuts 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"了解 App Intents","date":"2025-06-10T07:43:02.000Z","path":"2025/06/10/2025-06-10-wwdc2025_244/","text":"了解 app intents 框架及其在 apple 开发者平台中愈显关键的作用。我们将向你全面介绍意图、实体、查询等核心概念。你将了解如何综合运用这些概念，以便使你的 app 与 apple 设备 (从“聚焦”和“快捷指令”等软件功能到操作按钮等硬件功能) 实现整合。我们还将介绍如何将 app intents 作为你 app 的入口，以便将来实现与 apple 智能的整合。 视频地址 App Intents 框架：将应用功能扩展到整个 Apple 生态引言作为 Apple 开发者，您是否想让应用的功能在全系统范围内可用？App Intents 框架正是为此而生。它能帮助您的应用深度集成到 Apple 生态系统中，无论是聚焦搜索、快捷指令、控制中心还是硬件交互，都能为用户提供无缝体验。本文将带您全面了解 App Intents 的核心概念、技术实现和最佳实践。 App Intents 的核心价值App Intents 不只是个功能框架，更是让应用能力向外辐射的生态系统。通过它，您可以将应用的功能扩展到： 聚焦搜索：呈现定制化结果 操作按钮：提供情境感知体验 小组件：增加可配置交互 控制中心：添加快捷控件 Apple Pencil Pro：设计专属动作 今年的新功能中，特别值得注意的是 Mac 版聚焦搜索现已支持直接调用应用动作。 App Intents 基本概念Intent（意图）Intent 是应用动作的定义，可以理解为应用的”动词”。它能接收参数并返回值，这些输入输出可以是： Swift 原生类型 自定义类型 App Enum（固定值集合） App Entity（动态类型数据） App Shortcuts（应用快捷指令）App Shortcuts 能将关键意图提升为系统级功能，在聚焦搜索、Siri、操作按钮等场景直接触达用户。它由意图和参数组成，只需几行代码即可实现。 如何创建您的第一个 App Intent下面通过一个旅行地标应用的案例，演示如何创建基本的导航意图： 12345678910struct NavigateIntent: AppIntent &#123; static let title: LocalizedStringResource = &quot;前往地标列表&quot; static let supportedModes: IntentModes = .foreground @MainActor func perform() async throws -&gt; some IntentResult &#123; Navigator.shared.navigate(to: .landmarks) return .result() &#125;&#125; 这个基础意图包含三个关键部分： title：定义意图的显示名称 supportedModes：指定运行模式（前台/后台） perform：实现具体功能 进阶功能实现支持多模块导航我们可以扩展上面的基础意图，使其支持多个导航选项： 123456789101112enum NavigationOption: String, AppEnum &#123; case landmarks = &quot;地标&quot; case map = &quot;地图&quot; case collections = &quot;收藏集&quot; // 显示配置代码...&#125;struct NavigateIntent: AppIntent &#123; @Parameter(title: &quot;目标模块&quot;) var navigationOption: NavigationOption // 执行代码...&#125; 优化用户体验通过添加参数摘要，可以进一步提升用户体验： 123static var parameterSummary: some ParameterSummary &#123; Summary(&quot;跳转到\\(\\.$navigationOption)模块&quot;)&#125; 特别提示：当意图包含完整参数摘要时，用户可以直接在 Mac 聚焦搜索中运行该动作。 处理动态数据（App Entity）对于像地标这样的动态数据，我们需要使用 App Entity 进行建模： 12345struct LandmarkEntity: AppEntity &#123; var id: Int &#123; landmark.id &#125; @ComputedProperty var name: String &#123; landmark.name &#125; // 查询协议实现...&#125; 今年的新特性包括： @ComputedProperty：动态获取属性值 Transferable：支持跨应用数据分享 IndexedEntity：与聚焦搜索深度集成 精准导航实现使用 TargetContentProvidingIntent 协议可以实现精准跳转： 12345678struct OpenLandmarkIntent: OpenIntent, TargetContentProvidingIntent &#123; @Parameter var target: LandmarkEntity&#125;// 在SwiftUI中绑定导航.onAppIntentExecution(OpenLandmarkIntent.self) &#123; intent in path.append(intent.target.landmark)&#125; App Intents 的架构原理App Intents 采用编译时代码解析机制： 构建时分析 Swift 源码生成意图描述 描述数据打包进应用二进制 安装后系统直接读取元数据 无需运行应用即可理解功能 跨目标共享实现要在不同目标间共享 App Intents，需要声明 AppIntentsPackage： 123456789// 共享框架中public struct TravelTrackingKitPackage: AppIntentsPackage &#123;&#125;// 主应用中struct TravelTrackingPackage: AppIntentsPackage &#123; static var includedPackages: [any AppIntentsPackage.Type] &#123; [TravelTrackingKitPackage.self] &#125;&#125; 今年新增了对 Swift 包和静态库的完整支持。 实施路线建议 从核心功能创建首个 App Shortcut 逐步添加实体和高级查询 利用新特性优化系统集成 参考其他专题会议深化应用 相关视频 使用 App Intents 针对”快捷指令”和”聚焦”进行开发 设计交互式摘要卡片 利用 App Intents 为用户奉上 App 的核心功能 利用 App Intents 设计提升系统体验 带你的 App 登陆 Siri App Intents 的新功能 文档 App intent domains App Intents App Shortcuts Creating your first app intent Integrating actions with Siri and Apple Intelligence Making actions and content discoverable and widely available 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"使用 Vision 框架读取文档","date":"2025-06-10T07:42:38.000Z","path":"2025/06/10/2025-06-10-wwdc2025_272/","text":"了解 vision 框架的最新进展。我们将介绍 recognizedocumentsrequest，并介绍如何使用该工具读取文本行并将其分组为段落、读取表格等。此外，我们将深入探讨相机镜头污渍检测，以及如何在照片图库或你自己的相机拍摄管道中识别可能有污渍的图像。 视频地址 Vision 框架新功能解析：文档读取与镜头污渍检测引言Apple 的 Vision 框架一直是开发者实现计算机视觉功能的利器。在最新版本中，Vision 框架新增了文档结构识别和相机镜头污渍检测两大功能，为应用开发带来了更多可能性。本文将详细介绍这些新功能的技术实现和使用方法。 文档读取功能详解结构化文档解析传统的 RecognizeTextRequest 只能提取文本行信息，而全新的 RecognizeDocumentsRequest 则能识别文档的结构化元素： 自动分组文本行为自然阅读段落 识别表格及其行列结构 检测列表及其层次关系 提取二维码等机器可读编码 识别电子邮件、电话号码等关键信息 代码实现示例以下是使用新 API 处理文档表格的 Swift 代码： 12345678// 从图像中提取第一个表格func extractTable(from image: Data) async throws -&gt; DocumentObservation.Container.Table &#123; let request = RecognizeDocumentsRequest() let observations = try await request.perform(on: image) guard let document = observations.first?.document else &#123; throw AppError.noDocument &#125; guard let table = document.tables.first else &#123; throw AppError.noTable &#125; return table&#125; 表格内容可通过多种方式访问： transcript：获取完整文本字符串 lines：按行分组的文本数组 paragraphs：自然段落分组 detectedData：识别出的结构化信息 相机镜头污渍检测技术特点新的 DetectLensSmudgeRequest 能检测镜头污渍问题： 返回 0-1 的置信度分数 建议设置 0.9 左右的阈值 需注意运动模糊等特殊情况 使用建议为提高检测准确率，可以结合其他 Vision API： 人像照片：使用 DetectFaceCaptureQualityRequest 普通照片：使用 CalculateImageAestheticScoresRequest 手部姿态检测更新2020 年推出的手部姿态检测模型已升级： 更小的模型体积 更低的延迟 更高的精度 注意：关节定位方式有变化，建议重新训练分类器 结论Vision 框架的新功能为开发者带来了： 更强大的文档解析能力 实用的镜头污渍检测 性能提升的手部姿态检测 这些改进将使您的应用获得更精准的视觉处理能力。建议下载官方示例应用并观看相关视频以深入了解。 相关视频 探索 Apple 平台上的机器学习和 AI 框架 探索 Vision 框架中的 Swift 增强功能 在 Vision 中探索 3D 人体位姿和人像分隔 在 Vision 中检测动物体态 文档资源 Classifying Images with Vision and Core ML Vision 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"了解 Foundation Models 框架","date":"2025-06-10T07:42:32.000Z","path":"2025/06/10/2025-06-10-wwdc2025_286/","text":"了解如何利用 apple 智能背后的设备端大语言模型！这个简介讲座涵盖了丰富的主题，从用于生成 swift 数据结构并结合流式传输实现灵敏响应体验的引导式生成功能，到用于整合数据源和会话以进行上下文管理的工具调用机制，应有尽有。这个讲座不设任何先决条件。 视频地址 探索 Apple 的 Foundation Models 框架：设备端大语言模型开发指南引言Apple 最新推出的 Foundation Models 框架为开发者提供了访问设备端大语言模型的能力。这个强大的 Swift API 框架支持 macOS、iOS、iPadOS 和 visionOS 平台，让开发者可以轻松构建个性化搜索建议、行程生成等智能功能，同时确保数据隐私和设备端处理。 框架概览Foundation Models 框架的核心是一个 30 亿参数的设备端大语言模型，虽然规模不及服务器级大模型，但针对内容生成、文本摘要和用户输入分析等任务进行了优化。所有计算都在设备端完成，不会增加应用体积。 模型测试体验在 Xcode 中，开发者可以通过 Playground 快速测试模型效果： 1234567import FoundationModelsimport Playgrounds#Playground &#123; let session = LanguageModelSession() let response = try await session.respond(to: &quot;为日本之旅起个好名字？只需回复标题&quot;)&#125; 核心功能1. 引导式生成框架通过 @Generable 和 @Guide 宏提供结构化输出功能： 12345@Generablestruct 搜索建议 &#123; @Guide(description: &quot;建议搜索词列表&quot;, .count(4)) var 搜索词: [String]&#125; 这种方式确保了输出结构与 Swift 类型系统兼容，简化了提示词设计并提高了准确率。 2. 快照流式传输不同于传统的令牌增量流，框架采用快照流技术： 12345678let stream = session.streamResponse( to: &quot;制定富士山三日行程&quot;, generating: 行程.self)for try await partial in stream &#123; print(partial)&#125; 每个快照代表部分生成响应，属性逐步填充，与 SwiftUI 完美契合。 3. 工具调用模型可以自主执行应用定义的代码： 12345protocol Tool &#123; var name: String &#123; get &#125; var description: String &#123; get &#125; func call(_ parameters: Generable) async throws -&gt; Generable&#125; 这种机制扩展了模型能力，使其可以整合实时信息、提供事实依据或执行系统操作。 4. 状态化会话会话对象支持多轮对话上下文保持、自定义指导语和专业化适配器： 1234let session = LanguageModelSession( guidance: &quot;你是一个专业的旅行助手&quot;, tools: [mapTool, weatherTool]) 开发者体验框架提供了一系列开发工具支持： Xcode Playground 即时测试 Instruments 性能分析模板 Feedback Assistant 反馈通道 适配器训练工具包 结论Foundation Models 框架为 Apple 开发者开启了一个设备端智能的新时代。通过简洁的 Swift API 和强大的功能组合，开发者可以轻松构建创新的 AI 体验。 相关视频 探索 Apple 平台上的机器学习和 AI 框架 探索设备端基础模型的提示设计和安全 深入了解 Foundation Models 框架 跟着视频学编程：使用 Foundation Models 框架将设备端 AI 引入你的 App 文档 人机界面指南：生成式 AI 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"BNNS Graph 的新功能","date":"2025-06-10T07:42:00.000Z","path":"2025/06/10/2025-06-10-wwdc2025_276/","text":"借助 bnns graph builder api，开发者现在可以使用熟悉的 swift 语言来编写操作图，从而生成预处理和后处理例程以及小型机器学习模型。bnns 可在执行前先编译图形，并支持那些具有实时性和延迟敏感性的应用场景，例如音频处理。在本次讲座中，我们将重温去年的比特失真器示例，通过移除对单独 python 文件的依赖性来简化 swift 组件，并转而完全用 swift 实现音频效果。此外，bnns graph builder api 还适用于在将图像数据传递到机器学习模型之前对数据进行预处理。本次讲座还将演示如何裁剪一张带有 alpha 通道的图像中的透明像素。 视频地址 使用 BNNS Graph Builder API 实现高效机器学习推理引言在机器学习领域，推理性能至关重要。苹果推出的 BNNS Graph Builder API 为开发者提供了一种在 Swift 中构建高效推理管道的全新方式。本文将详细介绍这项技术的核心优势和使用方法，帮助您在音频处理、图像预处理等场景中实现低延迟、高性能的机器学习解决方案。 BNNS Graph 核心优势BNNS (Basic Neural Network Subroutines) 是苹果提供的高性能机器学习库，特别适合以下场景： 实时音频处理（如人声分离、音色转换） 图像预处理/后处理 延迟敏感型推理任务 BNNS Graph 通过以下方式优化性能： 将整个网络视为单一图对象进行全局优化 自动执行层融合、数学变换等优化 精细控制内存分配和多线程 BNNS Graph Builder 新特性Swift 原生支持新推出的 BNNS Graph Builder API 允许开发者完全使用 Swift 构建操作图： 1234567let context = try BNNSGraph.makeContext &#123; builder in let x = builder.argument(name: &quot;x&quot;, dataType: Float.self, shape: [8]) let y = builder.argument(name: &quot;y&quot;, dataType: Float.self, shape: [8]) let product = x * y let mean = product.mean(axes: [0], keepDimensions: true) return [product, mean]&#125; 优势包括： 编译时类型检查 运行时形状推断 中间张量可调试 强类型减少运行时错误 高效切片操作新增的切片功能支持零拷贝数据选择： 12345let result = src[ BNNSGraph.Builder.SliceRange(startIndex: verticalMargin, endIndex: -verticalMargin), BNNSGraph.Builder.SliceRange(startIndex: horizontalMargin, endIndex: -horizontalMargin), BNNSGraph.Builder.SliceRange.fillAll] 实际应用案例图像预处理将连续色调图像二值化： 1let thresholded = src .&gt; src.mean(axes: [0,1], keepDimensions: false) 模型后处理执行 softmax 和 topK 操作： 12let softmax = x.softmax(axis: 1)let topk = softmax.topK(k, axis: 1, findLargest: true) 音频处理改进将 Bitcrusher 效果改用 Swift 实现： 12typealias BITCRUSHER_PRECISION = Float16var destination = (source * saturationGain).tanh() 使用建议 对于现有 PyTorch 模型，仍推荐使用基于文件的 API 对于小型模型或操作图，优先使用 Swift 原生 API 实时音频处理优先考虑 FP16 数据类型 总结BNNS Graph Builder API 提供了： 更直观的 Swift 开发体验 更高的运行时性能 更低的推理延迟 更广泛的应用场景 相关视频 探索 Apple 平台上的机器学习和 AI 框架 在 CPU 上助力实现实时 ML 推理 文档 BNNS 官方文档 vImage.PixelBuffer 文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"机器学习与-ai","slug":"机器学习与-ai","permalink":"http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"}]},{"title":"设计基础：从创意到界面","date":"2025-06-10T07:41:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_359/","text":"清晰、直观、易用，是每款优秀 app 的必备要素。在本讲座中，你将了解如何通过 app 设计来加强功能效果、充分展现 app 的用途、引导用户浏览你的内容，并合理使用组件打造简洁明了又打动人心的出色体验。本次讲座适合各种技能水平的设计师和开发者，也欢迎希望了解设计知识的其他人员参加。 视频地址 打造卓越用户体验：苹果平台应用设计全解析引言在当今竞争激烈的应用市场中，用户体验已成为决定产品成败的关键因素。本文将以苹果设计布道师Majo的分享为基础，系统讲解如何从结构、导航、内容和视觉四个维度打造出色的iOS应用体验。无论您是设计师、开发者还是产品经理，这些实用技巧都能帮助您提升应用品质。 结构设计：应用的骨架核心设计原则优秀应用结构应当让用户能够快速回答三个基本问题： 我在哪里？ 我能做什么？ 我可以去哪里？ 实战案例：黑胶唱片应用以黑胶唱片收藏应用为例，原始版本存在三个主要问题： 首屏展示菜单而非上下文内容 标题更像是品牌标识而非定位信息 核心功能入口隐藏过深 优化三步法 全面梳理功能点：先不加筛选地列出所有功能 模拟用户场景：设计典型用户流程和使用路径 精简重组模块：保留核心功能，优化关联性 导航设计：用户的路标Tab Bar最佳实践iOS平台推荐使用Tab Bar作为主要导航方式，设计时应注意： 标签项不超过5个（最好3-4个） 避免在Tab Bar中放置动作按钮 使用语义明确的标签文字 导航优化案例在原唱片应用中，导航系统经过以下改进： 合并”唱片”与”分类箱”（后者仅是前者的分组视图） 移除Tab Bar中的”添加”动作（不符合HIG规范） 采用SF Symbols图标确保视觉一致性 增强定位感通过引入Toolbar组件，包含： 当前屏幕标题 情境化操作按钮 使用SF Symbols保持操作识别度 内容呈现：信息的艺术内容组织原则优秀的内容呈现应当： 突出关键信息 符合用户浏览习惯 引导有效操作 渐进式披露策略针对信息量大的情况，建议： 首屏只展示少量精选内容 提供展开控件查看更多 保持次级页面与主视图的视觉连贯性 智能分组方法根据黑胶唱片应用特性，可采用三种分组逻辑： 时间维度：最新添加/最近播放 进度维度：未完成收藏/进行中交易 模式维度：风格流派/艺术家关联 视觉设计：品牌与功能的平衡视觉层级构建 增强重点内容对比度 采用系统文本样式（支持Dynamic Type） 图片文字添加渐变蒙层保障可读性 色彩系统规范 优先使用语义化系统颜色（自动适配深色模式） 谨慎使用强调色（不影响可访问性） 保持动态色彩适应性 图像处理技巧为列表项添加代表性图片时： 建立统一视觉风格 限定4种主色 使用复古几何元素 标题使用扩展字体 结论设计是一个持续迭代的过程。通过优化信息架构、导航系统、内容组织和视觉表现，您的应用将能够提供更流畅、更直观的用户体验。苹果的设计系统提供了丰富的资源支持，期待看到更多优秀的创意成果！ 相关文档人机交互指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"通过 Instruments 优化 CPU 性能","date":"2025-06-10T07:41:14.000Z","path":"2025/06/10/2025-06-10-wwdc2025_308/","text":"了解如何借助 instruments 中的两个新硬件辅助工具，针对 apple 芯片来优化你的 app。我们将首先介绍如何分析你的 app，然后深入介绍通过 processor trace 调用的每个函数。此外，我们将讨论如何使用 cpu counters 的各个模式来分析代码中的 cpu 瓶颈问题。 视频地址 使用 Instruments 优化 Apple 芯片 CPU 性能的完整指南引言在 Apple 硅芯片时代，充分利用 CPU 性能对应用流畅体验至关重要。本文将系统介绍如何利用 Instruments 中的高级工具分析并优化您的代码，从基础性能思维到处理器指令级的深度优化技巧。 性能优化方法论性能调查需要科学的方法论： 保持开放心态：瓶颈可能出现在意想不到的地方 数据验证假设：不要依赖直觉判断 分阶段排查：从线程阻塞问题到算法效率逐层深入 常用诊断工具组合： CPU 仪表盘：识别高负载时段 System Trace：分析线程阻塞行为 Hangs 工具：诊断主线程问题 Instruments 分析工具详解1. CPU Profiler 工具相比传统的 Time Profiler，CPU Profiler 提供两种模式： 采样模式：常规性能分析 延迟模式(deferred mode)：降低运行时开销 典型使用场景：123456// 优化前的二分查找实现func binarySearch(_ array: [Int], _ target: Int) -&gt; Int &#123; var low = 0 var high = array.count - 1 // ...标准实现&#125; 通过聚焦子树功能，可以快速定位集合类型操作的开销。 2. Processor Trace 技术(需要 Instruments 16.3+ 和 M4/A18 芯片) 关键优势： 完整记录用户空间所有指令 精确测量软件抽象成本 可视化时间线火焰图： 棕色：系统框架 品红：Swift 运行时 蓝色：应用代码 典型优化案例：12345// 优化后使用特化实现func binarySearch&lt;S: RandomAccessCollection&gt;(_ array: S, _ target: S.Element) -&gt; Int where S.Element == Int &#123; // ...特化实现&#125; CPU 瓶颈分析与微优化Apple 硅芯片的工作流程分为： 指令交付阶段（取指/解码） 指令处理阶段（执行） CPU Counters 工具的新预设模式： 分支预测错误分析 缓存命中率分析 指令并行度分析 高级优化技巧：1234// 无分支实现示例let midValue = array[midIndex]low = condition ? low : midIndex + 1high = condition ? midIndex - 1 : high 最终采用 Eytzinger 布局优化内存访问模式，实现高达 25 倍的性能提升。 结论与最佳实践优化路径总结： 用 CPU Profiler 识别集合类型开销 用 Processor Trace 定位泛型特化问题 通过瓶颈分析进行微优化 推荐实践： 建立性能测试基准 优先考虑算法级优化 谨慎使用微优化 相关视频 优化 Swift 代码的内存使用和性能 分析并优化 App 的功耗 通过 Instrument 优化 SwiftUI 性能 探索 Swift 性能 使用 Instruments 分析挂起 Swift 并发的可视化与优化 文档资源 使用 Processor Trace 分析 CPU 使用率 Apple 硅芯片 CPU 优化指南 性能与指标 为 Apple 硅芯片调整代码性能 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"开始使用 Game Center","date":"2025-06-10T07:40:46.000Z","path":"2025/06/10/2025-06-10-wwdc2025_214/","text":"探索 game center 的功能并了解如何开始使用。我们将展示实现成就、挑战、排行榜和活动的最佳实践，助你最大限度地提高游戏的曝光度、吸引新玩家并提升用户参与度。 为了充分从这个讲座中获益，我们还建议你观看“通过 apple games app 吸引玩家”。 视频地址 使用 Game Center 提升游戏体验与玩家参与度引言Game Center 是苹果提供的一套功能强大的游戏服务，它不仅能增强玩家参与度，还能帮助游戏获得更多曝光。通过集成成就、排行榜、挑战和活动等功能，开发者可以显著提升游戏的社交性和可玩性。本文将详细介绍如何快速集成 Game Center 并充分利用其功能优势。 Game Center 的核心功能为何使用 Game CenterGame Center 提供以下关键功能，帮助游戏脱颖而出： 成就系统：奖励玩家达成重要里程碑 排行榜与挑战：激发玩家间的竞争意识 活动深度链接：将玩家直接引导至特定游戏内容 这些功能不仅能提高玩家留存率，还能通过 Apple Games 应用（预装在苹果设备上）增加游戏的可见性。 提升游戏曝光Game Center 集成直接影响游戏在以下场景的展示机会： App Store 的”热门游戏”排行榜 Games 应用的”好友在玩”推荐版块 好友超越玩家时的推送通知 快速集成 Game Center项目设置步骤只需两个简单步骤即可启用 Game Center： 添加 Game Center 权限 在 Xcode 中： 打开项目 → 导航至”Signing and Capabilities”标签页 点击”+ Capability” → 搜索并添加”Game Center” Unity 开发者： 使用苹果提供的插件，自动生成包含正确权限的 Xcode 项目 初始化 GameKit 框架使用以下 Swift 代码进行初始化： GKLocalPlayer.local.authenticateHandler = &#123; _, error in print(\"\\(GKLocalPlayer.local.alias) 已准备好游玩！\") &#125; 最佳实践： 在游戏启动时尽早调用初始化（如标题屏幕出现时） 这将帮助游戏更快出现在推荐列表中 配置游戏功能Game Center 功能可以通过三种方式配置： Xcode 26 的 GameKit 包（推荐开发阶段使用） 直接在 Xcode 中测试成就/排行榜/活动 配置数据自动纳入版本管理 App Store Connect 网站 用于审核前的配置检查 App Store Connect API 适合自动化持续集成流程 创建排行榜示例以游戏《The Coast》中的”Cape Cod”关卡为例： 在 Xcode 中添加 GameKit 包 从 App Store Connect 同步现有配置 设置排行榜标识符和本地化名称 注意：为支持的每种语言准备本地化内容，Game Center 会自动适配玩家语言。 社交功能实现挑战功能无需额外代码即可将单机游戏转化为社交体验： 玩家可以邀请好友进行实时比拼 自定义比赛时长（1/3/7天） 限制参赛者或尝试次数 实现示例： GKLeaderboard.submitScore(points, context: 0, player: GKLocalPlayer.local, leaderboardIDs: [\"thecoast.lb.capecod\"]) 活动深度链接将玩家直接带到特定内容： func player(_ player: GKPlayer, wantsToPlay activity: GKGameActivity) async -&gt; Bool &#123; if activity.activityDefinition.identifier == \"thecoast.activity\" &#123; startCapeCod(activity) &#125; return true &#125; 多人活动提示： 启用”支持派对代码”选项 在游戏中展示当前派对代码 提供手动输入代码的功能 测试与发布测试工具 启用 Xcode 的 GameKit 调试模式 使用 Game Progress Manager 模拟分数提交 验证活动深度链接的正确性 发布流程 将 GameKit 包推送到 App Store Connect 审核时包含”未上线”的 Game Center 资源 审核通过后，将资源状态改为”已上线” 结论通过集成 Game Center，开发者可以： 显著提升玩家参与度和留存率 增加游戏在苹果生态系统的曝光机会 无需复杂开发即可实现丰富的社交功能 建议立即行动： 为项目添加 GameKit 包 初始化 GameKit 提升可见性 探索活动和挑战的社交潜力 相关视频 让游戏更上一层楼 通过 Apple Games App 吸引玩家 即插即用：向你的 Unity 游戏项目添加 Apple 框架 文档 为游戏创建活动 从排行榜创建吸引人的挑战 人机界面指南：Game Center 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"Platforms State of the Union (ASL)","date":"2025-06-10T07:40:45.000Z","path":"2025/06/10/2025-06-10-wwdc2025_112/","text":"深入了解 apple 平台上的最新进展。 视频地址 Apple平台2025重大革新：液态玻璃设计、AI整合与开发工具升级引言2025年成为Apple平台发展的里程碑之年，通过这场主题演讲，我们将全面解析Apple在UI设计、人工智能、开发工具和跨平台体验等方面的重大革新，帮助开发者打造更出色的应用体验。 平台生态系统硬件基础Apple芯片为所有平台提供： 统一内存架构：最大化性能表现 专用加速器：强化视频处理与机器学习能力 安全飞地：确保系统完整性 关键技术组合 Metal：底层API充分释放硬件潜力 Apple Intelligence：结合生成式模型与隐私保护 Swift：提供跨系统开发的高性能与安全性 SwiftUI：构建丰富交互与自适应界面 液态玻璃设计革命设计理念液态玻璃融合了玻璃的光学特性与流体的动态质感，具有三大特征： 折射内容与反射光线效果 响应式边缘透镜交互 深度层次感构建 适配指南开发适配流程分为三步： 重新编译现有代码查看自动适配效果 使用新API优化设计 更新自定义视图 123// 为自定义视图添加液态玻璃效果ContentView() .glassEffect() Apple Intelligence增强基础模型框架Foundation Models框架特性： 引导式生成：自动填充数据结构 工具调用：模型自主决策 完全隐私保护：设备端处理 离线可用：不依赖网络连接 开发工具升级Xcode 26 预测代码补全更精准 整合ChatGPT编程辅助 新增”编码工具”快速操作 改进语音控制支持 Swift 6.2 内联数组优化性能 span类型安全访问内存 增强C++互操作性 简化单线程代码编写 SwiftUI与visionOS创新SwiftUI改进 声明式WebView组件 富文本编辑器支持 3D图表功能 列表性能提升6-16倍 visionOS 26 全新Volume API 附近窗口共享功能 沉浸式媒体工具 环境遮挡效果 游戏开发增强Metal 4新特性 神经网络渲染 MetalFX帧插值 光线追踪去噪 游戏移植工具包增强 迁移提醒macOS Tahoe将是最后一个支持Intel芯片的版本，开发者应尽快完成Apple芯片适配。 结语超过100场深度课程即将上线，欢迎开发者积极参与讨论。Apple平台2025年的全面革新将为开发者创造前所未有的机遇，期待见证更多创新应用的诞生！ 相关视频平台进展主题演讲完整视频 文档资源Apple开发者文档中心 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"探索 Apple 平台上的机器学习和 AI 框架","date":"2025-06-10T07:40:31.000Z","path":"2025/06/10/2025-06-10-wwdc2025_360/","text":"浏览 apple 平台上机器学习和 ai 框架的最新更新。无论你是准备利用 apple 智能功能的 app 开发者、希望为设备端部署优化模型的 ml 工程师，还是想要探索无限可能的 ai 爱好者，我们都会提供应你所需的指导，帮你选择适合自己的工具。 视频地址 探索 Apple 平台上的机器学习和 AI 框架引言Apple 平台为开发者提供了丰富的机器学习和人工智能框架，帮助您轻松构建智能应用。无论您是应用程序开发者、机器学习工程师，还是 AI 爱好者，这些工具都能助您一臂之力。本文将带您了解这些框架的最新进展和选择指南。 Apple 机器学习和 AI 框架概览Apple 提供了一系列强大的工具，使开发者能够轻松集成智能功能到应用程序中。这些框架专注于设备端模型优化，确保用户体验流畅且隐私安全。 如何选择适合的框架选择框架时，您需要考虑以下因素： 应用场景需求 模型复杂度 设备性能要求 隐私保护需求 开发指南与最佳实践Apple 提供了详细的开发指南，帮助您更好地集成 AI 功能到应用中。遵循这些最佳实践，可以确保您的应用提供出色的用户体验。 结语Apple 平台的机器学习和 AI 框架为开发者提供了强大的工具，使构建智能应用变得更加简单。现在就开始探索这些可能性，为您的应用添加令人惊艳的智能功能吧！ 相关视频 Introduction to Neural Networks 文档资料 人机交互指南：生成式 AI 人机交互指南：机器学习 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"跟着视频学编程：使用 Xcode 探索本地化","date":"2025-06-10T07:40:29.000Z","path":"2025/06/10/2025-06-10-wwdc2025_225/","text":"探索如何使用 xcode 将你的 app 本地化为其他语言。我们将逐步介绍创建 string catalog、翻译文本以及与外部翻译器交换文件的流程。你将了解为翻译器提供必要语境信息的最佳实践，以及 xcode 如何帮你自动提供这类信息。对于大型项目，我们将还深入探讨使用类型安全的 swift 代码来管理复杂度并简化字符串管理的实用技巧。 视频地址 使用 Xcode 实现应用本地化的完整指南引言在当今全球化市场中，应用本地化已成为提升用户体验的关键因素。通过 Xcode 强大的本地化工具，开发者可以轻松将应用适配多种语言。本文将带你从零开始学习如何配置本地化支持，管理翻译流程，并应对大型项目的本地化挑战。 字符串目录基础创建字符串目录是本地化的第一步： 在 Xcode 中打开你的项目 通过文件菜单添加字符串目录，命名为”Localizable” 将其放入 Resources 组（与资产目录同组） 构建项目后，Xcode 会自动发现并添加可本地化字符串到目录中。 代码中的本地化实现在 Swift 代码中添加本地化字符串的几种方式： 123456// SwiftUI 视图中的本地化Text(&quot;精选地标&quot;, comment: &quot;特色地标英雄图像中的大标题&quot;)Button(&quot;保留&quot;) &#123; &#125;// Foundation 框架中的本地化String(localized: &quot;新建收藏&quot;, comment: &quot;用户创建新收藏的默认名称&quot;) 处理复数形式时，右键选择”根据复数变化”即可设置不同数量的表述。 翻译工作流程专业翻译流程： 通过 Xcode 产品菜单选择”导出本地化” 生成行业标准 XLIFF 文件给翻译服务 翻译完成后通过”导入本地化”功能整合译文 在方案编辑器中切换应用语言测试翻译效果 翻译上下文的重要性为翻译人员提供充分的上下文注释： 说明字符串的使用场景（按钮、标签栏等） 描述周边界面元素 解释占位符内容类型 Xcode 26 新增自动注释生成功能： 右键菜单选择”生成注释” 或在设置中开启自动生成选项 123456&lt;!-- XLIFF 文件示例 --&gt;&lt;trans-unit id=&quot;大峡谷&quot; xml:space=&quot;preserve&quot;&gt; &lt;source&gt;大峡谷&lt;/source&gt; &lt;target state=&quot;new&quot;&gt;大峡谷&lt;/target&gt; &lt;note from=&quot;auto-generated&quot;&gt;地标搜索建议&lt;/note&gt;&lt;/trans-unit&gt; 大型项目管理技巧随着项目规模扩大，可以采用以下策略： 使用 bundle 参数指定字符串资源位置： 1#bundle 宏可自动识别当前目标的资源包 tableName 参数分组： 将相关字符串分组到不同的字符串目录 例如所有”发现”功能字符串放入 Discover.xcstrings 符号引用工作流：123Text(.介绍标题).navigationSubtitle(.副标题(friendsPosts: 42))String(localized: .精选收藏) 对于现有项目，需开启”Generate String Catalog Symbols”构建设置才能使用符号生成功能。 最佳实践建议 从字符串提取开始本地化项目 提供详细注释（手动或自动生成） 随着复杂度增加，考虑使用生成的符号 两种工作流可随时通过”重构&gt;转换为符号”切换 总结Xcode 提供了完整的本地化工具链，从字符串提取到翻译管理，再到复杂项目支持。通过合理使用这些功能，开发者可以高效完成应用本地化工作，为用户提供更好的多语言体验。 相关视频 探索字符串目录 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"Welcome to WWDC25","date":"2025-06-10T07:40:12.000Z","path":"2025/06/10/2025-06-10-wwdc2025_364/","text":"there’s so much to dive into at wwdc25. here’s a quick guide to help get you started. 视频地址 WWDC25 开发者大会全攻略：创新技术与实用指南引言每年的苹果全球开发者大会(WWDC)都是科技界的盛事，WWDC25更是带来了前所未有的创新内容与开发者工具。本文将为您梳理本届大会的核心亮点和实用资源，帮助您快速掌握关键信息。 全新设计系统WWDC25推出了苹果史上最具革命性的设计革新： 跨平台无缝缩放：全新美学体系可完美适配各应用与平台 液态玻璃(Liquid Glass)技术：结合玻璃光学特性与流体动态质感，显著提升内容表现力 体验延续性：在创新同时保持了用户熟悉的操作精髓 这项设计革新将为应用界面带来质的飞跃，开发者可以期待自己的作品在新体系下焕发全新生命力。 Apple Intelligence突破本届大会在智能系统方面实现了重大突破： 隐私优先架构：所有处理优先在设备端完成 离线大语言模型：即便无网络连接也能提供强大功能 本地生成能力：演示内容完全由设备端模型生成，响应快速且安全 开发者工具升级WWDC25为开发者提供了全方位的工具支持： 100+场技术会议：涵盖Xcode、Swift、SwiftUI、Metal等核心开发工具 CodeAlong实践课程：与苹果工程师同步编写代码的学习体验 RealityCube游戏演示：展示Apple TV平台的最新开发可能 Foundation专题：深入讲解核心设计与技术原理 Foundation Models框架：全新的开发框架亮相 学习资源优化苹果大幅改进了技术资源的易用性： 视频文字摘要：快速定位会议要点、文档和示例代码 代码直连Xcode：可直接从会议视频复制代码到开发环境 一对一实验室：预约专家咨询专属项目问题 团体实验室：参与苹果工程师主持的深度技术讨论 开发者论坛：会议期间及会后持续获取技术支持 参与方式开发者可以通过多种渠道参与WWDC25： 观看平台年度主题演讲获取完整信息 参加”Meet with Apple”全球交流活动(线上线下同步) 在开发者论坛提问互动 旁听或参与团体实验室投票讨论 结语WWDC25带来了从设计语言到开发工具的全方位革新，为开发者创造了前所未有的可能性。无论您关注界面设计、智能系统还是开发效率，都能在本届大会中找到激动人心的新机遇。立即参与WWDC25，开启您的创新之旅吧！ 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"Swift 的新功能","date":"2025-06-10T07:39:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_245/","text":"与我们一起了解 swift 的最新更新。我们将讨论有助于提高效率的工作流程改进，以及用于处理基本编程任务的全新现代 api 资源库。我们还将举例说明 swift 在软件堆栈各层的广泛采用情况。最后，我们将探索新的语言特性，这些特性有助于提高并发易用性，同时确保在需要时实现最佳性能。 视频地址 Swift 6.2 新特性全解析：从开发工作流到全栈应用引言Swift 语言持续演进，6.2版本带来了众多令人振奋的改进。本文将全方位介绍Swift 6.2的新特性，包括开发工作流优化、现代化API库、全栈应用支持以及语言本身的演进。这些改进将使开发者更高效地构建从嵌入式系统到云服务的各类应用。 开发工作流优化代码编写VS Code的Swift扩展获得多项增强： 后台索引功能默认启用，保持编辑器功能响应 改进的代码补全相关性 自动添加LLDB调试支持 新增项目面板管理依赖项 支持并排DocC文档实时预览 构建过程 宏API项目构建时间显著缩短 编译器诊断信息附带详细说明文档 新增灵活的警告控制功能 调试体验 增强异步代码调试能力 显示任务信息并支持任务命名 “显式构建模块”功能加速调试 新型API库Subprocess包1234import Subprocesslet result = try await run(.name(&quot;pwd&quot;)) // 通过PATH查找let swiftPath = FilePath(&quot;/usr/bin/swift&quot;)let result = try await run(.path(swiftPath), arguments: [&quot;--version&quot;]) Foundation改进通知处理获得类型安全增强：123center.addObserver(of: screen, for: .keyboardWillShow)&#123; keyboardState in let frame = keyboardState.endFrame // 类型安全访问&#125; Observation库新增状态变更流式传输：12345678@Observable class Player &#123; var score: Int = 0 var item: Item = .none&#125;let values = Observations &#123; &quot;\\(player.score) points and \\(player.item.description)&quot;&#125; 全栈应用支持嵌入式开发Embedded Swift新增支持： 完整字符串API class约束协议的any类型 高效内存操作的InlineArray和Span类型 安全增强新增”严格内存安全”模式，要求所有不安全API显式标注 服务器端Swift重写的密码安全服务性能显著提升： 吞吐量提升40% 硬件需求减半 平台扩展新增支持： FreeBSD官方支持 WebAssembly编译支持 语言演进性能优化新增InlineArray和Span类型：12let nums: InlineArray&lt;3, Int&gt; = [1, 2, 3] // 编译期已知尺寸array.span.withUnsafeBytes &#123; ... &#125; // 安全内存访问 并发改进 默认在主Actor运行异步函数 隔离协议遵从 可选全局主Actor推断模式 明确后台工作标识 结语Swift 6.2带来了全方位的改进，从开发工具链到语言特性，从嵌入式开发到云服务，为开发者提供了更强大、更高效的开发体验。这些改进源于社区的共同贡献，期待更多开发者加入Swift生态系统的建设。 相关视频了解 Containerization优化 Swift 代码的内存使用和性能安全地混合使用 C、C ++ 和 Swift探索 Swift 和 Java 互操作性跟着视频学编程：使用 Swift 并发机制提升 App 性能采用 Swift 并发利用 Embedded Swift 实现轻量级开发探索 Swift 性能揭秘显式构建的模块 文档Swift 官方网站 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"了解 Containerization","date":"2025-06-10T07:39:53.000Z","path":"2025/06/10/2025-06-10-wwdc2025_346/","text":"认识一下 containerization，它是一个用 swift 编写的开源项目，用于在 mac 上创建和运行 linux 容器。了解 containerization 如何安全私密地对 linux 容器进行管理。探索开源 container cli 工具如何利用 containerization 软件包提供简单而强大的功能，以在 mac 上构建、运行和部署 linux 容器。 视频地址 在Mac上使用Swift构建和运行Linux容器引言容器技术已经成为现代应用开发和部署的核心工具。本文将介绍一个全新的开源框架Containerization——这是一个专为Mac设计的Swift框架，它使开发者能够安全、高效地构建和运行Linux容器。我们将深入探讨其工作原理、技术实现以及配套命令行工具。 什么是容器？Linux容器已成为构建、测试和部署服务器应用的标准解决方案。容器技术主要解决了以下问题： 环境隔离：将工作负载与主机隔离，同时实现工作负载间的相互隔离 环境一致性：在本地机器上准确复现生产环境 依赖管理：打包应用程序及其所有依赖项（二进制文件、库和资源） 容器还提供额外的运行时隔离功能，包括独立的网络栈、进程隔离和资源分配能力。 Containerization框架技术解析镜像管理机制容器通常基于镜像创建，镜像作为分发产物包含文件系统内容和默认配置。Containerization框架提供了： 从镜像仓库获取镜像的API 将镜像内容写入本地文件系统的功能 支持将文件系统暴露为EXT4格式的块设备 12// 示例：拉取容器镜像container image pull alpine:latest 轻量级虚拟化实现与传统方案不同，Containerization为每个容器分配独立的轻量级虚拟机，实现： 亚秒级启动速度 为每个容器分配专属IP地址 细粒度的目录访问控制 资源按需分配和释放 容器运行环境虚拟机启动后会运行vminitd初始化系统，这是一个用Swift构建的静态可执行文件，负责： 网络接口配置 文件系统挂载 进程管理和监控 12// 示例：运行容器container run -t -i alpine:latest sh 配套命令行工具Containerization提供了基于框架API构建的CLI工具，主要功能包括： 镜像管理（拉取、存储） 容器生命周期管理（创建、运行、停止） 网络服务（IP分配、DNS处理） 工具已开源，开发者可以直接使用或参与改进。 总结Containerization框架为Mac开发者提供了： 安全隔离的Linux容器运行环境 高性能的轻量级虚拟化方案 完整的Swift API和命令行工具 无论是希望集成容器功能到项目，还是直接使用容器进行开发，Containerization都提供了强大的支持。 相关视频 Introduction to Neural Networks 文档 Containerization GitHub Repository EXT4 Filesystem Specification 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"跟着视频学编程：使用 Swift 并发机制提升 App 性能","date":"2025-06-10T07:39:49.000Z","path":"2025/06/10/2025-06-10-wwdc2025_270/","text":"通过更新一个现有的示例 app，我们将向你介绍如何通过 swift 并发机制来优化 app 的用户体验。我们将从一个主 actor app 入手，然后根据需要逐步引入异步代码。我们将使用任务来优化主 actor 上运行的代码，并探索如何通过将工作转移到后台来实现代码并行运行。我们将探讨数据争用安全机制提供的功能，并讲解如何解读和修复数据争用安全错误。最后，我们将展示如何在 app 情境中充分利用结构化并发机制。 视频地址 使用 Swift 并发机制提升应用性能的实践指南引言在现代应用开发中，保持主线程流畅响应至关重要。Swift 提供了一套完整的并发机制工具链，帮助开发者编写安全高效的异步代码。本文将带您通过一个贴纸制作应用的实例，学习如何运用 Swift 并发机制优化应用性能。 应用架构设计我们的演示应用包含两个核心视图组件： 贴纸轮播视图 - 展示带有渐变背景的贴纸 贴纸网格视图 - 预览整套可导出的贴纸 核心处理逻辑由 PhotoProcessor 结构体实现，主要负责两个耗时的操作： 贴纸图像提取 主色调分析 关键技术实现异步照片加载使用 PhotosPickerItem 的异步方法 loadTransferable 从相册加载数据，并通过 SwiftUI 的 task 修饰符触发异步操作： 123.task &#123; await viewModel.loadPhoto(selectedPhoto)&#125; 后台线程处理为 PhotoProcessor 添加适当的标记，使其能够安全地在后台线程运行： 1234nonisolated struct PhotoProcessor &#123; @concurrent func process(data: Data) async -&gt; ProcessedPhoto?&#125; 并行任务优化利用 async let 语法同时执行贴纸提取和颜色分析操作： 12async let sticker = extractSticker(from: data)async let colors = extractColors(from: data) 数据竞争防护通过将 ColorExtractor 改为局部变量，确保每个任务都有独立的实例，从而消除并行访问的内存风险： 1234private func extractColors(from data: Data) -&gt; PhotoColorScheme? &#123; let colorExtractor = ColorExtractor() // 每个任务独立实例 return colorExtractor.extractColors(from: data)&#125; 结构化并发使用 TaskGroup 批量处理所有照片，提高整体效率： 12345await withTaskGroup &#123; group in for item in selection &#123; group.addTask &#123; /* 处理单个照片 */ &#125; &#125;&#125; 性能优化成果通过以上技术实现，我们取得了显著的性能提升： 主线程保持流畅响应 处理耗时降低50%以上 完全消除了数据竞争风险 实现了高效的批量导出功能 总结与建议Swift的并发机制为应用性能优化提供了强大而安全的工具。从简单的异步操作到复杂的结构化并发，开发者可以逐步将这些技术应用到实际项目中。建议从项目中识别出可以异步执行的操作开始，逐步引入这些技术。 相关视频 探索 SwiftUI 中的并发机制 采用 Swift 并发 使用 Instruments 分析挂起 超越结构化并发的基础 文档 Swift 迁移指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"Platforms State of the Union","date":"2025-06-10T07:39:48.000Z","path":"2025/06/10/2025-06-10-wwdc2025_102/","text":"深入了解 apple 平台上的最新进展。 视频地址 2025 Apple 平台年度主题演讲精华解读引言Apple 2025 年平台年度主题演讲展示了令人振奋的技术创新，为开发者提供了打造卓越应用与游戏的全新工具。让我们一起探索这些突破性进展如何重塑开发体验。 强大的平台生态系统Apple 平台的核心优势在于其深度整合的生态系统： Apple芯片：统一内存架构带来极致性能，专用加速器强化视频处理和机器学习能力 Metal框架：底层API套件充分释放硬件潜能 Swift语言：全系统提供卓越性能与安全性 SwiftUI：简化丰富交互和自适应设计的构建过程 关键技术创新设计与用户体验 Liquid Glass材质：为UI注入全新视觉活力 智能小组件：让内容在恰当位置自动呈现 实时活动：即时推送应用数据更新 开发工具革新 Xcode生成式智能：借助AI加速开发流程 增强型SwiftUI：更强大的布局与动画控制 Metal优化：进一步提升图形处理性能 隐私与安全 Apple智能：结合强大生成式模型与隐私保护技术 安全隔离区：保障系统完整性 iCloud同步：数据自动同步同时保持高级隐私保护 跨平台能力这些技术无缝扩展到visionOS等新平台，开发者可以： 使用同一套框架构建多设备体验 通过CloudKit实现数据自动同步 打造1+1&gt;2的整合体验 总结与展望2025年的Apple平台为开发者带来了前所未有的机遇。从革命性的Liquid Glass设计语言到强大的AI辅助开发工具，这些创新将帮助您打造更智能、更安全、更具沉浸感的应用程序。 相关视频 神经网络简介 文档 Swift 编程指南 Metal 图形编程 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"技术介绍与最佳做法","slug":"技术介绍与最佳做法","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"}]},{"title":"SwiftUI 的新功能","date":"2025-06-10T07:39:28.000Z","path":"2025/06/10/2025-06-10-wwdc2025_256/","text":"了解 swiftui 中用于为任一 apple 平台打造出色 app 的新功能。我们将探索如何通过 liquid glass 为你的 app 提供焕然一新的外观和风格。了解如何通过框架增强功能和新的 instrument 来提升性能，以及如何整合网页内容和多信息文本编辑等先进功能。我们还将向你展示 swiftui 如何扩充自身的应用范围，包括在三维空间中布局视图。 视频地址 SwiftUI 新特性全面解析：从设计革新到三维交互引言作为 Apple 平台应用开发的核心框架，SwiftUI 在最新版本中带来了令人振奋的创新。本文将系统性地介绍这些新特性，从视觉设计革新到性能优化，从富文本支持到三维交互体验，帮助开发者掌握如何利用这些功能打造更出色的应用。 焕然一新的设计系统SwiftUI 引入了全新的视觉设计语言，为所有 Apple 平台提供一致且流畅的体验： 液态玻璃特效 边栏和工具栏现在具备玻璃质感外观 导航过渡时会产生形变动画效果 可通过ToolbarSpacer精确控制工具栏布局 12345678910.toolbar &#123; ToolbarItemGroup(placement: .primaryAction) &#123; UpButton() DownButton() &#125; ToolbarSpacer(.fixed, placement: .primaryAction) ToolbarItem(placement: .primaryAction) &#123; SettingsButton() &#125;&#125; 搜索体验优化 iPhone版搜索栏移至底部更符合人体工学 iPad版自动定位在右上角 全新搜索标签样式让标签类应用更美观 123Tab(role: .search) &#123; NavigationStack &#123; Text(&quot;Search&quot;) &#125;&#125; 框架性能全面提升SwiftUI 底层架构进行了重大优化： 性能提升数据 macOS列表加载速度提升6倍 更新速度最高提升16倍 iOS/macOS滚动响应更加流畅 新增性能工具开发者现在可以分析： 长列表视图更新性能 平台视图更新瓶颈 渲染效率问题 三维交互与空间计算SwiftUI 为visionOS等平台带来了突破性的三维体验： 3D布局功能123Model3D(named: &quot;waterBottle&quot;) .manipulable() .opacity(snappingInfo.classification == .table ? 1.0 : 0.0) 三维图表支持123Chart3D &#123; SurfacePlot(x: &quot;x&quot;, y: &quot;y&quot;, z: &quot;z&quot;) &#123; ... &#125;&#125; 内容呈现与交互增强SwiftUI 扩展了对各类内容的支持： WebKit集成12WebView(url: sunshineMountainURL)WebView(page).ignoresSafeArea() 富文本编辑1TextEditor(text: $commentText) // 支持AttributedString绑定 改进的拖放系统12.dragContainer(for: Photo.self) &#123; draggedIDs in ... &#125;.dragConfiguration(DragConfiguration(allowDelete: true)) 跨平台一致性SwiftUI 现在提供更统一的跨平台体验： watchOS 26/macOS Tahoe支持自定义控制中心控件 visionOS/CarPlay新增小组件支持 辅助访问场景适配认知障碍用户需求 结语SwiftUI 的这些新特性为开发者提供了更强大的工具来创造卓越的应用体验。从视觉设计到性能优化，从平面布局到三维交互，这些改进将帮助您的应用在所有Apple平台上脱颖而出。 建议开发者： 全面应用新的设计语言 使用性能工具优化现有应用 探索三维空间交互的可能性 整合富文本和网页内容支持 相关视频了解 SwiftUI 空间布局了解适用于 SwiftUI 的 WebKit使用全新设计系统构建 SwiftUI App借助 SwiftUI 在 visionOS 中设置场景将 Swift Charts 扩展成三维图表 文档资源采用液态玻璃特效为自定义视图应用液态玻璃拖拽操作 API)人机界面指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"开发者工具","slug":"开发者工具","permalink":"http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"}]},{"title":"让你的 UIKit App 更加灵活","date":"2025-06-10T07:38:56.000Z","path":"2025/06/10/2025-06-10-wwdc2025_282/","text":"探究如何使用场景和容器视图控制器让你的 uikit app 在 iphone、ipad、mac 和 apple vision pro 上变得更加灵活。了解如何从以 app 为中心的生命周期过渡到基于场景的生命周期 (包括优化的窗口大小调整和改进的多任务处理)，以便解锁 app 的全部潜能。探索 uisplitviewcontroller 的增强功能，例如以交互方式调整列大小以及为检查器列提供一流支持；并通过采用新的布局 api 来增强视图和控制器的自适应性。 视频地址 构建适应多平台的 UIKit 应用：场景、容器与自适应 UI引言在今天的多设备时代，一个优秀的应用需要在 iPhone、iPad、Mac 和 Apple Vision Pro 等不同平台上提供一致的体验。本文将深入探讨如何利用 UIKit 的场景系统、容器视图控制器和自适应 UI 技术，让你的应用在各种尺寸和环境下都能展现最佳状态。 场景：灵活应用的基础场景是 UIKit 应用 UI 的独立实例，每个场景拥有： 独立的视图控制器和视图层级 专属的状态保存与恢复机制 精确的显示上下文信息（包括屏幕详情和窗口几何数据） 场景配置与生命周期123456789101112131415@mainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; func application(_ application: UIApplication, configurationForConnecting sceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123; if sceneSession.role == .windowExternalDisplayNonInteractive &#123; return UISceneConfiguration(name: &quot;Timer Scene&quot;, sessionRole: sceneSession.role) &#125; else &#123; return UISceneConfiguration(name: &quot;Main Scene&quot;, sessionRole: sceneSession.role) &#125; &#125;&#125; iOS 26 起，采用 UIScene 生命周期将成为强制要求，这是迈向灵活应用的第一步。 容器视图控制器UIKit 提供了强大的容器视图控制器来管理复杂布局： 增强的分栏视图控制器UISplitViewController 的最新改进包括： 交互式列宽调整 检查器列的一流支持 灵活的宽度控制 123splitViewController.minimumPrimaryColumnWidth = 200.0splitViewController.maximumPrimaryColumnWidth = 400.0splitViewController.preferredSupplementaryColumnWidth = 500.0 标签栏控制器的多平台适应UITabBarController 在不同设备上呈现不同形态： iPhone：底部标签栏 Mac：工具栏或侧边栏 Apple Vision Pro：场景边缘装饰栏 iPad：顶部标签栏可自适应为侧边栏 构建真正的自适应 UI要实现完全自适应的界面，需要关注以下关键点： 安全区域与布局边距1234let contentGuide = containerView.layoutMarginsGuideNSLayoutConstraint.activate([ contentView.anchors.constraint(equalTo: contentGuide)]) 窗口尺寸控制1234func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options: UIScene.ConnectionOptions) &#123; let windowScene = scene as! UIWindowScene windowScene.sizeRestrictions?.minimumSize.width = 500.0&#125; 方向锁定处理1234override var prefersInterfaceOrientationLocked: Bool &#123; return isDriving &#125;var isDriving = false &#123; didSet &#123; setNeedsUpdateOfPrefersInterfaceOrientationLocked() &#125;&#125; 未来兼容性建议随着 iOS 26 的推出，系统将不再对新屏幕尺寸进行自动缩放调整。开发者需要： 移除 UIRequiresFullscreen 这种兼容模式 确保应用在各种尺寸下都能正确显示 采用最新的自适应布局技术 结论构建真正灵活的多平台应用需要： 采用场景生命周期作为基础架构 合理使用容器视图控制器管理复杂布局 充分利用安全区域和自适应布局 API 关注未来兼容性要求 通过这些技术组合，你的应用将能够在 Apple 生态系统的任何设备上提供卓越的用户体验。 相关视频 UIKit 的新功能 提升 iPadOS 中的标签页和边栏使用体验 文档 TN3187: 迁移至 UIKit 基于场景的生命周期 UIKit 更新 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"深入探索 MapKit","date":"2025-06-10T07:38:45.000Z","path":"2025/06/10/2025-06-10-wwdc2025_204/","text":"了解 mapkit 和 mapkit js 的最新更新。我们将介绍一种新的路线类型——骑行路线，并向你展示如何在网页上启用 3d 环视图像。了解新的 geocoding api 如何支持坐标与地址之间的转换，以及如何使用 address representations api 来获取某一区域最恰当的地址。最后，我们将介绍一种新的地点引用方式，确保你的 app 能与 app intents 无缝协作。 视频地址 探索 MapKit 最新功能：骑行路线、3D环视与地理编码升级引言Apple 地图正在不断进化！MapKit 和 MapKit JS 迎来了多项激动人心的更新，包括全新的骑行路线、3D环视图像支持、升级版地理编码 API 等。这些功能将帮助开发者构建更强大的位置服务应用和网站。让我们一起来看看这些新特性如何改变用户体验。 PlaceDescriptor：地点引用的新方式为什么需要 PlaceDescriptor传统 Place ID 虽然有效，但在某些场景下并不理想： 当系统仅提供营业点名称和地址时 需要跨框架/应用协作时 传递地点引用给非 MapKit 环境时 PlaceDescriptor 三大要素 commonName：使用广为人知的名称 representations 数组：必须包含至少一种地理信息表达方式 supportingRepresentations 数组：可选字段，支持服务标识符 12345// 创建 PlaceDescriptor 示例let descriptor = PlaceDescriptor( representations: [.coordinate(coordinates)], commonName: &quot;帝国大厦&quot;) 地理编码技术升级主要变化 从 CoreLocation 迁移至 MapKit 新增智能地址格式功能 12345// 反向地理编码示例let request = MKReverseGeocodingRequest(location: photoLocation)if let mapItems = try await request?.mapItems &#123; photoContext = mapItems.first?.address?.cityWithContext&#125; 导航功能增强骑行路线支持新增的骑行路线功能会自动避开机动车道，优选绿道： 123request.transportType = .cyclinglet route = try await MKDirections(request: request).calculate()MapPolyline(route).stroke(.blue, lineWidth: 5) 3D环视功能MapKit JS 现在支持： 交互式环视视图 静态预览图 123new mapkit.LookAround(containerElement, place, &#123; showsDialogControl: true&#125;) 结论与行动指南立即行动 使用 PlaceDescriptor 实现灵活的地点引用 更新 Apple Maps 链接格式 迁移至新版地理编码 API 为应用添加骑行导航和3D环视功能 这些新功能将显著提升您应用的位置服务体验，帮助用户更好地探索世界。 相关视频 使用 MapKit 充分优化位置相关功能 认识 SwiftUI 版 MapKit MapKit 的新功能 文档 Adopting unified Maps URLs 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"地图和位置","slug":"地图和位置","permalink":"http://djs66256.github.io/tags/%E5%9C%B0%E5%9B%BE%E5%92%8C%E4%BD%8D%E7%BD%AE/"}]},{"title":"通过 Apple Games App 吸引玩家","date":"2025-06-10T07:38:33.000Z","path":"2025/06/10/2025-06-10-wwdc2025_215/","text":"认识一下 games app，这是一个全新的一站式平台，供玩家了解所玩游戏的最新动态、发现新游戏并与朋友一起玩。了解如何在 games app 中设置游戏以提升曝光度，如何整合 game center 以打造社交游戏，以及如何通过“app 内活动”来吸引玩家再次参与游戏。 为了充分从这个讲座中获益，我们还建议观看“开始使用 game center”。 视频地址 Apple Games App 全攻略：如何让您的游戏脱颖而出引言Apple 推出的 Games App 是一款革命性的游戏平台，它为玩家提供了全新的一站式游戏体验。作为开发者，了解如何充分利用这个平台的特性，将大大提升您游戏的曝光度和玩家参与度。本文将详细介绍如何配置游戏信息、整合 Game Center 功能以及使用 App 内活动来吸引和保持玩家。 Games App 核心功能概览Games App 预装在 iPhone、iPad 和 Mac 设备上，深度整合于操作系统，具有以下特点： 首页标签页：展示游戏内活动动态、好友游戏动态、Game Center 活动更新和精选游戏合集 专属游戏页面：包含游戏详情、成就进度、排行榜、挑战任务和多人活动 “一起玩”标签页：展示好友游戏动态和比分对比 “游戏库”：集中管理已安装游戏 “搜索”标签页：帮助玩家探索新游戏 如何配置游戏信息要让您的游戏在 Games App 中拥有定制化页面，需要： 在 App Store Connect 中将主/次类别设为”游戏” 确保游戏图标、名称和副标题清晰醒目 上传高质量的预览视频和截图 设置详细的游戏描述和精准搜索关键词 特别提示：如果您的游戏支持控制器，记得在 Xcode 添加 Game Controller 功能，这样游戏会在 Games App 和 App Store 显示控制器徽章。 整合 Game Center 功能Game Center 是增强玩家参与度的强大工具，包含以下功能： 成就系统 追踪游戏进度 鼓励玩家完成所有目标 支持与好友分享成就 排行榜 让玩家衡量技能水平 与好友较量 激发竞争欲望 挑战任务 将单人游戏转化为社交体验 玩家可与好友进行限时比分竞赛 实时查看成绩并重赛 活动功能 通过深度链接直达游戏特定场景 特别适合多人体验发现 可生成跨平台分享的派对码 用 App 内活动保持玩家参与度App 内活动是保持游戏热度的关键策略： 突出季节性内容和特殊促销 营造紧迫感 出现在首页、游戏库、搜索结果和游戏页面优先位置 支持分享功能 实践建议：可以策划”即将开始”的活动，提前两周发布作为预热，使用深度链接指向活动并带参数标识。 总结与行动建议要让您的游戏在 Games App 中获得最佳表现，您应该： 检查 Games App 中的页面信息是否完整 确保已启用 Game Center 并整合所有适用功能 策划新活动保持游戏热度 利用预购功能为即将发布的游戏造势 相关视频 开始使用 Game Center 让游戏更上一层楼 App Store 预定的新功能 利用虚拟和物理游戏手柄 认识 App Store 上的 app 内活动 文档 Creating activities for your game Creating engaging challenges from leaderboards Human Interface Guidelines: Game Center 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"让游戏更上一层楼","date":"2025-06-10T07:37:57.000Z","path":"2025/06/10/2025-06-10-wwdc2025_209/","text":"了解如何让你的游戏在统一游戏平台上大放异彩。我们将介绍一些可用于让你的游戏更上一层楼并进一步提升玩家体验的技术。简要了解构建、调试和分析游戏所必需的基本工具。 视频地址 打造卓越游戏体验：统一游戏平台的进阶技巧引言在Apple生态系统中开发游戏时，充分利用系统特性和工具可以让你的游戏脱颖而出。本文将介绍如何通过性能优化、社交功能集成、图形渲染等关键技术，为玩家提供流畅、沉浸式的跨平台游戏体验。 系统性能优化游戏模式游戏模式通过优先分配系统资源来提升游戏表现： 减少后台活动占用 增加CPU处理时间 改善蓝牙设备响应速度 在info.plist中添加LSSupportsGameMode键即可启用。全屏启动游戏时系统会自动激活该模式。 持续执行模式为保持帧率稳定，可以使用持续执行模式： 在Xcode的”Signing &amp; Capabilities”中启用权限 将权限包含在游戏配置文件中 低功耗模式适配通过监听NSProcessInfoPowerStateDidChange通知，游戏可以动态调整画质设置以适应低功耗状态，延长电池续航。 增强玩家互动Game Center集成 成就系统与排行榜 挑战和活动功能 完全集成在Xcode工作流中 Apple Games应用预装在Apple设备上的中心化游戏门户，提供： 游戏启动与发现 社交互动功能 系统级深度集成 核心技术实现资源下载优化使用Background Assets框架实现： 分段下载（先下核心内容） 后台持续下载剩余资源 高达200GB的托管存储空间 跨设备存档同步GameSave框架基于iCloud提供： 自动存档同步 离线支持 默认冲突解决UI 输入控制方案 Game Controller框架支持所有外设 新Touch Controls框架为移动端提供定制触控方案 图形渲染进阶Metal 4技术栈Apple的低阶图形API提供： 简化资源管理 降低CPU开销 机器学习集成 MetalFX升频技术 空间/时间升频平衡画质与性能 帧插值提升流畅度 光线追踪降噪处理 调试与分析工具 Metal性能HUD（新增性能洞察） Xcode Metal调试器 Instruments系统跟踪 结语通过系统性能调优、社交功能集成、核心技术实现和图形渲染进阶，你可以在Apple生态系统中打造出令人惊艳的游戏体验。立即开始运用这些技术，让你的游戏在统一游戏平台上大放异彩！ 相关视频开始使用 Game Center探索 Apple 托管的 Background Assets探索 Metal 4探索 Metal 4 游戏深入探索 Metal 4 游戏用于打造沉浸式 App 的 Metal 渲染的新功能通过 Apple Games App 吸引玩家为 Apple 平台设计高端游戏将高端游戏移植到 Apple 平台 文档人机界面指南：游戏设计 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"探索 Metal 4","date":"2025-06-10T07:37:51.000Z","path":"2025/06/10/2025-06-10-wwdc2025_205/","text":"了解如何开始利用 metal 4 强大的新功能，让你的现有 metal app 更上一层楼。我们将介绍 metal 如何助你充分发挥 apple 芯片的优势，并以更高效的方式进行硬件编程。你还将了解如何借助 metal 4 的新功能，将机器学习整合到 metal 代码中。 视频地址 Metal 4 全面解析：释放 Apple 芯片的图形与计算潜能引言Metal 作为 Apple 平台的低阶图形与计算 API，已成为开发者构建高性能应用的核心工具。随着 Metal 4 的推出，Apple 进一步提升了其能力，让开发者能够充分发挥 Apple 芯片的性能潜力。本文将深入探讨 Metal 4 的关键创新，包括指令编码、资源管理、着色器编译优化，以及机器学习的无缝集成。 指令编码革新Metal 4 引入了全新的指令编码模型，显著提升了编码效率： 解耦设计：将指令缓冲区与队列解耦，使应用能够并行编码 统一编码器：整合了传统编码器类型，减少了所需编码器总数 附件映射：允许实时切换颜色附件配置，无需额外编码器 显式内存管理：通过 MTL4CommandAllocator 直接控制指令缓冲区内存 先进的资源管理面对现代应用日益增长的资源需求，Metal 4 提供了更精细的控制： 参数表(MTL4ArgumentTable)：简化无绑定模式下的资源绑定 驻留集(Residency Sets)：确保关键资源保持驻留，优化GPU访问 放置稀疏资源：动态控制资源内存使用，支持更广泛的设备适配 屏障同步：提供低开销的阶段间同步，与其他API中的屏障良好对应 12345// 示例：创建驻留集并添加到指令队列MTL4ResidencySet* residencySet = [device newResidencySet];[residencySet addResource:resource1];[residencySet addResource:resource2];[commandQueue addResidencySet:residencySet]; 着色器编译优化Metal 4 通过以下改进大幅提升了着色器编译效率： 独立编译上下文：新的 MTL4Compiler 接口提供更明确的控制 QoS 继承：编译线程继承请求线程的服务质量优先级 灵活管线状态：重用 Metal IR 减少重复编译时间 简化管线配置收集：进一步消除设备上编译需求 机器学习无缝集成Metal 4 将机器学习能力深度整合到图形管线中： 原生张量支持：在多维数据处理上远超传统缓冲区/纹理 专用编码器：ML编码器与现有编码器类型协同工作 内核级集成：小网络可直接嵌入着色器使用 性能原语：优化的张量操作原语在Apple芯片上极速运行 MetalFX 增强功能Metal 4 配合 MetalFX 提供了多项生产就绪的解决方案： 升频技术：以低分辨率渲染+智能升频节省GPU时间 帧插值：生成中间帧实现更高刷新率 光线追踪降噪：去除少光线渲染的噪声，保持图像质量 迁移与采用策略Metal 4 设计为模块化采用，开发者可分阶段集成： 编译优化：先采用新的编译器接口 指令编码：逐步迁移到新的编码模型 机器学习：根据网络规模选择合适的集成方式 资源管理：最后采用驻留集等高级功能 开发工具支持Xcode 26 提供了全面的 Metal 4 开发支持： 专用模板：新建项目可选择 Metal 4 游戏模板 调试工具：API验证、性能HUD和系统追踪 示例代码：快速上手的实用范例 结论Metal 4 代表了 Apple 图形技术的重大飞跃，为开发者提供了前所未有的控制力和灵活性。无论是追求极致性能的游戏，还是需要复杂计算的专业应用，Metal 4 都能提供强大的支持。建议开发者从最符合自身需求的特性开始，逐步将应用迁移到 Metal 4，充分释放 Apple 芯片的潜能。 相关视频 实现 Metal 4 机器学习与图形应用程序的完美融合 探索 Metal 4 游戏 深入探索 Metal 4 游戏 用于打造沉浸式 App 的 Metal 渲染的新功能 让游戏更上一层楼 文档 Understanding the Metal 4 core API Using the Metal 4 compilation API 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"深入探索 Metal 4 游戏","date":"2025-06-10T07:37:45.000Z","path":"2025/06/10/2025-06-10-wwdc2025_211/","text":"深入了解 metal 4 的最新改进。我们将介绍全新光线追踪功能，助你将复杂度极高且视觉效果丰富的工作负载成功移植到 apple 芯片上。了解 metalfx 如何通过渲染画质提升、帧插值和场景去噪来扩展工作负载。 为了充分从这个讲座中获益，我们建议你先观看“探索 metal 4”和“探索 metal 4 游戏”。 视频地址 Metal 4 游戏开发进阶指南：光线追踪、MetalFX 与性能优化引言现代游戏开发正朝着更逼真的视觉效果发展，而 Metal 4 为开发者提供了实现这一目标的强大工具。本文将深入探讨 Metal 4 的最新特性，包括光线追踪增强、MetalFX 超采样和帧插值技术，帮助您在 Apple 平台上打造高性能的沉浸式游戏体验。 MetalFX 超采样技术时域超采样基础MetalFX 基于机器学习的超采样器自 2022 年就成为 Apple 平台的一部分。它通过在渲染管线中应用时域技术，显著提升游戏质量和性能。关键步骤包括： 正确设置曝光输入参数 合理应用抖动渲染 在后处理效果前集成超采样 12345// 创建典型时域超采样器的示例代码let descriptor = MTLCreateMetalFXSpatialScalerDescriptor()descriptor.colorTextureFormat = colorFormatdescriptor.outputTextureFormat = outputFormatlet spatialScaler = device.makeMetalFXSpatialScaler(descriptor: descriptor) 曝光调试工具今年新增的曝光调试工具可帮助调整曝光输入值。启用环境变量 MTLFX_EXPOSURE_TOOL_ENABLED 后，超采样器会在画面上渲染灰色棋盘格图案。正确曝光值时，网格图案应保持稳定的中灰色。 动态分辨率与反应性蒙版MetalFX 时域超采样器现在支持： 动态尺寸输入：无需每帧固定尺寸 反应性像素提示：通过可选的反应性蒙版输入标记透明特效或粒子覆盖区域 MetalFX 帧插值技术工作原理帧插值技术利用已渲染像素在两帧之间生成插值帧，需要提供： 两帧渲染画面 运动矢量 深度数据 UI 渲染策略启用帧插值时，有三种常用 UI 渲染技术： 复合 UI 模式：插值器尝试分离带 UI 和不带 UI 的帧差值 离屏 UI：将 UI 渲染到独立纹理中 逐帧 UI：由代码完全控制，实现最流畅体验 12345// 创建帧插值器的示例代码let descriptor = MTLCreateMetalFXTemporalScalerDescriptor()descriptor.motionVectorTextureFormat = motionFormatdescriptor.depthTextureFormat = depthFormatlet temporalScaler = device.makeMetalFXTemporalScaler(descriptor: descriptor) Metal 4 光线追踪增强相交函数缓冲器Metal 4 引入相交函数缓冲器，是包含场景相交函数句柄的参数缓冲器。设置步骤包括： 在实例级别和几何级别配置状态 创建实例加速结构时指定 intersectionFunctionTableOffset 在着色器中添加”intersection_function_buffer”标签 加速结构优化Metal 4 提供多种加速结构构建选项： 优先快速相交以减少光线追踪时间 最小化加速结构内存占用 支持更大场景或更快构建 MetalFX 降噪超采样集成方法集成降噪超采样器只需在超采样器基础上添加： 世界空间法线 漫反射 albedo 粗糙度值 镜面 albedo 1234// 创建降噪超采样器的示例代码let descriptor = MTLCreateMetalFXDenoiserDescriptor()descriptor.inputTextureFormats = [colorFormat, normalFormat, albedoFormat]let denoiser = device.makeMetalFXDenoiser(descriptor: descriptor) 常见问题与优化 避免输入噪点过多：使用标准路径追踪采样改进技术 处理金属材质：确保镜面 albedo 有颜色时，漫反射 albedo 较暗 使用世界空间法线：以优化降噪决策 结论与后续步骤Metal 4 为游戏开发者提供了强大的工具链，从光线追踪到MetalFX性能优化技术。建议开发者： 已集成超采样器的项目可升级到帧插值 新项目应从MetalFX超采样技术开始 优化光线追踪效果使用相交函数缓冲器等最佳实践 通过降噪超采样器减少光线预算 相关视频 探索 Metal 4 探索 Metal 4 游戏 用于打造沉浸式 App 的 Metal 渲染的新功能 Metal 光线追踪指南 利用 MetalFX Upscaling 提升性能 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"用于打造沉浸式 App 的 Metal 渲染的新功能","date":"2025-06-10T07:37:14.000Z","path":"2025/06/10/2025-06-10-wwdc2025_294/","text":"探索用于通过 compositor services 打造沉浸式 app 的 metal 渲染的最新改进。了解如何通过添加悬停效果来突出展示 app 的交互式元素，以及如何通过动态渲染质量实现更高保真度的渲染。了解新的 progressive 沉浸样式。探索如何通过将 mac 中的 metal 内容直接渲染至 vision pro，来为 macos app 提供沉浸式体验。 要充分利用好本次讲座，请先观看 wwdc23 讲座“探索 metal 技术打造沉浸式 app”。 视频地址 探索 Vision Pro 的 Metal 渲染新功能：打造更沉浸的体验引言随着 Vision Pro 的推出，开发者们获得了在 visionOS 上创建沉浸式应用的新机遇。苹果在今年的开发者大会上宣布了一系列 Metal 渲染的新功能，这些改进将为用户带来更丰富、更交互的沉浸式体验。本文将详细介绍这些新特性，帮助开发者更好地利用它们。 新的渲染循环 APIMetal 沉浸式应用始于 SwiftUI，开发者需要创建包含 compositor 层的沉浸空间。今年的 Compositor Services 新增了返回数组的 queryDrawables 函数： 12345678910111213141516171819// 场景渲染循环示例extension Renderer &#123; func renderFrame(with scene: MyScene) &#123; guard let frame = layerRenderer.queryNextFrame() else &#123; return &#125; frame.startUpdate() scene.performFrameIndependentUpdates() frame.endUpdate() let drawables = frame.queryDrawables() guard !drawables.isEmpty else &#123; return &#125; guard let timing = frame.predictTiming() else &#123; return &#125; LayerRenderer.Clock().wait(until: timing.optimalInputTime) frame.startSubmission() scene.render(to: drawable) frame.endSubmission() &#125;&#125; 根据系统上下文，该数组可能包含 1-2 个 drawable，这为开发提供了更大的灵活性。 交互式悬停效果新增的悬停效果能让用户直观识别可交互对象。实现步骤包括： 配置 layer renderer 使用 8 位像素格式的跟踪区域纹理 注册交互对象时添加唯一标识符 通过 .automatic 属性添加悬停效果 使用多采样抗锯齿(MSAA)时需要特别注意跟踪区域纹理的处理方式。 动态渲染质量开发者现在可以根据场景复杂度动态调整分辨率： 指定应用适用的最大渲染质量 运行时在设定范围内调整质量等级 质量调整会影响纹理细节和性能，开发者应针对不同场景元素采用合适的质量设置。 渐进式沉浸模式新型渐进式沉浸模式允许用户通过 Digital Crown 控制沉浸度： 仅支持 layered 布局 配置 8 位模板格式(stencil8) 添加 render context 绘制模板遮罩 Xcode 模板已经包含渐进式沉浸的完整示例，开发者可以直接参考。 macOS 空间渲染最新功能允许通过 Mac 向 Vision Pro 直接渲染/流式传输沉浸式内容： 使用 RemoteImmersiveSpace 场景类型 通过 remoteDeviceIdentifier 连接 ARKit 会话 支持多种输入方式 C/C++渲染引擎可以通过原生 C API 接入，为已有应用添加沉浸式功能提供了便利。 结论这些 Metal 渲染新功能为开发者提供了更强大的工具，可以创建更具交互性、更沉浸的应用体验。无论是悬停效果、动态质量调整还是渐进式沉浸模式，都为应用带来了新的可能性。特别是 Mac 内容直接渲染至 Vision Pro 的能力，为高性能应用开发开辟了新途径。 相关视频 探索 visionOS 上的空间配件输入 visionOS 26 的新功能 在 visionOS 中使用透视功能渲染 Metal 探索 Metal 技术打造沉浸式 App 文档 Optimizing GPU performance 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"探索 visionOS 上的空间配件输入","date":"2025-06-10T07:36:49.000Z","path":"2025/06/10/2025-06-10-wwdc2025_289/","text":"了解如何将空间配件整合到你的 app 中。展示虚拟内容、与 app 进行交互、在空间中进行追踪，并获取有关交互效果的信息，进一步提升 visionos 上的虚拟体验。 视频地址 在 visionOS 中集成空间配件：开发实践与设计指南引言随着 Apple Vision Pro 的推出，空间计算体验迎来了新的可能性。今年 WWDC 带来的空间配件支持功能，让开发者能够通过 PlayStation VR2 Sense 控制器和罗技 Muse 手写笔等设备，为用户提供更精确的输入控制和沉浸式反馈体验。本文将深入解析如何在 visionOS 应用中整合这些空间配件，从技术实现到设计考量，一网打尽。 空间配件概述visionOS 目前支持两类空间配件： PlayStation VR2 Sense 控制器 专为游戏场景设计 配备按钮、摇杆和扳机键 支持标准手势操作 高精度空间追踪，适合运动类游戏 罗技 Muse 手写笔 专为生产力与创意应用设计 力敏传感器提供变量输入 侧键与笔尖支持 强大的触觉反馈功能 这些配件通过 Apple Vision Pro 的摄像头与其内置传感器协同工作，实现精确的空间位置和旋转追踪。 开发实践：构建空间雕刻应用1. Xcode 基础配置首先需要在项目中添加必要的配置： 123// 在 capabilities 编辑器中添加 Spatial Gamepad 支持// 并在 Info.plist 中添加：// Accessory Tracking Usage 描述: &quot;追踪配件移动以雕刻虚拟粘土&quot; 该描述会显示为系统权限提示，告知用户配件追踪的目的。 2. 配件连接管理监听配件连接事件是关键步骤： 12345678910111213141516171819// 检查空间配件支持NotificationCenter.default.addObserver(forName: NSNotification.Name.GCControllerDidConnect, object: nil, queue: nil) &#123; notification in if let controller = notification.object as? GCController, controller.productCategory == GCProductCategorySpatialController &#123; // 处理控制器连接 &#125;&#125;// 对于手写笔的特殊处理NotificationCenter.default.addObserver(forName: NSNotification.Name.GCStylusDidConnect, object: nil, queue: nil) &#123; notification in if let stylus = notification.object as? GCStylus, stylus.productCategory == GCProductCategorySpatialStylus &#123; // 处理手写笔连接 &#125;&#125; 3. 虚拟内容锚定使用 RealityKit 的锚点系统将虚拟内容与配件位置同步： 1234567func setupSpatialAccessory(device: GCDevice) async throws &#123; let source = try await AnchoringComponent.AccessoryAnchoringSource(device: device) guard let location = source.locationName(named: &quot;aim&quot;) else &#123; return &#125; let sculptingEntity = AnchorEntity(.accessory(from: source, location: location), trackingMode: .predicted) // 添加虚拟模型到 sculptingEntity&#125; 追踪模式说明： .predicted: 低延迟渲染，适合快速响应需求 .continuous: 更高精度，适合精细操作 4. 触觉反馈实现增强交互真实感的触觉反馈实现： 123456789101112let stylus: GCStylus = ...guard let haptics = stylus.haptics else &#123; return &#125;guard let hapticsEngine: CHHapticEngine = haptics.createEngine(withLocality: .default) else &#123; return &#125;do &#123; try hapticsEngine.start() // 在适当时机触发反馈 let pattern = try CHHapticPattern(events: [...], parameters: [...]) let player = try hapticsEngine.makePlayer(with: pattern) try player.start(atTime: 0)&#125; catch &#123; print(&quot;触觉反馈错误: \\(error)&quot;)&#125; ARKit直接追踪方案对于需要更底层控制的场景，可以直接使用ARKit API： 配置AccessoryTrackingProvider 处理配件连接/断开事件 选择适当的更新模式： 实时流式更新 按需预测更新 示例项目《Tracking accessories in volumetric windows》展示了完整实现。 重要设计考量1. 输入兼容性确保应用同时支持手势和控制器输入： 12ContentView() .receivesEventsInView(true) // 允许视图接收控制器输入 空间事件手势会自动获取控制器的左右手信息，实现无缝切换。 2. 沉浸式体验优化针对全空间应用的建议：12345// 隐藏Home指示器.persistentSystemOverlays(.hidden)// 隐藏上肢和配件模型.upperLimbVisibility(.hidden) 3. 适配策略 同时支持配件和手部输入 在App Store中添加适当徽章： “支持空间游戏控制器” 如需必备配件则使用”需要空间游戏控制器” 结语空间配件为visionOS应用带来了新的交互维度，从游戏到创意工具都有广阔的应用前景。通过GameController、RealityKit和ARKit的协同工作，开发者可以实现精细控制与沉浸式反馈的完美结合。期待看到更多充分利用这些特性的创新应用！ 相关视频 RealityKit 的新功能 使用 ARKit 打造更出色的空间计算体验 使用 RealityKit 构建空间绘画 App 利用虚拟和物理游戏手柄 游戏控制器的进展 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"探索 Metal 4 游戏","date":"2025-06-10T07:36:40.000Z","path":"2025/06/10/2025-06-10-wwdc2025_254/","text":"了解如何借助 metal 4 的最新改进来优化游戏引擎。我们将介绍如何统一命令编码来充分降低 cpu 开销，如何扩大图形资源管理来支持海量场景并最大限度地提高内存预算，以及如何快速载入大型管道状态库。 为了充分从这个讲座中获益，请先观看“探索 metal 4”。 视频地址 Metal 4游戏开发全面解析：从命令编码到管线优化引言Apple的Metal 4为现代游戏引擎带来了一系列突破性的改进，特别是针对高性能游戏开发的关键需求。本文将深入解析Metal 4在游戏开发中的三大核心优势：高效命令编码、规模化资源管理以及快速管线加载，帮助开发者充分挖掘Apple Silicon的潜力。 高效命令编码Metal 4通过统一编码架构显著降低了CPU开销： 统一计算编码器：将内核调度、数据拷贝和加速结构构建整合到单一编码器中 通道屏障机制：使用barrierAfterEncoderStages精确控制执行依赖关系 多线程命令缓冲：利用Apple Silicon多核优势实现并行编码 12345678910// 典型Metal 4命令编码流程id&lt;MTL4ComputeCommandEncoder&gt; encoder = [commandBuffer computeCommandEncoder];[encoder copyFromBuffer:src sourceOffset:0 toBuffer:buffer1 destinationOffset:0 size:64];[encoder barrierAfterEncoderStages:MTLStageBlit beforeEncoderStages:MTLStageDispatch visibilityOptions:MTL4VisibilityOptionDevice];[encoder setComputePipelineState:pso];[argTable setAddress:buffer1.gpuAddress atIndex:0];[encoder setArgumentTable:argTable];[encoder dispatchThreads:threadsPerGrid threadsPerThreadgroup:threadsPerThreadgroup]; 规模化资源管理Metal 4为现代游戏的大规模资源需求提供了系统化解决方案： 参数表(Argument Table)：通过索引绑定数千资源 驻留集(Residency Set)：显式管理GPU可见资源 纹理视图池：预分配视图内存避免动态开销 稀疏堆(Sparse Heap)：支持64KB大页面配置优化内存性能 快速管线加载技术针对游戏启动时的管线编译瓶颈，Metal 4提供三级优化方案： 灵活渲染管线状态：先创建未特化状态，运行时快速特化 多线程设备编译：利用GCD线程池并行编译 预编译管线二进制：通过metal-tt工具链生成Metal存档 性能优化建议 使用device.maximumConcurrentCompilationTaskCount确定最佳编译线程数 关键管线使用DEFAULT QoS级别进行后台编译 结合Metal调试器优化屏障放置和同步范围 结论Metal 4为游戏开发者提供了从底层命令编码到高层资源管理的全方位优化方案，特别适合《刺客信条：影》这类需要处理GB级资源和数千着色器的AAA级游戏。通过合理应用统一编码、参数表和管线预编译等技术，开发者可以显著提升游戏性能和加载速度。 相关视频 探索 Metal 4 深入探索 Metal 4 游戏 用于打造沉浸式 App 的 Metal 渲染的新功能 文档 人机交互指南：游戏设计 理解Metal 4核心API 使用Metal 4编译API 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"RealityKit 的新功能","date":"2025-06-10T07:36:27.000Z","path":"2025/06/10/2025-06-10-wwdc2025_287/","text":"利用全新的 realitykit 功能尽情挥洒创意，这些功能可帮助你为 ios、ipados、macos、apple tvos 和 visionos 构建丰富的 3d 内容。了解如何直接通过 realitykit 来访问 arkit 数据。探究如何使用对象操作功能与 3d 内容进行更自然的交互。通过一个交互式示例，探索一些适用于场景理解、环境融合、实例化等方面的新 api。 视频地址 RealityKit 新特性全面解析：从空间锚定到沉浸式交互引言RealityKit 作为苹果生态系统的 3D 内容开发框架，在 WWDC 2025 迎来了一系列重大更新。这些新特性不仅增强了 visionOS 的沉浸式体验，还将强大的 3D 交互能力扩展到了 iOS、iPadOS、macOS 和 tvOS 平台。本文将深入解析这些创新功能，并通过一个空间解谜游戏的开发案例，展示如何利用这些技术构建引人入胜的混合现实体验。 核心新特性概览1. 原生 ARKit 数据访问今年 RealityKit 开放了直接访问 ARKit 数据的接口，使开发者能更精准地控制虚实融合。 关键实现步骤：1234567// 配置空间追踪会话@State var spatialTrackingSession = SpatialTrackingSession()// 设置平面锚点实体let planeAnchor = AnchorEntity(.plane(.horizontal, classification: .table, minimumBounds: [0.15, 0.15])) 通过新的 AnchorStateEvents API，开发者可以实时响应锚点状态变化，如 DidAnchor 事件触发时获取平面变换矩阵和范围数据，实现精确定位。 2. 革命性交互组件ManipulationComponent 彻底改变了 3D 对象交互方式： 1234// 配置操作组件var manipulationComponent = ManipulationComponent()manipulationComponent.releaseBehavior = .stayentity.components.set(manipulationComponent) 该组件自动集成以下功能： 拾取检测（InputTarget） 碰撞体（Collision） 悬停效果（HoverEffect） 手势交互（Manipulation） 配合 ManipulationEvents 事件系统，可以精细控制物理模拟的启用时机： 123willBegin = content.subscribe(to: ManipulationEvents.WillBegin.self) &#123; event in // 切换物理模式为 kinematic&#125; 3. 环境理解与融合新增功能让虚拟对象更自然地与现实环境交互： 场景理解网格碰撞：123let configuration = SpatialTrackingSession.Configuration( sceneUnderstanding: [.collision, .physics]) 环境融合组件：1234entity.components.set( EnvironmentBlendingComponent(precedence: .normal, preferredBlendingMode: .occluded(by: .surroundings))) 4. 性能优化技术MeshInstancesComponent 实现了高效批量渲染： 123var meshInstancesComponent = MeshInstancesComponent()let instances = try LowLevelInstanceData(instanceCount: 20)meshInstancesComponent[partIndex: 0] = instances 该技术特别适合需要大量重复模型（如地板瓷砖、装饰物品）的场景，显著提升渲染效率。 沉浸式媒体增强图像呈现革新ImagePresentationComponent 支持三种模式： 传统 2D 图像 空间照片（立体图像） 3D 空间场景（带深度信息） 1let component = try await ImagePresentationComponent(contentsOf: url) 视频播放升级VideoPlayerComponent 新增支持： 空间视频 180度/360度全景视频 Apple 投影媒体格式 开发者工具完善SwiftUI深度整合新增组件简化UI开发： ViewAttachmentComponent：连接SwiftUI视图与3D实体 PresentationComponent：控制显示方式 GestureComponent：统一手势处理 资源加载优化 支持从内存Data直接加载模型 AVIF纹理格式（更小的文件体积，更好的质量） 骨架关节网格快速附着方法 实战案例：空间解谜游戏我们设计了一个包含以下要素的游戏体验： AR锚定：使用平面检测在桌面定位游戏 物理交互：可抓取翻转的物件寻找钥匙 环境融合：宝箱被真实桌面遮挡的效果 批量渲染：20个随机摆放的装饰石子 奖励效果：解锁后的粒子烟花系统 结论与展望2025年的RealityKit更新标志着苹果在空间计算领域的重大进步。通过： 更自然的交互组件 更深入的场景理解 更高效的渲染技术 更丰富的媒体支持 开发者现在能够构建质量更高、性能更好的跨平台3D体验。这些改进特别有利于： 教育类应用（实物交互模拟） 零售场景（AR产品展示） 游戏开发（沉浸式玩法） 工业设计（虚实融合原型） 相关视频 探索 visionOS 上的空间配件输入 搭配使用更出色：SwiftUI 和 RealityKit 支持 visionOS App 播放沉浸视频 推荐学习路径 先掌握基础锚定和交互功能 实验环境融合效果 优化项目性能（实例化渲染） 集成沉浸式媒体 适配多平台特性差异 建议从简单Demo开始，逐步添加复杂功能，充分利用Xcode的实时预览功能加速迭代过程。 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"实现 Metal 4 机器学习与图形应用程序的完美融合","date":"2025-06-10T07:35:55.000Z","path":"2025/06/10/2025-06-10-wwdc2025_262/","text":"了解如何使用 metal 4 将机器学习无缝融入你的图形应用程序中。我们将介绍用于在 gpu 时间线上连同渲染和计算工作一同运行模型的张量资源和 ml 编码器。了解如何使用着色器 ml 将神经网络直接嵌入着色器中，以实现高级效果和性能提升。我们还将通过示例 app 来展示适用于 metal 4 ml 工作负载的新调试工具的实际应用。 视频地址 Metal 4 机器学习与图形渲染的完美结合引言随着机器学习技术的飞速发展，游戏和图形领域正经历着一场革命。Metal 4 作为苹果强大的图形框架，现在提供了将机器学习无缝集成到图形应用程序的新方法。本文将详细介绍如何在 Metal 4 中利用机器学习增强图形渲染效果并提升性能。 Metal 4 机器学习核心特性1. 机器学习赋能图形技术机器学习正在通过以下方式改变图形处理： 超分辨率提升图像质量 更高效的资源压缩技术 智能动画混合 神经着色实现高级视觉效果 2. MTLTensor 张量资源MTLTensor 是 Metal 4 为机器学习工作流设计的新资源类型： 支持多维数据结构（超越传统纹理的4通道限制） 内置跨步(Stride)和维度信息简化索引 三种创建方式：12345678// 1. 从设备创建let tensorFromDevice = device.makeTensor(descriptor: desc)// 2. 从缓冲区创建let tensorFromBuffer = buffer.makeTensor(descriptor: desc)// 3. 从纹理创建let tensorFromTexture = texture.makeTensor(descriptor: desc) 3. 机器学习编码器MTL4MachineLearningCommandEncoder 允许在 GPU 时间线上同步运行完整网络： 离线准备阶段： 转换模型为 CoreML 格式 生成 MTLPackage 运行时阶段： 加载 MTLLibrary 配置管线状态 创建中间堆(Heap) 分派网络执行 4. 着色器 ML在着色器中直接嵌入小型神经网络的技巧： 包含 metal_tensor 头文件 通过缓冲区传递权重 使用 MPP 进行高效张量运算 典型应用场景： 神经材质压缩（减少50%内存） 全局光照优化 几何压缩 调试与优化Metal 4 提供了强大的调试工具： 依赖关系查看器：验证同步设置 张量查看器：检查输入/输出数据 ML 网络调试器：逐层分析中间结果 实战案例神经环境光遮蔽实现 使用 CoreML 转换预训练模型 在渲染管线中： 1234567// 创建 ML 管线状态let pipelineState = device.makeMLPipelineState(descriptor: mlDesc)// 在编码器中执行mlEncoder.setPipelineState(pipelineState)mlEncoder.setTensor(inputTensor, index: 0)mlEncoder.dispatch(gridSize: gridSize) 同步处理： 12// 使用屏障确保渲染等待ML输出renderEncoder.waitForStage(.machineLearning) 结论Metal 4 通过三大创新将机器学习深度整合到图形管线中： 专为ML设计的张量资源 全网络GPU时间线集成 着色器级微型网络嵌入 开发者现在可以： 在Xcode中全面调试ML工作负载 实现传统方法无法达到的视觉效果 获得显著的性能提升 相关视频 探索 Metal 4 探索 Metal 4 游戏 深入探索 Metal 4 游戏 用于打造沉浸式 App 的 Metal 渲染的新功能 利用 Metal 加快机器学习 基于 Apple GPU 训练机器学习和 AI 模型 文档资源 自定义 PyTorch 操作 Metal 性能着色器 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"将 SceneKit 项目移植到 RealityKit","date":"2025-06-10T07:35:16.000Z","path":"2025/06/10/2025-06-10-wwdc2025_288/","text":"了解为什么要弃用 scenekit，并探索如何将你的 3d 项目迁移至 realitykit 这一 apple 推荐的高级 3d 引擎。我们将阐明弃用 scenekit 对你的项目意味着什么，比较这两个引擎之间的关键概念，并向你展示如何将一个示例 scenekit 游戏移植到 realitykit。我们还将探讨 realitykit 在所有受支持平台上拥有的巨大潜力，以帮助你为 app 和游戏打造出精彩的 3d 体验。 视频地址 从 SceneKit 迁移到 RealityKit：完整指南引言随着苹果生态系统的不断发展，3D 开发框架也在不断演进。SceneKit 作为苹果早期的 3D 引擎已被 RealityKit 取代。本文将详细介绍如何将您的 SceneKit 项目迁移到 RealityKit，并解析两大框架的核心差异。 核心架构差异SceneKit 的节点式架构SceneKit 采用基于节点的架构设计： 每个场景对象都是 SCNNode 通过预定义属性实现功能 角色模型通过几何属性加载 动画通过动画播放器属性驱动 RealityKit 的实体组件系统RealityKit 使用现代的实体组件系统(ECS)： 每个对象都是 Entity 通过附加 Component 实现不同行为 模块化设计支持灵活扩展 更适合复杂场景和交互 资产迁移方案格式转换方法将 SCN 格式转换为 USDZ 格式的三种途径： 原生导出（推荐） 从原始建模工具直接导出 USD 格式 Xcode 转换 1231. 在 Xcode 中选择资产2. 文件 → 导出3. 选择 USDZ 格式 命令行工具 1xcrun scntool --convert max.scn --format usdz --append-animation max_spin.scn 场景构建新方式使用 Reality Composer Pro 创建新项目并导入资产 通过拖拽方式添加模型 使用变换工具精确定位 编辑材质和灯光效果 作为 Swift 包依赖添加到工程 关键功能实现对比动画系统123456// RealityKit 动画播放guard let max = scene.findEntity(named: &quot;Max&quot;), let library = max.components[AnimationLibraryComponent.self], let spinAnimation = library.animations[&quot;spin&quot;] else &#123; return &#125;max.playAnimation(spinAnimation) 光照系统12345// 带阴影的方向光let lightEntity = Entity(components: DirectionalLightComponent(), DirectionalLightComponent.Shadow()) 音频处理RealityKit 通过 AudioLibraryComponent 提供： 流式播放 循环模式 环境音效 空间音频 视觉特效 粒子系统：在 Reality Composer Pro 中创建 后期处理：使用 Metal 着色器实现高级效果123content.renderingEffects.customPostProcessing = .effect( BloomPostProcess()) 全平台支持优势RealityKit 支持所有苹果平台： iOS/iPadOS/macOS：标准 3D 渲染 tvOS：新增控制器支持 visionOS：原生空间计算支持 迁移策略建议 现有项目：可暂不迁移，SceneKit 仍可运行 新项目：优先选择 RealityKit 长期维护：SceneKit 仅修复关键 bug 相关视频 RealityKit 的新功能 利用 RealityKit 音频让空间计算 App 更加引人入胜 在 Reality Composer Pro 中编写交互式 3D 内容 认识 Reality Composer Pro 结语迁移到 RealityKit 不仅能让您的应用获得更好的性能和支持，还能充分利用苹果最新的 3D 技术特性。建议开发者根据项目情况制定合适的迁移计划，充分利用 RealityKit 提供的现代化工具链和全平台支持能力。 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"图形和游戏","slug":"图形和游戏","permalink":"http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"}]},{"title":"Apple 设备管理和身份管理方面的新动向","date":"2025-06-10T07:34:41.000Z","path":"2025/06/10/2025-06-10-wwdc2025_258/","text":"本次讲座主要面向 it 管理员、mdm 开发者和身份提供商，内容涵盖声明式设备管理、apple 商务管理、apple 校园教务管理、平台单点登录等方面的最新更新。了解如何利用这些改进来简化部署流程、增强安全性，并提升用户体验。 视频地址 Apple设备管理与身份管理的全面革新引言作为IT管理员或MDM开发者，您是否在寻找更高效的Apple设备管理方案？在2025年的WWDC大会上，Apple带来了众多激动人心的新功能，从声明式设备管理到身份集成，每一项革新都旨在简化部署流程、增强安全性并提升用户体验。 Apple服务更新托管式Apple账户托管式Apple账户是为工作/教育场景设计的专属账户，IT部门拥有完全控制权。今年新增： 账户列表下载功能，便于批量通知用户升级 组织设备上禁止个人Apple账户登录 分步实施建议：域名锁定→账户捕获→联邦认证→启用服务 设备清单增强设备清单信息更加丰富： 新增蜂窝网络信息(IMEI/EID) 即将推出蓝牙/Wi-Fi的Mac地址 AppleCare保修状态查询 突破性API开放Apple商务管理和校园教务管理首次开放API： 首批提供设备清单查询和MDM服务器分配功能 通过创建API账户并使用私钥访问 部署改进 Vision Pro支持通过iPhone的Apple Configurator加入组织 账户驱动注册优化：自动发现MDM服务器端点 设备管理迁移：无需擦除即可切换MDM服务器 设备管理增强软件更新声明式软件更新扩展至： Vision Pro Apple TV逐步淘汰传统MDM软件更新方式 Safari管理新增声明式配置： 书签管理 默认主页设置整合原有Safari限制配置 恢复服务优化共享设备场景改进： iPhone/iPad重置保留托管应用 Vision Pro新增”为下位用户重置”选项 控制中心10秒倒计时或锁定界面操作 应用管理新能力iOS/iPadOS应用控制托管应用配置新增： 逐应用定义更新行为 实时安装进度监控 蜂窝数据下载限制 macOS应用部署macOS Tahoe引入： 声明式管理App Store应用 自定义应用和包部署 安装状态报告 ManagedApp框架开发者新工具： 安全部署应用配置 获取API令牌 添加自定义证书 访问硬件密钥 身份集成改进平台SSO优化Mac设置助手整合： 自动设备注册时完成SSO配置 同步本地账户密码或使用安全enclave密钥 账户头像同步功能 认证访客模式共享设备新方案： 直接使用云身份登录 登出自动清除数据 “自动推进”静默完成配置 轻触登录医疗等行业优化： Mac支持NFC读卡器配置 企业工牌/学校ID快速登录 通行证密钥存储在安全enclave 总结与行动建议2025年的Apple设备管理革新覆盖了从基础服务到高级集成的各个环节。我们建议： 立即评估托管Apple账户新功能 探索API自动化可能性 开始迁移到声明式应用管理 为Vision Pro部署做好准备 实施平台SSO优化登录体验 相关视频 了解 ManagedApp 框架 借助 NetworkExtension 优化网络流量过滤和隧道 文档 Apple School Manager User Guide ManagedApp Support - Apple Platform Deployment 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"商务-&-教育","slug":"商务-教育","permalink":"http://djs66256.github.io/tags/%E5%95%86%E5%8A%A1-%E6%95%99%E8%82%B2/"}]},{"title":"了解 ManagedApp 框架","date":"2025-06-10T07:34:34.000Z","path":"2025/06/10/2025-06-10-wwdc2025_203/","text":"了解 managedapp 框架如何帮助你的 app 适应受管理环境。我们将介绍如何接收配置数据、如何安全地管理 app 密钥，以及如何根据组织提供的设置来定制 app 的行为。我们还将通过一些真实示例来说明如何为企业和教育环境打造更灵活、更易于管理的 app。 视频地址 使用 ManagedApp 框架优化企业应用管理体验引言在企业和教育环境中，苹果设备的应用部署与管理面临诸多挑战。传统设置流程复杂，用户体验不佳，技术支持成本高昂。苹果推出的 ManagedApp 框架为开发者提供了全新的解决方案，让应用能自动完成配置和安全认证，显著提升管理效率和用户体验。 ManagedApp 框架核心功能自动化配置管理ManagedApp 框架允许管理员通过 MDM 服务器预先配置应用，支持四种数据类型： 应用专属配置（任意支持的数据类型） 密码 证书 身份凭证（包括PKCS#12文件、SCEP身份和ACME身份） 所有数据都安全存储，仅提供给指定的应用或扩展程序。当应用启动时，它可以立即获取这些配置数据并应用，无需用户手动设置。 简化开发和部署流程开发者只需完成三个关键步骤： 编写配置解码器 实现配置应用和密钥使用的代码 发布应用配置规范 框架将配置规范的定义权完全交给开发者，使他们能够根据应用特性设计最合适的配置方案。 典型应用场景ManagedApp 框架特别适用于以下场景： 许可证管理：提供更安全的加密身份凭证替代传统许可证令牌 VPN扩展：支持硬件绑定认证密钥，确保只有授权设备能连接网络 身份提供商：结合扩展单点登录(SSO)，支持多种认证材料类型 开发实践指南配置处理示例以”地标”教学应用为例，开发者可以： 定义可配置项（如教师预设的地标集合） 创建Decodable配置结构体 使用ManagedAppConfigurationProvider的异步序列接收配置 1let identity = try? await ManagedAppIdentitiesProvider.shared.identity(for: &quot;landmarks-asset-downloader&quot;) 最佳实践建议 保持配置数据量在KB级，大文件通过配置中的URL下载 每次使用时获取最新密钥，避免持久化存储 提供细粒度配置选项而非单一”管理模式”开关 确保解码器能处理旧配置并忽略未知新键值 考虑添加演示模式或提交功能演示视频 提供从旧配置方式到新框架的迁移路径 文档规范开发者需要发布配置规范文档，内容应包括： 配置格式示例（属性列表形式） 有效值范围 可能的解码错误代码 支持的密钥标识符及其用途说明 总结ManagedApp 框架为企业和教育环境的应用部署提供了革命性的简化方案。通过自动化配置和安全认证流程，开发者可以显著提升用户体验，降低技术支持成本，同时保持高度的安全性和灵活性。 相关视频 Apple 设备管理和身份管理方面的新动向 文档 Apple School Manager User Guide ManagedApp Support - Apple Platform Deployment 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"商务-&-教育","slug":"商务-教育","permalink":"http://djs66256.github.io/tags/%E5%95%86%E5%8A%A1-%E6%95%99%E8%82%B2/"}]},{"title":"watchOS 26 的新功能","date":"2025-06-10T07:34:19.000Z","path":"2025/06/10/2025-06-10-wwdc2025_334/","text":"了解 watchos 26 的新功能，以及如何将这些功能整合到你的 watchos 和 ios app 中。探索 arm64 架构，并深入了解全新设计系统。我们还将介绍小组件方面的更新，并就如何将控件引入 apple watch 提供一些建议。 视频地址 watchOS 26 新功能全面解析：从设计革新到情境化智能引言watchOS 26带来了从内到外的全方位革新，为开发者提供了更强大的工具和更丰富的展示场景。本文将深入解析这些新特性，帮助您更好地将应用融入Apple Watch生态。 watchOS 26核心升级全新设计系统watchOS 26采用了全新的设计语言，包含： 材质与控件的视觉更新 应用图标重新设计 系统界面全面优化 开发建议： 在watchOS 10+上运行应用验证兼容性 检查自定义样式在新系统中的表现 ARM64架构支持Apple Watch Series 9/Ultra 2现已支持ARM64架构，开发时需注意： 使用Xcode标准架构构建设置 处理Float/Int类型差异及指针运算 进行真机和模拟器双重测试 12// 标准架构设置示例// Xcode 14+已原生支持ARM64构建 拓展应用交互场景控制系统革新用户现在可以通过多种方式使用控件： 添加到控制中心/智能叠放 绑定Ultra系列的操作按钮 内容展示策略智能叠放新增支持三种内容类型： 控件(快速操作) 小组件(持续信息展示) 实时活动(时效性事件) 开发示例：1234567891011struct ConfigurableMeditationControl: ControlWidget &#123; var body: some ControlWidgetConfiguration &#123; AppIntentControlConfiguration( kind: WidgetKinds.configurableMeditationControl, provider: Provider() ) &#123; value in // 控件内容实现 &#125; .promptsForUserConfiguration() &#125;&#125; 情境化智能体验RelevanceKit框架通过上下文线索智能推荐内容，支持的情境类型包括： 时间日期 睡眠状态 健身数据 地理位置 实现示例：123456func relevance() async -&gt; WidgetRelevance&lt;Void&gt; &#123; guard let context = RelevantContext.location(category: .beach) else &#123; return WidgetRelevance&lt;Void&gt;([]) &#125; return WidgetRelevance([WidgetRelevanceAttribute(context: context)])&#125; 相关小组件开发分三步实现情境化小组件： 定义RelevanceEntry数据结构 实现RelevanceEntriesProvider 配置关联的时间线小组件 1234567891011struct BeachEventWidget: Widget &#123; var body: some WidgetConfiguration &#123; RelevanceConfiguration( kind: &quot;BeachWidget&quot;, provider: BeachEventRelevanceProvider() ) &#123; BeachWidgetView(entry: $0) &#125; .associatedKind(WidgetKinds.beachEventsTimeline) &#125;&#125; 总结与建议watchOS 26通过设计革新、ARM64支持和情境化智能等功能，为开发者提供了更丰富的可能性。建议您： 适配新设计系统 优化ARM64架构兼容性 充分利用情境化智能功能 相关视频 了解 Liquid Glass 使用 Icon Composer 构建图标 小组件的新功能 文档资源 创建系统级控件 增强智能叠放可见性 构建可配置小组件 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"健康与运动","slug":"健康与运动","permalink":"http://djs66256.github.io/tags/%E5%81%A5%E5%BA%B7%E4%B8%8E%E8%BF%90%E5%8A%A8/"}]},{"title":"将 Swift Charts 扩展成三维图表","date":"2025-06-10T07:34:18.000Z","path":"2025/06/10/2025-06-10-wwdc2025_313/","text":"了解如何使用 chart3d 将你的 2d swift charts 转换为三维图表，从全新角度直观呈现你的数据集。绘制 3d 数据图表，以可视化方式显示数学表面，并对摄像头、材质等各种因素进行自定，让你的 3d 图表更加清晰直观、赏心悦目。 为了充分从这个讲座中获益，我们建议你先熟悉一下如何创建 2d swift charts。 视频地址 探索 Swift Charts 的三维可视化能力引言Swift Charts 是 Apple 提供的一个强大框架，用于创建直观精美的图表。在 iOS、macOS 和 visionOS 26 中，Swift Charts 迎来了令人振奋的新功能 - 三维图表支持。本文将带您了解如何将二维图表升级为三维，绘制三维数学曲面，以及如何定制三维图表的外观和行为。 从二维到三维的转变Swift Charts 的二维图表已经广泛应用于天气应用、系统设置等多个场景。现在，通过 Chart3D 视图，我们可以轻松地将二维图表升级为三维： 12345678910111213141516// 二维图表Chart &#123; PointMark( x: .value(&quot;Flipper Length&quot;, penguin.flipperLength), y: .value(&quot;Body Mass&quot;, penguin.bodyMass) )&#125;// 三维图表Chart3D &#123; PointMark( x: .value(&quot;Flipper Length&quot;, penguin.flipperLength), y: .value(&quot;Body Mass&quot;, penguin.bodyMass), z: .value(&quot;Beak Length&quot;, penguin.beakLength) )&#125; 这种转变让用户可以从全新的视角探索和理解数据，特别是对于本身就具有三维特征的数据集。 曲面图(SurfacePlot)的应用SurfacePlot 是 Chart3D 的独家功能，它是 LinePlot 的三维扩展，非常适合绘制包含两个变量的数学曲面： 12345Chart3D &#123; SurfacePlot &#123; x, z in x * z &#125;&#125; 您可以在 SurfacePlot 中实现任意复杂的数学表达式：123SurfacePlot &#123; x, z in sin(x * .pi) * cos(z * .pi)&#125; SurfacePlot 也适用于数据可视化，比如展示企鹅体征数据的线性回归关系：123SurfacePlot &#123; flipperLength, beakLength in LinearRegression.predictBodyMass(flipperLength: flipperLength, beakLength: beakLength)&#125; 三维图表定制技巧Chart3D 提供了丰富的定制选项： 调整初始姿态： 123.chart3DPose(.front) // 预设视角// 或自定义视角.chart3DPose(Pose3D(azimuth: .degrees(45), elevation: .degrees(30))) 投影方式选择： 12.chart3DProjection(.orthographic) // 正交投影(默认).chart3DProjection(.perspective) // 透视投影 曲面样式定制： 123456// 渐变着色.foregroundStyle(.ellipticalGradient(colors: [.red, .green, .blue]))// 基于高度着色.foregroundStyle(heightBased: [.red, .green, .blue])// 基于法线角度着色.foregroundStyle(normalBased: [.red, .green, .blue]) 三维图表的应用建议虽然三维图表提供了新的数据视角，但需要注意： 三维图表的可读性高度依赖交互操作 评估交互体验是否对您的应用场景必不可少 二维与三维图表可以互补使用 特别是在 Vision Pro 上，三维图表能够提供惊艳的视觉效果和交互体验。 结论Swift Charts 的三维功能为数据可视化开辟了新的可能性。通过 PointMark、RuleMark、RectangleMark 和 SurfacePlot 的组合使用，结合丰富的定制选项，开发者可以创建出独具特色的三维可视化方案。 相关视频 Swift Charts：矢量图与函数图 利用图表设计 App 体验 设计实用高效的图表 文档 Swift Charts 官方文档 Swift Charts 更新日志 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"提升 iPad App 设计","date":"2025-06-10T07:33:50.000Z","path":"2025/06/10/2025-06-10-wwdc2025_208/","text":"让你的 app 在 ipados 上呈现出色观感。了解设计响应式布局的最佳实践，轻松创建可调整大小的窗口。熟悉窗口控件，并探索适配不同窗口控件的最佳方式。了解出色菜单栏的构建要素。此外，探索全新指针及其效果更新。 视频地址 提升 iPad 应用设计体验：从导航到窗口系统的全面优化引言随着 iPadOS 26 的发布，Apple 为开发者带来了一系列强化应用设计的新特性。从流畅的多任务处理到精准的指针交互，这些改进让 iPad 应用能够呈现更专业的用户体验。本文将深入解析 iPad 应用设计的核心优化要点，帮助你打造更出色的应用。 导航设计的最佳实践选择合适的导航模式是提升用户体验的第一步。iPad 提供了两种主要导航方案： 侧边栏：适合包含大量子视图或深层嵌套内容的应用（如邮件和音乐应用） 标签栏：更紧凑灵活的导航方案，能为内容展示留出更多空间 关键建议： 优先考虑标签栏方案，它可以随时扩展为侧边栏 确保导航系统能够适应不同屏幕尺寸 通过”滚动边缘效果”扩展内容区域，充分利用屏幕空间 全新窗口系统解析iPadOS 26 带来了革命性的窗口系统改进： 拖拽手柄：右下角的拖拽手柄让用户可以轻松创建浮动窗口 窗口控件：左上角的新型控件点击放大功能选项，长按则展开更多布局选择 增量式窗口：每个文档都会在独立窗口中开启，取代原有的”原位替换”逻辑 开发建议： 让工具栏环绕窗口控件排列，避免预留安全区域 为每个文档创建独立窗口 为所有窗口设置描述性名称 指针交互的升级iPadOS 26 的指针系统实现了质的飞跃： 1:1 输入跟踪：新型指针比前代更加精准跟手 “液态玻璃”高亮效果：悬停时会直接在控件上方显现，通过折射底层元素指示选中状态 无磁吸效应：新效果不再有磁吸特性，操作更加自然流畅 适配建议：全面测试应用与新指针的交互表现，确保最佳用户体验。 菜单栏设计指南虽然菜单栏是 macOS 的经典元素，但 iPad 版有其独特性： 科学组织菜单项：按使用频率排序，关联操作分组显示 充实”查看”菜单：纳入标签页布局和侧边栏开关 保持一致性：为菜单项添加与应用内保持一致的图标 稳定性原则：永远不要隐藏菜单或菜单项，仅做淡化处理 总结通过整合这些设计元素，你的 iPad 应用将获得： 更流畅的导航体验 更强大的多任务处理能力 更精准的指针交互 更高效的菜单访问 这些构建模块的组合将产生远超单个功能之和的价值，真正提升你的应用体验层次。 相关文档 人机界面指南：多任务处理 人机界面指南：菜单栏 人机界面指南：窗口系统 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"采用 Swift 并发","date":"2025-06-10T07:33:32.000Z","path":"2025/06/10/2025-06-10-wwdc2025_268/","text":"与我们一起了解 swift 并发方面的核心概念。并发可帮助你提高 app 的响应速度和性能，而 swift 旨在让正确编写异步和并发代码变得更加简单。我们会介绍将 app 编程从单线程转换为并发流程所需的步骤。无论你想让代码更加异步化、将代码移到后台，还是在并发任务中共享数据，我们都将帮助你确定充分利用 swift 并发功能的恰当方式和时机。 视频地址 掌握 Swift 并发编程：从单线程到高效并发的演进之路引言在当今移动应用开发中，响应速度和性能表现至关重要。Swift 并发模型为开发者提供了强大的工具，使异步与并发代码的编写变得简单可靠。本文将带您了解如何从单线程应用逐步演进到高效的并发架构，并介绍 Swift 并发模型的各种特性和最佳实践。 单线程基础所有 Swift 程序默认在主线程运行，这是最简单的开发模式： 1234567var greeting = &quot;Hello, World!&quot;func greet() &#123; print(greeting)&#125;greet() 这种单线程模式具有以下优势： 简单性：同一时间只执行一个操作 安全性：无需担心并发访问问题 维护性：代码逻辑更直观易懂 Swift 默认使用 @MainActor 保护主线程代码，这意味着编译器会自动确保这些内容只在主线程访问。 异步任务处理当需要处理网络请求等耗时操作时，异步编程可以显著提升用户体验： 12345func fetchAndDisplayImage(url: URL) async throws &#123; let (data, _) = try await URLSession.shared.data(from: url) let image = decodeImage(data) view.displayImage(image)&#125; 使用 async/await 语法时： async 标记可能暂停的函数 await 标识潜在的暂停点 系统会在等待时自动释放线程资源 任务交错与并发多个任务可以交错执行，充分利用系统资源： 123456789func onTapEvent() &#123; Task &#123; do &#123; try await fetchAndDisplayImage(url: url) &#125; catch let error &#123; displayError(error) &#125; &#125;&#125; Swift 的并发模型特点： 每个 Task 独立执行特定操作 系统自动管理任务调度 暂停的任务会让出线程给其他就绪任务 后台执行与数据安全当主线程负载过高时，可以将工作移至后台： 1234@concurrentfunc decodeImage(_ data: Data) async -&gt; Image &#123; Image()&#125; 处理数据安全的关键点： 使用 Sendable 协议确保线程安全 值类型(URL, Data)天然线程安全 引用类型需要特别注意并发访问 Actor 模型对于复杂的并发需求，可以使用 Actor 隔离共享状态： 1234567actor NetworkManager &#123; var openConnections: [URL: Connection] = [:] func openConnection(for url: URL) -&gt; Connection &#123; // 线程安全的连接管理 &#125;&#125; Actor 的特性： 内部数据自动隔离保护 不绑定特定线程 可以创建多个实例 适合非UI子系统 总结与最佳实践Swift 并发编程的演进路径： 从单线程开始，保持简单 引入异步任务处理高延迟操作 使用并发减轻主线程负担 采用 Actor 管理后台数据 推荐做法： 先用性能分析工具定位瓶颈 逐步引入并发特性 启用”Approachable Concurrency”构建选项 主模块默认使用 MainActor 隔离 Swift 并发是提升应用性能的强大工具，但并非所有应用都需要复杂的并发架构。明智的做法是根据实际需求逐步引入适当的并发特性。 相关视频 跟着视频学编程：使用 Swift 并发机制提升 App 性能 超越结构化并发的基础 文档 Swift Migration Guide 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"提升 App 的多语言体验","date":"2025-06-10T07:33:27.000Z","path":"2025/06/10/2025-06-10-wwdc2025_222/","text":"为使用多种语言的用户打造顺畅体验。了解语言发现功能如何以用户偏好的语言优化你的 app。探索为从右至左显示的语言提供支持的最新进展，包括用来在双向文本中选择多个范围的自然选择。我们还将介绍在你的 app 中支持多语言场景的最佳实践。 视频地址 提升应用多语言体验：iOS 26新功能全解析引言在全球化的数字时代，打造优秀的应用需要考虑语言多样性。iOS 26带来了一系列强化多语言支持的新特性，让开发者能够为用户提供更自然的跨语言体验。本文将介绍语言自动识别、替代日历支持和双向文本处理三大核心改进，帮助您构建更具包容性的国际化应用。 语言自动识别：智能化多语言支持在iOS 26中，系统可以智能识别用户的多语言使用习惯。新推出的Arabizi音译键盘和双语建议功能极大降低了阿拉伯语等语言的输入门槛。 开发者在代码层面可以通过以下方式获取用户语言偏好： 123456789101112let preferredLocales = Locale.preferredLocaleslet availableLocales = getAvailableLocalesForTranslatingFrom()var matchedLocales: [Locale] = []for locale in availableLocales &#123; for preferredLocale in preferredLocales &#123; if locale.language.isEquivalent(to: preferredLocale.language) &#123; matchedLocales.append(locale) break &#125; &#125;&#125; 新API Locale.preferredLocales 相比传统的 Locale.preferredLanguages 提供了更丰富的本地化数据，建议开发者尽快迁移使用。 更全面的替代日历支持iOS 26新增了11种替代日历，包括： 古吉拉特语日历 马拉地语日历 韩语日历等 目前Foundation框架的Calendar.Identifier共支持27种日历系统，让全球用户都能按自己的文化习惯查看日期。 革命性的双向文本处理双向文本(混合从左至右和从右至左文本)的处理在iOS 26中获得了重大改进： 自然选择技术：文本选择不再受存储顺序限制，实现了视觉连贯的跨语言选择体验 多选区支持：通过selectedRanges属性(将取代selectedRange)支持非连续选区 需要文本编辑功能的开发者应调整代码如下： 1234let ranges = textView.selectedRanges.reversed()for range in ranges &#123; textView.textStorage.deleteCharacters(in: range)&#125; TextKit2是这些改进的基础，开发者应使用textLayoutManager而非layoutManager来保持完整功能。 结论iOS 26的多语言增强特性让应用能够： 更智能地适配用户语言偏好 提供更多本地化日历选择 更自然地处理双向文本 开发者应尽快采用这些新技术，为全球用户打造更完美的使用体验。 相关视频 跟着视频学编程：使用 SwiftUI 和 AttributedString 精心打造富文本体验 构建支持多语言的 App 向左语言 文档 人机交互指南：从右至左布局 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"使用全新设计系统构建 AppKit App","date":"2025-06-10T07:33:19.000Z","path":"2025/06/10/2025-06-10-wwdc2025_310/","text":"更新你的 appkit app，以便充分利用全新设计系统。我们将深入探索标签视图、分屏浏览、栏、演示文稿、搜索和控制项等方面的主要变化，并向你展示如何在自定 ui 中使用 liquid glass。为了充分从这个视频中获益，建议你先观看“了解全新设计系统”以获取一般性设计指导。 视频地址 适配macOS全新设计系统：从玻璃材质到控件升级引言macOS全新设计系统带来了视觉体系的全面革新，液态玻璃材质和重新设计的控件为Mac应用树立了新标准。本文将深入解析如何将您的AppKit应用升级至这一系统，涵盖工具栏、分屏布局、控件优化等关键变化，以及如何巧妙运用液态玻璃效果提升用户体验。 核心设计理念液态玻璃材质成为新系统的明星元素，其半透明特性能够动态反射和折射光线，赋予界面立体层次感。这种材质被广泛应用于窗口结构组件，如悬浮工具栏和边栏，创建出独具特色的视觉深度。 工具栏升级技巧 自动分组逻辑：AppKit会根据控件类型自动将相关操作分组到同一玻璃面板 外观自适应：玻璃材质会根据下层内容智能调整浅色/深色主题 突出显示技术：1234// 使用强调色突出重要操作toolbarItem.style = .prominent// 自定义着色toolbarItem.backgroundTintColor = .systemGreen 窗口结构与布局优化新系统采用”同心圆嵌套”设计理念，窗口圆角半径与内部元素保持和谐比例关系。关键改进包括： 安全区域管理123456// 避免内容与圆角重叠的布局示例let safeArea = layoutGuide(for: .safeArea(cornerAdaptation: .horizontal))NSLayoutConstraint.activate([ safeArea.leadingAnchor.constraint(equalTo: button.leadingAnchor), safeArea.trailingAnchor.constraint(greaterThanOrEqualTo: button.trailingAnchor)]) 控件系统全面升级macOS Tahoe带来了焕然一新的控件家族： 尺寸阶梯扩展：新增超大尺寸，用于强调核心操作 形状自适应：从圆角矩形到胶囊形状的智能转换 突出度控制：通过tintProminence属性精细调整视觉权重123// 设置不同突出度级别shuffleButton.tintProminence = .secondaryplayButton.keyEquivalent = &quot;\\r&quot; // 自动获取主要突出度 液态玻璃材质实践在自定义UI中应用玻璃效果时，需遵循”顶层悬浮”原则： 12345678// 创建玻璃效果视图的正确方式let glassView = NSGlassEffectView()glassView.contentView = customContentViewglassView.cornerRadius = 10// 多个玻璃元素的组合技巧let container = NSGlassEffectContainerView()container.contentView = stackOfGlassViews 结语升级到全新设计系统不仅是视觉焕新，更是提升用户体验的重要机遇。建议从工具栏改造开始，逐步应用无边滚动布局，最后为关键控件添加液态玻璃效果。记住：好的设计应当强化功能，而非分散注意力。 相关视频 了解液态玻璃 了解全新设计系统 文档 Adopting Liquid Glass Human Interface Guidelines: Designing for macOS 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"小组件的新功能","date":"2025-06-10T07:32:49.000Z","path":"2025/06/10/2025-06-10-wwdc2025_278/","text":"widgetkit 带来小组件、实时活动以及控制方面的众多更新，助你提升 app 性能。了解如何将小组件引入 visionos，如何利用 carplay 车载让小组件在驾驶途中也能顺畅使用，以及如何使用强调渲染模式优化小组件的视觉效果。此外，探索如何让相关小组件呈现在 watchos 的智能叠放中，以及如何使用推送通知确保小组件保持最新。 视频地址 WidgetKit 新特性全解析：打造跨平台智能小组件体验引言随着 iOS 17 和 visionOS 的推出，WidgetKit 迎来了重大更新。小组件不再只是简单的信息展示窗口，而是成为连接用户与应用的核心桥梁。本文将深入解析如何利用 WidgetKit 的新特性，为您的应用打造更智能、更沉浸的小组件体验。 视觉革新：强调渲染模式iOS 17 引入了全新的”透明玻璃”风格小组件呈现方式。这种视觉体系的核心是强调渲染模式，它会自动将小组件内容转为白色调，并替换背景为符合主题的玻璃或着色效果。 优化技巧对于包含复杂视觉元素的小组件，可以使用 widgetAccentedRenderingMode 修饰符精确控制呈现效果： 1234Image(entry.beverageImage) .resizable() .widgetAccentedRenderingMode(.desaturated) .aspectRatio(contentMode: .fill) 支持五种渲染模式： nil: 应用主色调 .accented: 应用强调色 .desaturated: 去饱和度处理 .accentedDesaturated: 复合效果 .fullColor: 原色显示 visionOS 小组件开发visionOS 26 首次支持小组件功能，具有以下特性： 123456789101112131415struct CaffeineTrackerWidget: Widget &#123; var body: some WidgetConfiguration &#123; StaticConfiguration( kind: &quot;BaristaWidget&quot;, provider: Provider() ) &#123; entry in CaffeineTrackerWidgetView(entry: entry) &#125; .configurationDisplayName(&quot;咖啡因追踪&quot;) .description(&quot;记录每日咖啡因摄入量的小组件&quot;) .supportedMountingStyles([.elevated]) .widgetTexture(.paper) .supportedFamilies([.systemExtraLargePortrait]) &#125;&#125; 关键配置项： supportedMountingStyles: 悬浮或嵌入风格 widgetTexture: 材质选择（玻璃/纸质） systemExtraLargePortrait: 新增特大尺寸 跨平台适配策略各平台新增支持： CarPlay: 仪表盘小组件叠放 macOS Tahoe: iPhone 实时活动镜像 watchOS 26: 控制中心/操作按钮/智能叠放三位置控件 相关性小组件(RelevanceConfiguration) 内容更新机制三种更新方式确保信息实时性： 定时重载(TimelineReloadPolicy) 应用主动触发(WidgetCenter API) 服务器推送(WidgetPushHandler) 12345struct CaffeineTrackerPushHandler: WidgetPushHandler &#123; func pushTokenDidChange(_ pushInfo: WidgetPushInfo, widgets: [WidgetInfo]) &#123; // 向服务器注册推送令牌 &#125;&#125; 推送请求格式：12345&#123; &quot;aps&quot;: &#123; &quot;content-changed&quot;: true &#125;&#125; 结语WidgetKit 的新特性为开发者提供了更丰富的工具集，让小组件能在更多场景中发挥价值。无论是视觉优化、跨平台适配还是实时更新，这些改进都将显著提升用户体验。建议开发者根据应用特性，选择最适合的新功能进行集成。 相关视频 针对 CarPlay 车载优化你的 App 针对 visionOS 设计小组件 watchOS 26 的新功能 为 Apple Watch 设计实时活动 文档资源 提升智能叠放中的小组件可见性 优化强调渲染模式和玻璃效果 通过推送通知更新小组件 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"SF Symbols 7 的新功能","date":"2025-06-10T07:32:12.000Z","path":"2025/06/10/2025-06-10-wwdc2025_337/","text":"探索 apple 图标资料库 sf symbols 的最新更新。了解全新动画系统 draw，让符号模仿手写笔画自然的流畅性；还有用来表示强度或进度的 variable draw。探索为符号增添立体感和视觉吸引力的 gradients，以及在相关符号间增强连贯性的魔术替换增强功能。此外，了解如何预览并将这些功能整合到自己的 app 中。 视频地址 SF Symbols 7 全新功能解析：从动态绘制到渐变渲染引言苹果设计团队的成员 Kelsey 在 WWDC 上揭晓了 SF Symbols 7 的一系列创新功能。作为苹果生态系统中的核心图标资源库，SF Symbols 7 带来了革命性的动态绘制系统、增强的魔术替换、渐变渲染效果等多项改进。本文将带您深入了解这些新特性及其应用场景。 绘制(Draw)系统：让图标”活”起来SF Symbols 7 最引人注目的创新是全新的 Draw 系统，它能让图标沿预设路径呈现生动的绘制动画： 核心动画预设 绘制出现(Draw On)：图标在屏幕上动态绘制成形 绘制消失(Draw Off)：图标以绘制方式淡出 三种播放模式： 按图层(By Layer)：路径错开起始时间 整体符号(Whole Symbol)：所有图层同步绘制 逐层(Individually)：前一层完成后再开始下一层 可变绘制渲染这是 Draw 系统的进阶功能，通过显示特定进度的路径绘制来表示强度或进度，适用于： 下载进度显示 温度指示器 课程完成度追踪 123// SwiftUI 中使用 Draw 动画的示例代码Image(systemName: &quot;arrow.right&quot;) .symbolEffect(.appear, isActive: isActive) 魔术替换(Magic Replace)增强SF Symbols 7 优化了关联符号间的转场效果： 系统识别匹配的外框容器，转场时只替换差异图层 支持 Draw 的符号自动应用 Draw Off 和 Draw On 动画 结合外框匹配技术，实现更流畅的视觉过渡 渐变效果(Gradients)深度解析渐变渲染为符号增添了立体感和视觉吸引力： 使用单一源色生成平滑线性渐变 支持系统色和自定义色 适用于所有渲染模式 在大尺寸显示时效果尤为突出 1234// 在 SwiftUI 中启用渐变效果Image(systemName: &quot;cloud.fill&quot;) .symbolRenderingMode(.multicolor) .foregroundStyle(.blue.gradient) 自定义符号标注指南要充分利用这些新功能，需要正确标注自定义符号： 绘制标注要点 每条路径至少需要两个引导点（起点和终点） 复杂路径需要额外引导点填补间隙 锐角转折处需要特殊拐角点 多路径符号每条路径都适用相同规则 实用技巧 使用自适应端帽改善绘制效果 对于中心对称符号，从中心双向绘制 通过引导点上下文菜单调整绘制方向 使用引导点编号检查标注顺序 API 更新速览SF Symbols 7 提供了新的 API 支持： 新增 symbolEffect 修饰符调用动画预设 可变绘制通过 variableValue 参数控制 渐变渲染在 SwiftUI 中通过视图修饰符设置 结论与下一步行动SF Symbols 7 通过 Draw 系统、魔术替换增强、渐变效果等功能，为开发者提供了更丰富的视觉表达工具。建议您： 立即下载 SF Symbols 7 测试版体验新功能 检查现有自定义符号的标注兼容性 参考框架文档了解具体实现细节 这些创新功能将帮助您打造更具表现力和交互性的应用界面。 相关视频 SF Symbols 6 的新功能 文档资源苹果官方 SF Symbols 文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"使用 Icon Composer 构建图标","date":"2025-06-10T07:32:04.000Z","path":"2025/06/10/2025-06-10-wwdc2025_361/","text":"了解如何使用 icon composer 为 ios、ipados、macos 和 watchos 构建最新 app 图标。探索如何从你选择的设计工具中导出素材，将它们添加到 icon composer 中，应用实时玻璃属性和其他效果，以及预览不同平台和外观模式下的显示效果并进行调整。 视频地址 使用 Icon Composer 轻松打造跨平台应用图标引言在2025年，随着iOS、macOS和watchOS的外观模式不断丰富，应用图标设计迎来了新的挑战与机遇。Apple推出的Icon Composer工具，让开发者能够通过单一文件为所有Apple平台创建完美适配的图标，同时支持多种外观模式的实时预览和调整。本文将详细介绍Icon Composer的工作流程和实用技巧。 Icon Composer概述Icon Composer是Apple最新推出的图标设计工具，它能够： 通过单一设计文件为iPhone、iPad、Mac和Apple Watch生成差异化呈现 实时预览六种全新外观模式（默认、深色、透明浅色、透明深色、着色浅色、着色深色） 自动适配不同设备尺寸，告别繁琐的多尺寸图标制作 应用Liquid Glass技术，赋予图标动态生命力 工作流程详解1. 在设计工具中创作推荐使用矢量绘图工具（如Illustrator）进行设计，并采用分层设计原则： 每个图层代表Z轴深度层级 背景为底层，其余图像逐层叠加 简单图标（如”信息”App）只需前景加背景 复杂设计（如”家庭”App）可能需要更多分层 设计建议： 使用Apple设计资源网站提供的图标模板 iPhone/iPad/Mac统一采用1024px画布 Watch采用1088px画布 为不同图层设置差异颜色，便于后期调整 2. 导出图层将图层导出为SVG文件时需注意： 确保画布尺寸准确 按Z轴顺序编号图层 背景色和渐变无需手动导出 文本需转为轮廓 复杂元素导出为PNG（保留透明背景） 切勿在导出文件中添加圆角或圆形蒙版 3. 导入Icon Composer调整Icon Composer界面分为三部分： 左侧边栏：画布、分组与图层管理 中央预览区：多平台/模式效果展示 右侧检查器：外观属性与文档设置调整 实用调整技巧： 设置画布背景（建议使用系统预设的优化配色） 每层可应用独立玻璃效果 关闭狭窄元素的镜面效果提升清晰度 深色模式需重点调整填充色 单色模式至少保留一个白色元素确保辨识度 4. 保存并导入Xcode完成调整后： 保存为.icon文件 导入Xcode 项目编辑器选择图标后，应用将自动适配各平台与外观模式 设计技巧与注意事项 Liquid Glass效果： 可动态添加重叠部分模糊效果或细微阴影 源文件应保持简洁图形核心 圆形平台（如Watch）： 注意构图调整 边缘元素可适度放大 预览功能： 更换背景测试对比度 图标堆叠查看光影流动 缩放检查细节 结论Icon Composer代表了图标设计从平面图像向沉浸式体验的演进，它不仅节省了反复生成素材的时间，更让开发者能以灵动方式创作响应式、多层次的动态图标。通过单一设计文件，您的应用图标将能够在所有Apple平台上呈现浑然一体的视觉体验。 相关视频 了解 Liquid Glass 了解全新设计系统 了解焕然一新的 App 图标 文档 使用 Icon Composer 创建应用图标 人机界面指南：应用图标 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"了解焕然一新的 App 图标","date":"2025-06-10T07:31:45.000Z","path":"2025/06/10/2025-06-10-wwdc2025_220/","text":"简要了解 ios、ipados 和 macos 的全新 app 图标外观，包括浅色调和深色调以及透明选项。了解如何使用霜冻质感和半透明效果使 app 图标更生动鲜活、更富表现力，并了解如何确保你的图标与镜面高光效果相得益彰。 视频地址 全新 App 图标设计语言解析：从 Liquid Glass 到跨平台适配引言Apple 近期全面革新了 iOS、iPadOS 和 macOS 平台的 App 图标视觉体系。这次重塑不仅带来了惊艳的 Liquid Glass 材质效果，更统一了各平台的设计语言，为开发者提供了更强大的创意表达工具。本文将深入解析这套全新设计系统的核心特性和实用技巧。 Liquid Glass 材质革命本次设计革新最引人注目的突破是Liquid Glass材质： 灵感源自 visionOS 的分层图标和真实玻璃特性 通过边缘高光、磨砂质感与半透明效果叠加实现立体感 支持”由内发光”的视觉体验 利用陀螺仪数据实现光线随环境流动的动效 这套材质系统完美适配： 浅色/深色双模式 全新半透明外观选项（包括浅色/深色单色玻璃版本） 创新的双色调模式（深色调前景元素/浅色调玻璃材质） 统一的设计体系跨平台一致性优化新系统解决了历史遗留的平台差异问题： 简化设计网格结构，增大圆角半径 1024像素画布统一标准 圆形图案获得专属框架和留白空间 watchOS采用1088像素画布保持视觉协调 macOS专项优化 使用画布形状作为蒙版规范辅助元素 形状匹配的图标自动适配新材质 独特形状图标系统会自动处理（建议手动优化） 图标设计五大黄金法则 分层设计架构 基础结构=背景层+前景层 支持多层前景叠加 推荐使用立体形状增强材质表现 半透明艺术 模糊效果创造精妙层次 透明模式可透见墙纸 各类外观模式下表现稳定 简约至上原则 减少重叠区域突出材质特性 更新色彩方案保持活力 避免过度静态效果 细节精修指南 圆角设计优化光线传播 功能视角优先（如放大镜案例） 确保小尺寸可读性 背景设计秘诀 采用System Light/Dark渐变 柔和渐变配合光线方向 彩色背景增强模式辨识度 设计资源与工具Apple为开发者准备了全面支持： Figma/Sketch/Photoshop/Illustrator模板 配套开发工具Icon Composer 详细Human Interface Guidelines 结语这套全新的App图标设计语言不仅是一次视觉升级，更开创了数字产品表达的新纪元。通过掌握Liquid Glass材质特性和分层设计方法，开发者可以创作出既保持品牌调性又充满生命力的图标作品。现在就访问设计资源页面，开启您的创意之旅吧！ 相关视频 了解 Liquid Glass 了解全新设计系统 使用 Icon Composer 构建图标 文档资源 Human Interface Guidelines: App icons 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"了解全新设计系统","date":"2025-06-10T07:31:42.000Z","path":"2025/06/10/2025-06-10-wwdc2025_356/","text":"深入了解全新设计系统，探索视觉设计、信息架构及核心系统组件方面的关键变化。了解如何借此重塑界面与内容之间的关系，打造动态、和谐且一致的设计，完美适配各种设备、屏幕尺寸和输入模式。 视频地址 苹果液态玻璃设计系统全解析：从视觉语言到连续性体验引言苹果最新的液态玻璃（Liquid Glass）设计系统代表了该公司有史以来最全面的软件设计革新。这一系统通过全新的启发式方法重塑了界面与内容的关系，构建了一套更具凝聚力、适应性和表现力的统一设计语言。本文将深入解析这一设计系统在视觉设计、信息架构和核心组件方面的创新之处。 设计语言：构建统一视觉基础液态玻璃设计语言的核心在于通过系统性思维建立跨平台的一致体验，同时保留各平台的个性特征。几个关键革新点包括： 色彩系统：在浅色、深色和高对比度模式间进行了精妙调整，提升了色相区分度同时保留了苹果特有的乐观精神 字体排版：采用更粗体且左对齐的排版，强化了关键场景的可读性 形状应用：引入了三种形状类型 固定形状：保持恒定圆角半径 胶囊形状：半径取容器高度的一半 同心形状：半径通过父容器内边距计算得出 这些形状设计使UI元素能够完美嵌套，创造出设备与视觉体验的和谐韵律。特别是在触控界面中，胶囊形状能有效聚焦用户注意力。 结构体系：导航与内容的和谐互动液态玻璃在UI中定义了新的功能层，悬浮于内容之上提供结构清晰度却不喧宾夺主。几个重要的结构创新包括： 新版动作菜单：不再固定于屏幕底部，而是从触发点弹性展开，保持了操作源头的视觉锚定 材质变化：反映导航深度，主流程中断时结合遮罩层集中注意力，并行任务时创造自然分界 导航控件提升：静止状态时不再隐入背景，而是与内容形成优雅分离 开发者应注意精简自定义栏位设计，改用布局和分组表达层级，合理组织栏位项目。 连续性体验：跨设备无缝衔接液态玻璃设计系统的终极目标是实现连续性体验，让用户在设备间切换或调整窗口时，体验的是任务的延续而非重启。几个关键策略包括： 设计一次，适配所有平台：应用骨架只需设计一次即可适配iPhone、Mac和iPad 内容编组一致性：使用相同符号建立认知惯性 可伸缩组件：组件需保持核心交互一致性，如标签栏、分段控制和边栏都应统一传达选择状态 如何开始采用液态玻璃想要将液态玻璃设计理念融入您的应用，可以： 下载Apple设计资源库的新UI套件 深入研究更新后的《人机界面指南》 观看相关WWDC视频了解详细实现方法 相关视频 了解 Liquid Glass 了解焕然一新的 App 图标 使用 Icon Composer 构建图标 文档资料 Adopting Liquid Glass Human Interface Guidelines Human Interface Guidelines: Icons Human Interface Guidelines: Materials Human Interface Guidelines: Toolbars 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"优化 Swift 代码的内存使用和性能","date":"2025-06-10T07:31:29.000Z","path":"2025/06/10/2025-06-10-wwdc2025_312/","text":"了解如何提升 swift 代码的性能和内存管理。我们将探索优化代码的多种方法，包括进行高级算法更改，以及采用新的 inlinearray 和 span 类型对内存和分配进行更精细的控制。 视频地址 Swift 代码性能优化实战：从算法到内存管理引言在 Swift 开发中，性能优化是一个永恒的话题。无论是处理大规模数据还是构建高性能应用，理解如何分析和提升代码性能都至关重要。本文将带您深入 Swift 性能优化的世界，从基础算法调整到高级内存管理技术，揭示让 Swift 代码跑得更快的秘密。 性能问题定位与分析案例：QOI 图像解析器我们从一个实际的 QOI 图像格式解析器案例开始。这个解析器在处理小文件时表现良好，但在加载稍大的图像时却出现了明显的延迟。 123456789// 原始读取方法 - 存在性能问题extension Data &#123; mutating func readByte() -&gt; UInt8? &#123; guard !isEmpty else &#123; return nil &#125; let byte = self[0] self = Data(self.dropFirst()) return byte &#125;&#125; Instruments 分析使用 Instruments 工具套件（特别是 Time Profiler 和 Allocations 工具）可以帮助我们： 识别性能瓶颈 发现内存分配问题 定位具体的慢速代码 分析结果显示，platform_memmove 系统调用占据了大部分时间，表明代码中存在大量不必要的内存复制操作。 算法优化改进数据读取方式将原来的 Data 切片操作改为使用 popFirst() 方法，消除了不必要的内存复制： 1234567// 优化后的读取方法extension Data &#123; mutating func readByte() -&gt; UInt8? &#123; guard !isEmpty else &#123; return nil &#125; return self.popFirst() &#125;&#125; 这一简单的改变就将算法复杂度从二次方降低到了线性，性能提升显著。 内存管理优化减少中间分配原始代码中存在大量中间数组分配： 123456789// 存在内存分配问题的像素数据处理extension RGBAPixel &#123; func data(channels: QOI.Channels) -&gt; some Collection&lt;UInt8&gt; &#123; switch channels &#123; case .rgb: return [r, g, b] case .rgba: return [r, g, b, a] &#125; &#125;&#125; 优化后改为预分配内存并直接写入： 12345678910111213// 内存优化版本extension QOIParser &#123; func parseQOI(from input: inout Data) -&gt; QOI? &#123; // 预分配内存 let totalBytes = header.pixelCount * Int(header.channels.rawValue) var pixelData = Data(repeating: 0, count: totalBytes) // 直接写入预分配的内存 previousPixel.write(to: &amp;pixelData, at: &amp;offset, channels: header.channels) return QOI(header: header, data: pixelData) &#125;&#125; 高级优化技术InlineArray 的使用Swift 6.2 引入的 InlineArray 类型可以帮助我们将固定大小的数组存储在栈上，避免堆分配： 12// 使用 InlineArray 优化像素缓存var pixelCache: InlineArray&lt;64, RGBAPixel&gt; = [] Span 类型的应用Span 家族类型（Swift 6.2 新增）提供了安全且高效的内存访问方式： 12345678910// 使用 RawSpan 优化数据读取@available(macOS 16.0, *)extension RawSpan &#123; mutating func readByte() -&gt; UInt8? &#123; guard !isEmpty else &#123; return nil &#125; let value = unsafeLoadUnaligned(as: UInt8.self) self = self._extracting(droppingFirst: 1) return value &#125;&#125; 实战成果通过上述优化技术的组合应用，最终实现了： 比初始版本快 700 倍的性能提升 完全消除了不必要的内存分配 显著减少了引用计数操作 更加安全和可维护的代码结构 开源工具：Swift Binary Parsing基于这些优化技术，开发了 Swift Binary Parsing 开源库，专为安全高效地解析二进制格式设计： 12345678910111213141516// 使用 Swift Binary Parsing 解析 QOI 头部let headerParser = Parser&lt;QOI.Header&gt; &#123; input in let magic = try input.parse(4, as: UInt8.self) let width = try input.parse(bigEndian: UInt32.self) let height = try input.parse(bigEndian: UInt32.self) let channels = try input.parse(Channels.self) let colorspace = try input.parse(Colorspace.self) return QOI.Header( magic: magic, width: width, height: height, channels: channels, colorspace: colorspace )&#125; 结论Swift 性能优化是一个多层次的工程，需要： 选择合适的算法和数据结构 减少不必要的内存分配 利用最新的语言特性（如 InlineArray 和 Span） 持续使用 Instruments 等工具进行分析 通过系统化的优化方法，我们可以将 Swift 代码的性能提升到新的高度。 相关视频分析并优化 App 的功耗通过 Instruments 优化 CPU 性能Swift 的新功能探索 Swift 性能 文档性能与指标Swift 官网 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"了解 Liquid Glass","date":"2025-06-10T07:31:18.000Z","path":"2025/06/10/2025-06-10-wwdc2025_219/","text":"liquid glass 统一了 apple 平台的设计语言，同时提供更生动、更富表达力的用户体验。了解 liquid glass 的设计原则，探索它核心的光学和物理特性，并了解相关用途和原理。 视频地址 液态玻璃：苹果设计语言的全新进化引言液态玻璃(Liquid Glass)是苹果最新推出的设计语言，它标志着苹果视觉与交互设计的新纪元。这一创新设计语言不仅统一了苹果全平台体验，还实现了前所未有的流畅交互。液态玻璃汲取了苹果历代操作系统设计精华，创造出一种全新的数字超材料，为开发者提供了更具表现力的设计工具。 液态玻璃的核心特性动态视觉效果液态玻璃延续了苹果产品设计的演进轨迹，以圆润悬浮的形态呈现： 完美适配现代设备的曲面屏幕 符合手指自然几何特征的设计 通过”透镜效应”实现视觉分层 动态折射和聚集光线，保持背景内容的可见性 显隐过程通过渐变光线折射实现，带来优雅过渡 交互反馈特性液态玻璃借鉴了液体特有的流畅响应特性： 通过即时反射和光线增强响应用户交互 凝胶弹性呈现自然的可塑性 完美契合人类思维的流动特质 控件会随应用状态变化而动态变形 菜单展开等过渡效果直接而连贯 自适应设计系统液态玻璃天生具备尺寸与环境适应能力： 多层结构协同工作，每层都根据背景内容动态调整 文字滚动时自动增强阴影对比度 着色程度随环境智能变化 在菜单展开等场景模拟更厚重的光学特性 通过深度阴影和折射效果强化层次感 跨平台适配表现： 在iPad和Mac上同样适用 悬浮控件完美契合窗口圆角 边栏等大元素吸收周围环境光线特征 滚动边缘效果与液态玻璃协同工作 针对不同场景提供”硬风格”等特殊效果 设计原则与应用指南液态玻璃是一个协同工作的有机系统： 强光层模拟真实光照行为 阴影层根据内容动态调节不透明度 交互时的光晕反馈赋予界面生命力 窗口失去焦点时效果自动弱化 使用注意事项： 优先用于导航层，避免在内容层使用 禁止重叠使用，多层玻璃会导致视觉混乱 提供常规与透明两种变体： 常规变体适用性最广 透明变体需配合调暗层使用 可读性优化方案： 小元素自动适配背景深浅 大元素保持稳定色调 符号颜色动态反相确保对比度 着色系统借鉴彩色玻璃原理 辅助功能支持： 透明度调节 高对比度模式 动态减弱等选项 系统层面集成，开发者无需额外适配 结语液态玻璃为每个界面元素带来令人惊艳的新外观，同时保持了苹果一贯的易用性标准。我们鼓励开发者深入探索这一新设计语言的潜力，创造出更加自然流畅的用户体验。 相关视频 了解全新设计系统 了解焕然一新的 App 图标 使用 Icon Composer 构建图标 文档 Adopting Liquid Glass Human Interface Guidelines Human Interface Guidelines: Materials 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"swiftui-和-ui-框架","slug":"swiftui-和-ui-框架","permalink":"http://djs66256.github.io/tags/swiftui-%E5%92%8C-ui-%E6%A1%86%E6%9E%B6/"}]},{"title":"探索 Swift 和 Java 互操作性","date":"2025-06-10T07:30:39.000Z","path":"2025/06/10/2025-06-10-wwdc2025_307/","text":"了解如何在一个代码库中混合使用 swift 和 java。我们将介绍 swift-java 互操作性项目，该项目让你可以在 java 程序中使用 swift，反之亦然。我们将向你展示如何使用 swift-java 提供的工具和库来编写可在这两个运行时之间进行互操作的安全高效代码。 视频地址 Swift与Java互操作性解析：跨越语言边界的桥梁引言在现代软件开发中，多语言协作已成为常态。Swift作为苹果生态的主力语言，如何与其他主流语言(如Java)实现无缝互操作？本文将深入探讨Swift-Java互操作性项目，揭示其技术实现和最佳实践。 项目背景与目标Swift-Java互操作性项目由Swift语言团队于今年初启动，旨在实现： 在Java应用中调用Swift代码 在Swift项目中集成Java库 双向无缝类型转换与内存管理 这种互操作性让开发者可以： 渐进式地在现有Java代码库中引入Swift 复用成熟的Java库 将Swift库提供给Java项目使用 技术实现方案基础方案：Java原生方法(JNI)传统的Java与原生代码交互方式是通过JNI(Java Native Interface)： 定义本地方法1public native Integer compute(Integer value); 生成C头文件 用Swift实现函数 虽然可行，但存在以下问题： 模板代码复杂 手动管理对象生命周期 易出现类型匹配错误 改进方案：SwiftJava工具链SwiftJava项目提供了更优雅的解决方案，包含： JavaKit：Swift包的JNI安全封装 SwiftKit：Java处理Swift对象的辅助库 Swift-Java CLI工具：自动生成桥接代码 示例实现：1234567@JavaImplementationextension JNIExample: JNIExampleNativeMethods &#123; @JavaMethod func compute(value: JavaLang.Integer) -&gt; JavaLang.Integer &#123; return JavaLang.Integer(value.intValue * 2) &#125;&#125;优势： 简化模板代码 自动类型安全 更好的对象生命周期管理 高级应用场景场景一：Swift调用Java库以Apache Commons CSV为例： 指定Maven坐标 使用SwiftJava工具解析依赖 自动生成Swift包装 123456import JavaKitimport CommonsCSVlet jvm = try JVM()let fileReader = try JavaIO.FileReader(&quot;data.csv&quot;)let csvParser = try CSVParser(fileReader, CSVFormat.DEFAULT) 场景二：Java调用Swift库使用Java 22的Foreign Function API： 生成Java包装类 管理Swift值类型内存 安全释放资源 1234try (var arena = ConfinedArena.open()) &#123; SwiftValue value = new SwiftValue(arena, 42); System.out.println(value.compute());&#125; // 自动释放内存 内存管理策略SwiftJava提供了两种内存管理方式： GC依赖模式：依靠Java垃圾回收器 作用域模式(推荐)：使用try-with-resources语法 1234// 推荐方式try (var arena = ConfinedArena.open()) &#123; // 使用Swift对象&#125; // 自动释放 项目现状与未来SwiftJava项目已经： 实现基础双向互操作 支持常见类型转换 提供构建系统集成 未来计划： 完善Gradle插件 优化性能 扩展类型支持 结语Swift-Java互操作性为跨语言开发开辟了新途径，让开发者可以充分利用两种语言的优势。无论您是想在Java中引入Swift的现代特性，还是在Swift项目中复用Java生态，SwiftJava项目都值得尝试。 相关视频优化 Swift 代码的内存使用和性能安全地混合使用 C、C ++ 和 SwiftSwift 的新功能融合 Swift 和 C++ 文档Swift官方网站 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"通过 Instrument 优化 SwiftUI 性能","date":"2025-06-10T07:30:10.000Z","path":"2025/06/10/2025-06-10-wwdc2025_306/","text":"探索全新的 swiftui instrument。我们将介绍 swiftui 如何更新视图、app 数据的变化对这些更新会产生什么影响，以及新的 instrument 如何帮助你以可视化方式了解相应的原因和效果。 为了充分从这个讲座中获益，建议你先熟悉一下如何用 swiftui 编写 app。 视频地址 使用 Instrument 全面优化 SwiftUI 应用性能引言在 SwiftUI 开发中，性能优化是构建流畅用户体验的关键。随着 WWDC 2025 推出的 Instruments 26 全新版本，开发者现在拥有更强大的工具来分析并优化 SwiftUI 应用的性能问题。本文将带您深入了解如何利用这些新工具诊断和解决常见的 SwiftUI 性能瓶颈。 发现 SwiftUI 性能工具Instruments 26 为 SwiftUI 开发带来了革命性的分析工具： 123456// 示例：可能导致性能问题的距离计算属性var distance: String &#123; let formatter = MeasurementFormatter() formatter.unitStyle = .short return formatter.string(from: Measurement(value: landmark.distance, unit: UnitLength.meters))&#125; 新版模板包含三个核心组件： SwiftUI 工具：可视化展示框架内部工作状态 Time Profiler：记录 CPU 负载情况 卡顿检测工具：识别界面响应延迟 关键分析技巧： 首先查看”Update Groups”轨道 关注三种颜色标记的问题： 橙色/红色：视图 body 计算耗时过长 蓝色：Representable 更新延迟 紫色：其他类型延迟 诊断与修复实战案例我们以 Landmarks 应用为例，演示完整优化流程： 发现问题： 滚动列表时出现卡顿 Instruments 显示”Long View Body Updates”轨道出现红色标记 定位到 LandmarkListItemView 的距离计算属性 优化方案： 123456789101112// 优化后的距离计算 - 预缓存格式化结果class LocationFinder &#123; private static let formatter: MeasurementFormatter = &#123; let formatter = MeasurementFormatter() formatter.unitStyle = .short return formatter &#125;() static func formattedDistance(for landmark: Landmark) -&gt; String &#123; return formatter.string(from: Measurement(value: landmark.distance, unit: UnitLength.meters)) &#125;&#125; 验证效果： 重新分析后红色标记消失 滚动流畅度显著提升 深入理解 SwiftUI 更新机制SwiftUI 的声明式特性带来了独特的性能挑战： 123456789101112131415161718192021// 优化前的数据依赖 - 整个收藏数组struct LandmarkListView: View &#123; @State private var favorites: Set&lt;Int&gt; = [] var body: some View &#123; List(landmarks) &#123; landmark in LandmarkRow(landmark: landmark, isFavorite: favorites.contains(landmark.id)) &#125; &#125;&#125;// 优化后 - 使用独立 ViewModelclass LandmarkViewModel: ObservableObject &#123; @Published var isFavorite: Bool // 仅包含必要数据&#125;struct LandmarkRow: View &#123; @ObservedObject var viewModel: LandmarkViewModel // 只依赖自身数据&#125; 关键优化原则： 最小化数据依赖：使视图仅依赖其真正需要的数据 避免环境变量滥用：EnvironmentValues 变化会触发所有依赖视图更新 利用因果图：可视化追踪更新链条，定位不必要的更新源头 性能优化黄金法则 保持视图 body 简洁高效 精确控制数据依赖关系 开发过程中持续使用 Instruments 分析 确保视图只在必要时更新 结论通过合理运用 Instruments 26 的新工具，结合对 SwiftUI 更新机制的深入理解，开发者可以系统性地诊断和解决性能问题。记住，预防胜于治疗 - 在开发过程中定期进行性能分析，远比在用户反馈问题后再修复要高效得多。 相关视频 通过 Instruments 优化 CPU 性能 使用 Instruments 分析挂起 解密 SwiftUI 性能 文档 Understanding and improving SwiftUI performance Analyzing the performance of your visionOS app Improving app responsiveness 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"跟着视频学编程：使用 SwiftUI 和 AttributedString 精心打造富文本体验","date":"2025-06-10T07:29:56.000Z","path":"2025/06/10/2025-06-10-wwdc2025_280/","text":"了解如何使用 swiftui 的 texteditor api 和 attributedstring 构建富文本体验。探索如何启用富文本编辑功能、构建用来操控编辑器内容的自定控件，并对提供的众多格式选项进行自定。了解 attributedstring 的高级功能，以便精心打造超棒的文本编辑体验。 视频地址 使用 SwiftUI 和 AttributedString 打造富文本编辑器引言在现代应用开发中，富文本编辑功能已成为提升用户体验的重要环节。SwiftUI 与 AttributedString 的结合，为开发者提供了构建强大富文本编辑器的绝佳工具。本文将详细介绍如何利用这些技术，从基础实现到高级定制，打造完美的文本编辑体验。 基础实现：从纯文本到富文本纯文本编辑器123456789import SwiftUIstruct RecipeEditor: View &#123; @Binding var text: String var body: some View &#123; TextEditor(text: $text) &#125;&#125; 这是最基本的文本编辑器实现，仅支持纯文本编辑。 升级为富文本支持1234567struct RecipeEditor: View &#123; @Binding var text: AttributedString var body: some View &#123; TextEditor(text: $text) &#125;&#125; 只需将String改为AttributedString，编辑器立即获得以下能力： 支持粗体/斜体等格式切换 调整字号、插入Genmoji表情 完美适配深色模式和动态类型 兼容SwiftUI的Text显示 AttributedString基础AttributedString由字符序列和属性区间组成。例如： 123456var text = AttributedString(&quot;Hello 👋🏻! Who&#x27;s ready to get &quot;)var cooking = AttributedString(&quot;cooking&quot;)cooking.foregroundColor = .orangetext += cookingtext += AttributedString(&quot;?&quot;)text.font = .largeTitle AttributedString是值类型，采用UTF-8编码，并符合Equatable、Hashable等Swift协议。 构建自定义控件常见错误示例1234567891011121314struct RecipeEditor: View &#123; @Binding var text: AttributedString @State private var selection = AttributedTextSelection() var body: some View &#123; TextEditor(text: $text, selection: $selection) .preference(key: NewIngredientPreferenceKey.self, value: newIngredientSuggestion) &#125; private var newIngredientSuggestion: IngredientSuggestion &#123; let name = text[selection.indices(in: text)] // 编译错误 return IngredientSuggestion(suggestedName: AttributedString()) &#125;&#125; 问题在于selection.indices返回的是RangeSet而非单一Range，这是为了支持双向文本布局。 正确实现方式1234private var newIngredientSuggestion: IngredientSuggestion &#123; let name = text[selection] // 直接使用selection return IngredientSuggestion(suggestedName: AttributedString(name))&#125; 自定义文本格式定义专属格式1234567891011struct RecipeFormattingDefinition: AttributedTextFormattingDefinition &#123; struct Scope: AttributeScope &#123; let foregroundColor: AttributeScopes.SwiftUIAttributes.ForegroundColorAttribute let adaptiveImageGlyph: AttributeScopes.SwiftUIAttributes.AdaptiveImageGlyphAttribute let ingredient: IngredientAttribute &#125; var body: some AttributedTextFormattingDefinition&lt;Scope&gt; &#123; IngredientsAreGreen() // 配料文本显示为绿色 &#125;&#125; 实现格式约束12345struct IngredientsAreGreen: AttributedTextValueConstraint &#123; func constrain(_ container: inout Attributes) &#123; container.foregroundColor = container.ingredient != nil ? .green : nil &#125;&#125; 高级属性控制1234struct IngredientAttribute: CodableAttributedStringKey &#123; static let inheritedByAddedText = false // 新增文本不继承属性 static let invalidationConditions: Set&lt;AttributedString.AttributeInvalidationCondition&gt;? = [.textChanged] // 文本修改时移除属性&#125; 这种设置确保： 在配料文本后输入时，新文本不会变绿 删除配料字符时，整个单词立即恢复默认颜色 结论SwiftUI与AttributedString的结合为富文本编辑提供了强大而灵活的解决方案。从基础实现到高级定制，开发者可以构建出满足各种需求的文本编辑器。无论是简单的格式调整，还是复杂的业务逻辑，这套技术栈都能完美应对。 相关视频 提升App的多语言体验 向左语言 Foundation中的新功能 文档 AttributedTextFormatting AttributedTextSelection Character 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"}]},{"title":"录制、重播和查看：使用 Xcode 实现 UI 自动化","date":"2025-06-10T07:29:52.000Z","path":"2025/06/10/2025-06-10-wwdc2025_344/","text":"了解如何在 xcode 中录制、运行和维护 xcuiautomation 测试。利用测试计划配置，在数十个语言、设备类型和系统条件下重播 xctest ui 测试。使用 xcode 测试报告来查看测试结果，并下载运行情况的截图和视频。我们还将介绍有关通过辅助功能为 app 做好自动化准备以及编写稳定、高质量自动化代码的最佳做法。 视频地址 使用 Xcode 实现 UI 自动化测试：从录制到回放全攻略引言在 App 开发中，确保用户界面在不同设备和语言环境下都能正常工作至关重要。Xcode 提供了一套强大的 UI 自动化测试工具，让你可以轻松录制交互行为，在多配置环境下回放测试，并查看详细的测试报告。本文将带你全面了解 Xcode 的 UI 自动化功能。 UI 自动化测试概述Xcode 的 UI 自动化测试基于 XCTest 框架中的 XCUIAutomation 模块，它能模拟真实用户与 App 的交互。完整的测试套件通常包含： 单元测试：验证应用逻辑 UI 测试：验证用户体验和核心工作流 UI 自动化工作流分为三个阶段： 录制：将用户交互转换为代码 回放：在多设备/语言环境下执行 审查：查看测试结果和视频记录 为自动化测试准备应用添加辅助功能标识符辅助功能是自动化测试的基础，通过为 UI 元素添加标识符可以提高测试的稳定性： 123456// SwiftUI 示例Image(landmark.backgroundImageName) .accessibilityIdentifier(&quot;LandmarkImage-\\(landmark.id)&quot;)// UIKit 示例button.accessibilityIdentifier = &quot;LandmarkButton-\\(landmark.id)&quot; 优秀标识符应具备： 全应用唯一性 描述性（说明所属元素） 静态性（不随内容变化） 使用辅助功能检查器通过 Xcode &gt; Open Developer Tool 启动辅助功能检查器，检查元素的可访问性属性。 录制交互行为Xcode 提供一键录制功能： 点击录制按钮 在模拟器中操作应用 停止录制生成代码 录制后生成的代码中，每个 UI 元素都有多种定位方式可选，建议优先使用辅助功能标识符而非本地化字符串。 多配置回放测试计划(Test Plan)让你可以： 包含/排除特定测试 设置系统参数（语言/地区/设备方向） 管理超时、重复、并行等属性 配置建议： 添加多语言环境测试 设置视频/截图捕获规则 通过 Xcode Cloud 在云端运行测试 查看测试结果测试报告提供强大功能： 视频播放时显示交互标记点 失败时刻显示所有 UI 元素状态 提供代码修复建议 支持视频下载 最佳实践12345678// 优先使用辅助功能标识符XCUIApplication().staticTexts[&quot;Collection-1&quot;]// 保持查询简洁XCUIApplication().staticTexts[&quot;Collection-1&quot;]// 动态内容使用通用查询XCUIApplication().staticTexts.firstMatch 结论Xcode 的 UI 自动化测试功能强大且易于使用，从录制交互到多环境回放，再到详细的结果分析，为开发者提供了完整的测试解决方案。通过遵循本文介绍的实践方法，你可以构建更稳定、高效的自动化测试套件。 相关视频 了解 Swift Testing 使用 Xcode 测试报告更快修复故障 在 SwiftUI 和 UIKit 中创建易于访问的 App 文档 通过测试计划组织测试改进代码评估 为应用执行辅助功能测试 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"安全地混合使用 C、C ++ 和 Swift","date":"2025-06-10T07:29:50.000Z","path":"2025/06/10/2025-06-10-wwdc2025_311/","text":"了解如何混合使用 c、c++ 和 swift，同时提高 app 的安全性。我们将介绍如何在 swift 代码中找到不安全的 c 和 c++ api 调用位置、如何更安全地调用这些 api，以及如何使 app 中的现有 c 和 c++ 代码默认处于更安全的状态。 视频地址 安全混合编程：如何让 Swift 与 C/C++ 安全共处引言在现代应用开发中，混合使用 Swift 与 C/C++ 代码的情况十分常见。Swift 以其内存安全性著称，而 C/C++ 则因其高性能和不安全特性成为潜在的安全隐患。如何让这两种语言安全共存？本文将介绍 Apple 在 Swift 6.2 中引入的新技术，帮助你识别和消除跨语言调用的安全隐患。 问题根源：指针的不安全特性C/C++ 中的原始指针缺乏安全防护机制，这导致了两大核心问题： 边界检查缺失：无法防止数组越界访问 生命周期管理缺失：可能导致”释放后使用”等严重漏洞 在 Swift 中调用这些不安全函数时，编译器会将其导入为UnsafeMutablePointer等类型，但开发者往往难以察觉这些隐式的不安全操作。 定位安全隐患：严格内存安全模式Swift 6.2 引入的”严格内存安全模式”(Strict Memory Safety)能有效识别这些安全隐患： 123// 开启严格模式后会标记不安全操作var imageData = [UInt8](repeating: 0, count: imageDataSize)filterImage(&amp;imageData, imageData.count) // 警告：不安全操作 在 Xcode 项目中开启该模式后，所有涉及不安全指针的操作都会被明确标记，帮助开发者发现潜在风险。 安全调用 C/C++ API 的解决方案1. 处理指针参数函数对于接受原始指针的 C 函数，可以使用__counted_by注释明确指针与数组大小的关系： 1void invertImage(uint8_t *__counted_by(imageSize) imagePtr __noescape, size_t imageSize); 这种注释让 Swift 编译器能将指针安全地转换为MutableSpan类型，自动处理边界检查。 2. 处理 C++ Span 类型C++的std::span虽然比原始指针更安全，但仍需__noescape注释来确保生命周期安全： 1void applyGrayscale(CxxSpanOfByte imageView __noescape); 3. 处理返回指针的函数对于返回视图的函数，使用__lifetimebound注释声明返回值的生命周期依赖： 1CxxSpanOfByte scanImageRow(CxxSpanOfByte imageView __lifetimebound, size_t width, size_t rowIndex); 安全导入自定义 C++ 类型不同类型的 C++ 结构体需要不同的注释策略： 视图类型：使用SWIFT_NONESCAPABLE标记 引用计数类型：配合保留/释放函数使用SWIFT_SHARED_REFERENCE 1struct ImageBuffer SWIFT_SHARED_REFERENCE(retain_image_buffer, release_image_buffer); 提升 C/C++ 代码安全性的额外措施 开启 C++标准库的边界检查 强制使用 C++ Span 替代原始指针 对 C 语言使用边界安全扩展(__counted_by) 结论实现 Swift 与 C/C++ 安全互操作的关键步骤： 在 Swift 项目中启用严格内存安全模式 为所有 C/C++ API 添加适当的安全注释 启用 C/C++ 端的边界安全检查功能 通过这些措施，你可以在保留 C/C++ 高性能优势的同时，享受 Swift 的内存安全保障。 相关视频 优化 Swift 代码的内存使用和性能 文档 -fbounds-safety: Enforcing bounds safety for C Safely Mixing Swift and C++ 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"},{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"}]},{"title":"进一步了解声明式网页推送","date":"2025-06-10T07:29:38.000Z","path":"2025/06/10/2025-06-10-wwdc2025_235/","text":"了解声明式网页推送如何帮助你更可靠地发送通知。了解如何借鉴现有标准实现更高效、更透明的设计，同时保证与原始网页推送的向后兼容性。 视频地址 声明式网页推送：更高效可靠的通知解决方案引言推送通知已成为现代数字体验的核心功能。无论是在原生应用还是网页中，它都扮演着至关重要的角色。苹果早在2009年就开始构建推送通知系统，而现在，Web标准社区正在通过声明式网页推送来重新定义网页推送的未来。 传统网页推送的局限性传统Web Push规范完全依赖JavaScript代码驱动： 需要开发者在Service Worker中编写处理逻辑 代码执行带来性能开销 存在潜在的隐私安全风险 智能防追踪(ITP)限制了JS的生命周期 声明式推送的核心理念声明式网页推送借鉴了原生推送系统的成功经验： 无需代码编写：采用标准化JSON格式描述通知 更高效率：浏览器直接解析处理，无需JS执行 更好兼容性：与现有Web Push标准保持向后兼容 渐进增强：在不支持的浏览器中自动回退传统方式 技术实现对比传统Web Push流程 获取推送订阅 服务器发送消息到订阅URL 浏览器唤醒Service Worker Service Worker处理push事件并调用showNotification 用户点击触发notificationclick事件 声明式Web Push流程 获取推送订阅（可通过window.PushManager） 服务器发送标准化JSON消息 浏览器自动验证并显示通知 用户点击自动打开指定URL 声明式JSON格式详解最小化示例：123456789&#123; &quot;web_push&quot;: &quot;8-0-3-0&quot;, &quot;notification&quot;: &#123; &quot;title&quot;: &quot;您有新消息&quot;, &quot;data&quot;: &#123; &quot;url&quot;: &quot;https://example.com&quot; &#125; &#125;&#125; 完整支持W3C NotificationOptions的所有选项： 消息正文 通知标签 系统提示音 应用角标更新 高级定制能力对于需要额外处理的场景： 在JSON中添加”mutable”:true标记 Service Worker将收到推送事件 可以进行消息解密或内容修正 处理失败时回退原始通知 迁移与兼容性策略现有Web Push应用可轻松迁移： 重命名现有JSON属性为标准格式 添加”web_push”魔法键 简化Service Worker中的处理逻辑 新旧浏览器自动获得最佳体验 结语声明式网页推送代表了Web通知技术的未来方向，它结合了原生推送的可靠性和Web的开放性。现在就是开始采用这一新技术的最佳时机，无论是新建项目还是现有应用的升级。 相关视频 在网页上验证身份证件 Safari浏览器和WebKit的新功能 Safari浏览器网页推送功能简介 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"safari-浏览器和网页","slug":"safari-浏览器和网页","permalink":"http://djs66256.github.io/tags/safari-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E9%A1%B5/"}]},{"title":"使用 WebGPU 解锁 GPU 计算能力","date":"2025-06-10T07:29:23.000Z","path":"2025/06/10/2025-06-10-wwdc2025_236/","text":"了解 webgpu api 如何为图形和通用计算提供安全访问 gpu 设备的权限。我们还将探讨用来编写 gpu 程序的 wgsl 着色语言。此外，我们将深入探索在台式机和移动设备上实现最优性能同时尽可能降低能耗的最佳实践。 视频地址 WebGPU：解锁浏览器中的GPU计算潜能引言WebGPU作为下一代图形API，正在彻底改变网页GPU计算的方式。它不仅完美替代WebGL，更为开发者带来了前所未有的高性能通用GPU计算能力。本文将带你深入了解WebGPU的核心架构、WGSL着色语言以及苹果平台上的关键性能优化技巧。 WebGPU架构解析WebGPU采用与Metal框架高度相似的API设计，主要包含以下核心组件： 核心资源类型 GPUDevice：API的主要入口点，类似Metal的MTLDevice GPUAdapter：代表物理GPU适配器 GPUCanvasContext：与HTML canvas元素交互的接口 12345// 创建WebGPU设备的典型流程const adapter = await navigator.gpu.requestAdapter();const device = await adapter?.requestDevice();const context = canvas.getContext(&#x27;webgpu&#x27;);context.configure(&#123; device, format, alphaMode &#125;); 资源管理WebGPU支持两种主要资源类型： GPUBuffer：灵活的内存块，可存储各种数据 GPUTexture：专为图像处理优化的内存结构 123456789101112// 创建缓冲区示例const buffer = device.createBuffer(&#123; size: 1024, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST&#125;);// 创建纹理示例const texture = device.createTexture(&#123; size: &#123; width: 512, height: 512 &#125;, format: &#x27;rgba8unorm&#x27;, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST&#125;); WGSL着色语言WGSL(WebGPU Shading Language)是专为Web设计的着色语言，具有以下特点： 程序类型 顶点着色器：处理几何体位置 片段着色器：计算像素颜色 计算着色器：执行通用GPU计算 12345678// 计算着色器示例@group(0) @binding(0) var&lt;storage, read&gt; input: array&lt;f32&gt;;@group(0) @binding(1) var&lt;storage, read_write&gt; output: array&lt;f32&gt;;@compute @workgroup_size(64)fn main(@builtin(global_invocation_id) id: vec3&lt;u32&gt;) &#123; output[id.x] = input[id.x] * 2.0;&#125; 性能优化技巧内存管理 使用半精度浮点(f16)：减少内存占用 避免频繁更新缓冲区：特别是索引/间接缓冲区 优先使用只读访问：除非必须写入 1234// 启用f16扩展const device = await adapter.requestDevice(&#123; requiredFeatures: [&#x27;shader-f16&#x27;]&#125;); 命令优化 使用渲染包(render bundles)：复用编码命令 合并通道：减少Metal对象数量 动态偏移绑定组：共享布局降低资源消耗 123456789// 创建渲染包示例const bundleEncoder = device.createRenderBundleEncoder(&#123; colorFormats: [&#x27;rgba8unorm&#x27;]&#125;);bundleEncoder.draw(3, 1, 0, 0);const renderBundle = bundleEncoder.finish();// 后续帧中复用passEncoder.executeBundles([renderBundle]); 结论WebGPU为网页带来了前所未有的GPU计算能力，使开发者能够创建高性能的图形和计算应用。通过合理使用WGSL语言和遵循性能优化准则，你的应用可以在所有支持WebGPU的平台上获得最佳表现。 相关视频 了解适用于SwiftUI的WebKit Safari浏览器和WebKit的新功能 为Apple芯片Mac优化Metal性能 使用Metal技术驾驭Apple图形处理器 文档 Metal Performance Shaders Transformers.js - Huggingface WebGPU - W3C WebGPU Samples - github.io 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"了解适用于 SwiftUI 的 WebKit","date":"2025-06-10T07:29:21.000Z","path":"2025/06/10/2025-06-10-wwdc2025_231/","text":"了解如何使用 webkit 将网页内容轻松整合到你的 swiftui app 中。了解如何载入和显示网页内容、与网页进行通信等。 视频地址 在 SwiftUI 中无缝集成 WebKit：构建强大的网页应用体验引言随着 SwiftUI 的不断发展，苹果为开发者提供了更简单高效的方式来集成 WebKit 功能。无论您需要在应用中展示网页内容，还是实现复杂的网页交互，新的 WebKit API 都能满足您的需求。本文将带您深入了解如何利用这些新特性，构建功能丰富的应用。 WebView 基础使用全新的 WebView 组件让网页内容集成变得异常简单。只需创建一个 WebView 并指定 URL，就能在所有支持 WebKit 的平台展现精美网页内容。 1WebView(url: URL(string: &quot;https://www.apple.com&quot;)!) 如果需要动态切换 URL，WebView 会自动导航至新地址： 12345678@State private var currentURL = URL(string: &quot;https://www.apple.com&quot;)!var body: some View &#123; WebView(url: currentURL) Button(&quot;切换页面&quot;) &#123; currentURL = URL(string: &quot;https://developer.apple.com&quot;)! &#125;&#125; 高级内容加载当需要更复杂的交互时，可以创建 WebPage 实例并与 WebView 绑定： 12345678910struct ContentView: View &#123; @State private var webPage = WebPage() var body: some View &#123; WebView(page: webPage) .onAppear &#123; webPage.load(URLRequest(url: URL(string: &quot;https://www.apple.com&quot;)!)) &#125; &#125;&#125; 加载内容的方式多样： 通过 load API 加载远程 URL 直接注入 HTML 字符串及基准 URL 加载 WebArchive 等数据类型（需指定 MIME 类型和编码） 本地资源管理通过实现 URLSchemeHandler 协议，您可以轻松加载本地资源： 1234567891011121314151617class LakesSchemeHandler: NSObject, URLSchemeHandler &#123; func webView(_ webView: WebView, start task: URLSchemeTask) &#123; // 处理自定义 URL 请求 &#125; func webView(_ webView: WebView, stop task: URLSchemeTask) &#123; // 停止任务 &#125;&#125;// 注册自定义 schemeWebPage.registerURLSchemeHandler( LakesSchemeHandler(), forURLScheme: &quot;lakes&quot;) 导航与交互控制监听导航状态变化： 123456789.onReceive(webPage.currentNavigationEvent) &#123; event in switch event &#123; case .startedProvisionalNavigation: print(&quot;导航开始&quot;) case .finish: print(&quot;导航完成&quot;) // 其他情况处理... &#125;&#125; 通过 callJavaScript API 执行 JS 代码： 12345678webPage.callJavaScript(&quot;document.title&quot;) &#123; result in switch result &#123; case .success(let value): print(&quot;返回值：\\(value)&quot;) case .failure(let error): print(&quot;错误：\\(error)&quot;) &#125;&#125; 视图修饰与定制WebView 提供丰富的修饰符来优化体验： 1234WebView(url: url) .scrollBounceBehavior(.always) .findNavigator() .webViewScrollPosition($scrollPosition) 结语SwiftUI 中的 WebKit 新 API 提供了简单易用的网页内容集成方案，同时支持高级定制功能。无论您需要基本的网页展示，还是复杂的交互控制，这些新工具都能帮助您构建出色的用户体验。 立即尝试这些新特性，并将 WebKit 的强大功能整合到您的 SwiftUI 应用中吧！ 相关视频 使用 WebGPU 解锁 GPU 计算能力 空间网页的新功能 Safari 浏览器和 WebKit 的新功能 Swift 的新功能 SwiftUI 的新功能 文档资源 SwiftUI 官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"safari-浏览器和网页","slug":"safari-浏览器和网页","permalink":"http://djs66256.github.io/tags/safari-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8C%E7%BD%91%E9%A1%B5/"}]},{"title":"深入探索适用于 App 内购买项目的 App Store Server API","date":"2025-06-10T07:28:13.000Z","path":"2025/06/10/2025-06-10-wwdc2025_249/","text":"了解 app store server api、app store 服务器通知以及 app store server 资源库如何帮助你直接在服务器上管理顾客购买数据，并提供卓越的 app 内购买项目体验。我们将介绍 appaccounttoken 和签名流程的最新更新、签名交易和续订信息的新字段，以及一些全新 api。然后，我们将展示如何在服务器上生成促销优惠签名，以及如何使用 send consumption information 端点。 视频地址 掌握App Store Server API：优化应用内购管理新功能引言在移动应用生态中，App内购项目的高效管理直接影响用户体验和业务收入。苹果推出的App Store Server API、服务器通知及资源库，为开发者提供了直接在服务器端管理用户购买数据的强大工具。本文将解析最新功能更新，包括appAccountToken优化、签名流程改进，以及如何利用新API简化促销优惠签名生成和消费数据上报。 核心功能更新1. 强化交易标识管理JWSTransaction数据结构现包含关键改进： 新增offerPeriod字段：采用ISO 8601持续时间格式，明确标识兑换优惠的有效期（如订阅优惠的适用周期）。 交易元数据增强：除传统字段（如transactionId、产品价格和货币）外，现支持更详细的优惠信息： &#123; \"offerType\": \"促销类型\", \"offerIdentifier\": \"优惠ID\", \"offerDiscountType\": \"折扣类别\", \"offerPeriod\": \"P1M\" // 示例：1个月有效期 &#125; 适用场景：准确追踪用户优惠使用状态，防止服务交付误差。 2. 简化的签名请求流程服务器端生成请求签名时，新版API提供： 自动化签名验证工具：通过App Store Server Library快速验证JWSTransaction和JWSRenewalInfo的完整性。 字段级签名覆盖：新增订阅续订状态的签名字段，确保关键数据（如续订日期）的不可篡改性。 实践应用：促销优惠与退款决策生成促销优惠签名通过服务器API生成促销签名（如限时折扣）的步骤： 调用/generatePromotionSignature端点，传递用户账户ID和优惠参数。 返回JWS格式签名，供客户端验证优惠有效性。 优势：避免客户端篡改风险，提升促销活动安全性。 参与退款决策流程使用Send Consumption Information端点上报用户消费数据： 关键字段：consumptionStatus（使用状态）、refundPreference（退款倾向）。 影响机制：帮助App Store基于实际使用情况评估退款请求合理性。 总结与下一步本次更新显著优化了交易关联准确性、签名安全效率和退款决策协同性。建议开发者： 集成App Store Server Library以快速适配新功能。 查阅官方文档，深入探索API细节点。 相关视频 StoreKit与应用内购新功能 App Store Server API详解 文档资源 高级商务API App Store Server API 简化实现指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 iOS 和 iPadOS 上的 HealthKit 跟踪体能训练","date":"2025-06-10T07:28:03.000Z","path":"2025/06/10/2025-06-10-wwdc2025_322/","text":"了解有关为 ios 打造出色体能训练体验的最佳做法。探究体能训练会话的生命周期，探索 apple watch 上和 iphone 上体能训练的不同之处，并了解如何使用实时活动和 siri 来提升 app 的锁屏体验。 视频地址 在 iOS 和 iPadOS 上使用 HealthKit 实现专业的体能训练追踪引言随着健康意识的提升，越来越多的用户开始关注自己的体能训练数据。通过 HealthKit，开发者可以为用户打造卓越的体能训练体验。本文将详细介绍如何在 iPhone 和 iPad 上使用 HealthKit API 来实现完整的训练追踪功能，包括训练会话的生命周期管理、健康指标采集、崩溃恢复机制以及锁屏状态下的训练控制。 训练会话的基础流程初始化训练配置首先需要创建一个训练配置对象，指定训练类型和位置： 123let configuration = HKWorkoutConfiguration()configuration.activityType = .running // 训练类型设置为跑步configuration.locationType = .outdoor // 设置为户外训练 创建训练会话和 Builder使用配置创建训练会话，并获取关联的 Workout Builder： 1234567let session = try HKWorkoutSession(healthStore: healthStore, configuration: configuration)session.delegate = selflet builder = session.associatedWorkoutBuilder()builder.delegate = selfbuilder.dataSource = HKLiveWorkoutDataSource(healthStore: healthStore, workoutConfiguration: configuration) 启动训练会话在显示倒计时后，正式启动训练： 1234session.prepare() // 准备阶段// 显示3秒倒计时后session.startActivity(with: startDate)try await builder.beginCollection(at: startDate) 处理实时数据Workout Builder 会通过代理方法提供最新的训练数据： 12345678func workoutBuilder(_ workoutBuilder: HKLiveWorkoutBuilder, didCollectDataOf collectedTypes: Set&lt;HKSampleType&gt;) &#123; for type in collectedTypes &#123; guard let quantityType = type as? HKQuantityType else &#123; return &#125; let statistics = workoutBuilder.statistics(for: quantityType) updateForStatistics(statistics) // 更新UI显示 &#125;&#125; 结束训练结束训练时需要按照正确顺序调用各个方法： 123456session.stopActivity(with: .now) // 停止活动// 在会话状态变为stopped后try await builder.endCollection(at: change.date)let finishedWorkout = try await builder.finishWorkout()session.end() // 最终结束会话 iPhone/iPad 与 Apple Watch 的差异传感器支持iPhone 和 iPad 没有内置心率传感器，但可以连接支持心率 GAT 协议的外设（如 Powerbeats Pro 2）。配对后，HealthKit 会自动获取并存储心率数据。 数据类型分类 生成类型：系统自动生成的数据（如卡路里、距离） 收集类型：应用需要实时观察的数据（可通过 enableCollection/disableCollection 方法控制） 锁屏状态处理在锁屏状态下，大多数健康数据不可访问。建议： 首次启动时请求锁屏数据访问权限 锁屏时仅显示训练时长等基本信息 结合实时活动和 Siri 意图提供完整体验 Siri 语音控制实现设置意图处理器123456public class IntentHandler: INExtension &#123;&#125;extension IntentHandler: INStartWorkoutIntentHandlingextension IntentHandler: INPauseWorkoutIntentHandlingextension IntentHandler: INResumeWorkoutIntentHandlingextension IntentHandler: INEndWorkoutIntentHandling 处理开始训练意图1234567891011121314public func handle(intent: INStartWorkoutIntent) async -&gt; INStartWorkoutIntentResponse &#123; let state = await WorkoutManager.shared.state guard state != .running, state != .paused else &#123; return INStartWorkoutIntentResponse(code: .failureOngoingWorkout, userActivity: nil) &#125; Task &#123; await MainActor.run &#123; WorkoutManager.shared.setWorkoutConfiguration(activityType: .running, location: .outdoor) &#125; &#125; return INStartWorkoutIntentResponse(code: .success, userActivity: nil)&#125; 崩溃恢复机制应用委托设置1234567891011121314func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123; if options.shouldHandleActiveWorkoutRecovery &#123; let store = HKHealthStore() store.recoverActiveWorkoutSession &#123; workoutSession, error in Task &#123; await WorkoutManager.shared.recoverWorkout(recoveredSession: workoutSession) &#125; &#125; &#125; return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role)&#125; 恢复训练会话12345678910func recoverWorkout(recoveredSession: HKWorkoutSession) &#123; session = recoveredSession builder = recoveredSession.associatedWorkoutBuilder() session?.delegate = self builder?.delegate = self let dataSource = HKLiveWorkoutDataSource(healthStore: healthStore, workoutConfiguration: recoveredSession.workoutConfiguration) builder?.dataSource = dataSource&#125; 最佳实践 优先启动 Apple Watch 端训练以获得更完整的指标数据 仅请求必要的健康数据权限 始终使用 Workout Builder API 创建和保存训练 合理处理锁屏状态下的用户体验 为关键功能添加 Siri 语音控制支持 结论通过 HealthKit 的体能训练 API，开发者可以在 iPhone 和 iPad 上构建专业的训练追踪应用。新版本提供了更强大的崩溃恢复能力和锁屏控制功能。建议开发者： 下载示例应用参考完整实现 将现有应用迁移到 Workout Builder API 利用统一 API 开拓多设备市场 持续提供反馈帮助改进 API 相关视频 了解 HealthKit Medications API 利用 App Intents 为用户奉上 App 的核心功能 了解 ActivityKit 构建多设备训练 App 文档 HKWorkoutSession 文档 运行训练会话 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"探索 Apple 托管的 Background Assets","date":"2025-06-10T07:27:37.000Z","path":"2025/06/10/2025-06-10-wwdc2025_325/","text":"本次讲座将以 background assets 为基础，介绍用于为游戏和其他应用程序下载内容素材包的新功能。了解 apple 如何为你托管这些素材包，或如何管理自托管选项。我们将深入探索原生 api 整合及相应的 app store 实现，并为你提供工具来提升 app 的内容交付体验和用户体验。 视频地址 利用 Apple 托管 Background Assets 优化应用资源交付引言在当今应用生态中，资源交付的效率直接影响用户体验。Apple 推出的 Background Assets 技术为开发者提供了全新的资源包管理方案，既能提升首启动体验，又能灵活更新内容而不必重新提交应用。本文将详细介绍这项技术的核心功能、实现方式以及最佳实践。 Background Assets 的核心价值传统资源交付方式存在明显局限： 主应用包内置：导致安装包过大，小更新需全包重发 自主托管：服务器维护成本高 按需资源：即将退出的遗留方案 Background Assets 提供了以下优势： 独立更新：无需提交应用即可更新单个资源文件 智能下载：系统自动处理下载调度与压缩 多策略支持： 必需资源（Essential）：与安装流程集成 预载资源（Prefetch）：后台自动完成 按需资源（On-demand）：API触发下载 技术实现详解资源包创建流程使用跨平台打包工具（Xcode内置或独立版本）：1ba-package template # 生成清单模板编辑JSON配置文件：123456789101112&#123; &quot;assetPackID&quot;: &quot;教程关卡&quot;, &quot;downloadPolicy&quot;: &#123; &quot;essential&quot;: &#123; &quot;installationEventTypes&quot;: [&quot;firstInstallation&quot;] &#125; &#125;, &quot;fileSelectors&quot;: [&#123; &quot;file&quot;: &quot;Assets/教程开场动画.mp4&quot; &#125;], &quot;platforms&quot;: [&quot;iOS&quot;,&quot;macOS&quot;]&#125;关键配置项： assetPackID：应用内识别的唯一ID downloadPolicy：定义下载触发条件 fileSelectors：指定包含的文件/目录 platforms：目标平台列表 应用集成方案主应用通过AssetPackManager API操作资源：123456// 确保资源可用let pack = try await AssetPackManager.shared.assetPack(withID: &quot;教程关卡&quot;)try await AssetPackManager.shared.ensureLocalAvailability(of: pack)// 访问资源内容let videoData = try AssetPackManager.shared.contents(at: &quot;Assets/教程开场动画.mp4&quot;) 开发者可选择： 零代码集成：使用系统预制扩展 自定义逻辑：覆写shouldDownload(_:)方法 测试与分发实践本地测试方案 配置模拟服务器（支持macOS/Linux/Windows） 在设备开发者设置中输入测试服务器地址 验证下载流程与资源访问 Apple 托管服务部署上传途径对比：| 方法 | 适用场景 | 特点 ||——|———|——|| Transporter应用 | 手动操作 | 拖拽.aar文件可视化上传 || App Store Connect API | 自动化流程 | 分三步创建记录并上传 | API调用序列： POST /backgroundAssets 创建资源包记录 POST /backgroundAssetVersions 创建版本 PATCH /backgroundAssetUploadFiles 上传文件 关键注意事项 版本管理：同一上下文仅生效最新资源包版本 兼容性：资源更新会影响所有用户（包括旧版应用） 审核策略：可指定资源包与应用版本的组合提交 结论与建议Background Assets 技术为应用资源管理带来了质的飞跃，特别适合： 大型游戏的多关卡交付 频繁更新的媒体内容 机器学习模型等动态资源 推荐行动路线： 使用打包工具创建测试资源包 评估现有资源交付方案的迁移路径 充分利用200GB免费托管空间（Apple开发者计划会员） 相关视频 借助 App Store Connect API 实现开发流程自动化 App Store Connect 的新功能 Background Assets 的新动向 文档 配置 Background Assets 项目 最大构建文件尺寸 Apple 托管资源包概述 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 AlarmKit API 实现唤醒功能","date":"2025-06-10T07:27:32.000Z","path":"2025/06/10/2025-06-10-wwdc2025_230/","text":"铃-铃-铃！从你食谱 app 中的倒计时器到你旅行规划 app 中的闹钟，ios 和 ipados 26 中的 alarmkit 框架可将计时器和闹钟引入到锁定屏幕、灵动岛等其他地方。了解如何使用 app intents 框架来创建和管理你 app 的闹钟，自定闹钟的实时活动，并提供自定提醒操作。为了充分从这个视频中获益，建议你先观看 wwdc23 讲座“了解 activitykit”。 视频地址 AlarmKit 框架详解：在 iOS 中创建智能闹钟功能引言随着 iOS 和 iPadOS 26 的推出，Apple 引入了全新的 AlarmKit 框架，让开发者能够在应用中实现高级闹钟功能。无论是烹饪应用的倒计时器，还是旅行应用的行程提醒，AlarmKit 都能将这些功能带到锁定屏幕、灵动岛等系统级界面。本文将详细介绍如何使用 AlarmKit 框架创建和管理应用闹钟。 AlarmKit 框架概览AlarmKit 允许应用创建两种类型的提醒： 固定时间闹钟：基于特定日期和时间触发 倒计时闹钟：基于预设时长触发 这些提醒具有以下特性： 突破静音模式和专注模式限制 显示自定义标题和应用名称 支持在待机模式和 Apple Watch 上显示 可通过 Live Activities 实现动态倒计时界面 授权配置使用 AlarmKit 前，需要获取用户授权： 在 Info.plist 中添加 NSAlarmKitUsageDescription 说明使用目的 通过代码请求授权： 1234567891011import AlarmKitfunc requestAuthorization() &#123; AlarmManager.requestAuthorization &#123; granted in if granted &#123; print(&quot;授权成功&quot;) &#125; else &#123; print(&quot;授权被拒绝&quot;) &#125; &#125;&#125; 创建闹钟倒计时设置12345// 设置预提醒和后续提醒间隔（单位：秒）let countdownDuration = Alarm.CountdownDuration( preAlert: (10 * 60), // 10分钟预提醒 postAlert: (5 * 60) // 5分钟后续提醒间隔) 日程安排固定日期模式（不受时区变化影响）： 123456789let keynoteDate = DateComponents( calendar: .current, year: 2025, month: 6, day: 9, hour: 9, minute: 41)let scheduleFixed = Alarm.Schedule.fixed(keynoteDate) 相对时间模式（自动适应时区变化）： 123let time = Alarm.Schedule.Relative.Time(hour: 7, minute: 0)let recurrence = Alarm.Schedule.Relative.Recurrence.weekly([.monday, .wednesday, .friday])let schedule = Alarm.Schedule.Relative(time: time, repeats: recurrence) 界面定制提醒按钮设置123456789101112131415161718let stopButton = AlarmButton( text: &quot;关闭&quot;, textColor: .white, systemImageName: &quot;stop.circle&quot;)let repeatButton = AlarmButton( text: &quot;重复&quot;, textColor: .white, systemImageName: &quot;repeat.circle&quot;)let alertPresentation = AlarmPresentation.Alert( title: &quot;食物烹饪完成!&quot;, stopButton: stopButton, secondaryButton: repeatButton, secondaryButtonBehavior: .countdown) 实时活动界面1234567891011struct AlarmLiveActivity: Widget &#123; var body: some WidgetConfiguration &#123; ActivityConfiguration(for: AlarmAttributes&lt;CookingData&gt;.self) &#123; context in switch context.state.mode &#123; case .countdown: countdownView(context) case .paused: pausedView(context) case .alert: alertView(context) &#125; &#125; &#125;&#125; 生命周期管理使用 AlarmManager 管理闹钟状态： 12345678910111213// 创建闹钟let alarm = Alarm( id: UUID(), schedule: schedule, presentation: alertPresentation, metadata: cookingData)// 调度闹钟AlarmManager.shared.schedule(alarm)// 取消闹钟AlarmManager.shared.cancel(alarmID: alarm.id) 最佳实践 适用场景选择： 精确倒计时（如烹饪、实验计时） 循环提醒（如起床闹钟、服药提醒） 界面设计原则： 保持提醒信息简洁明了 倒计时界面应显示剩余时间 提供明显的关闭和暂停/恢复按钮 避免滥用： 不要替代关键系统通知 不要用于时效性不强的普通提醒 结论AlarmKit 为 iOS 应用带来了强大的闹钟功能，通过系统级集成提供了出色的用户体验。开发者可以灵活地定制闹钟的外观和行为，同时确保符合 Apple 的设计规范。 相关视频 了解 App Intents 了解 ActivityKit 文档 ActivityKit 官方文档 AlarmKit 官方文档 App Intents 框架文档 创建第一个 App Intent 实时活动人机界面指南 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用 PermissionKit 增强儿童安全保护","date":"2025-06-10T07:27:31.000Z","path":"2025/06/10/2025-06-10-wwdc2025_293/","text":"了解 permissionkit 如何帮助你的 app 增强儿童通信安全。我们将向你展示如何使用这一全新框架来创建适龄通信体验，并利用“家人共享”请求获得家长批准。你将了解如何构建与“信息”无缝整合的权限请求、处理家长答复，并为儿童用户量身定制 ui。为了充分从这个讲座中获益，我们建议你先观看 wwdc25 讲座“在你的 app 中提供适龄体验”视频。 视频地址 使用 PermissionKit 为儿童通信安全保驾护航引言在数字时代，保护儿童上网安全已成为开发者的重要责任。苹果最新推出的 PermissionKit 框架为开发者提供了一套完整的解决方案，通过”信息”应用建立亲子沟通桥梁，让家长能够直接审批孩子的通信请求。本文将详细介绍如何利用这一技术构建更安全的儿童通信环境。 PermissionKit 框架概述PermissionKit 是 iOS/iPadOS/macOS 26 中的全新框架，专为标准化权限流程设计。其核心价值在于： 利用”信息”作为天然沟通渠道 支持儿童向父母/监护人申请新联系人权限 提供家长直接审批的便捷体验 实施前注意事项在集成 PermissionKit 前需确认： 用户需加入”家人共享”群组 家长需为孩子启用”通信限制”功能 若不符合条件，API 将返回默认响应 儿童界面定制方案针对儿童用户的安全界面设计要点： 123456789import PermissionKitlet knownHandles = await CommunicationLimits.current.knownHandles(in: conversation.participants)if knownHandles.isSuperset(of: conversation.participants) &#123; // 显示完整内容&#125; else &#123; // 隐藏敏感信息&#125; 通过 knownHandles(in:) 方法识别已知联系人，动态调整界面展示逻辑。 构建权限申请流程分步骤创建完整的通信权限申请： 基础请求创建 1234var question = PermissionQuestion(handles: [ CommunicationHandle(value: &quot;dragonslayer42&quot;, kind: .custom), CommunicationHandle(value: &quot;progamer67&quot;, kind: .custom)]) 增强元数据支持 12345678910let people = [ PersonInformation( handle: CommunicationHandle(value: &quot;dragonslayer42&quot;, kind: .custom), nameComponents: nameComponents, avatarImage: profilePic )]var topic = CommunicationTopic(personInformation: people)topic.actions = [.message]var question = PermissionQuestion(communicationTopic: topic) 界面集成方案 SwiftUI 实现：123CommunicationLimitsButton(question: question) &#123; Label(&quot;申请权限&quot;, systemImage: &quot;paperplane&quot;)&#125; UIKit 实现：1try await CommunicationLimits.current.ask(question, in: viewController) AppKit 实现：1try await CommunicationLimits.current.ask(question, in: window) 家长响应处理机制通过 AsyncSequence 实时监听家长答复： 1234567.task &#123; let updates = CommunicationLimits.current.updates for await update in updates &#123; // 更新界面状态 self.isShowingResponseAlert = true &#125;&#125; 完整工作流程演示 儿童端隐藏未知联系人内容 触发权限申请按钮 系统自动生成信息请求 家长端审批操作 儿童端实时接收响应 扩展安全方案苹果生态提供的完整儿童保护方案： 敏感内容分析 API Declared Age Range API 屏幕使用时间框架 家庭控制框架 实施路线建议 确定用户年龄区间 适配儿童友好界面 集成 PermissionKit 流程 相关视频 在你的 App 中提供适龄体验 文档 DeclaredAgeRange 文档 PermissionKit 文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"在网页上验证身份证件","date":"2025-06-10T07:27:27.000Z","path":"2025/06/10/2025-06-10-wwdc2025_232/","text":"了解 digital credentials 如何增强在线身份验证流程。我们将介绍网站如何整合 digital credentials api，以便请求访问“钱包”中的身份证件所包含的信息。我们还将探讨 app 如何利用新的 identitydocumentservices 框架提供 app 内的身份证件进行在线验证。 视频地址 数字身份证件验证：从网页到App的无缝体验引言随着数字身份证件的普及，在线身份验证正迎来革命性变革。本文将带您了解如何通过W3C数字凭证API和IdentityDocumentServices框架，在网页和应用中实现安全高效的身份证件验证流程。无论是网站开发者希望集成验证功能，还是应用开发者需要提供证件服务，这些技术都能显著提升用户体验。 数字身份证件的优势移动证件（mdoc）标准数字身份证件基于ISO 18013-5标准的mdoc格式，具有三大核心优势： 跨平台互操作性：确保不同系统和设备间的兼容性 隐私保护：仅共享必要信息（如仅验证年龄时无需暴露完整住址） 安全可靠：所有数据均由签发机构数字签名认证，防伪能力远超纸质证件 Apple Wallet中的证件正是采用这一标准，目前已在美国部分机场、商户和Apple Store使用。 技术实现方案网页端集成（W3C数字凭证API）网站可通过三个步骤完成验证流程： 构建请求：向服务器获取签名的文档请求 传递请求：通过JavaScript调用数字凭证API 验证响应：将加密结果传回服务器解密认证 123456789// 示例：调用数字凭证APIconst credential = await navigator.credentials.get(&#123; identity: &#123; providers: [&#123; protocol: &quot;iso18013-5&quot;, request: signedRequest // 服务器生成的签名请求 &#125;] &#125;&#125;); 跨设备支持： 在Mac操作时，验证请求会推送到用户的iPhone完成 非Apple设备可通过扫描二维码使用iPhone存储的证件 应用端集成（IdentityDocumentServices框架）应用开发者需要： 注册可提供的证件类型 实现授权UI界面 处理验证请求并返回加密响应 1234567// 注册证件提供者let store = IDSDocumentProviderRegistrationStore.sharedtry await store.registerDocumentProvider( configuration: IDSDocumentProviderConfiguration( supportedDocumentTypes: [.driversLicense] )) 安全机制整个流程包含四层防护： 请求认证：验证请求方合法身份 响应加密：端到端数据传输加密 签发认证：确认数据来源真实性 mdoc认证：防止证件数据被复制冒用 开发实践建议网站开发者 通过Apple Business Connect获取开发者证书 遵循ISO 18013-5/7标准构建请求 实现W3C数字凭证API前端集成 应用开发者 使用IdentityDocumentProviderRegistrationStore注册服务 添加身份文档提供者扩展目标 设计用户友好的授权界面 结语数字身份证件验证技术正在重塑在线身份认证的体验。通过标准化API和框架，开发者可以构建更安全、更便捷的验证流程。现在就开始探索这些技术，为用户带来无缝的身份验证体验吧！ 相关视频 进一步了解声明式网页推送 Safari浏览器和WebKit的新功能 钱包与Apple Pay的新功能 文档资料 Implementing as an identity document provider Requesting a mobile document on the web 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"了解 PaperKit","date":"2025-06-10T07:27:27.000Z","path":"2025/06/10/2025-06-10-wwdc2025_285/","text":"了解如何将 paperkit 引入你的 ios、ipados、macos 以及 visionos app。我们将介绍如何将 pencilkit 绘画与标记功能 (如形状和图像) 无缝整合，以及如何自定用户界面。了解向前兼容性的最佳实践，并探索高级自定选项，以便为你的 app 打造真正与众不同的标记体验。 视频地址 PaperKit：为您的应用打造强大标记体验引言苹果在 WWDC 上推出了全新的 PaperKit 框架，它为开发者提供了简单易用的方式来为 iOS、iPadOS、macOS 和 visionOS 应用添加丰富的标记功能。本文将带您深入了解 PaperKit 的核心功能、集成方法和自定义选项，让您能够在应用中快速实现专业级的标记体验。 PaperKit 核心组件PaperKit 主要由三个关键组件构成： PaperMarkupViewController：负责交互式创建和显示标记内容 PaperMarkup：数据模型容器，处理标记数据的保存、加载和渲染 插入菜单：提供添加各种标记元素的界面（iOS/iPadOS/visionOS 使用 MarkupEditViewController，macOS 使用 MarkupToolbarViewController） 快速集成指南iOS 平台集成123456789101112131415161718override func viewDidLoad() &#123; super.viewDidLoad() let markupModel = PaperMarkup(bounds: view.bounds) let paperViewController = PaperMarkupViewController(markup: markupModel, supportedFeatureSet: .latest) view.addSubview(paperViewController.view) addChild(paperViewController) paperViewController.didMove(toParent: self) becomeFirstResponder() let toolPicker = PKToolPicker() toolPicker.addObserver(paperViewController) pencilKitResponderState.activeToolPicker = toolPicker pencilKitResponderState.toolPickerVisibility = .visible toolPicker.accessoryItem = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(plusButtonPressed(_:)))&#125; macOS 平台集成1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() let markupModel = PaperMarkup(bounds: view.bounds) let paperViewController = PaperMarkupViewController(markup: markupModel, supportedFeatureSet: .latest) view.addSubview(paperViewController.view) addChild(paperViewController) let toolbarViewController = MarkupToolbarViewController(supportedFeatureSet: .latest) toolbarViewController.delegate = paperViewController view.addSubview(toolbarViewController.view) setupLayoutConstraints()&#125; 高级定制功能自定义功能集1234567891011var featureSet: FeatureSet = .latestfeatureSet.remove(.text)featureSet.insert(.stickers)// 启用HDR支持featureSet.colorMaximumLinearExposure = 4toolPicker.colorMaximumLinearExposure = 4let paperViewController = PaperMarkupViewController(supportedFeatureSet: featureSet)let markupEditViewController = MarkupEditViewController(supportedFeatureSet: featureSet) 自定义背景视图123let template = UIImage(named: &quot;MyTemplate.jpg&quot;)let templateView = UIImageView(image: template)paperViewController.contentView = templateView 数据持久化与兼容性自动保存标记更改1234567func paperMarkupViewControllerDidChangeMarkup(_ paperMarkupViewController: PaperMarkupViewController) &#123; let markupModel = paperMarkupViewController.markup Task &#123; let data = try await markupModel.dataRepresentation() try data.write(toFile: paperKitDataURL) &#125;&#125; 处理版本兼容性12345678910func updateThumbnail(_ markupModel: PaperMarkup) async throws &#123; let thumbnailSize = CGSize(width: 200, height: 200) let context = makeCGContext(size: thumbnailSize) context.setFillColor(gray: 1, alpha: 1) context.fill(renderer.format.bounds) await markupModel.draw(in: context, frame: CGRect(origin: .zero, size: thumbnailSize)) thumbnail = context.makeImage()&#125; 结语PaperKit 为开发者提供了强大而灵活的标记功能解决方案。无论是简单的笔记应用还是复杂的创意工具，通过合理利用 PaperKit 的各种定制选项，您都能打造出满足用户需求的标记体验。现在就尝试将 PaperKit 集成到您的应用中，开启全新的标记可能性吧！ 相关视频 充分利用 Apple Pencil 的强大功能 PencilKit 的新功能 SwiftUI 新功能 文档 PaperKit 官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"深入了解写作工具","date":"2025-06-10T07:27:26.000Z","path":"2025/06/10/2025-06-10-wwdc2025_265/","text":"借助写作工具，用户可以直接在你的 app 内进行文本校对、改写和转换。了解为你的 app 自定写作工具的高级技巧。探索众多格式选项，以及如何在富文本编辑中加以利用。如果你使用自定文本引擎，欢迎了解如何无缝整合完整的写作工具体验，以便用户直接在文本视图中进行修改。 视频地址 深入解析写作工具：从基础集成到高级定制引言在现代应用中，文本处理能力直接影响用户体验。Apple推出的写作工具（Writing Tools）为开发者提供了一套强大的文本处理解决方案，支持校对、改写和总结等核心功能。本文将带你深入了解写作工具的最新特性、原生文本视图定制技巧、富文本格式支持，以及如何为自定义文本引擎整合完整的写作工具体验。 写作工具新特性今年的写作工具迎来多项重要更新： AI增强：通过ChatGPT集成，用户只需简单指令即可生成内容或创建图像 跨平台支持：现已完美适配visionOS，覆盖邮件、备忘录及第三方应用场景 智能调整：在iOS/iPadOS/macOS 26中，用户完成文本改写后可追加风格要求（如”更温暖”或”更口语化”） 自动化支持：新增快捷指令功能，结合Apple Intelligence可自动执行校对和改写操作 开发者现在可以使用新API： 获取系统工具栏按钮和标准菜单项 让写作工具返回富文本的呈现意图 将写作工具协调器整合到自定义文本引擎 原生文本视图定制系统原生文本视图默认支持写作工具。开发者可以通过以下方式优化体验： 使用生命周期方法响应写作工具操作 通过Writing Tools Result Options（原Allowed Input Options）管理格式支持 指定禁止改写的文本范围 对于以文本编辑为核心的应用（如备忘录），建议：1234567// UIKit示例let writingToolItem = UIBarButtonItem.writingToolsItem()toolbarItems?.append(writingToolItem)// AppKit示例let item = NSToolbarItem.writingToolsItem()toolbar.insertItem(withItemIdentifier: .writingTools, at: 0) 富文本格式支持写作工具支持三种文本视图类型： 纯文本视图：使用.plainText选项 富文本视图：使用.richText选项（可附加.list和.table） 语义格式视图：使用.richText+.presentationIntent组合 重要区别： 显示属性：如粗体/斜体等直接样式 呈现意图：传递标题/列表等语义信息，需应用自行转换为具体样式 自定义文本引擎整合对于完全自定义的文本引擎，今年新增的协调器API可实现深度集成： 创建并绑定WritingToolsCoordinator 通过代理方法提供文本上下文 处理文本替换请求 实现动画预览和校对标记 同步编辑状态 示例工作流程：1234567891011// 绑定协调器let coordinator = WritingToolsCoordinator()textView.addInteraction(coordinator)// 处理文本变更func coordinator(_ coordinator: WritingToolsCoordinator, replaceTextIn range: NSRange, with replacement: NSAttributedString) &#123; // 更新文本存储 textStorage.replaceCharacters(in: range, with: replacement)&#125; 结论与下一步写作工具为应用文本处理提供了强大而灵活的解决方案。建议开发者： 尝试新推出的改写追加调整功能 为文本密集型应用添加专用工具栏按钮 探索语义格式支持可能性 参考示例项目实现自定义引擎集成 相关视频 开始使用 Writing Tools 文档 Writing Tools官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"了解面向空间商务 App 的增强功能","date":"2025-06-10T07:27:18.000Z","path":"2025/06/10/2025-06-10-wwdc2025_223/","text":"在去年发布的访问和企业级功能基础上，visionos 26 中最新的增强功能和 api 实现了进一步扩展，快来一探究竟吧！了解这些全新功能如何助你轻松构建模型训练工作流程、增强视频影像，并在本地网络上统一坐标系，从而为企业内部 app 打造协作体验。 视频地址 重磅升级：visionOS 26 企业级空间商务应用开发全解析引言随着 visionOS 26 的发布，苹果为企业级开发者带来了更强大的 API 扩展与增强。这些新特性将彻底改变企业内部应用的开发方式，从模型训练自动化到多人协同空间定位，为企业打造真正高效的沉浸式工作环境。本文将深入解析这些创新功能及其应用场景。 核心功能概览1. 开发流程革命性优化visionOS 26 在开发效率方面实现了三大突破： 开放更多硬件权限：UVC视频外接功能和Neural Engine加速器现已全面开放 命令行模型训练工具：支持自动化对象追踪模型训练 简化许可证管理：全新的Vision EntitlementServices框架让授权管理更智能 2. 用户体验多维增强 窗口跟随模式：关键信息窗口可随用户移动而动态调整位置 共享空间坐标系：基于SharePlay实现多人协同空间锚定 内容安全保护：敏感内容在屏幕共享时自动模糊处理 3. 环境可视化技术创新 多相机访问增强：支持左右相机独立访问和立体视觉处理 区域增强视图：通过VisionKit实现局部区域放大和图像优化 ARKit底层控制：提供更精确的空间定位锚点能力 技术实现深度解析自动化模型训练开发者现在可以通过终端命令直接训练对象追踪模型：1xcrun createml objecttracker -s my.usdz -o my.referenceobject这个功能特别适合需要批量管理追踪资产的工业场景。 共享空间坐标系实现通过SharedCoordinateSpaceProvider API，开发者可以轻松构建多人协同应用： 123456789class SharedCoordinateSpaceModel &#123; let sharedCoordinateSpace = SharedCoordinateSpaceProvider() func pushCoordinateSpaceData(_ data: Data) &#123; if let coordinateSpaceData = SharedCoordinateSpaceProvider.CoordinateSpaceData(data: data) &#123; sharedCoordinateSpace.push(data: coordinateSpaceData) &#125; &#125;&#125; 内容安全保护机制只需简单添加视图修饰符，即可保护敏感内容不被泄露： 123456struct SecretDocumentView: View &#123; var body: some View &#123; SensitiveDataView() .contentCaptureProtected() &#125;&#125; 最佳实践建议 安全第一：明确数据采集用途，最小化隐私信息获取 性能优化：相机增强区域不宜超过视野的1/6 权限管理：确保按需申请企业授权，避免不必要的权限请求 结语visionOS 26 的企业级API为开发者提供了前所未有的工具和能力，从自动化工作流到安全协作，每个功能都针对企业实际需求精心设计。现在是探索这些新技术，为企业创造下一代空间计算应用的最佳时机。 相关视频 与附近用户共享 visionOS 体验 为你介绍适用于 visionOS 的企业 API 使用 ARKit 打造更出色的空间计算体验 探索适用于 visionOS 的对象追踪 文档资源 Building spatial experiences for business apps with enterprise APIs for visionOS Implementing object tracking in your visionOS app 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"StoreKit 和 App 内购买项目的新功能","date":"2025-06-10T07:26:36.000Z","path":"2025/06/10/2025-06-10-wwdc2025_241/","text":"了解最新的 storekit api 增强功能，它们有助于你为顾客提供出色的 app 内购买项目体验。我们将介绍 apptransaction、transaction 和 renewalinfo 中新增的字段，以及针对 app 内购买项目优惠代码所做的更新。我们还将介绍如何使用 app store server library 创建已签名的 app 内购买项目请求，以及如何使用 swiftui 来更新陈列订阅项。 视频地址 StoreKit 与 App 内购买新功能全面解析引言苹果在最新的 StoreKit API 中引入了一系列增强功能，旨在帮助开发者提供更卓越的应用内购买体验。本文将详细介绍 AppTransaction、Transaction 和 RenewalInfo 的新增字段，解析优惠代码的使用更新，并演示如何利用 App Store Server Library 创建已签名的购买请求，以及如何使用 SwiftUI 优化订阅项展示。 核心框架新特性AppTransaction 更新AppTransaction 提供应用原始购买的关键信息，包括： 客户首次购买日期 下载的应用版本号 预购日期（如适用） 新版本新增了两个重要字段： appTransactionID（兼容iOS 15+）：每个Apple ID下载您应用的全局唯一标识符，支持家庭共享场景下的成员唯一识别 originalPlatform（iOS 18.4+）：显示客户最初购买应用的平台（iOS/macOS/tvOS/visionOS），帮助应对商业模型变更 12// 获取AppTransaction示例let appTransaction = try await AppTransaction.shared Transaction 更新Transaction代表成功的应用内购买，新增： appTransactionID Offer Period（优惠对应的订阅周期） advancedCommerceInfo（适用于Advanced Commerce API） iOS 18.4用currentEntitlementsAPI取代了旧的productID查询，能返回用户有权访问的所有交易记录。 RenewalInfo 更新专用于自动续订订阅，新增四个字段： appTransactionID Offer Period advancedCommerceInfo appAccountToken（关联用户账户） 优惠码功能增强今年优惠码支持范围扩大至： 消耗型商品 非消耗型商品 非续订订阅 用户可通过offerCodeRedemptionAPI在应用内兑换。自动续订订阅的优惠码兑换支持到iOS 14.2。新增oneTime支付模式（兼容iOS 17.2+）。 签署购买请求实践采用JSON签名的新API流程： 从App Store Connect获取内购签名密钥 初始化签名上下文 调用创建签名函数 推荐使用开源的App Store Server Library（支持Java/Python/Node.js/Swift）简化签名流程。 12345678// 促销优惠示例SubscriptionPromotionalOffer( offerID: &quot;special_offer&quot;, keyID: &quot;your_key_id&quot;, nonce: UUID(), signature: &quot;signature_data&quot;, timestamp: Date().timeIntervalSince1970) 订阅展示优化新增SwiftUI视图SubscriptionOfferView，特点： 支持通过产品ID或订阅组ID初始化 可选App Store Connect预设图标或自定义图标 visibleRelationship参数控制展示关系（升级/降级/同级/当前/全部） 实现建议：123456SubscriptionOfferView(subscriptionGroupID: &quot;premium_group&quot;) &#123; // 自定义内容&#125;.subscriptionOfferViewDetailAction &#123; product in // 处理详情点击&#125; 迁移建议推荐开发者： 采用StoreKit视图构建应用商店 集成App Store Server Library简化签名 利用新API优化订阅管理流程 相关视频 App Store Connect 的新功能 探索适用于 App 内购买项目的 App Store Server API 认识 StoreKit 与 SwiftUI 认识 StoreKit 2 文档资源 Advanced Commerce API 人机界面指南：应用内购买 设置优惠码 App Store Server Library StoreKit文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"App Store Connect 的新功能","date":"2025-06-10T07:26:23.000Z","path":"2025/06/10/2025-06-10-wwdc2025_328/","text":"了解 app store connect 的最新更新，包括适用于构建版本交付的新网页 ui 以及 testflight 通知的增强功能。我们还将探讨新的 app 发现功能和增强功能，例如适用于自定产品页面的关键词、辅助功能标签以及年龄分级方面的更新等。此外，你还将了解 app 内购买项目优惠代码以及评论总结工具等新功能。 视频地址 App Store Connect 新功能全面解析：从构建管理到应用发现引言App Store Connect 作为开发者管理应用上架的核心平台，每年都会带来多项重要更新。今年，苹果团队推出了从构建上传流程优化到应用发现机制革新的全方位改进。本文将详细介绍这些新功能，帮助开发者更高效地管理应用生命周期并提升用户获取效果。 应用管理优化构建上传与状态追踪 可视化构建流程：新版界面展示应用所有进行中的交付任务，团队成员均可查看 错误构建保留：即使构建因处理错误未被接受，相关记录仍会保留并显示完整错误详情 TestFlight 新界面：新增「构建上传」分区，实时显示从创建到处理的完整状态流程 1234567// 构建状态追踪示例代码（示意）enum BuildStatus &#123; case uploading case processing case readyForReview case rejected(error: String)&#125; 通知与自动化 Webhooks 支持：接收构建状态变更的实时通知 邮件通知增强：处理完成或遇到问题时自动发送提醒 提升应用可见性应用标签系统 AI 生成标签：基于大语言模型分析应用元数据自动生成功能标签 手动编辑控制：在「应用信息」页调整标签展示范围 自定义产品页优化 关键词关联：为不同语言版本设置独立搜索关键词，无需审核即时生效 流量分析：通过应用分析查看各定制页面的搜索表现 应用内购买与营销优惠码扩展 支持类型：消耗型、非消耗型和非续订订阅项目 用户分层：三类目标用户资格设置（新用户/近期消费/非近期用户） 沙箱测试：支持生成测试用优惠码（每季度上限1万组） 用户体验与合规评论摘要 自动生成：整合用户评价亮点的智能摘要 修正机制：对不准确的摘要可提交修改请求 年龄分级改进 新增5个阈值：包含3个新年龄级别 全球适配：自动计算符合各地区要求的分级 家长控制声明：可说明应用内的内容限制功能 无障碍功能 专用展示区：新版产品页单独展示无障碍功能标签 设备级声明：需按设备类型分别说明支持的功能 持续更新：发布后仍可编辑标签内容 其他重要更新 App分析增强：新增100+指标（含订阅和变现数据） Game Center：推出全新社交功能 审核流程优化：支持独立提交背景资源和Game Center内容 技术支持Apple开发者支持团队提供24/7服务（含节假日），建议提交问题时附带： 问题截图 HAR日志文件 详细操作步骤描述 总结本次App Store Connect更新从构建管理到营销推广实现了全链路优化，特别是AI驱动的应用标签系统和优惠码扩展将为开发者带来显著的用户获取提升。建议开发者充分利用新推出的分析工具和自动化功能，持续优化应用表现。 相关视频 使用「App 分析」优化盈利策略 借助 App Store Connect API 实现开发流程自动化 探索 Apple 托管的 Background Assets 通过 Apple Games App 吸引玩家 针对辅助功能标签评估你的 App StoreKit 和 App 内购买项目的新功能 实现 App Store Offers 文档 年龄分级 App Store Connect 帮助 Apple 开发者支持 配置多版本产品页面 无障碍功能营养标签概述 评分与评论概览 申请和管理促销代码 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"了解 HealthKit Medications API","date":"2025-06-10T07:26:21.000Z","path":"2025/06/10/2025-06-10-wwdc2025_321/","text":"了解 healthkit 中的全新 medications api。探索一个使用此全新 api 的示例 app，了解如何访问药品和剂量，并了解你的 app 如何管理此类新数据的授权。 视频地址 HealthKit药物API全面解析：从数据读取到权限管理引言随着iOS 15引入药物追踪功能，Apple的HealthKit框架为开发者提供了全新的药物管理API。这些API不仅能让用户记录用药情况，更为健康类应用开发者开辟了创新空间。本文将深入解析这些新功能，并通过实际案例展示如何高效利用这些API。 药物数据存储机制自iOS 15起，健康App新增了完整的药物追踪功能。用户可以通过以下方式管理药物数据： 在”搜索”标签页添加新药物 设置个性化的服药提醒时间 记录每次服药状态（包括”已服用”、”跳过”或”延迟”等） 所有这些数据都安全存储在HealthKit中，为开发者提供了丰富的集成可能。 核心API解析HealthKit新增了两类关键数据类型和对应的查询方式： 1. 药物对象(HKUserAnnotatedMedication)药物对象包含四个核心属性：1234isArchived // 标记药物是否已停用hasSchedule // 是否设置了服药提醒nickname // 用户自定义的药物昵称medicationConcept // 药物临床标识信息 其中medicationConcept尤为重要，它包含： 唯一药物标识符 标准显示名称（如”阿莫西林三水合物500mg口服片剂”） 药物剂型（片剂/液体等） 临床编码（如RxNorm代码308192） 2. 剂量事件(HKMedicationDoseEvent)作为新型HKSample，剂量事件记录： 服药状态（已服/跳过） 实际剂量与计划剂量的差异 通过medicationConcept关联到特定药物 数据查询实践开发者可以通过以下方式查询药物数据： 基本查询：使用HKUserAnnotatedMedicationQueryDescriptor和HKUserAnnotatedMedicationQuery获取授权药物列表 条件查询： 123456// 查询当日已服用的特定药物记录let predicate = HKQuery.predicateForSamples( withStart: todayStart, end: todayEnd, options: .strictStartDate) 锚定查询：对于需要持续更新的数据（如服药趋势图表），推荐使用HKAnchoredObjectQuery，它能： 动态处理新增样本 跟踪删除的对象 兼容历史数据编辑 实战应用案例通过一个示例应用，我们展示了API的典型使用场景： 授权流程：请求HKUserAnnotatedMedicationType读取权限后，应用自动获得关联剂量事件的访问权 副作用分析：利用RxNorm编码匹配预设的副作用模型（如头痛、恶心） 症状记录：使用表情符号表示症状强度，保存为HKCategorySample 数据可视化：构建服药依从性趋势图表，帮助用户了解用药规律 权限管理最佳实践当用户在健康App添加新药物时： 已请求药物权限的应用会出现在分享选项中 用户可直接授权新药物，无需额外操作 应用重新激活后即可立即访问新增药物数据 特别提示：对于敏感数据，应考虑使用requiresPerObjectAuthorization()进行细粒度控制。 总结与下一步HealthKit药物API通过以下方式赋能健康应用开发： 连接个性化用药数据与临床标准信息 提供完整的用药记录生命周期管理 支持丰富的用药分析和提醒功能 建议开发者： 下载官方示例应用研究实现细节 深入了解RxNorm等临床编码系统 查阅文档掌握剂量事件状态和查询谓词的使用 相关视频 使用iOS和iPadOS上的HealthKit跟踪体能训练 HealthKit入门讲座 文档参考 健康数据访问授权 HKAnchoredObjectQuery文档 HKSampleQuery文档 requiresPerObjectAuthorization()) 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"“钱包”的新功能","date":"2025-06-10T07:26:19.000Z","path":"2025/06/10/2025-06-10-wwdc2025_202/","text":"了解“钱包”中的最新功能和改进。我们将介绍如何以惊艳的全新设计更新你的登机牌，并探索适用于多场次活动门票的新功能。我们还将讨论有助于你将凭证无缝添加到“钱包”中的 api 更新。 视频地址 钱包应用全新升级：多场次活动与智能登机牌解析引言苹果钱包应用在最新版本中带来了多项创新功能，从支持多场次活动的门票到全面升级的登机牌体验，以及更加便捷的通行证添加API。这些改进将显著提升用户使用体验，同时为开发者提供了更强大的工具。本文将深入解析这些新特性，帮助您快速掌握并应用到实际开发中。 多场次活动门票功能功能概述今年的钱包应用推出了”后续活动”功能，允许用户通过一张门票访问多个活动场次。这一功能基于iOS 18引入的海报活动门票语义体系实现，为用户提供了更加连贯的活动体验。 技术实现细节在pass.json配置文件中，”后续活动”信息定义在新的”upcomingPassInformation”数组中：12345678910&#123; &quot;upcomingPassInformation&quot;: [ &#123; &quot;type&quot;: &quot;event&quot;, &quot;identifier&quot;: &quot;unique_event_id&quot;, &quot;name&quot;: &quot;Event Name&quot;, &quot;date&quot;: &quot;2024-07-15&quot; &#125; ]&#125; 每个后续活动对象包含以下关键字段： 类型(type)必须为”event” 唯一标识符(identifier) 活动名称(name) 活动日期(date) 活动详情页配置活动详情页继承了海报活动门票的设计理念，支持以下配置项： 头图展示：默认使用通行证背景图，也可通过”headerImage”指定自定义图片 场馆信息：通过语义字段”venueName”、”venuePlaceID”和”venueLocation”添加 活动指南：可配置常用操作按钮、天气卡片、场馆地图等 值得注意的是，后续活动与通行证结构相同但不会复用通行证属性。开发者需要在后续活动对象中重复定义所有需要的属性。 登机牌全面升级核心改进新版登机牌带来了多项重大改进： 航班追踪系统：自动订阅航班状态变更 深度系统集成：与地图导航和”查找”行李追踪无缝对接 航空公司服务专区：集中展示乘机全流程可操作事项 徽章系统：突出显示票务等级、行李限额等重要信息 智能时间管理：基于语义字段自动计算并维持值机时长 配置建议1234567891011&#123; &quot;semantics&quot;: &#123; &quot;airlineCode&quot;: &quot;AA&quot;, &quot;flightNumber&quot;: &quot;123&quot;, &quot;originalDepartureDate&quot;: &quot;2024-07-15T08:00:00&quot; &#125;, &quot;serviceURLs&quot;: &#123; &quot;lounge&quot;: &quot;https://example.com/lounge&quot;, &quot;upgrade&quot;: &quot;https://example.com/upgrade&quot; &#125;&#125; 重要配置提示： 使用airlineCode+flightNumber+originalDepartureDate语义组合启动航班追踪 代码共享航班优先提供市场方航班号 仅当航班正式改期时才更新originalDepartureDate 在pass.json顶层定义服务URL 自动添加通行证API新版PKPassLibrary API全新PKPassLibrary API简化了通行证添加流程，主要包含三个步骤： 12345678// 1. 请求权限PKPassLibrary.requestAuthorization()// 2. 检查状态let status = PKPassLibrary.authorizationStatus// 3. 添加通行证PKPassLibrary.addPasses([pass1, pass2]) 注意事项 权限请求仅生效一次，后续调用直接返回当前状态 用户可在系统设置中随时修改授权状态 开发者应保持对旧版系统的兼容性 结论苹果钱包应用的最新升级带来了更加灵活的活动门票管理、更智能的登机牌体验以及更便捷的API集成方式。这些改进不仅提升了用户体验，也为开发者提供了更多可能性。建议开发者尽快熟悉这些新特性，为用户提供更加无缝的钱包应用体验。 相关视频 Apple Pay 的新功能 「钱包」和 Apple Pay 的新功能 文档资源 Human Interface Guidelines: Wallet PassKit (Apple Pay and Wallet) 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"Safari 浏览器和 WebKit 的新功能","date":"2025-06-10T07:26:18.000Z","path":"2025/06/10/2025-06-10-wwdc2025_233/","text":"了解 safari 浏览器和 webkit 中最新的网页技术如何助你打造妙不可言的体验。我们将重点介绍不同的 css 功能及其工作原理，包括滚动驱动动画、跨文档视图转换和锚点定位。我们还将探讨针对音频、视频、图像以及图标的新增媒体支持。 视频地址 Safari 和 WebKit 新功能全解析：从动画到布局的全面升级引言作为 Safari 和 WebKit 团队的技术布道师，我很高兴为大家介绍今秋即将发布的一系列网页技术革新。这些新功能不仅响应了开发者的需求，更将为网页设计和开发带来惊喜。我们将重点探讨四大领域的创新：动画效果、布局系统、视觉特效和媒体支持。 动画效果：让网页动起来滚动驱动动画Safari 19 引入了全新的滚动驱动动画技术，它让动画效果与用户的滚动行为直接关联，完全无需 JavaScript 介入。这项技术基于两种新型时间轴： 滚动时间轴：比如页面底部进度条随着滚动进度增长 视窗时间轴：当元素进入视窗时触发特定动画 实现示例：12345@keyframes grow &#123; to &#123; transform: scaleX(1); &#125; &#125;.progress-bar &#123; animation: grow linear; animation-timeline: scroll();&#125; 跨文档视图过渡从 Safari 18.2 开始，只需一行 CSS 就能实现页面切换时的优雅过渡效果：1@view-transition &#123; navigation: auto; &#125; 布局系统：更智能的定位方案锚点定位今秋即将登陆 Safari 的锚点定位功能，与 Popover API 配合使用，可以轻松创建智能定位的提示框和菜单。新特性包括： position-area 属性实现精准对齐 position-try 属性自动调整定位策略 内置响应式处理机制 示例代码：12&lt;button popovertarget=&quot;menu&quot; aria-haspopup=&quot;true&quot;&gt;...&lt;/button&gt;&lt;div id=&quot;menu&quot; popover anchor-name=&quot;--profile&quot;&gt;...&lt;/div&gt;12345#menu &#123; position-anchor: --profile; position-area: bottom span-right; position-try: flip-inline;&#125; 视觉特效：提升设计美感边框背景与形状控制background-clip 新增 border-area 值，允许为边框添加渐变或图像背景。配合新的 shape() 函数，开发者可以轻松创建响应式路径图形。 智能文本排版text-wrap: pretty 特性（Safari 19）自动优化文本排版： 消除段落末行单字现象 减少连字符使用 平衡行尾参差度 实现方式：1article &#123; text-wrap: pretty; &#125; 媒体支持：更丰富的多媒体体验SVG 图标与 HDR 图像今秋将迎来 SVG 图标全面支持，取代传统 favicon。HDR 图像提供更丰富的动态范围和色域，通过 dynamic-range-limit 属性控制与 SDR 内容的和谐呈现。 音视频扩展新增对 Ogg Opus/Vorbis 格式和 WebM 媒体录制 API 的支持，扩展了音视频创作可能性。空间计算方面，现已支持立体渲染 3D 模型和沉浸式视频的无缝集成。 结语这些新功能将帮助开发者创建更流畅、美观且功能强大的网页体验。建议开发者： 使用 Safari Technology Preview 体验前沿功能 通过 bugs.webkit.org 提交技术反馈 访问 webkit.org 查阅完整更新日志 相关视频 了解适用于 SwiftUI 的 WebKit 使用 WebGPU 解锁 GPU 计算能力 在网页上验证身份证件 空间网页的新功能 进一步了解声明式网页推送 文档资源 Can I use Submit feedback Web Speech API - Web APIs | MDN WebKit.org – Bug tracking for WebKit open source project 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"AdAttributionKit 的新功能","date":"2025-06-10T07:26:16.000Z","path":"2025/06/10/2025-06-10-wwdc2025_221/","text":"了解 adattributionkit 的新功能，包括如何衡量重叠的重新吸引转化，以及如何为你的 app 自定广告归因规则。深入了解一个新的回传属性，你可以使用这个属性来衡量广告系列在各个国家和地区的实际效果。我们还将展示新的功能，以及用于测试 adattributionkit 实现情况的最佳做法。为了充分从这个讲座中获益，建议你先观看“了解 adattributionkit”。 视频地址 AdAttributionKit 新功能全面解析：从重叠转化到地理数据引言随着 iOS 18.4 的发布，Apple 为开发者带来了 AdAttributionKit 的一系列重要更新。作为隐私优先的广告归因解决方案，这些新功能将帮助开发者更精准地衡量广告效果，同时保持对用户隐私的最高保护标准。本文将详细介绍这些新特性及其应用场景。 核心新功能1. 重叠转化窗口测量问题背景：以往同一时间只能有一个活跃的重新互动转化窗口，导致复杂用户路径难以准确追踪。 解决方案： 引入转化标签（Conversion Tag）机制，类似书签功能 允许同时追踪多个广告带来的转化行为 技术实现：123456789// 在 Info.plist 中启用功能&lt;key&gt;EligibleForAdAttributionKitOverlappingConversions&lt;/key&gt;&lt;true/&gt;// 使用更新APIlet update = PostbackUpdate(fineConversionValue: conversionValue, lockPostback: false, conversionTag: conversionTag)try await Postback.updateConversionValue(update) 应用场景：用户点击广告A浏览商品，几小时后点击广告B，但最终购买的是广告A的商品——现在可以准确归因。 2. 自定义归因规则灵活配置选项： 归因窗口期自定义 默认值：点击广告30天，浏览广告1天 可针对特定广告网络单独设置 支持完全忽略某类互动（如仅追踪点击广告） 冷却期设置 防止安装后短时间内重新互动的归因干扰 可分别设置安装和重新互动的冷却时长 配置示例（实际使用Info.plist，此处为示意JSON）：123456&#123; &quot;com.example.adNetwork&quot;: &#123; &quot;click&quot;: 5, // 5天点击归因窗口 &quot;view&quot;: &quot;ignore&quot; // 忽略浏览广告 &#125;&#125; 3. 回传地理数据新增字段：国家代码（countryCode） 数据来源： App Store安装：用户账户国家/地区 重新互动：沿用安装时的地理位置 替代应用市场：通过安装验证令牌传递 隐私保护： 采用群体匿名算法 仅当同国家转化量达到阈值时才包含在回传中 不影响现有数据聚合层级 4. 开发者测试工具iOS 18.4新功能： 进入设置 &gt; 开发者 &gt; 广告归因测试 配置应用Bundle ID和测试服务器URL 自定义回传属性（包括国家代码） 手动触发测试回传 测试回传特征： 使用特殊开发签名密钥（kid值不同） 广告网络ID固定为development.adattributionkit 调试时应用ID可能显示为0 最佳实践建议 立即行动项： 评估现有归因策略，在Info.plist中配置新规则 测试环境验证重叠转化功能 SKAdNetwork用户应考虑迁移 升级路径： 先测试新功能再逐步部署到生产环境 监控归因准确性和回传数据质量 资源利用： 充分利用新的测试工具缩短开发周期 结合文档优化配置 总结AdAttributionKit 的这些增强功能代表了Apple在隐私保护广告技术领域的最新进展。通过更精细的转化追踪、灵活的规则配置和实用的测试工具，开发者现在能够在不牺牲用户隐私的前提下，获得更全面的广告效果洞察。 相关视频 将隐私保护融入开发流程 了解 AdAttributionKit 文档资源 AdAttributionKit 主文档 归因规则配置指南 开发者模式测试回传 转化标签使用说明 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"SwiftData：深入了解继承和架构迁移","date":"2025-06-10T07:26:14.000Z","path":"2025/06/10/2025-06-10-wwdc2025_291/","text":"了解如何使用类继承对数据进行建模。了解如何优化查询，并无缝迁移你的 app 数据以便使用继承。探索如何通过子类归类来构建模型图形、编写高效的数据获取和查询，并实现顺畅平稳的架构迁移。了解如何使用可观测持久性历史记录来有效进行更改跟踪。 视频地址 SwiftData 深度解析：类继承与架构迁移实战指南引言SwiftData 是苹果在 iOS 17 推出的强大数据持久化框架，它结合了 Swift 的现代语言特性，让开发者能够轻松建模和存储应用数据。本文将深入探讨 SwiftData 中类继承的运用场景、架构迁移策略以及查询优化技巧，并通过实际案例演示如何构建高效的数据模型。 类继承在 SwiftData 中的应用何时使用类继承类继承在以下场景特别有用： 模型存在自然层级关系且共享共同特征（如旅行模型的基本属性） 属于父模型的自然子域（如商务旅行和个人旅行） 12345678910111213141516171819202122232425262728@Modelclass Trip &#123; var name: String var destination: String var startDate: Date var endDate: Date var bucketList: [BucketListItem] = [BucketListItem]() var livingAccommodation: LivingAccommodation?&#125;@available(iOS 26, *)@Modelclass BusinessTrip: Trip &#123; var perdiem: Double = 0.0&#125;@available(iOS 26, *)@Modelclass PersonalTrip: Trip &#123; enum Reason: String, CaseIterable, Codable &#123; case family case reunion case wellness &#125; var reason: Reason&#125; 继承设计原则 适用于「is-a」关系（如 PersonalTrip IS-A Trip） 避免仅因共享单一属性而滥用继承，这种情况下协议更适合 考虑查询方式：如果需要同时查询父类和子类，继承架构更合适 数据架构迁移策略版本化 Schema 管理随着应用迭代，数据模型可能需要变更。SwiftData 提供了 Schema 版本化和迁移机制： 123456789enum SampleTripsSchemaV2: VersionedSchema &#123; static var versionIdentifier: Schema.Version &#123; Schema.Version(2, 0, 0) &#125; @Model class Trip &#123; @Attribute(.unique) var name: String @Attribute(originalName: &quot;start_date&quot;) var startDate: Date // ... &#125;&#125; 自定义迁移阶段对于复杂的迁移需求，可以定义自定义迁移逻辑： 12345static let migrateV1toV2 = MigrationStage.custom( willMigrate: &#123; context in let fetchDesc = FetchDescriptor&lt;SampleTripsSchemaV1.Trip&gt;() // 执行去重等预处理逻辑 &#125;) 查询优化技巧高效数据查询 复合谓词：结合搜索条件和类型过滤 属性预取：只获取必要属性 关系预加载：提前加载关联对象 限制结果数：如只需获取最近记录 12345678910let searchPredicate = #Predicate&lt;Trip&gt; &#123; searchText.isEmpty ? true : $0.name.localizedStandardContains(searchText) || $0.destination.localizedStandardContains(searchText)&#125;var fetchDesc = FetchDescriptor&lt;SampleTripsSchemaV1.Trip&gt;()fetchDesc.propertiesToFetch = [\\.name]fetchDesc.relationshipKeyPathsForPrefetching = [\\.livingAccommodation]fetchDesc.fetchLimit = 1 数据变更观测变更追踪方法SwiftData 提供了两种数据变更观测方式： 本地变更：通过 Observable 跟踪属性变化 外部变更：使用持久化历史记录追踪 1234var historyDesc = HistoryDescriptor&lt;DefaultHistoryTransaction&gt;()historyDesc.sortBy = [.init(\\.transactionIdentifier, order: .reverse)]historyDesc.fetchLimit = 1let transactions = try context.fetchHistory(historyDesc) 结论SwiftData 提供了一套完整的解决方案来处理数据建模、持久化和迁移。通过合理运用类继承、精心设计迁移计划以及优化查询性能，开发者可以构建高效、稳定的数据层。建议从简单模型开始，逐步应用这些高级特性。 相关视频 SwiftUI 的新功能 使用 SwiftData 历史记录 API 跟踪模型更改 文档 SwiftData 官方文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"使用“App 分析”优化盈利策略","date":"2025-06-10T07:26:09.000Z","path":"2025/06/10/2025-06-10-wwdc2025_252/","text":"探索“app 分析”中新推出的盈利、订阅和优惠分析指标。我们将介绍强大的新数据可视化功能和自动报告如何帮助你做出基于数据的决策，从而推动收入增长。我们还将探讨如何将这些指标与自定产品页面等用户获取功能相结合，以优化并改进你的盈利策略。 视频地址 利用「App 分析」全面优化应用盈利策略概述苹果App Analytics迎来了重大更新，为开发者提供更强大的数据分析工具来衡量和优化应用变现表现。本文将详细介绍新功能的实际应用场景，包括付费用户指标、订阅分析、优惠效果追踪等核心模块。 全新界面与筛选能力2025年版本将分析入口迁移至「应用」标签下，主要改进包括： 重新设计的导航侧边栏：按照用户旅程组织指标 扩展筛选功能：支持同时应用7个筛选条件（之前仅支持3个） 多值选择：单个筛选中可选择多个参数值组合 典型使用场景示例：分析iOS 18设备在美国/加拿大市场，不同流量来源对特定自定义产品页面转化率的影响。 付费用户深度分析针对含内购的应用，新增「盈利」板块提供关键指标： 下载到付费转化率：追踪用户从安装到首次消费的转化路径 每下载平均收入（ARPD）：衡量用户生命周期价值 行业基准对比：自动显示应用表现在同类产品中的百分位排名 实际案例中，某健身应用发现： 整体付费转化率3%（行业25-50百分位） 骑行课程收入显著高于跑步课程 通过群体分析发现跑步者35天转化率仅1.3% 订阅业务分析体系新增的订阅分析模块提供50+专业指标： 状态指标：实时订阅业务快照（活跃计划数、MRR等） 事件指标：订阅状态迁移数据（转化、流失等） 留存率分析：可细分到不同用户群体 关键洞察案例： 跑步订阅用户虽然初始转化率低，但6个月留存率达73%高于平均 骑行订阅更受欢迎但长期留存表现一般 优惠效果追踪针对促销活动的专项分析功能： 优惠转化漏斗：从领取到付费的全流程追踪 留存影响评估：对比优惠用户与非优惠用户的长期留存差异 某免费试用优惠的数据表现： 67%试用用户转化为付费订阅 6个月留存率保持73% 数据导出与APIAnalytics Reports API新增两类订阅报告： 订阅状态报告：时点数据快照 订阅事件报告：状态变更记录替代原有「销售和趋势」报告，提供更完整的数据链路 实施建议 基准对比：定期检查行业百分位排名 优惠策略：针对低转化高留存群体设计试用活动 页面优化：结合自定义产品页面分析不同用户群体的转化路径 技术准备：接入最新的StoreKit API提升购买体验 相关视频 App Store Connect 的新功能 StoreKit 和 App 内购买项目的新功能 探索「App 分析」中的基准 App Analytics 中的新功能 文档资源 Analytics Reports API文档 应用内优惠实施指南 应用性能衡量手册 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"借助 App Store Connect API 实现开发流程自动化","date":"2025-06-10T07:26:08.000Z","path":"2025/06/10/2025-06-10-wwdc2025_324/","text":"了解新的 webhook api 如何为你提供 app store connect 中的实时通知。我们还将介绍一些可帮助你管理用户反馈和构建版本交付的 apl，并讨论如何将这些工具整合到你的开发工作流程中，以提高效率并简化流程。 视频地址 利用 App Store Connect API 实现高效开发流程自动化引言在当今快节奏的应用开发环境中，自动化已成为提升团队效率的关键因素。App Store Connect API 的最新更新为开发者提供了强大的工具集，特别是全新的 WebHook API，能够实现 App Store Connect 的实时通知功能。本文将深入解析如何利用这些 API 来优化用户反馈管理和构建版本交付流程。 Webhook 通知：实时事件驱动开发传统 API 采用轮询机制，效率低下且资源消耗大。Webhook 彻底改变了这一模式，实现了服务器间的主动推送通信。 核心优势 即时响应：当应用状态变化时立即收到通知 多种事件类型：包括构建上传状态、测试版状态、用户反馈等 简化流程：无需持续查询，降低系统负担 配置步骤 登录 App Store Connect 进入”用户与访问”→”集成” 添加 Webhook 监听器并配置： 名称和监听 URL 安全密钥（用于验证） 订阅的事件类型 123456789101112// 示例：通过API注册WebhookPOST https://api.appstoreconnect.apple.com/v1/webhooks&#123; &quot;data&quot;: &#123; &quot;type&quot;: &quot;webhooks&quot;, &quot;attributes&quot;: &#123; &quot;url&quot;: &quot;https://your-server.com/webhook&quot;, &quot;secret&quot;: &quot;your-secret-key&quot;, &quot;events&quot;: [&quot;BUILD_UPLOAD&quot;] &#125; &#125;&#125; 构建上传 API：全流程自动化新的构建上传 API 标准化了整个上传流程，支持跨平台使用。 四步上传流程 创建BuildUpload：指定版本和平台 提供文件详情：通过BuildUploadFiles 上传构建文件：按指令操作 确认完成：发送PATCH请求 12345678910111213// 示例：创建构建上传请求fetch(&#x27;https://api.appstoreconnect.apple.com/v1/buildUploads&#x27;, &#123; method: &#x27;POST&#x27;, body: JSON.stringify(&#123; data: &#123; type: &#x27;buildUploads&#x27;, attributes: &#123; platform: &#x27;IOS&#x27;, version: &#x27;1.0.0&#x27; &#125; &#125; &#125;)&#125;); 测试反馈管理：快速迭代的关键TestFlight 反馈是改善应用质量的重要渠道，新API使其管理更加高效。 反馈类型处理 截图反馈：获取设备信息和截图URL 崩溃日志：直接下载崩溃报告 12345# 示例：获取崩溃日志response = requests.get( &#x27;https://api.appstoreconnect.apple.com/v1/betaFeedbackCrashLogs/&#123;id&#125;&#x27;, headers=&#123;&#x27;Authorization&#x27;: &#x27;Bearer YOUR_TOKEN&#x27;&#125;) 实施建议 建立Webhook监听系统：优先处理关键事件 设计自动化流水线：将构建、测试、反馈处理自动化 探索完整API生态：结合其他App Store Connect功能 相关视频 探索 Apple 托管的 Background Assets App Store Connect 的新功能 文档资源 Beta反馈崩溃提交 Beta反馈截图提交 预发布版本与测试者管理 Webhook通知文档 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-store、分发与营销","slug":"app-store、分发与营销","permalink":"http://djs66256.github.io/tags/app-store%E3%80%81%E5%88%86%E5%8F%91%E4%B8%8E%E8%90%A5%E9%94%80/"}]},{"title":"Apple Pay 的新功能","date":"2025-06-10T07:25:56.000Z","path":"2025/06/10/2025-06-10-wwdc2025_201/","text":"探索 apple pay 中的最新改进和新 api。你将探索 apple pay ecommerce 体验有哪些优化 (例如新增的动态支付按钮)，并了解如何充分利用增强后的预授权付款支持。我们将介绍“钱包”中的订单跟踪将迎来哪些全新功能，并了解一些有助于让订单呈现精美外观的建议。我们还将深入了解 financekit 的新背景交付 api，这些 api 让财务管理 app 即使在非活跃状态下也能获取最新数据。 视频地址 Apple Pay 新功能全面解析：从支付体验到财务管理引言Apple Pay 近期迎来多项重要更新，涵盖支付流程优化、订单追踪增强和财务管理革新三大领域。这些改进不仅提升了用户体验，也为开发者提供了更多创新可能。本文将深入解析这些新功能的技术实现和最佳实践。 增强支付体验动态Apple Pay按钮今年Apple Pay推出了全新设计的动态支付按钮，能够自动显示用户的默认支付方式及卡片图案。这一功能通过以下方式实现： 在支付请求中添加商户类别码（MCC）属性 声明支持的所有支付网络 使用merchantCategoryCode属性设置商业类型代码 如需保留传统按钮样式，可以使用payWithApplePayButtonDisableCardArt视图修饰符。 预授权付款优化预授权付款功能现在提供统一的管理界面和增强的品牌展示能力： 商户可通过Apple Business Connect配置品牌图标、名称和描述图片 在服务器端建立包含加密元数据的接口 返回包含企业标识和交易记录的压缩包（最大5MB） 所有数据传输采用端到端加密 技术实现基于iOS 16的商户令牌（Merchant Token）功能。 订单追踪优化智能邮件识别钱包应用现在能够自动检测邮件中的订单信息并转换为钱包订单。关键实现要素包括： 订单邮件须包含商户名称、订单编号和物流单号 支持通过Apple Business Connect进行品牌统一配置 仍可通过订单文件附件或webServiceURL提供完整功能 订单展示功能钱包中的订单展示支持： 自动通知和实时更新 无邮件更新功能 集成收据与退换货服务 FinanceKit革新后台交付扩展FinanceKit API新增的后台交付功能允许应用在非活跃状态下获取财务数据： 创建后台交付扩展目标 处理didReceiveData回调（包含账户、余额、交易等数据） 可设置小时、天、周等不同更新频率 长时间任务需在willTerminate回调中保存进度 注意扩展与主应用需共享相同的财务数据权限。 结语Apple Pay的最新改进从支付按钮到财务管理形成了完整的生态闭环。开发者可以通过Apple Business Connect统一品牌形象，查阅商户令牌实现细节，或探索FinanceKit后台交付的强大功能。这些创新将帮助您打造更安全、便捷和个性化的支付体验。 相关视频 “钱包”的新功能 了解FinanceKit “钱包”和Apple Pay的新功能 钱包与Apple Pay的新功能 文档资源 Apple Pay开发文档 人机交互指南：Apple Pay 此文章由AI生成，可能存在错误，如有问题，请联系djs66256@163.com","categories":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/categories/wwdc2025/"}],"tags":[{"name":"wwdc2025","slug":"wwdc2025","permalink":"http://djs66256.github.io/tags/wwdc2025/"},{"name":"ios","slug":"ios","permalink":"http://djs66256.github.io/tags/ios/"},{"name":"ipados","slug":"ipados","permalink":"http://djs66256.github.io/tags/ipados/"},{"name":"macos","slug":"macos","permalink":"http://djs66256.github.io/tags/macos/"},{"name":"tvos","slug":"tvos","permalink":"http://djs66256.github.io/tags/tvos/"},{"name":"visionos","slug":"visionos","permalink":"http://djs66256.github.io/tags/visionos/"},{"name":"watchos","slug":"watchos","permalink":"http://djs66256.github.io/tags/watchos/"},{"name":"app-服务","slug":"app-服务","permalink":"http://djs66256.github.io/tags/app-%E6%9C%8D%E5%8A%A1/"}]},{"title":"给面试者的一些建议","date":"2021-12-22T14:02:29.000Z","path":"2021/12/22/2021-12-22-给面试者的一些建议/","text":"前言从一个面试者到面试官，然后再到考虑团队建设，很多看法都发生了很大的改变。但是在自己上百场的面试过程中，也看到了很多自己以前的影子。很多时候并不是自己不够优秀，而是在某些方面没有做好。所以这里来聊聊这些问题。 本文并不想传授什么面试技巧，或者刷提指南，个人认为知识永远是无法短时间内补齐的，只要是有经验的面试官，其实很容易拆穿这种小把戏。我更希望能给大家了解招聘和面试中的一些标准和要求，让大家把最好的一面表现出来。当然在这方面我也还没达到特别高的程度，只能聊聊招聘技术开发的角色的一些问题。 面试官与团队角度很多人，包括我自己，以及刚开始做面试官的时候，都很难去思考我们的招聘标准以及对人的一个要求是什么。但这的确是招人最重要的一个环节。 如何考察一个人考察一个面试者，一般会从下面3个方面进行： 知识 对知识的应用 软实力 知识毫无疑问，作为一个技术人员，知识是最基本的，知识的深度和体量直接决定了上层建筑，这也是最容易区分人和进行量化的部分。 相信大厂的职级系统应该大部分都是直接对标的知识这个维度来设计的。 对知识的应用其实这一点并不太好衡量，这里包括业务经验，过往工作经验，同时作为编程能力的一部分，抽象、总结能力也是非常重要的一部分。所以这点往往会从过往的项目中去考察。 但也存在着一定的问题，一个是不同的业务方向会有不同的经验，另一个是不同的面试官对这个标准都不太一样，很难形成一致的标准。这也是为什么有些面试官会被吐槽，往往都是拿着自己业务的东西，代入到他人的项目中去问。 至于为什么有些大厂会考察算法题，我个人感觉还是有一定道理的。算法除了能看出个人的编码习惯，也能看出一定的抽象逻辑思维能力。单纯从能力角度去量化衡量太难了，而变成算法就容易多了。 软实力作为技术人员，软实力这部分是最不重要的。但是会作为你最终职位和定位的一个参考。这个会在下一点讨论。 所以，只要你技术方面足够厉害，作为技术开发这个职位来说，就不会有任何问题。从Google的招聘思路上，宁缺毋滥，也是类似的。我们可以花大价钱找一个不听话的技术达人（当然不是指破坏者），也不会找一个处事圆滑的老油条。 从招人角度看我们招到的人不可能从一个模子里刻出来的，也不可能在各个方面都达到要求，而如何发挥每个人最大的作用这就属于管理范畴的内容了，团队人才培养与梯度建设不在这里讨论。所以从团队管理的角度看一个人的部分缺点是完全可以用团队来弥补的，这也是我为什么说软实力在技术开发的角色中并不是特别重要，只要你不是害群之马，都不存在问题。 所以，关键的是每个人都要有自己的特色，自己突出的能力，这才是团队比较喜欢的一点。阿里曾经的招聘要求是，必须招到比团队平均线以上的人。我个人的理解应该是，招到在某个方向，或者某个领域，能够超过目前团队能力的人，这样团队才能不停的变的更优秀。 说了这么多，你应该知道企业都想要找到什么样的人了吧？时刻问问自己，自己的优势是什么？不要相信木桶原理，不停的在自己不擅长的领域做无用功。当然基础知识这一点不算在内，因为这是基础的基础。 面试者角度在做面试官后，遇到过各式各样的面试者，这里说一说大家普遍性的几个问题吧。 简历简历是我们给面试官的第一印象，但是从我的角度看来，我几乎没有遇到过一份简历是写的很好的。 从我个人的角度看，我并不想了解你的毕业，四六级成绩，考过什么证书，只会关注你的最近2年左右的工作内容，以及你对技术领域方面的能力。当然这里不是指这些信息没用，而是说对于技术面的面试官来说不是重点。 有些人可能觉得简历应该足够精简，控制在一页以内。其实我想说的是这个完全是误导人，如果你几年的工作经历能够凝练在十行以内，那么我想说的是完全看不出来你所做的事情。精简是对的，但是必须能够说明白你做的事情，你做这件事情的前后缘由，自己的思考和思路，以及最终产生的收益和结果，如果有后续的一些反思是最好的。你需要找到你最亮眼的工作内容，在其中体现出你对于技术的应用，对于问题的探索和思考，这才是一份有亮点的简历。同时，这也能引导面试官在这个方向上来提问题，而不是基于面试官的个人经验。 其中比较典型的问题是流水账，大部分简历都是写的是 1234XXX公司：1. 负责xxxx2. 负责xxx3. 性能优化 当然不是说这样写存在问题，而是在这种描述中完全看不出你个人在这些工作中所做的贡献与价值，这些描述都过于泛泛而谈了，面试官也不知道改怎么询问你在这个业务中的贡献。 与其让面试官去挖掘你的亮点，为什么不直接展示出来呢？所以我的建议是不要被篇幅局限了，找到你自己觉得最优秀的几个方面，用最精炼的语言说明白你在这件事情中的贡献。当然这个要基于你真正做过的事情，不能凭空捏造，被发现了反而是件非常不好的事情。 至于怎么展示你的亮点，可以参考下Star法则。亮点贵在精，而不在多。 准备些什么很多人都会问，我要面试了，需要准备些什么，可以刷哪些题。而我想说的是，临时抱佛脚都是没用的，特别是在知识这一块。 知识只能通过平时的日积月累，以及平时遇到的困难中去总结，任何临阵磨枪其实在优秀的面试官面前都会原形毕露，只要随便换种方式问一问就能知道你是不是真正的掌握了。刷题能骗过的也就是在这一块也不懂的面试官。 那么我们需要准备什么呢？其实很简单，把自己之前做过的事情重新梳理一遍，把自己以前对其中的各种问题的思考都再总结一遍。确保自己能够在讲述自己做的事情的时候，是完整的，条理清晰的。如果有条件可以找别人听一听你的描述，在这个基础上可以进行改进下就好了。其实我们最忌讳问到面试者怎么做或怎么思考的时候，说这个东西其实也没做什么，这个东西是老板派的任务，这个时间有点久了，记不清了。 只要做好平时的积累，以及对自己做的事情的梳理，剩下的就交给机遇吧。 面试中面试中的问题只要你做好前几个，一般问题不大，但是必须要注意几个点。 不要不懂装懂如果被问到知识盲区的时候，千万不要自以为是的回答，不知道就是不知道，没有人是完美的，面试官并不会因为一个盲点而否定一个人的能力，可以大方的承认自己在这块的能力不足。 如果你有自己的理解和推断，可以先承认自己的盲区，然后再说明自己的推断和思路。哪怕这种推断和实际情况不符，但是合理也不会有什么问题。 描述要精炼有部分面试者会出现这类问题，觉得自己回答的东西越多，总有一个点答到了面试官的点。 可以说这种思路完全是错误的，首先不说你说的内容是否有面试官关心的点，你的长篇大论可能面试官根本没有耐心听完。因为面试官要从回答中提炼出重点，然后思考和组织你的知识体系，并且记录，本身就是一件非常耗精力的事情，可能只能专注你的回答前半分钟。所以切记不要有这种想法。 回答一定要精炼，有重点，最好能够做到结构化的去描述。 同时不要夸夸而谈，技术出身的人大部分都是非常务实的，避免天马行空而没有办法实际落地的东西。 技术人员一般对沟通能力不会做太大的要求，只要能精炼的描述清楚一件事情就好了。 总结机遇总是给有准备的人的，所以只要在平时做好积累，总有一天会降临到你的头上的。 欢迎大家给我投简历 djs66256@163.com","categories":[],"tags":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"微前端笔记","date":"2021-06-06T12:26:43.000Z","path":"2021/06/06/2021-06-06-微前端笔记/","text":"目前很多大型业务随着业务的飞速膨胀，单体结构(monolithic)已经远不能符合当前开发模式了，所以后端有微服务，前端有微前端，客户端有组件化，其主要目标都是一致的，都是为了解决单体结构的问题，但是各端也有各自的一些特色，其中后端的拆分最为复杂，而客户端拆分最难以彻底，而微前端则介于这两者之间。 一般来说，都是后端先进行的微服务拆分，而组织架构的调整最好是前后端保持一致，才能确保最低的沟通成本，而从康威定律来看，相应的架构也需要进行同样的调整。 同时服务拆分也给我们带来了异构系统的可能性，不仅仅是后端服务的异构实现，甚至前端也可以采用不同的框架进行搭建，这给予了团队不同的技术选型空间。 服务拆分的最大一个好处就是功能发版不再相互依赖了，减少了团队间的沟通成本与增加了迭代速度。 而对于微前端来说，比较重要的几个方面就是： 页面路由 跨组件通信 页面组合 路由的事情相对比较容易解决，对于多页应用来说，通过配置反向代理即可，只需要定义好各个团队之间的域即可，避免出现冲突等问题。 通信的问题对前端来说也比较容易解决，通过事件冒泡的形式向上传递事件，接收方可以通过在window上加入监听实现。 其中组合的方式较为复杂，有多种形式进行，但是需要保证的是各个团队的职责足够的清晰。 页面合成可以通过： iframe ajax web component 从渲染发生的时间可以分为： CSR SSR 两者混合渲染 可以看到两种渲染方式的明显区别。这种特点在加载时间上也带来了不一样的体验。 下面是技术选型的一个指导。 总结可以看出来微前端既有一部分微服务在后台拆分思路一致的地方，也有和客户端一样单体页面拆分问题。","categories":[],"tags":[{"name":"micro-frontend","slug":"micro-frontend","permalink":"http://djs66256.github.io/tags/micro-frontend/"}]},{"title":"wakeup in XNU","date":"2021-04-03T07:04:51.000Z","path":"2021/04/03/2021-04-03-wakeup-in-XNU/","text":"苹果在iOS13的时候，在内核中加入了一个新的性能衡量指标wakeup，同时由于这个指标而被系统杀死的应用数不胜数，其中也包括我们常用的微信淘宝等。而这个指标完全是由XNU内核统计的，所以我们很难通过日志等普通手段去准确的定位问题，所以这里通过另一种思路去解决这个问题。 为什么要统计 wakeup要定位这个问题，首先我们需要知道这个指标的目的是什么。 XNU中，对性能的指标有CPU、内存、IO，而wakeup属于CPU的性能指标，同时属于CPU指标的还有CPU使用率，下面是XNU中对其限制的定义。 1234567/* * Default parameters for CPU usage monitor. * * Default setting is 50% over 3 minutes. */#define DEFAULT_CPUMON_PERCENTAGE 50#define DEFAULT_CPUMON_INTERVAL (3 * 60) 12345678910#define TASK_WAKEUPS_MONITOR_DEFAULT_LIMIT 150 /* wakeups per second */#define TASK_WAKEUPS_MONITOR_DEFAULT_INTERVAL 300 /* in seconds. *//* * Level (in terms of percentage of the limit) at which the wakeups monitor triggers telemetry. * * (ie when the task&#x27;s wakeups rate exceeds 70% of the limit, start taking user * stacktraces, aka micro-stackshots) */#define TASK_WAKEUPS_MONITOR_DEFAULT_USTACKSHOTS_TRIGGER 70 总结来说，当CPU使用率在3分钟内均值超过50%，就认为过度使用CPU，当wakeup在300秒内均值超过150次，则认为唤起次数过多，同时在阈值的70%水位内核会开启监控。 CPU使用率我们很容易理解，使用率越高，电池寿命越低，而且并不是线性增加的。那么wakeup又是如何影响电池寿命的呢？ 首先我们需要看看ARM架构中对于CPU功耗问题的描述： 1Many ARM systems are mobile devices and powered by batteries. In such systems, optimization of power use, and total energy use, is a key design constraint. Programmers often spend significant amounts of time trying to save battery life in such systems. 由于ARM被大量使用与低功耗设备，而这些设备往往会由电池来作为驱动，所以ARM在硬件层面就对功耗这个问题进行了优化设计。 1234567Energy use can be divided into two components: - Static Static power consumption, also often called leakage, occurs whenever the core logic or RAM blocks have power applied to them. In general terms, the leakage currents are proportional to the total silicon area, meaning that the bigger the chip, the higher the leakage. The proportion of power consumption from leakage gets significantly higher as you move to smaller fabrication geometries. - Dynamic Dynamic power consumption occurs because of transistor switching and is a function of the core clock speed and the numbers of transistors that change state per cycle. Clearly, higher clock speeds and more complex cores consume more power. 功耗可以分为2种类型，即静态功耗与动态功耗。 静态功耗指的是只要CPU通上电，由于芯片无法保证绝对绝缘，所以会存在“漏电”的情况，而且越大的芯片这种问题越严重，这也是芯片厂家为什么拼命的研究更小尺寸芯片的原因。这部分功耗由于是硬件本身决定的，所以我们无法去控制，而这种类型功耗占比不大。 动态功耗指的是CPU运行期间，接通时钟后，执行指令所带来的额外开销，而这个开销会和时钟周期频率相关，频率越高，耗电量越大。这也就说明了苹果为什么会控制CPU使用率，而相关研究（Facebook也做过）也表明，CPU在20以下和20以上的能耗几乎是成倍的增加。 CPU使用率已经能够从一定程度上限制电池损耗问题了，那么wakeup又是什么指标呢？ wakeup 是什么要了解wakeup是什么，首先要知道ARM低功耗模式的2个重要指令WFI和WFE。 1ARM assembly language includes instructions that can be used to place the core in a low-power state. The architecture defines these instructions as hints, meaning that the core is not required to take any specific action when it executes them. In the Cortex-A processor family, however, these instructions are implemented in a way that shuts down the clock to almost all parts of the core. This means that the power consumption of the core is significantly reduced so that only static leakage currents are drawn, and there is no dynamic power consumption. 通过这2个指令进入低功耗模式后，时钟将会被关闭，这个CPU将不会再执行任何指令，这样这个CPU的动态能耗就没有了。这个能力的实现是由和CPU核心强绑定的空转线程idle thread实现的，有意思的是XNU中的实现较为复杂，而Zircon中则非常直接暴力： 12345__NO_RETURN int arch_idle_thread_routine(void*) &#123; for (;;) &#123; __asm__ volatile(“wfi”); &#125;&#125; 在XNU中，一个CPU核心的工作流程被概括为如下状态机： 12345678/* * -------------------- SHUTDOWN * / ^ ^ * _/ | \\ * OFF_LINE ---&gt; START ---&gt; RUNNING ---&gt; IDLE ---&gt; DISPATCHING * \\_________________^ ^ ^______/ / * \\__________________/ */ 而wakeup则表示的是，从低功耗模式唤起进入运行模式的次数。 wakeup 如何统计的ARM异常系统CPU时钟被关闭了，那么又要怎么唤起呢？这就涉及到CPU的异常系统。 在ARM中，异常和中断的概念比较模糊，他把所有会引起CPU执行状态变更的事件都称为异常，其中包括软中断，debug中断，硬件中断等。 从触发时机上可以区分为同步异常与异步异常。这里指的同步异步并不是应用程序的概念，这里同步指的是拥有明确的触发时机，比如系统调用，缺页中断等，都会发生在明确的时机，而异步中断，则完全无视指令的逻辑，会强行打断指令执行，比如FIQ和IRQ，这里比较典型的是定时器中断。 异常系统有很多能力，其中一个重要的能力就是内核态与用户态切换。ARM的执行权限分为4个等级，EL0，EL1，EL2，EL3。其中EL0代表用户态，而EL1代表内核态，当用户态想要切换至内核态的时候，必须通过异常系统进行切换，而且异常系统只能向同等或更高等级权限进行切换。 那么这么多类型的异常，又是如何响应的呢？这里就涉及到一个异常处理表（exception table），在系统启动的时候，需要首先就去注册这个表，在XNU中，这个表如下： 12345678910111213141516171819 .section __DATA_CONST,__const .align 3 .globl EXT(exc_vectors_table)LEXT(exc_vectors_table) /* Table of exception handlers. * These handlers sometimes contain deadloops. * It&#x27;s nice to have symbols for them when debugging. */ .quad el1_sp0_synchronous_vector_long .quad el1_sp0_irq_vector_long .quad el1_sp0_fiq_vector_long .quad el1_sp0_serror_vector_long .quad el1_sp1_synchronous_vector_long .quad el1_sp1_irq_vector_long .quad el1_sp1_fiq_vector_long .quad el1_sp1_serror_vector_long .quad el0_synchronous_vector_64_long .quad el0_irq_vector_64_long .quad el0_fiq_vector_64_long .quad el0_serror_vector_64_long wakeup 计数那么我们回过头来看看wakeup计数的地方： 1234567891011121314151617181920212223242526272829/* * thread_unblock: * * Unblock thread on wake up. * Returns TRUE if the thread should now be placed on the runqueue. * Thread must be locked. * Called at splsched(). */boolean_tthread_unblock( thread_t thread, wait_result_t wresult)&#123; // . . . boolean_t aticontext, pidle; ml_get_power_state(&amp;aticontext, &amp;pidle); /* Obtain power-relevant interrupt and “platform-idle exit&quot; statistics. * We also account for “double hop” thread signaling via * the thread callout infrastructure. * DRK: consider removing the callout wakeup counters in the future * they’re present for verification at the moment. */ if (__improbable(aticontext /* . . . */)) &#123; // wakeup ++ &#125; // . . .&#125; 而这里的aticontext则是通过ml_at_interrupt_context获取的，其含义则是是否处于中断上下文中。 123456789101112131415161718/* * Routine: ml_at_interrupt_context * Function: Check if running at interrupt context */boolean_tml_at_interrupt_context(void)&#123; /* Do not use a stack-based check here, as the top-level exception handler * is free to use some other stack besides the per-CPU interrupt stack. * Interrupts should always be disabled if we’re at interrupt context. * Check that first, as we may be in a preemptible non-interrupt context, in * which case we could be migrated to a different CPU between obtaining * the per-cpu data pointer and loading cpu_int_state. We then might end * up checking the interrupt state of a different CPU, resulting in a false * positive. But if interrupts are disabled, we also know we cannot be * preempted. */ return !ml_get_interrupts_enabled() &amp;&amp; (getCpuDatap()-&gt;cpu_int_state != NULL);&#125; 那么cpu_int_state标记又是在什么时候设置上去的呢？只有在locore.S中，才会更新该标记：1str x0, [x23, CPU_INT_STATE] // Saved context in cpu_int_state 同时发现如下几个方法会配置这个标记： 12345el1_sp0_irq_vector_longel1_sp1_irq_vector_longel0_irq_vector_64_longel1_sp0_fiq_vector_longel0_fiq_vector_64_long 结合上述的异常处理表的注册位置，与ARM官方文档的位置进行对比，可以发现： 这几个中断类型均为FIQ或者IRQ，也就是硬中断。由此我们可以判断，wakeup必然是由硬中断引起的，而像系统调用，线程切换，缺页中断这种并不会引起wakeup。 进程统计由上可以看出，wakeup其实是对CPU核心唤起次数的统计，和应用层的线程与进程似乎毫不相干。但从程序执行的角度思考，如果一个程序一直在运行，就不会进入等待状态，而从等待状态唤醒，肯定是因为某些异常中断，比如网络，vsync等。 在CPU核心被唤醒后，在当前CPU核心执行的线程会进行wakeup++，而系统统计维度是应用维度，也就是进程维度，所以会累计该进程下面的所有线程的wakeup计数。 1234queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) &#123; info-&gt;task_timer_wakeups_bin_1 += thread-&gt;thread_timer_wakeups_bin_1; info-&gt;task_timer_wakeups_bin_2 += thread-&gt;thread_timer_wakeups_bin_2;&#125; 所以在我们代码中，如果在2个不同线程启用用同样的定时器，wakeup是同一个线程起2个定时器的2倍（同样的定时器在底层其实是一颗树，注册同样的定时器实际只注册了一个）。 用户层获取该统计值则可以通过如下方式： 1234567891011121314151617181920212223242526#include &lt;mach/task.h&gt;#include &lt;mach/mach.h&gt;BOOL GetSystemWakeup(NSInteger *interrupt_wakeup, NSInteger *timer_wakeup) &#123; struct task_power_info info = &#123;0&#125;; mach_msg_type_number_t count = TASK_POWER_INFO_COUNT; kern_return_t ret = task_info(current_task(), TASK_POWER_INFO, (task_info_t)&amp;info, &amp;count); if (ret == KERN_SUCCESS) &#123; if (interrupt_wakeup) &#123; *interrupt_wakeup = info.task_interrupt_wakeups; &#125; if (timer_wakeup) &#123; *timer_wakeup = info.task_timer_wakeups_bin_1 + info.task_timer_wakeups_bin_2; &#125; return true; &#125; else &#123; if (interrupt_wakeup) &#123; *interrupt_wakeup = 0; &#125; if (timer_wakeup) &#123; *timer_wakeup = 0; &#125; return false; &#125;&#125; wakeup 治理从以上分析来看，我们只需要排查各种硬件相关事件即可。 从实际排查结果来看，目前只有定时器或者拥有定时能力的类型是最普遍的场景。 比如NSTimer，CADisplayLink，dispatch_semaphore_wait，pthread_cond_timedwait等。 关于定时器，我们尽量复用其能力，避免在不同线程去创建同样的定时能力，同时在回到后台的时候，关闭不需要的定时器，因为大部分定时器都是UI相关的，关闭定时器也是一种标准的做法。 关于wait类型的能力，从方案选择上避免轮询的方案，或者增加轮询间隔时间，比如可以通过try_wait，runloop或者EventKit等能力进行优化。 监控与防劣化一旦我们知道了问题原因，那么对问题的治理比较简单，而后续我们需要建立持续的管控等长效措施才可以。 在此我们可以简单的定义一些规则，并且嵌入线下监控能力中： 定时器时间周期小于1s的，在进入后台需要进行暂停 wait类型延迟小于1s，并且持续使用10次以上的情况需要进行优化 总结wakeup由于是XNU内核统计数据，所以在问题定位排查方面特别困难，所以从另一个角度去解决这个问题反而是一种更好的方式。 同时从XNU中对CPU功耗的控制粒度可以看出，苹果在极致的优化方面做的很好，在自身的软件生态中要求也比价高。电量问题在短时间内应该不会有技术上的突破，所以我们自身也需要多思考如何减少电池损耗。 附录armv8 armv8 program guide","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"},{"name":"wakeup","slug":"wakeup","permalink":"http://djs66256.github.io/tags/wakeup/"},{"name":"XNU","slug":"XNU","permalink":"http://djs66256.github.io/tags/XNU/"}]},{"title":"Flutter 图片控件适配之路","date":"2020-12-10T15:33:36.000Z","path":"2020/12/10/2020-12-10-Flutter图片组件踩坑/","text":"背景目前大部分应用都会使用大量的图片，图片成为当前应用带宽占比最大的一种资源。在我们接入 Flutter 的时候，发现 Flutter 的图片控件缓存完全由自己管理，同时还没有提供磁盘缓存（1.22版本），所以在性能以及体验上均比较差，所以必须对其进一步优化。 图片缓存在目前很多 CDN 实现上，所有资源都是拥有唯一 uri 的，所以很多的客户端实现，是忽略了 HTTP 协议中的 Caches 能力，而是直接将 uri 作为唯一标识符来判断图片资源是否唯一的。这样大大节省了向服务端确认 304 的时间与请求。 而在客户端，一般都会存在至少内存和磁盘这两级缓存，而我们在接入 Flutter 图片库的时候，就希望能够将客户端的缓存与 Flutter 中的缓存进行打通，从而减少内存和网络的消耗。 而目前复用缓存的方向大致有如下3种： 复用视图，完全由客户端来提供 Flutter 的图片能力，就像 React Native 一样。 复用磁盘缓存，不复用内存缓存，这种方案实现相对简单，但会导致内存中存在两份图片数据。 复用内存缓存，由客户端从磁盘加载到内存，并由客户端来管理整个缓存的生命周期，比如和 SDWebImage 进行深度融合。该方案看似是最完美的复用，而且客户端有能力对整个应用的图片缓存大小进行精确的控制。 那么下面我们来看看这几种方案的实现，哪些看似美好的方案，我们都踩了哪些坑。 复用视图Flutter 提供了一种和客户端原生视图进行无缝拼接的方案，原始的动机其实是为了像地图、WebView 这种场景，Flutter 不可能再去实现一套如此复杂的控件。那么如果我们用这个来做客户端图片桥接方案会怎么样呢？ 首先，我们要明白 PlatformView 是如何进行桥接的（以下讨论的都是iOS实现）。在 Widget 中插入一层客户端 View，此时并不是我们想的那样，将此 View 简单的draw到 Flutter Root Layer 上。因为 Flutter 的draw call并不是发生在主线程上的，而是发生在raster线程上的，如果我们想要将客户端的 View 绘制到 Flutter 上，则必须先光栅化为一张图片，然后再进行绘制，这中间的性能开销与延迟显而易见是不可接受的，同时每帧都需要这么做也是不现实的。 所以，Flutter 采用了一种拆分 Flutter Layer 的形式。在插入一个客户端 View 后，Flutter 会自动将自己拆为2层： 123|-----| Flutter Overlay View 2|-----| Native View|-----| Flutter Root View 1 客户端 View 就像夹心饼干一样被2个 Flutter view 夹住，此时位于 Platform View 上层以及后续的兄弟 Widget 都会被绘制到上层的 View 上，其他的依旧绘制在底层。这样虽然解决了客户端视图的接入，但也会导致一个问题，当上层视图发生位置等变更的时候，需要重新创建对应的 Overlay View，为了减少这种开销，Flutter 采用了一种比较 trick 的做法，即 Overlay View 会铺满屏幕，而通过移动上面的 mask 来进行控制展示区域。 1234567891011121314// The overlay view wrapper masks the overlay view.// This is required to keep the backing surface size unchanged between frames.//// Otherwise, changing the size of the overlay would require a new surface,// which can be very expensive.//// This is the case of an animation in which the overlay size is changing in every frame.//// +------------------------+// | overlay_view |// | +--------------+ | +--------------+// | | wrapper | | == mask =&gt; | overlay_view |// | +--------------+ | +--------------+// +------------------------+ 目前已经解决了客户端视图接入 Flutter 的能力，但可以看到，当插入一张客户端 View，Flutter 需要额外创建2个 View 进行分区域绘制。当一个页面存在多张图片的时候，此时额外产生的开销显然也是不可接受的，性能更是不可接受。 下面是 Flutter 官方在 Platform View 上描述的关于性能的考虑。 123456789Platform views in Flutter come with performance trade-offs.For example, in a typical Flutter app, the Flutter UI is composed on a dedicated raster thread. This allows Flutter apps to be fast, as the main platform thread is rarely blocked.While a platform view is rendered with Hybrid composition, the Flutter UI is composed from the platform thread, which competes with other tasks like handling OS or plugin messages, etc.Prior to Android 10, Hybrid composition copies each Flutter frame out of the graphic memory into main memory, and then copies it back to a GPU texture. In Android 10 or above, the graphics memory is copied twice. As this copy happens per frame, the performance of the entire Flutter UI may be impacted.Virtual display, on the other hand, makes each pixel of the native view flow through additional intermediate graphic buffers, which cost graphic memory and drawing performance. 复用磁盘缓存让我们都退一步，我们首先解决网络带宽的问题，那么一个简单的方案便是复用磁盘缓存。 复用磁盘缓存的方案相对可以做的非常简单，并且拥有极低的倾入性。我们只需要设计一套 channel 接口，来同步双方缓存的状态和缓存的地址。 1234567getCacheInfo(&#123; String url, double width, double height, double scale, BoxFit fit&#125;) -&gt; &#123;String path, bool exists&#125; 那么在使用的时候，我们仅需要定制一套新的 ImageProvider，将网络、本地两种 Provider 统一起来即可。 123456789101112131415161718192021222324252627282930313233343536_CompositeImageStreamCompleter(&#123; String url, double width, double height&#125;) &#123; getCacheInfo(&#123;url: url, width: width, height:height&#125;) .then((info) &#123; if (info != null &amp;&amp; info.path != null &amp;&amp; info.path.length &gt; 0) &#123; var imageProvider; var decode = this.decode; if (info.exists) &#123; final imageFile = File(info.path); imageProvider = FileImage(imageFile, scale: this.scale); &#125; else &#123; imageProvider = NetworkImage(info.fixUrl ?? this.url, scale: this.scale, headers: this.headers); decode = (Uint8List bytes, &#123;int cacheWidth, int cacheHeight, bool allowUpscaling&#125;) &#123; final cacheFile = File(info.path); // 缓存到磁盘 cacheFile.writeAsBytes(bytes).then((value) =&gt; &#123; &#125;); return this.decode(bytes, cacheWidth: cacheWidth, cacheHeight: cacheHeight, allowUpscaling: allowUpscaling); &#125;; &#125; _childCompleter = imageProvider.load(imageProvider, decode); final listener = ImageStreamListener(_onImage, onChunk: _onChunk, onError: _onError); _childCompleter.addListener(listener); &#125; &#125;).catchError((err, stack) &#123; print(err); &#125;);&#125; 这里需要注意的是，当不存在磁盘缓存的时候，这里采用了 Flutter 来下载图片，此时需要我们手动将其保存到磁盘上，以保证磁盘缓存的一致性。 复用内存缓存复用磁盘缓存是风险较低的一种改动，但是代价是无法复用内存缓存，不仅仅需要分别读取，同时会保存多份内存缓存，因为双方的内存缓存部分是完全独立存在的。 那么如果我们想进一步优化，则需要采用复用内存缓存的方案，目前同步内存缓存大致有如下几种方案： 利用 channel 通信，将内存传输给 Flutter 利用新特性 ffi 通道，将内存直接传递给 Flutter 利用 Texture 控件，从纹理层面进行复用 ChannelFlutter 官方稳定的消息通信方案，兼容性和稳定性都非常高。当我们需要展示缓存图片的时候，只需要将图片数据通过 BinaryMessenger 形式传递到 Flutter 即可。 由于 Channel 本身就必须是异步过程，所以该方式通信会有一定开销。 同时由于 Channel 在客户端是在主线程进行处理，所以也需要注意避免在主线程直接做加载与解码等耗时操作。 而 Channel 在数据传递过程中，由于机制（从安全角度来看也必须这么做）原因，二进制数据必然会被拷贝一份，这样导致的结果是 Flutter 这边维护的内存缓存和客户端自身的缓存依然是两份，并没有完美的达到我们上述的复用效果。 ffi从消息通信开销以及消息的内存拷贝问题来看，ffi 的出现似乎能够完美解决 Channel 中所有的问题。 原理和实现过程与 Channel 完全一致，此时只需要替换为 ffi 通道即可。ffi 并没有像 Channel 那么长的通信过程，不需要进行消息序列化与解析，也不需要切换线程处理，就像一个 HTTP 请求和一个简单的 API 调用的区别一样。 这里我们需要注意的是 ffi 接口是同步执行的，也就是说客户端执行的时候是处于 flutter.ui 线程，我们必须注意线程安全问题。而对于 Flutter 来说，由于是在 UI 线程执行，所以该方法必须尽量快的返回，不能执行一些耗时比较长的操作。 但是我们采用 ffi 就真的能够解决上述问题吗？仔细研究发现，其实还是不能解决内存复用的根本性问题，下面可以看下 ffi 转换的过程。 当我们把客户端图片加载到内存的时候，是通过 Buffer 的形式传递给 Flutter 的，比如是这样一个结构： 1234struct Buffer &#123; int8 *ptr; size_t length;&#125; 而 Flutter 中图片解码过程会在 engine 层的 io 线程中执行，此时会进行一次图片数据拷贝。 所以，从最终结果来看，并不比 Channel 有更高的缓存复用能力。 Texture另一种是共享 PixelBuffer，也就是解码后的图片数据，在 Flutter 这里可以采用 Texture 来实现复用。 具体实现方案阿里已经研究的非常透彻，这里就不再复述了，我们主要分析下其性能与复用能力。 Texture 复用采用的是 TextureId，这是一个 int 值，所以在两端通信上不存在数据量上的性能开销。其主要过程是： 客户端将纹理注册到 Flutter，同时会返回一个 id 作为唯一标识符（i++）。这个过程发生在 Platform 线程，也就是客户端主线程，而真正注册到 TextureRegistry 中则是在 raster 线程中完成的。 在 flutter.ui 线程处理 paint 事件的时候，会将该 id 传递给 TextureLayer。 并在 raster 线程，从 TextureRegistry 中取出并生成 draw call。 从整体流程来看，Flutter 在中间流转过程全程只使用了 TextureId，并不会操作内存与纹理，并不存在多份缓存的问题。所以这种方案比较完美的解决了上述两个问题。 内存优化虽然从上述分析中，缓存利用率最高的是 Texture，但是从内存上来分析，则出现了一个意想不到的结果。 上图是使用 Flutter Image 控件，加载几张大图的一个内存图，总共增加了 10M 内存消耗。 上图是使用 Texture 方案，加载同样图片所产生的内存消耗，达到了 37M，相差巨大。 同时可以看到原生 Flutter 图片在初始阶段有一个比较大的波峰，同样纹理也有，但相对平缓一些。 产生这样大的区别主要还是要从 Flutter Image 控件的渲染流程中说起。 ImageProvider 将图片加载到内存后，首先会进行解码，而这个事情实在 flutter.io 线程完成的。 图片数据解码之后，会造成一个非常大的内存消耗，因为此时的图片数据是以 pixel buffer 的形式存储的。而 Flutter 在这一过程会进行一个优化，此时解码的数据将不是 100% 大小的，而是会当前 widget size进行调整，计算出一个最优的大小，然后在这一大小上进行解码，所以原生的 Image 反而在内存占用这个方面会比客户端更优秀。 在图片移除后，Flutter 会立刻回收解码后的内存，即 Flutter 仅对图片的原始压缩数据进行存储，并不缓存 pixel buffer。而我们客户端（SDWebImage）则会缓存解码后的全部数据，这也是另一个 Flutter 内存表现比客户端要优的地方。 那么 Flutter 这种策略在内存占用上完胜客户端，是否就必然是好的呢？ 其实从渲染流程中看，Flutter 仅仅是用解码时间换取了内存空间。在实际 Demo 中，列表快速滑动时，Flutter Image 控件的图片展示会有明显的延迟，而采用 Texture 方案，肉眼几乎无法分辨。所以从整体的表现上来说，Texture 方案并不是没有优点。 Size从上述中可以看出来，Texture 方案在内存的表现上比较差，那么我们如何去进一步优化呢？ 对于很多场景，比如用户头像等，都是有一个固定大小的，那么我们可以将该大小作为参数，传给 CDN，在 CDN 上就进行裁剪成我们需要的大小，这样也会节省大量流量。 但是同样有很多场景，我们是无法得到其控件大小的，比如充满容器大小这种场景。我们如何自动在所有图片上加上 Size 参数呢？ 从渲染过程中，Layout之后会触发Paint，而此时该控件的大小必然已经是完全确定的了，那么我们可以在这里做一个假的占位控件，在计算出大小后，再替换为真正的图片。 123456789101112131415161718192021222324252627282930313233343536373839404142typedef ImageSizeResolve = void Function(Size size);class ImageSizeProxyWidget extends SingleChildRenderObjectWidget &#123; const ImageSizeProxyWidget(&#123;Key key, Widget child, this.onResolve&#125;) : super(key: key, child: child); final ImageSizeResolve onResolve; @override ImageSizeProxyElement createElement() =&gt; ImageSizeProxyElement(this); @override ImageSizeRenderBox createRenderObject(BuildContext context) =&gt; ImageSizeRenderBox(onResolve); @override void updateRenderObject( BuildContext context, covariant ImageSizeRenderBox renderObject) &#123; super.updateRenderObject(context, renderObject); renderObject.onResolve = onResolve; &#125;&#125;class ImageSizeProxyElement extends SingleChildRenderObjectElement &#123; ImageSizeProxyElement(RenderObjectWidget widget) : super(widget);&#125;class ImageSizeRenderBox extends RenderProxyBox with RenderProxyBoxMixin &#123; ImageSizeRenderBox(ImageSizeResolve onResolve, [RenderBox child]) : onResolve = onResolve, super(child); ImageSizeResolve onResolve; @override void paint(PaintingContext context, ui.Offset offset) &#123; if (hasSize) &#123; if (onResolve != null) onResolve(size); &#125; super.paint(context, offset); &#125;&#125; 这样，我们就能强制所有图片都必须带上 Size 参数了。 经过这样的优化处理后，内存占用下降到了 2M 左右（由于我用的测试图都是高清图，所以效果看上去会比较明显）。 总结Flutter 的很多思路和策略和客户端有着明显的区别，从图片这一个能力来看，就可以从各个方面进行适配与优化，如果需要达到完美可用的一个状态，看来还是需要不断的投入与探索。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/tags/Flutter/"},{"name":"Image","slug":"Image","permalink":"http://djs66256.github.io/tags/Image/"},{"name":"Texture","slug":"Texture","permalink":"http://djs66256.github.io/tags/Texture/"}]},{"title":"谈谈 Flutter、客户端、React 组件的几个区别","date":"2020-12-01T15:37:30.000Z","path":"2020/12/01/2020-12-1-谈谈Flutter与React的几个区别/","text":"Flutter 是 Google 新的一种跨端方案，大家都非常的看好他的上限。但是实际和大家了解下来，却处于一种比较尴尬的地位。客户端开发觉得这个和原生开发相差很大，学习成本陡峭，而前端又觉得这是一个客户端的技术，同时 dart 语言也远没有 js 灵活好用。但技术总是万变不离其宗，很多思想其实都是殊途同归。这里我们就简单讨论一下 Flutter 与 React 之间的一些区别与联系，有 React 开发经验的同学会更容易理解。 Widget 与 Component 与 ViewFlutter 的 Widget 是页面的最基础组成部分，这个很类似与 React 中的 Component 和客户端中 View 的概念，但却又有本质上的区别。 首先不同的点是 mutable，Widget 是不可修改的，一旦创建就无法进行修改，因为一旦修改了其内容，就无法正确的对其进行 diff。这一点其实和 Component 很相似，虽然 Component 可以直接修改，但本质上还是需要通过状态机进行更新。而 View 则是完全开放其修改的能力的。 其次，概念本身会有区别，大致可以这么认为： 1RenderWidget + RenderElement + RenderObject == Component + &lt;div&gt; == View Widget 不一定会承载视图，即可能承载的是纯粹的业务逻辑或者消息通信能力，不像 Component，即使是个桥接能力的组件，也会生成一个 div 标签。粒度比 Component 更细，这可能也是前端同学觉得不够灵活的一个原因吧。 当 Widget 承载视图的时候，也不是直接承载的，而是通过 RenderElement 进行管理状态，RenderObject 管理布局与绘制。从客户端的角度看，可能这样的对应关系更为贴切： 12RenderElement -&gt; ViewRenderObject &gt;= Layer 从绘制角度看，一个 Widget 未必就代表一个图层，而对客户端来说，一个 View 则必然代表一个或多个图层。Flutter 会对其进行优化，将多个 Widget 合并到一个图层上进行绘制，也有可能一个 Widget 会拆分为多个图层。虽然业务开发过程中不会接触到这个概念，但是必须了解其不同点。其中 RepaintBoundary 就是强制进行拆分图层的一个组件。 Stateful 与 StatelessFlutter 和 React 进行界面更新，都是通过状态机进行的，个人认为这种思路非常的优秀，而客户端则很少基于这种思路进行开发。从性能来看状态机流程所需要处理的流程会多的多，而目前来说，基本不存在这种瓶颈，但在开发过程中却需要一定的技巧，减少状态变更导致的视图树重建开销。 在 React 中，并没有严格的 Stateful 和 Stateless 的区分，只有 class component 和 function component 的区别，Flutter 将这两个概念进行了严格的区分，不允许混用，同时 Flutter 将很多不同类型的能力都进行了特化，目的就是为了进一步的优化性能。 在 Flutter 中 Stateless 仅仅是对于 Widget 层的逻辑而言，并不是代表了这个组件是完全不会有状态更新的，这个在下面的依赖绑定中可以看到。 Dependency依赖绑定是 Flutter 中的一个优化特性，React 也可以做到同样的能力，但似乎并不是官方提供的能力。 依赖绑定让我们拥有了一种控制局部更新的能力，最典型的就是系统的 Theme 组件。如果没有这种能力，那么我们必须在每个使用该能力的地方，都注册监听来更新当前状态机，或者直接重建整棵树。前者会大大增加代码复杂度，而后者则会大大增加性能开销。 个人觉得依赖绑定特别适合应用于数据类型状态机与组件之间的关系绑定。比如当前用户信息状态，不同页面信息状态同步等，这种范围相对较大，同时又需要在多个地方进行数据同步。甚至我们可以实现自定义规则的依赖绑定，这些都可以根据我们的需要进行。 举个例子，当前用户头像中 VIP 状态同步，可以思考下直接使用 instance 和使用 of 之间的区别： 123456789Widget build(Context context) &#123; return AvatarImage(&#123; url: CurrentUser.instance.avatarUrl, childBuilder: (ctx) &#123; final currentUser = CurrentUser.of(ctx) return currentUser.isVIP ? VIP() : null; &#125; &#125;&#125; 依赖绑定\b的发挥空间很大，很多功能都可以考虑下这种能力。 LayoutFlutter 中的布局方案和前端基本保持一致，都是 Flex 布局。但是在 Flutter 中，布局模式被切分为各个子项进行特化，并且是与渲染组件是分离的，而不像网页那样，单个组件可以添加各种属性。这种改变让我感觉特别不适应，更不要说前端开发了，但这对于第一次接触的人来说，学习成本似乎会低一些。 前端写法类似于： 1234567Foo( style: &#123; padding: xxx, width: xxx, height: xxx, &#125;) 而在 Flutter 则需要改为如下结构，似乎变得更加啰嗦了。 12345Padding ( SizedBox ( Foo() )) 布局拆分特化同时也减少了代码复杂度，以及自己新增布局能力的灵活性。 总结可以看到，这几种技术的基本元素依然可以关联起来，只是各自有各自的一些独特能力，相信了解 React 或者 SwiftUI 这种框架的人应该能够很快适应这种开发。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://djs66256.github.io/tags/Flutter/"},{"name":"React","slug":"React","permalink":"http://djs66256.github.io/tags/React/"}]},{"title":"RN优化实践之拆包与预热","date":"2020-10-17T09:24:08.000Z","path":"2020/10/17/2020-10-17-RN优化实践之拆包与预热/","text":"随着RN技术在业务中广泛的应用，一些比较重要的功能也开始采用RN的方案来进行了，这就给RN页面的打开速度提出了更高的要求，因为打开速度是影响用户跳出率的重要原因之一。 拆包对于RN打开速度优化，业界比较通用的方案也就是预热+拆分基础包，减少容器初始化时间和基础库加载时间。 对RN进行拆包可以依赖于官方提供的工具进行，但是官方提供的能力是JS内部的一个拆分加载，如果我们需要做容器预热，则无法使用官方的加载方案，而需要我们从客户端原本的逻辑中进行，进行多步加载。 我们需要对RN的逻辑进行改造，就需要对RN初始化逻辑有所了解。 上图是一个大致的过程，这里我们对比较关键的几个步骤进行简单的说明。 RNBridge在实例化之后，会首先准备好JS运行线程和原生模块。 然后会创建一个JSExcutor，这个执行器决定了JS执行环境是客户端还是远程调试（安卓可以是自己定制的执行器，比如v8）。 加载源码（bundle），这个根据来源不同可能是从本地加载，也可能通过url从远端加载。 由于初始化JS执行器和代码是并行触发的，这里需要一个栅栏同步两者结果，之后开始将代码放入执行器执行（JS代码运行）。 在此之后，客户端会监听垂直同步信号（该信号的作用是在页面发生变更的时候，需要重新刷新页面）。 此时RootView收到JS加载完成的通知，开始触发RunApp逻辑，该逻辑就是启动前端的app注册表中对应的应用。 整个流程比较长，但是分工还是相当明确的，此次拆包改造的地方也非常明确。 上图中绿色框内就是我们此次改造的点，这里为了逻辑简单与实际需求，将加载代码设计了串行加载，如果有需要，加载过程也可以进行并发。 这里我们对加载能力进行一次抽象，加载一段代码定义为一个SourceLoader，那么一个拆包bridge就相当于有一个加载器列表，对应于bridge上的属性就非常简单。 1234567@property (nonatomic, strong) NSArray&lt;id&lt;RCTBridgeSourceLoaderProtocol&gt;&gt; *preloadSourceLoaders; // 预加载的加载器- (void)preloadSourceWithCompletion:(void(^)(NSError *error))completion; // 触发预加载加载器@property (nonatomic, strong) NSArray&lt;id&lt;RCTBridgeSourceLoaderProtocol&gt;&gt; *sourceLoaders; // 非预加载加载器- (void)loadSourceWithCompletion:(void(^)(NSError *error))completion; // 触发非预加载器- (void)loadAllSourcesWithCompletion:(void(^)(NSError *error))completion; // 先加载预加载代码，再加载非预加载代码 这里有一个需要注意的点是，我们需要启动一个垂直同步信号监听，为了性能考虑，需要在预热容器加载到真正视图的时候才能开启，所以这里对加载器增加一个标记，只有加载到该加载器之后才能开启监听。 经过这样的改造，我们的RN就已经支持了多包分布加载了。我们就可以把一些基础功能的js代码打包进app内部，也减少一些包大小。 容器预热以上的分包加载并不能对加载速度有太大的影响，而真正的优化点是容器的预热，可以将很多准备工作先做了，在业务加载的时候只会触发加载业务代码与渲染页面。 受限于手机性能的局限，以及一些苹果官方的策略，我们不太可能无限制的去使用该能力，所以这里按3个方面来看预热。 预热触发时机 目前预热触发的时机主要有下面3个点 冷启动 热启动 容器复用之后 在这些时机触发之后，再延迟一定时间（几秒），进行创建预热实例。延迟一会的原因是这些时机大概率都是在做一些CPU密集型任务，如果此时再加入创建预热容器这种非必须的任务，反而可能影响主业务的一些性能。 预热容器销毁 目前销毁的时机主要有下面2个 内存警告 进入后台 进入后台销毁的目的主要是为了降低后台运行的内存，虽然影响不是很大，但是目前苹果对后台app策略还是比较严格的，减少一点是一点。 预热的场景化 由于RN这种业务在我们的业务中并不是主流业务，可能大部分用户都不会使用到RN，而我们对全量用户进行无差别的开启预热功能，也不是一种最优的方式。目前我们还没有能力对用户场景进行机器学习这样的智能化分析，那么这次就对一些场景做一下简单的归类： 3天内没有使用过RN，则认为该用户 3天内没有由于内存警告而销毁的记录 当前应用启动周期内： 预加载失败3次，则该周期内不再启用预加载 容器预热的关键点是在不影响用户其他体验的时候，尽可能的提高预热的命中率，目前做的一些策略都比较简单，后续如果要优化，就需要深入业务场景中。 总结此次RN的优化分为拆包和预热两部分，各自能力独立，并分别进行AB控制，最大可能保证稳定性。后续优化将会深入业务场景去做一些优化策略。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"}]},{"title":"跨端能力平台化建设","date":"2020-10-05T14:12:59.000Z","path":"2020/10/05/2020-10-05-跨端能力平台化建设/","text":"跨端能力一直是近些年来的大热门，我们对跨端能力也一直抱有非常高的期望，我从2016年开始就一直关注着跨端能力的发展，经历了其中各个发展阶段，而目前我们团队也将建设整个跨端平台化能力，这里就来讨论下跨端的一些东西，以及我们的平台化会如何建设整个生态。 我们真的需要跨端能力吗跨端的发展基本经历了这么几个阶段，h5-&gt;RN/weex-&gt;小程序-&gt;flutter，而最近flutter成了最火爆的弄潮儿，但是我们可以看到，每种跨端方案在提出之初，都被吹捧为将会颠覆整个客户端开发，而现实却是原生开发依然占据着无法撼动的地位。 我在早期也非常的看好跨端方案，因为这是唯一一种能够同时大量降低业务开发工作量的方案，而且跨端的很多技术方案也是领先原生开发一个世代的，无论从学习成本，开发效率以及一些前后端融合的趋势都有着非常优秀的设计，以至于我一直认为跨端将是原生开发的未来，原生开发模式的终结者。然而后续的现实却深深的打了我的脸，从facebook放弃h5以及RN，阿里放弃weex，说明当时的跨端方案几乎是失败的。为什么我会认为当时的方案几乎是失败的，我们又将如何对待跨端这项技术呢，接下来我们可以简单的分析一下。 早期的跨端方案是失败的早期的跨端方案基本都是打着消灭原生开发的口号而进行的，从Facebook对h5的各种优化来看，认为当前的网页早已经能够承担所有能力了，而且随着手机摩尔定律的发展，不用几年，手机就会和电脑一样，能够很好的承载网页了。而现实却是Facebook最终还是没有等来那个美好的未来。 随着前端技术的快速发展，衍生出了react和vue这样的技术，这项技术给前端的开发模式带来了巨大的变革，从此前端不需要再依赖jQuery这样去操作具体节点了，所有DOM节点都被抽象化，这给也给一批跨端先驱者们带来了曙光。既然DOM节点可以被抽象化，同样的原生View也可以被抽象化，并通过映射关系，组建原生视图。可以说，这种思路是一个跨时代的想法，第一次前端与原生应用进行了一次激烈的碰撞。这种碰撞也催生了众多的新的思路与设计理念（比如swiftUI，个人也将部分理念贯彻到了原生开发之中，来解决原生开发的一些问题），在跨端方面也催生了RN和weex这两种方案，这两种方案都以write once, run anywhere这样的主旨努力，想要统一前端、iOS、安卓这几个平台。 但这些技术的最终结果却是很悲惨，Facebook放弃了h5和RN，目前RN也只是开源爱好者在用爱发电了，而阿里也逐步淘汰了weex，可能国内某些厂在内部还在维护一些魔改版。两大创时代的技术创造者最后却放弃了，这让我陷入深深的怀疑，跨端的方向是否是正确的。 大家可能会说，现在还是有大量的公司在使用这种方案，并不代表这项技术是失败的。但我个人认为它的失败在于它并没有完成最早所承诺的能力与效果。 实行这种方案对人员素质要求非常高，需要开发仅对前端、移动端都有所涉猎，在出现一些兼容问题的时候能够自主解决该问题。而现实是这种人才真的太少了，特别是在国内的这种环境，要找到并留住这种人才是非常困难的，而如果人员素质没有达到如此高的程度，那么会大大增加多端的沟通成本，甚至比原生开发需要更多的人力成本（以个人经验来看，一旦涉及到跨端能力接入，那么至少需要1iOS+1安卓+1前端人力，包括接口设计、调试等沟通时间，未必会比原生开发减少太多的人力）。 如果缺乏一个能够掌控全局的人，那么每次需要一个原生能力的时候，便会新增一个接口，而这些接口能力并没有经过良好设计，从而导致这些能力的复用性极差，以至于后期这类接口能力的爆炸，无法维护。这类问题虽然看似比较少见，但在一个业务快速膨胀的团队，仅需要1年时间就可以让沟通成本急剧增加。（不要说文档，如果文档能够解决这类问题，也就不存在前后端接口爆炸的问题了，而且文档也是一种大大增加沟通成本的东西，并且我不相信目前国内有哪个团队在文档这块做到及格的。） 双端有着这种不一致的体验与设计语言，write once, run anywhere这个理念本身就是一个无法达到的乌托邦，并且react-native自身也认识到这个问题，并没有把run anywhere作为自己的目标，而是区分对待两端的特殊性，而在上层进行整合这种特殊性，所以依然无法逃避在不同平台实现不同逻辑。而weex则更激进一些，甚至将原生View给映射为div这种前端标签，想要一次性整合3端，然而这种巨大的不一致性所导致的结果是彻底的失败，最终还是仅仅在移动端进行了部分整合。 当然这些跨端方案还有另一个问题就是通信成本特别高，特别是一些实时性、流畅性要求高的场景，往往是达不到要求的。 综上所述，早期的跨端方案在多个维度都没有兑现自己的想法，所以我认为是失败的，但是这些方案却给我们带了一个意料之外的惊喜，那就是动态化，这个之后再说。 特定领域跨端化实践在经历了早期跨端实践的失败后，大家都开始思考跨端的未来，如果还是想要统一各端的开发，那么很有可能将会经历一样的失败。此时微信找到了一个极好的应用场景，那便是小程序。 小程序这种场景有着这么几个特点： 对动态性要求特别高，因为苹果不允许执行下发动态库，所以必须采用动态化特性 对性能要求一般，但对功能要求较高，需要能够满足大量现有能力 要求较好的隔离性，由于子应用是可以由3方提供服务，那么主应用与子应用之间必须是单向管理的关系，需要严格限制子应用的能力特性，以防被3方软件滥用 要求较高的鲁棒性，主应用就相当于操作系统，能够保持每次升级与优化的兼容性与一致性 那么从以上几个特点来看，设计一套简化版的DSL是必须的，同时需要设计自己的通用能力与权限系统，以及OAuth2认证等。而目前最为符合，同时也是最小开发量的就是h5技术，所以目前常见的小程序基本还是以h5容器为主。 小程序的出现，不仅仅是跨端领域的一次新的尝试，同时也是业务领域的一个创举。小程序的出现，将一个普通的应用，演化成一个完整的平台系统，不仅仅给其他公司提供了一个发展的平台，同时也帮助自己巩固自身的平台地位。将一个巨应用，逐步转化为微应用集合，减少各类成本的同时，也极大的丰富了这种功能服务。可以说小程序就是大平台应用的一次战略性布局，当然现在已经展示出了它的价值。 这次，小程序给跨端指明了一个方向，那就是在特定领域创造价值。 统一移动端思潮的亡者归来flutter的出现，大家又掀起一次跨端思潮的崛起，但这次的崛起，似乎减少了对双端的统一要求（安卓的material与iOS的cupertino），大家似乎已经从狂热的思潮中冷静下来，认识到了各端不一致性的必然性，以及用户对各自平台的接受程度，这次的革新，似乎已经不是write once, run anywhere这样的呐喊，而更多的是对所有“大前端”的开发模式的一次统一。（有很多人认为write once, run anywhere就是flutter的目的，并且是跨端的终极模式，个人认为并不是，这个口号官方从来没有喊过，而且flutter的野心比单纯的实现跨端方案要大的多） flutter的目的并不是单纯的实现一个跨端方案，所以就决定了所采用的技术就不会依赖于各个平台的UI层，它从最基础的GPU绘制开始，完全使用自己的能力，这是一套非常完整的UI框架。由于flutter完全抛弃了各平台的UI层，那么便不存在各个平台的差异性了（这其实也是个坑），理论上可以做到不需要做任何兼容性实现。但现实却是，平台的差异性目前已经深入人心，粗暴的提供一种效果和习惯并不能收获用户最好回应。但是如果你是想要拿着flutter去实现安卓的效果，或者实现iOS的效果，那么你可以打消这个念头了，他能做到的最多是“模拟”，而非“实现”。 那么flutter的应用场景就比较固定了，我们依然只能在一些重业务与展示的场景去使用，而在个性非常突出的场景，以及涉及到大量原生能力的地方，就显得不那么适合了。 为什么我会认为flutter想要打造一个完善的统一的UI开发平台才是其真正的目的。由于目前移动端的开发人员依然比较割裂，而未来的趋势必然是整个前端的大融合，甚至是与部分后端的融合，让业务方去关注整个业务而不是业务的一个点，这样的融合就必须首先统一各端的开发模式以增加效率和人员的流通性，可以说flutter的出现对于移动端未来发展也有深刻的影响。 所以在此看来flutter依旧不能完全实现跨端统一这一乌托邦，但是其引入的很多前端思路将会给目前的客户端开发模式带来足够的冲击。由于flutter这个项目还在快速发展中，所以我会进行持续关注。 跨端能力总结在进入跨端平台化建设之前，我们花了大量的篇幅来回顾各个时间段的跨端发展历程，我这里更多的采用了批判性的角度去看待这些技术，目的是为了找到各个技术的局限性与应用场景。各种技术都有自己的优势与局限性，我们无法将其单纯的判定为成功与失败。 跨端的思路也给我们带来了一些业务上的创新力与未来开发模式的一次变革机会。我们可以看看如何做所有跨端能力平台化整合。 平台化目前业务的发展导致当前项目中引入了多种跨端方案，而在如此多的方案中，我们又该如何选择，如何去有效的利用各个能力，这是我们希望完成跨端平台化的初衷。 跨端方案想要解决的问题无非是两大类： 动态性（快速迭代） 开发效率（成本） 由于客户端应用更新的特性，导致我们的新功能、新特性永远无法第一时间到达用户手上，从安卓碎片化程度来看，就知道想让用户保持更新的习惯是多么困难的了。那么在一些场景，比如活动、微应用等，会非常依赖于实时性调整，就会有强烈的动态能力要求。 而效率问题一直是我们所探讨的，虽然有很多种解决效率问题的方案，但跨端给我们提供的一种思路似乎就是一种万能且直接有效的方案，能够大量缩减客户端的人力，毕竟前端人员比客户端人员会好招的多。 但是跨端方案毕竟不是万能的，在诸多方案上还是拥有大量限制，而理想化的一些优势也需要在特定场景才会有明显的发挥。我们想要组建的平台化，也将会从各个方面去帮助业务与开发人员去正确的选择方案，并且提供一系列完整的能力去保障业务的完好运行。 平台化整体能力大部分时候，我们关心的都是开发阶段的一些问题与解决，开发虽然是跨端方案影响和作用最大的一个环节，但在整个过程中，开发仅占用一部分环节。既然我们希望做一个平台化的能力，那么我们就必须考虑到整个过程的能力。 首先我们需要明确的是，我们的目标是希望所有参与人员，都去关注整个业务，而不是自己这一环节，之前也说过这是未来业务开发模式的一种革新方向。我们不希望产品提了需求就不管了，也不希望开发测试仅仅跟踪到上线这个环节。目前难以做到这一点的主要原因是因为整个流程是割裂的，不同环节都隶属于不同的团队，业务分工足够细，且需要大量人员参与。这种问题在越大的团队会越明显，那么需要平台化去整合的需求也会越强烈。 同时，在整个过程中，人员的因素太过于复杂，需要协调好各个人员与角色，显然不可以仅仅通过沟通与默契来解决，我们必须在整个过程中加入足够多的自动化过程，来推动整个流程的前进，而这自动化的过程，就需要平台化的能力。 跨端方案有很多选择，其之间有很多的相同点，也有很多的区别，而我们在整个过程中，如果因为这其中的不同，从而分化出不同的开发流程，反而会给所有人带来很大的困惑，增加各自的人力成本。 所以可以看到，平台化来整合所有能力也是非常重要的。 业务维度细化如果需要实现以上所说的全流程整合，那么每个业务功能则必会细化为一个个微服务，或者说是微应用。每个业务模块也是按照一个应用的流程来管理。 由于这些应用（业务）所承载的服务其实是比较小的内容，所以人员可以变得灵活调配，与普通开发人员调动不同，调配的不仅仅是“人力”，而是微型“团队”，以此也可以大幅减少沟通成本。 业务细化肯定会带来大量的微应用，就像淘宝这样的巨应用，存在着无数的微应用。我们需要管理所有的微应用，则不论使用跨端技术，都需要提供一套统一的管理流程。 在我们拥有这一个完整的流程后，可以来看看每个阶段需要哪些东西。 技术选型在业务方案的选择中，我们可以提供一个简单的筛选条件，但是并不是一个强制的约束。 在具体的业务场景中，我们所需要考虑会比这些条件多的多。比如有些强依赖原生能力的业务需求，如果我们使用跨端方案去实施，最终结果可能完全的违背了跨端的优势，从而导致多端开发的成本直线上升，可能短时间内看似美好，但从长远来看，将会陷入维护的泥潭。 所以这在很多场合是一个比较经验主义的过程，在我们选型的时候，不要先入为主的去决定使用哪种技术，而应该仔细分析业务场景，使用什么技术可以满足需求的同时，尽可能的减少成本。 框架在引入跨端方案的时候，如果我们毫无节制与约束的使用，最终肯定会变得非常糟糕，那么在此基础上必须有一定的规范来组织与约束大家的使用。 那么下面我们从组织结构、抽象层、沙盒化三个角度进行分析。 组织结构 我们的结构大致分为以上几个层次，这里解释一下中间2层代表的是什么。 基础能力桥接层，是与业务无关的能力，是组建所有应用都需要使用到的能力，可以认为这是一套像POSIX标准接口的定义。所有app内的这一层都是相同的，那么在我们想要移植一个跨端应用到另一个app的时候，就会变的非常简单。事实上我们也的确有一些这样的需求。另一个好处是，统一的标准能够让开发人员更好的进行跨应用间的开发，就像为什么支付宝会故意去抄袭微信小程序的api规范一样。 业务相关桥接层，每个应用必然是会有各自业务的特殊性，导致一些无法进行标准化与通用的能力，那么我们就需要这一层来做一些脏活了。 抽象层 为了满足上述组织结构中的标准接口定义，那么我们必须要引入一个抽象层，来屏蔽各个跨端技术与app之间的不同。 我们的抽象层大致是这么设计的，实现方案这里就不讨论了，后续会增加一篇该方案的文章[Native RPC]。抽象层给使用者与开发者都屏蔽了多端的特性，所表现出来的是完全的一致性。 我们会有一个专门管理接口定义的平台，从该平台上可以自动生成接口调用代码与demo工程，这样可以大大减少接入、测试、回归等成本。 沙盒化 业务细化后我们必须面对的是这些业务对主应用的影响，以及相互之间的影响。这种影响客户端以及平台层面上是无法把控的，所以需要对各个微应用之间进行沙盒化隔离。 沙盒化后带来的另一个需求则是权限管理，由于目前业务都是面向内部的，所以权限方面要求不是特别严格，这里暂不将权限控制作为重要的一环。 业务层多平台统一 上面所涉及的都是跨端与原生之间的一个统一，那么在各个跨端之间的也可以进行一次统一，比如比较有名的有Taro, rax等。 但这种统一仅仅是为了降低前端开发的学习成本与一些降级策略，强行将这些东西糅合到一起，反而可能会导致开发成本变高，不兼容性与性能下降。在我们有比较固定的人力做单平台业务开发的时候，完全没有必要再引入一层复杂的适配，带来额外的复杂度。 这种方案的适用场景比较局限，适合大量且业务复杂度不高的业务，可以快速搭建与上线，适合多平台3方应用的接入，比如各个平台的小程序。 所以这里并不考虑把这种方案作为我们其中一个目标，就像阿里也并没有吧rax作为内部的主流技术。 测试由于我们的跨端能力大部分是使用在业务场景中，所以大部分场景做自动化测试的成本都非常高，所以测试环节基本将会是黑盒测试。而得益于部分跨端技术的动态性，问题的修复成本与原生开发相比会小很多。 线上监控我们选择跨端应用的时候，会比较担心一些跨端应用的负面效果，比如性能，错误率等，所以必须建立比较完善的线上监控系统。 监控系统应该具备我们普遍会关心的一些数据，比如加载时长、错误率、性能指标等，同时提供横向对比的能力，提供业务方一个指导性的意见，同时增强线上预警的能力。 现在这么多不同的跨端技术方案，面临的问题是监控系统的分散，从而无法形成有效的闭环，所以建立一个统一的完整的系统，串联整个迭代链路。 总结随着跨端技术的发展与应用，也给我们的很多基础设施提供了巨大的挑战，如何将跨端的优势真正的发挥出来，来提高我们的效率与灵活性，这是我们必须面对与解决的问题，而在这之中，如何完善与整合多端能力则是重中之重。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"跨端","slug":"跨端","permalink":"http://djs66256.github.io/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"h5","slug":"h5","permalink":"http://djs66256.github.io/tags/h5/"},{"name":"小程序","slug":"小程序","permalink":"http://djs66256.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"react native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"flutter","slug":"flutter","permalink":"http://djs66256.github.io/tags/flutter/"}]},{"title":"谈谈苹果禁用HTML5应用","date":"2020-02-08T04:06:53.000Z","path":"2020/02/08/2020-02-08-谈谈苹果禁用HTML5应用/","text":"苹果在2019年更新了审核条款，其中可能对我们影响最大的就是HTML技术的应用了。 App Updates for HTML5 Apps 总所周知，苹果一向以来都不喜欢动态特性，从最早的其他语言限制，以及到jspatch的禁用。这里涉及到的就有两个问题了。 一是苹果自身所说的保证其生态以及用户体验一致性，这样的确能够淘汰一大批低质量和壳应用，清洗了整个生态环境。 二则是苹果自身的利益。苹果不予许一些应用绕过他的审核，来做一些事情。 国内开发者对于苹果对动态化的态度非常的不满，目前国内对于动态性的热情依然还是非常高涨，这得益于国内软件开发现状。但在我看来，这事情有好有坏。 对于我们客户端开发来说，这个饭碗不会那么容易丢了。 目前市面上的应用参差不齐，还有很多违法的，这的确能够减少很多这样的现象。 对于大部分应用来说，有没有动态化其实并没有太大的影响。 反对的人则主要觉得： 无法热修复（这个人觉得真不能怪苹果，自己的质量不过关，给应用埋下一个后门真的不太好，特别是一些涉及用户隐私和金钱的） 无法实现3端统一，无法一套代码多端使用，减少人力成本。（个人认为想要做3端统一，则必须要牺牲一些平台特性，反而可能造成不符合当前平台的行为。而所谓的write once，目前证明大部分都是夸张的。阿里已经抛弃weex，Facebook自己也没有用RN。至于较少人力成本，这个还真不一定，毕竟想要找到能够了解多端特性的人才还是非常困难的。） 快速响应，快速上线（由于苹果的审核机制，这个是国内最大的痛点。这可能与国内的环境有关，没有长远、详细的计划，经常改变策略） 那么我们真的无法使用HTML5技术了吗？下面我们来解读一下苹果条款。 App Store Review Guidelines: 4.7 HTML5 Games, Bots, etc. Apps may contain or run code that is not embedded in the binary (e.g. HTML5-based games, bots, etc.), as long as code distribution isn’t the main purpose of the app, the code is not offered in a store or store-like interface, and provided that the software (1) is free or purchased using in-app purchase; (2) only uses capabilities available in a standard WebKit view (e.g. it must open and run natively in Safari without modifications or additional software); your app must use WebKit and JavaScript Core to run third-party software and should not attempt to extend or expose native platform APIs to third-party software; (3) is offered by developers that have joined the Apple Developer Program and signed the Apple Developer Program License Agreement; (4) does not provide access to real money gaming, lotteries, or charitable donations; (5) adheres to the terms of these App Review Guidelines (e.g. does not include objectionable content); and (6) does not support digital commerce. Upon request, you must provide an index of software and metadata available in your app. It must include Apple Developer Program Team IDs for the providers of the software along with a URL which App Review can use to confirm that the software complies with the requirements above. 苹果并没有禁止HTML5，而是指出要合理的利用HTML技术。从苹果最终还是上了PWA这件事上来说，苹果并没有阻止HTML5这样的技术。苹果只是希望控制应用的权限，不要做一些挂羊头买狗肉的事情。那么我们来看看目前几种比较热门的技术吧。 RN、WEEX苹果已经警告过这两个方案了，后续虽然苹果并没有对这两个技术下手，但个人觉得从这次苹果的态度来说，还是非常反对这种技术的，因为这个技术太容易做到挂羊头卖狗肉的事情了。虽然这个和热修复来说，只是公开了有限的能力，但其本质上来说和HTML5应用还是一样的。 那么我们一点都不能用了吗？以目前苹果的态度来说，也没有完全禁止，只是禁止使用这些技术做核心功能，而一些次要功能应该暂时还是安全的。如果是纯RN应用，那么个人建议还是尽早想想退一步的方案了。优化好的网页也不比原生的差。 小程序小程序这个其实已经动到了苹果的利益了，如果你不是大厂，个人不太建议去试探苹果。 而这次更新，苹果更是明确说了HTML5应用更适合在浏览器上使用，而不是一个独立的app。\b所以个人并不太看好这个方案。 flutter以目前来看，最符合苹果的方案只有flutter了。 因为在iOS系统中，flutter是以二进制打包进去的，并没有违反苹果的条款。 听说咸鱼团队已经开始做flutter的字节码虚拟机了。恩。。。这个个人还是持保留态度，也建议小厂不要没事和苹果干。 最后最后，我们需不需要动态特性依然还是需要看自身业务需求，大量展示型的，没有复杂交互的页面使用这类技术的确拥有更多优势，但是动态性的投入产出比可能并不一定能有那些技术宣传的那么好。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"开发标准化杂谈","date":"2020-01-31T14:12:41.000Z","path":"2020/01/31/2020-01-30-开发标准化杂谈/","text":"在iOS开发这一块，国内的标准化做的都不太好，和国外的一些项目相比，差距非常大，所以这里就来谈谈标准化的重要性吧。 标准化需要标准化的场景非常多，比如： 文档 代码规范 接口 方案设计 就拿文档来说，目前应该几乎没有对注释的覆盖率有要求的，特别是客户端这种以写业务为主的场景，没有注释那是自然的。 Why为什么个人非常看重标准化这个问题。 因为在这些年的工作经验中，发现有很大一部分bug是由于标准化做的不足而引起的，而这些问题往往是那种非常简单的错误。 另外一个是在做一些重构或者整合的时候，没有做标准化的业务几乎很难去重构，需要花费大量精力去“适配”这种不标准。 比如： 用户id的定义，可能是id，userId，resourceId，这些不同的名字往往会让人非常困扰。更为困扰的是拥有相同名字，却有不同的含义的内容。 这些都非常影响软件的质量。 How其实这类问题并不是我们才有的问题，这些问题基本上都有现成的比较权威的方案。 比如代码规范，Google整理的各种语言的规范，阿里的java白皮书这种都可以参考。 比如接口中分页的设计，以前总要在pageSize，lastId，lastTime等众多方案中挑选一种，而没有采用一些更优秀的设计（可以参考GraphQL的分页方案）。 标准化的解决方案，大部分问题我们都可以参考现有的解决方案。 困难虽然标准化这个事情看起来非常简单，但是要实施起来却非常困难。 标准化不仅仅是单端的问题，甚至可能从需求方开始就要改善。这样所涉及的人过于庞大，更不要说像阿里这种大厂了。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"页面组件化设计汇总","date":"2019-11-29T17:58:55.000Z","path":"2019/11/30/2019-11-30-页面组件化设计汇总/","text":"现在的应用都是越来越大，越来越复杂，更加需要模块的精细化切分，以及支持多人共同合作开发。 目前大量应用单纯一个页面的业务量级已经非常庞大，这里就来再次从页面级别讨论一下页面组件化。 前言我们可以将任何一个页面都视作一个列表，每类元素都可以看做列表中的一个cell。之前，在美学新项目启动的时候，按照页面组件化的思路做了一个组件化拆分方案（DDComponent），在当时的业务场景来说，已经基本足够，但是在不停的使用过程中，也逐渐发现了一些问题，比如 数据源不匹配。这是一个非常常见的问题，异步、没有正确reloadData都是引起这类问题的原因，目前我还没有看见过有哪个开源方案能够彻底解决这个问题的。 reloadData效率问题。当一个列表足够长的时候，每次reloadData都将会非常消耗性能。 size计算。在布局和构建列表的时候，最让人麻烦的就是size计算，这会让我们的布局工作量加倍，而系统提供的方法实际效果并不好，虽然有FD的自动计算方案，但依然存在很多问题。 通信问题。组件间应该是相互独立的，如何解决相互间的通信问题也是一个重点。 这次重新设计的这套数据驱动系统主要考虑了如下几个目标： 开发效率。在目前的业务开发过程中，效率永远是第一的，决定业务快速迭代的基础。 并行开发。在这个多人合作的场景中，如何减少沟通成本也是非常关键的，而从架构层面解决这个问题是最有效的。 复用。对于一些信息展示类为主的应用，到处存在着复用问题，而以前的复用层面仅仅是view、model，而无法把这个模块的MVC进行复用。 标准化。提供一套完全标准化的页面组件方案。 扩展性。能够应对平时的大部分场景以及不同类型布局系统。 执行效率。从架构的层面考虑性能问题，并为性能优化提供一系列方案，并且可以进行逐步优化。 数据源不匹配问题数据源问题是我们开发列表中遇到的最大的一个问题，也是非常难以解决的问题。 场景当一个列表比较简单的时候，我们很少会有这样的问题。但是随着业务发展，列表内容越来越复杂，那么就非常容易出现这类问题，主要可能表现为以下几个场景： cell 为空 数组越界 非法调用（类型不匹配） 原因在我们处理数据的时候，如果在if-else的条件里面遗漏了某种数据，可能会导致该数据返回空cell。这种情况在迭代和重构的时候，由于对现有业务没有透彻的理解，就很容易发生。 而数组越界、非法调用，往往是异步和时序问题。在我们更新数据源之后，如果没有及时、同步、正确的更新列表，就会发生这样的问题。这类问题一般是偶现的问题，难以排查，也难以修改。而且如果该页面是拆分后的结构，那么每个独立模块内可能是正常的，但是多个模块间相互影响可能就是有问题的。 如何解决这个问题？我们很难去保证每个人的开发素质，也很难去保证多人并行开发过程中的沟通和一致性。所以我们需要从架构层面去解决这个问题。 解决这个问题的关键在于数据源，我们列表中所展示的数据，和我们正在处理的数据并不能保证一致性，那么最好的解决办法就是保存两份数据源，一份是开发自己维护的，一份是用于页面展示的。 目前列表所有接口返回的都是位置信息，而不是我们展示的数据，我们需要得到数据就需要从数组中的位置去取，这也无法保证展示的数据源index和真实的数据源index的一致性。 那么这里需要解决的问题总结为： 展示数据源和当前数据源的分离 抹除位置信息，直接通过数据来表示 数据源分离实现其实做数据源分离的思路很简单，系统的很多设计思路也是类似的。在我们提交数据源变化的时候，我们直接创建一个只读的数据源快照，用于展示使用。当我们再次刷新的时候，同样需要生成一个新的快照用于刷新列表。大致的流程如下： 123456789--&gt; update data ---&gt; original data source --&gt; update data --&gt; original data source --&gt; ... | | reload reload | | v v snapshot ---&gt; display data source snapshot ---&gt; display data source | | v v UICollectionView UICollecitonView 绑定数据，而不是index我们开发过程中，一直以来都是以index为核心进行布局数据，而没有从数据进行布局列表，这是导致这类问题最根本的思路上的问题，如果我们所有接口都是直接得到相应的数据，我们不需要操作index，那么我们就绝对不会出现越界等问题了。 那么我们可以把接口设计成这样： 123456- (NSArray *)viewModelsForComponent:(NELayoutEntityComponent *)component;- (Class)component:(NELayoutEntityComponent *)component cellClassForViewModel:(id)viewModel;- (CGSize)component:(NELayoutEntityComponent *)component sizeForViewModel:(id)viewModel;- (void)reloadViewModel:(id)viewModel;- (void)deselectViewModel:(Type)viewModel animated:(BOOL)animated; 所有行为都必须通过数据来执行，让真实的数据作为模块的核心。那么这里数据就必须具备唯一性这个条件。 可能你要说，并不是每一个模块都是有这么明确的数据类型来表示，那么这时候可以让该组件自己作为数据来表示。因为这里每一个组件的数据可以认为是每个组件的全局唯一id，只要保证其唯一性即可。 reload 效率问题列表刷新的效率问题主要集中在两个地方： 刷新导致重新计算布局 刷新导致大量更新视图数据 要解决这两个问题，可以增加size缓存、减少计算量以及视图更新的频次。为了减少计算量，这里引入增量系统。 对应于上面所述，我们将数据作为列表的核心，所以我们可以对数据源进行增量计算，对比得到变化的部分进行更新。而这也是很多系统所采用的方式，比如IGList。 这里为了一些异步能力考虑，并没有采用IGList这些成熟的开源框架，而是重新设计了更新流程。 1234567main thread: new data source -+ +-&gt; force update -&gt; reload collection view v ^thread1: +-&gt; size ----+ | |thread2: +-&gt; differ --+ v cancel ---&gt; back to &#x27;new data source&#x27; state 在触发更新并且重新生成快照之后，会进入两个异步线程，分别进行计算数据源增量和异步size计算（在需要极限优化性能的时候可以采用，在下个章节中讨论）。计算完增量后回到主线程，然后进行列表的更新。在这个过程中间如果触发了新reload，那么直接取消这一次的数据刷新操作，忽略该次结果。 这样，我们尽可能的减少列表的刷新和数据源的频繁计算，同时也在异步进行数据源增量计算（目前来看这个时间占总刷新时间的比例并不高）。 效率追踪在以前我们写一个大页面的时候，如果出现性能问题，我们需要去查找问题的原因往往靠经验，也就是猜测，然后一个个排查。这样大大降低了我们排查问题的效率和准确性。 而且以前的问题都是后知的，也就是发生严重影响的时候，才会反过来修改。 而我们进行组件拆分后，每个类型的组件都是独立的，我们可以在任意我们所需要的地方，比如： size计算 diff耗时 cell渲染 进行插桩、统计与分析。那么我们可以在投入生产之前就能得到一手数据，甚至在这些地方加入限制与报警，从而进行精确的优化。 数据源differ协议数据需要能够比对增量，就必须满足一定的规则，这里采用的和IGList一样的协议。但是这样会带来一些问题： 对每一个数据需要重写diffable协议，增加了开发工作量。 每一个数据都需要做copy，才能进行对比前后变化，这对工作量和性能都会有一定的影响。 并不能保证团队所有人都能够正确的理解和设计diffable内容，不良的设计可能直接导致增量系统的未知行为（比如不能保证数据的唯一性）。 在迭代过程中，数据diffable并不是一成不变的，可能会根据需求来改变其等价的条件。 在同一个应用中，可能在不同场景中的等价条件是互斥的，这样我们就无法复用该数据模型。 基于这些问题，我决定完全放弃基于diffable协议去做更新操作，而是基于数据去强制刷新。 12- (void)reloadDataWithForce:(BOOL)force animated:(BOOL)animated;- (void)reloadViewModel:(id)viewModel withForce:(BOOL)force animated:(BOOL)animated; 在很多场景下，我们仅需要更新某个cell的数据，就可以直接采用该能力，而默认我们则采用数据指针这一个唯一值作为参照条件。这样可以让我们减少需要小心维护数据协议的大量工作量。 size问题size计算一直是iOS开发过程中一个非常机械且重复的工作，而且特别容易出bug。 如果一个cell的布局非常复杂，那么这个计算过程也会显得难以阅读。 如果经过很长时间的迭代，也会让计算的逻辑变得复杂无比。 如果cell中有多行文字，那么计算文字既耗时，又会让逻辑变得混乱，同时一旦修改一个字体等属性，很容易遗漏了size计算中的属性。 如果cell中的元素比较动态，会根据不同数据做不同展示。 size计算如果由每个人去写，会产生各种各样的写法，甚至隐含了很多的问题（目前为止见过太多这样的问题了）。 自动计算其实cell最终展示的时候，我们是可以确认size的，比如安卓的listView，以及tableView的自动适应size。 既然我们可以根据cell的数据排版可以知道size，那么我们其实是可以自动计算出size的。这样不仅减少了一定的工作量，而且也避免了很多bug。 到这里，肯定很多人跳出来说，你这样做性能肯定不好。当然这么做性能可能会变差，但是以目前设备性能和未来的增长速度，大部分场景下性能是过剩的，那么我们为什么不去好好利用这一优势。就像有人说的，未来移动端肯定会被前端所统治一样。 要做到可以自动计算size，那么布局系统就不能使用手写frame的方式了。目前苹果提供给我们的AutoLayout布局就能很好的完成这个任务。 另外第三方的flexbox也是非常好的一种布局方式，关于flexbox布局之前我也介绍过，但是官方的YogaKit并不好用，所以我重新设计了一套与JSX、SwiftUI类似思想的方案，同时做了一些优化。这个之后可以专门介绍一下。 缓存size计算另一个非常重要的点就是缓存。我们的列表往往是增量加载的，所以每次的数据和展示并不会发生变化，所以也就没有必要每次都计算一次size。 目前有一些第三方库可以做到这一点，但是很多都是基于indexPath的，而且需要自己手动进行缓存与查找。而在这里，我们的架构有着天然的优势，那就是我们是完全基于数据的，所以这里可以做到完全自动的缓存能力。只需要开启该能力即可： 1self.cacheEnable = YES; 当然我们也会有手动清除缓存的接口和能力。 size性能优化当然，我们也不排除一些页面存在性能问题，比如一个页面加载了非常大量的数据，或者页面布局过于复杂，或者数据解析比较耗时等等，都可能导致我们的自动计算耗时增加。 一种方式是对解析完的数据和布局进行缓存，这样能够非常好的解决刷新与复用的问题。 如果随着业务迭代，我们发现了性能出现瓶颈，那么我们可以精确的对一类数据进行优化。如下表所示： 123 自动计算 自动计算+缓存 手动计算 手动计算+缓存 异步计算 异步计算+缓存 开发效率 &gt; &gt; &gt; &gt; &gt; &gt;执行效率 &lt; &lt; &lt; &lt; &lt; &lt; 但我们一般不推荐一开始就考虑性能问题，我们还是需要以质量和开发效率为主。 性能优化补充一般我们反对一开始就考虑性能优化，因为可能这里根本不会存在性能问题，没有必要浪费大量的时间在这，而且会把简单的东西变复杂了。 但是从架构上，我们还是需要考虑到需要优化的这种场景与需求，在架构层面我们就需要能够支持一步步的优化与数据验证，这样才能够看到量化的结果和形成闭环。 123开发 --&gt; 迭代 --&gt; 性能报告 ------&gt; 迭代 --&gt; 性能报告 \\ | 分析问题 --&gt; 优化性能 通信问题一个页面是有关联性的，当我们把一个页面拆分为多个组件的时候，就必然存在组件间通信的问题。 我这里的解决方案比较简单，做一个局部通知系统的机制，使用消息转发，只要组件实现了协议A，那么该组件就会自动接收到协议A的消息，从而达到了通信的目的。而这个通知系统只作用于当前vc和当前组件树中的组件，不会逃逸到其他地方。 这里为什么要使用通知这种方案呢？ 消息传递的层次性。我们要通过delegate从组件A上传递消息到组件B上，那么整个链路可能是：组件A-&gt;section A-&gt;viewController-&gt;section B-&gt;组件B，整个链路非常长，而且难以管理。 消息并不一定是一对一的，存在一对多的情况。比如viewController的appearence事件，可能任意组件都需要知道这个事件。 优点 开发效率高 灵活且适用性高 解决了链路长的问题 在不同组件组合的场景下，具有更高的兼容性与解耦性 避免了消息逃逸到其他页面 缺点 和常见的回调、通知机制不同，需要一定的了解学习 需要在组件树中的组件才会收到消息，会在某些时候产生一定的误解 其他方案这里并不限制和约束其他的通信方案，比如delegate，notification等。而该方案从总体来说，解耦的优势还是更为突出。 曝光问题对于cell的display事件来说，在某些情况下可能是不准确的： reloadData触发复用的时候 组件移除组件树的时候，或者组件发生替换的时候 这和CollectionView与拆分组件的机制有关，所以这里设计了一套全新的曝光方案，使用数据，而不是cell作为曝光源，来做到更为精确的曝光。 下面简单的说明下思路。 曝光检查此次采用的是主动检测方式，在列表发生滚动的时候，会触发一次曝光检查。检查的目的是为了找到： 哪些数据由不可见-&gt;可见 哪些数据由可见-&gt;不可见 这个可以利用CollectionView的visibleIndexPaths来查找，如果需要更为精确的数据，还可以自己再根据inset再校验一遍。 检查时间点那么那些场景可能会需要检查？ 列表滚动 reloadData viewControllerAppearance 以及其他根据业务需求可以增加的检查。 效率目前还未发现这种方案的效率问题，一般来说可见的组件也不会有很多，不会产生什么验证的效率问题。 并行开发与组件原子性每个组件我们希望承担的功能尽可能的单一，只负责一类数据与一类视觉展示，这样我们就能保证组件的最小粒度，以及其原子性。 这样，我们就可以很容易的将一个大型的复杂页面进行拆分，分配给多人开发，而不会产生很大的冲突和依赖。 同时这也非常有利于我们快速的开发一个功能，以适应市场变化。 复用性虽然组件化的一个很重要的特点是复用性，但是在实际情况下，可复用的组件依然占少数，而想要设计出一个能够比较好复用的组件是相当困难的，对人员的能力要求，以及对组件化的理解都很高。 所以这里我不想特意去要求高复用性，而更希望将组件做的更小，更简单，粒度更细。 最后这是从个人经验上，从最早的DDComponent拆分思想，以及后来出现的IGList的diff思路，经过自身的大量业务实践，最终总结所得，同时兼顾简单、易学的一套方案。 其实这里可以做的更激进一些，以满足一些比如动态化、DSL的能力，但考虑到受众应该是所有层次的开发，所以不便做的太过复杂。 由于项目原因，暂不便公开源码。","categories":[],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"UICollectionView","slug":"UICollectionView","permalink":"http://djs66256.github.io/tags/UICollectionView/"}]},{"title":"从响应链收集手动埋点","date":"2019-06-01T09:49:06.000Z","path":"2019/06/01/2019-06-01-从响应链收集手动埋点/","text":"背景手动埋点一直以来都是一个比较麻烦的行为，埋点不属于业务逻辑，而我们必须插入业务逻辑中，有可能就导致了我们不得不修改设计以满足埋点的需求。 同时数据方很多时候会要求带上额外的数据，而这些额外的数据甚至和当前模块毫无关系，也就是破坏了我们的独立性和解耦原则。比如在事件点击中加入当前页面的pageId，当前cell的index等等。 简介目前我们手动埋点的埋点信息可能包含的内容比较多，但也可以进行归类。 不同类型的埋点信息都是在不同的层上收集的，比如我们需要pageId，那么这个必然是在当前VC上才有，如果我们要收集上个页面的pageId，那么只有navigationController上会有该信息，而如果我们需要收集cell的位置信息，那么我们需要在dataSource上进行收集。 这给我们的埋点收集一个思路，我们手动埋点的时候不要马上收集完所有数据上报，而是收集当前层存在的信息，并把这个埋点任务抛向上层。每一层都会往埋点任务里面写入自己层的信息，直到结束，这样我们就可以收集一个非常完整的埋点信息。 当然这样做的缺点是埋点里面的信息比较多，比较冗余，但作为埋点信息来说，信息冗余并不是太大的问题。 要建立这样一个结构，如果是一些新业务或者组织架构设计较好的业务来说，会比较简单，但是对于一个已经成型的，有很多复杂的业务却比较麻烦。这里需要去寻找一种方法，使改动量尽可能的小，并且组织灵活。 数据流数据方向首先我们来看看一般应用的页面结构。 绿色：Application 蓝色：View 橘色：ViewController 我们更新页面的数据方向是这样的： 但是我们埋点触发，需要收集的数据却是这样的： 我们更新数据和收集数据的方向是完全相反的，这也就是导致我们手动埋点总是会感觉很别扭的原因。 而我们一般做埋点的方式，是将这个事件通过回调等方式一层层传递到ViewController上，然后进行统一埋点。 但是对于一个复杂的VC，我们往往会继续拆分，成为多个独立组件的组合（可以看我之前的DDComponent），这样不仅能避免VC的无限膨胀，也能解耦业务。但是遇到埋点需求时，我们却不得不打破这个组织方式，因为有很多信息必须要在VC上才能获取到。 数据流我们在上面了解到的埋点现状，可以抽象为一条数据流，在这个数据流上有多个节点，不同的节点可以收集必要的埋点信息。 而每一个节点，可以抽象为一个Stream。 这里我们可以看到每一个节点同时也是响应链的一部分，那么我们是不是就可以依靠响应链来连接整个数据流呢？这样我们就不需要大量改动代码，从而达到建立这套系统了。 123456@interface UIResponder (TraceStream)@property (nonatomic, strong, readonly, null_resettable) TraceStream *trace;@end 这里我们还需要为这条数据流创建一个终点，也就是最终输出端，可以选择Application上的节点为输出节点。 1234567891011121314@implementation UIApplication (TracePipeline)- (TraceStream *)trace &#123; NSAssert([NSThread isMainThread], @&quot;Must call on main thread.&quot;); TraceStream *stream = objc_getAssociatedObject(self, @selector(trace)); if (stream == nil) &#123; TraceStream *stream = [[LoggerTraceStream alloc] init]; objc_setAssociatedObject(self, @selector(nm_trace), stream, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return stream; &#125; return stream;&#125;@end 使用这里我们举一个列表中点赞埋点的列子： 在cell中的某个view中，触发了点赞： 12345678- (void)onPriase:(id)sender &#123; [self.trace addTraceInfoWithBuilder:^(TraceInfo * _Nonnull traceInfo) &#123; traceInfo .setAction(@&quot;praise&quot;) .setId(self.video.videoId) .setType(self.praised ? @&quot;1&quot; : @&quot;0&quot;); &#125;];&#125; 但是我们还需要知道这个cell是位于列表中的位置，那么我们可以cell中加入该信息： 12345678910- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = ...; [cell.trace.filter setFilterBlock:^BOOL(TraceInfo * _Nonnull traceInfo) &#123; traceInfo.set(@&quot;index&quot;, @(indexPath.row).stringValue); return YES; &#125; forKey:@&quot;index&quot;]; return cell;&#125; 然后我们还需要知道是在哪个页面中触发的，那么我们需要在vc中加入： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; [self.trace.filter setFilterBlock:^BOOL(TraceInfo * _Nonnull traceInfo) &#123; traceInfo.setPage(@&quot;test&quot;); return YES; &#125; forKey:@&quot;addPage&quot;];&#125; 那么最后我们收集到的埋点信息就会包括了praise, index, page信息。 自定义在开发过程中，我们可能还会有很多业务分割的部分，比如ViewModel，这些内容并不一定在响应链中，那么我们需要能够将这个数据流通过该组件来收集数据。 这里我们可以在默认的数据流中插入一个自定义节点来解决。本身这个数据流和响应链其实并没有什么关系，我们只是利用了响应链的结构而已。 12viewModel.view.trace.outStream = viewModel.trace;viewModel.trace.outStream = controller.trace; 这样我们就可以自定义数据节点了。 过滤器由于各种原因，我们的埋点并不能完全的通用，比如有时候，同样是点赞，有时候是praise，有时候是like。有时候我们又不希望触发某些埋点。 我们需要在某些确定的节点要求能够过滤或者转换某些埋点，那么我们需要在每个节点上添加过滤器： 123456[self.trace.filter setFilterBlock:^BOOL(NMTraceInfo * _Nonnull traceInfo) &#123; if ([traceInfo.action isEqual:@&quot;praise&quot;]) &#123; traceInfo.setAction(@&quot;like&quot;); &#125; return YES;&#125; forKey:@&quot;addPage&quot;]; 虽然这么做并不是特别好，但在一些无法抗拒的情况下还是能够给我们一个修改的机会。 逻辑型埋点另一种让我们所有人都头疼的就是逻辑型埋点。 一般来说我们的埋点都是事件埋点，也就是触发一个方法，我们埋一次。但是有些需求要统计时长，比如用户点播放，和点暂停之前的时间间隔。按照原有方法埋点，那么我们可能需要在VC里增加一个成员，专门为了记录这个时间间隔。而这些成员和业务毫无关系，只服务于埋点信息，导致了业务的耦合增加。 对于我们程序来说，事件的点是比较简单的，而这种逻辑型埋点则非常复杂。如果我们把逻辑型埋点都转化为事件埋点，那么就会减少很多复杂度。 123456789101112131415161718__block NSDate *playTime = nil;[self.trace.filter setFilterBlock:^BOOL(NMTraceInfo * _Nonnull traceInfo) &#123; if ([traceInfo.action isEqual:@&quot;play&quot;]) &#123; playTime = [NSDate date]; return NO; &#125; else if ([traceInfo.action isEqual:@&quot;pause&quot;]) &#123; // 得到两者之间的时间间隔 [self.trace addTraceInfoWithBuilder:^(TraceInfo * _Nonnull traceInfo) &#123; traceInfo .setAction(@&quot;play-pause&quot;) .setTime([playTime timeIntervalSinceNow]); &#125;]; playTime = nil; return NO; &#125; return YES;&#125; forKey:@&quot;play-pause&quot;]; 总结这种方案虽然能够解决很大一部分的埋点痛点，但也依然存在一些缺陷。 开发者必须要了解这种方案的原理，才能知道在什么节点收集埋点，以及如何插入自定义节点。 埋点信息会比较冗余，会带上一些无用信息。 埋点信息必须保证大部分是统一的，不然每个页面全部采用不同的key和埋点方式，也会让这个系统失去复用的能力。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"流程状态机架构","date":"2019-05-30T15:24:20.000Z","path":"2019/05/30/2019-05-30-流程状态机架构/","text":"背景在现实的项目过程中，由于人员的更替，以及业务的发展，总是会导致一个问题，那就是流程细节的丢失，项目时间越久，这个问题越是严重。所以往往会出现产品在不知道这个功能的流程的情况下设计方案，开发在开发过程中才发现流程上的设计缺陷，这不仅仅导致了项目时间的推迟，更可能导致整个业务流程上出现漏洞而危害整个产品，如果是云音乐这种类型产生问题可能表现不大，但像考拉这种涉及到钱的项目严重的可能导致信任危机。 要解决这个问题传统的做法就是详细业务文档，这需要： 文档要求详细，并且在统一的地方维护 人员交接的时候，文档需要完整交接 多方（产品、开发、测试等）的信息同步 遗憾的是，这么多年的工作中，我没有发现一个项目能够做到这一点的，遇到问题只能人肉阅读代码。在目前国内企业的环境来看，要写一份详细完整的文档，也是几乎不现实的。 无论在哪种问题下，产品不了解流程，或是视觉不知道中间的弹窗，或是多方出现理解分歧，最终都是由开发阅读老代码来判断以前的流程是怎么样的，所以代码中的逻辑一般是最准确和详细的。在需求变更后，最先更新的也往往是代码（上帝也不能保证产品会把变革更新到文档）。 那么我们如果能从我们的代码逻辑中直接提取这个流程，并且通过流程图的形式展示出来，也就省去了很多一部分为别人服务的时间。而且拥有流程图之后我们也可以直观的检查我们的代码逻辑是是不是存在bug。 markdown有一个流程图表的功能，很多markdown编辑器也已经支持了，这给了我一个开发一个能够解决流程问题的思路。 mermaid graph TD 简述我们需要这个新的框架能够足够通用，能够适用于大部分场景。 每个流程需要足够的独立，不能依赖太多的外部信息，能够复用和自由组合。 可以输出可读性强的流程信息，比如markdown等。 有一定的自检能力，保证整个流程的完整性和正确性。 这里我们用一个最简单的点赞流程来解决： 实现1. 结构1.1 状态 State我们在看流程图的时候，把一整个流程拆分为一个个节点的时候，可以看到每个节点（状态）都可以抽象为拥有一个输入，多个输出的结构： 每个具体状态必须只做一件事情，每个条件分支也必须为一个独立的状态。 123456if (isLogin) &#123; // do login&#125;else &#123; // do unlogin&#125; 需要抽象为： 12StateIsLogin --&gt; |isLogin| loginStateIsLogin --&gt; |!isLogin| unlogin 多个状态可以组合成为一个复杂的状态，这个复杂的状态其行为依然和最简单的状态一致。当我们最终组合而成的点赞功能，也应该是一个状态机，拥有一个输入和多个输出。 1.2 规则 Rule不同的状态之间，是通过某种规则进行连接。 最简单的规则就是执行下一步，最普遍的规则就是匹配上一个状态输出的结果。 为什么这里要加入个规则的概念，而不是直接建立状态直接的依赖关系？主要原因有： 设计上更简单、明确，通用性更强，我可以自定义规则来实现一些多参数的匹配等 条理更清晰，可以方便的转化、输出文档 可以集中化管理，可以方便的跟踪当前状态的变更 1.3 组合这里演示为了代码的可读性，所以采用了c++，实际使用的时候语言并不是阻碍。 所有的状态创建统一通过工厂创建： 1234567891011auto b = Builder(ctx);auto checkNetwork = b.check(^BOOL(NSDictionary *params) &#123; return ![self isOffline];&#125;).debugName(@&quot;网络连接&quot;);auto checkLogin = b.check(^BOOL(NSDictionary * _Nullable params) &#123; return [self isLogin];&#125;).debugName(@&quot;用户登录&quot;);... 那么上述一个简单的点赞流程可以写作： 12345678910111213141516171819202122b.start() &gt;&gt; checkNetwork;checkNetwork &gt;&gt; Result::Yes &gt;&gt; checkLogin &gt;&gt; Result::No &gt;&gt; b.end();checkLogin &gt;&gt; Result::Yes &gt;&gt; praiseRequest &gt;&gt; Result::No &gt;&gt; b.end();praiseRequest &gt;&gt; Result::Success &gt;&gt; successToast &gt;&gt; Result::Failure &gt;&gt; failureToast;successToast &gt;&gt; b.end();failureToast &gt;&gt; b.end(); auto praiseMachine = b.compositeMachine(); 那么我们最终得到的状态机可以在需要的时候启动： 1[praiseMachine startWithParams:@&#123;@&quot;test&quot;: @&quot;Test Value&quot;&#125;]; 这里就不再描述具体结构了，详细可以看我的demo 1.4 纯粹性/原子性一个状态在被使用过后，可能会产生很多垃圾，会污染了这个状态的内部。反之我们可以定义在执行前后不会发生变化的状态为纯状态。 如果我们的子状态机都是纯状态，那么我们组合而成的状态机也必然是纯状态。 纯状态的一个好处就是可以被反复使用，而不需要重新创建，减少创建的开销，以及提前创建流程状态机。 2. 输出文档我们把结构改成状态机虽然能够在代码流程上更为清晰，但也会增加学习成本和代码量，单纯这么做的意义并不大，所以我们需要将这个流程以更可见的形式输出。 某些markdown编辑器集成了流程图的语法，我们刚好可以借助这个功能。下面我们将我们的结构格式化后打印出来： 123DDStateMachineMarkdownWriter *writer = [DDStateMachineMarkdownWriter new];[praiseMachine debugWriteMarkdownText:writer];NSLog(@&quot;%@&quot;, writer.markdownText); 打印结果是 123456789101112graph TDDDBlockStateMachine1(网络连接) --&gt; |YES| DDBlockStateMachine2(用户登录)DDBlockStateMachine1(网络连接) --&gt; |NO| DDContinueStateMachine1(End)DDBlockStateMachine3(点赞请求) --&gt; |success| DDBlockStateMachine4(提示)DDBlockStateMachine3(点赞请求) --&gt; |failure| DDBlockStateMachine5(提示)DDContinueStateMachine2(Start) --&gt; DDBlockStateMachine1(网络连接)DDBlockStateMachine5(提示) --&gt; DDContinueStateMachine1(End)DDBlockStateMachine2(用户登录) --&gt; |NO| DDContinueStateMachine1(End)DDBlockStateMachine2(用户登录) --&gt; |YES| DDBlockStateMachine3(点赞请求)DDBlockStateMachine4(提示) --&gt; DDContinueStateMachine1(End) 复制到markdown编辑器中，可以转化为流程图： 当然这只是一种导出方式，我们可以自行设计更好的导出方式。 我们可以通过比对流程图，来看我们修改的逻辑流程是否发生了正确的改动。 甚至我们可以在自动化测试脚本中加入流程的验证，或者控制流程的走向。 在线上我们也可以用于记录用户操作，是在什么环节出现了错误导致本次流程的失败或者撤销。 3. 状态跟踪当我们把流程封装成一个状态后，就相当于一个黑盒系统了，我们无法在这个流程中插入一些额外的非流程内的东西了，比如统计埋点等。 这里我们需要给外部系统提供一个状态跟踪的能力，当触发这个状态变更的时候给予外部一个信号或者执行一段代码，具体能力可以依据需要实现。这也是上述为什么要设计Rule这一结构的原因之一。 以上的流程代码可改为： 123checkLogin &gt;&gt; Result::Yes &gt;&gt; Trace(@&quot;login&quot;) &gt;&gt; praiseRequest &gt;&gt; Result::No &gt;&gt; b.end(); 那么我们就可以去监听@”login”这个信号，在请求成功后就会自动触发。比如在这里增加一个埋点信息。（关于埋点，我们后续可以再讨论一篇） 比如打印信息：Machine (用户登录) will goto (点赞请求) with log (login) 4. 完整性检查另一个开发中比较容易出现的问题就是对异常和特殊情况的判断，这个问题在传统的开发中并没有什么特别有效的方法去避免，只能靠个人能力和测试的完备。 一个简单的例子就是，我们会在请求之后判断成功而更新UI，但会比较容易忽略失败的场景，而对于某些场景我们还是需要去处理失败的。 而在这种新的结构下，我们就比较容易做这个检查了。 我们需要在强制检查的状态中指定可能会返回的结果： 1machine.validResults = @[Result::Yes, Result::No]; 然后去检查可能的结果是否都已被Rule处理了： 12345NSError *error = nil;[praiseMachine checkRuleCompleteWithError:&amp;error];if (error) &#123; NSLog(@&quot;Error: %@&quot;, error.localizedDescription);&#125; 如果发现缺失，则会输出哪一个状态的哪一条规则缺失：Error: &lt;DDBlockStateMachine&gt; 用户登录 do not obey result(YES);。 这样我们就可以强制开发者必须保证逻辑流程的完整性，以防止我们在不经意间引入一些问题。 总结以上几个能力是我觉得在现实的场景中比较重要的，现实项目中，特别是大型项目，人员流动频繁，有些时候整个业务都可能会进入一个不可控的场景，这时候我们不能保证外部给我们信息是完整的，也不能保证内部人员足够的熟悉项目的细节，那么只能从架构上进行约束，将很多流程规范化，结构化，进行强校验才是解决这类问题的方法。 采用新的架构也必然会导致整个学习成本的上升，同时也要求整体人员的水平能够从更高的角度去看待问题，能够去理解这么做的原因和原理。 约束并不是目的，而是在约束下我们能更好的保证质量。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"Corountines 看似美好却危险重重","date":"2019-04-06T17:11:27.000Z","path":"2019/04/07/2019-04-07-Corountines-看似美好却危险重重/","text":"协程Coroutines这个概念在5、6年前就已经比较热门了，而且也涌现了一波以该目标的第三方库，但是这个概念并没有被广泛的应用，这里来看看Coroutines给我们带来的便利和危险吧。 简介关于Coroutines、Generator的介绍有大量优秀文章和wiki的介绍，这里不做赘述。 协程出现的时间非常早，在一批语言（C#，Go，ES7）从语言本身开始支持这种特性而再一次受到关注。同时也有一大批C/C++类库的出现，来实现协程的特性，比如PCL, fiber, coroutine，以及支持Coroutine的网络库asio。甚至有人提议C++标准组织增加关键字来支持【N3858】【N3985】。 化异步为同步Coroutine主要想解决的问题是异步回调问题，这个问题自从多线程开始就是另大家头疼的问题，我们使用过很多方法，都无法很好的解决这个问题。比如Callback和Promise，都存在着一些瑕疵。 123456// Callbackfs.readFile(&#x27;a.txt&#x27;, function (error, data) &#123; fs.readFile(&#x27;b.txt&#x27;, function (error, data) &#123; ... &#125;)&#125;) 1234567// PromisePromise.all([ fs.readFile(&#x27;a.txt&#x27;), fs.readFile(&#x27;b.txt&#x27;)]) .then(function () &#123; ... &#125;) 对我们来说同步执行的逻辑是最简单的，也是最清晰的，我们将很多同步功能放到异步执行往往是为了解决阻塞问题，所以我们是完全可以将异步的功能写成同步的。 12await fs.readFile(&#x27;a.txt&#x27;)await fs.readFile(&#x27;b.txt&#x27;) 这里我们可以用关键字await来表示这个方法是一个异步过程。有很多语言天生自带这一类特性，但是C系列语言并不具备这个关键字，下面来看看如何实现这个功能。 实现这里盗C++论文一张图来说明一下我们需要实现协程的流程： 123async foo() &#123; await bar()&#125; 我们需要在await的时候，将代码执行能力转交给bar，然后在bar异步回调的时候，将执行权限交还给foo，这需要一种上下文切换的能力，从CPU层面来说上下文就是寄存器，那么我们要实现上下文切换的功能也就非常简单了。 个人比较熟悉arm架构，所以这里简单说明下coobjc的setcontext和getcontext。对汇编不熟悉的人可以跳到C语言实现上下文切换。 1234567891011121314151617_coroutine_getcontext: stp x18,x19, [x0, #0x090] stp x20,x21, [x0, #0x0A0] stp x22,x23, [x0, #0x0B0] stp x24,x25, [x0, #0x0C0] stp x26,x27, [x0, #0x0D0] str x28, [x0, #0x0E0]; stp x29, x30, [x0, #0x0E8]; // fp, lr mov x9, sp str x9, [x0, #0x0F8] str x30, [x0, #0x100] // store return address as pc stp d8, d9, [x0, #0x150] stp d10,d11, [x0, #0x160] stp d12,d13, [x0, #0x170] stp d14,d15, [x0, #0x180] mov x0, #0 ret 12345678910111213141516_coroutine_setcontext: ldp x18,x19, [x0, #0x090] ldp x20,x21, [x0, #0x0A0] ldp x22,x23, [x0, #0x0B0] ldp x24,x25, [x0, #0x0C0] ldp x26,x27, [x0, #0x0D0] ldp x28,x29, [x0, #0x0E0] ldr x30, [x0, #0x100] // restore pc into lr ldr x1, [x0, #0x0F8] mov sp,x1 // restore sp ldp d8, d9, [x0, #0x150] ldp d10,d11, [x0, #0x160] ldp d12,d13, [x0, #0x170] ldp d14,d15, [x0, #0x180] ldp x0, x1, [x0, #0x000] // restore x0,x1 ret x30 arm64中寄存器分为两类：普通寄存器和向量寄存器（也可以称为浮点寄存器）。根据C++ abi文档，各种寄存器的功能如下： registers role SP stack pointer r30 LR r29 FP r0-r7 参数寄存器 r8 IR r9-r15 临时寄存器 r16/r17 PLT(目前我也不了解) r18 平台寄存器/临时寄存器 r19-r28 Callee寄存器，必要时由被调用者保存 v0-v7 参数寄存器 v8-v15 Callee寄存器，必要时由被调用者保存 v16-v31 其他 由此，我们可以知道必须缓存的寄存器是哪些了。 C语言实现上下文切换当然系统其实也给我们提供了相似的功能，原理其实都是一样的，下面介绍一下几种系统提供的方式，详细信息可以参考相关文档： setjmp/longjmp这种方式非常的容易理解，唯一的缺点就是返回值类型是int，所以在32位系统上我们可以返回上下文指针，而64位系统就不能这么做了。 ucontext目前苹果已经不支持了。 signal信号也是通过类似方式实现的。 危险具体实现细节还是需要自己去研究，这里说明一下其中带来的几个问题。 栈在我们的功能特性中，在执行async函数时，是需要直接返回的。由于C语言调用栈的结构，在函数返回时，是需要销毁栈的，所以我们必然不能在当前栈上运行我们的async函数，不然等异步返回的时候，函数栈帧已经被回滚（unwind）。所以在我们第一次（当前上下文的首次）启动一个async函数的时候，必须要为该函数申请一个不会被立刻销毁的栈，也就是malloc一块内存作为栈使用。目前像coobjc默认是64k的大小，对于性能要求比较关键的地方就需要好好考虑了。当然，按目前来说，一定的性能损耗给我们开发带来便捷还是可以接受的。 但是，上下文的切换可能让我们debug陷入一个无尽的深渊。大家在开发多线程的时候，都感觉比较难以调试，因为线程之间是独立的。而我们一旦切换了上下文，同时重新创建调用栈，也就意味着我们丢失了起点，有点像一个独立的线程，是无法找到调用地点的，除非我们在创建新栈的时候，将旧的栈全部拷贝，但这明显是不现实的，比较现实的可能是拷贝若干附近的栈帧数据。总之，c系语言的协程，debug将是一个比较困难的场景。 而coobjc在会库内部产生很多的栈帧，也增加了调试的复杂度。如果能够在切换上下文的时候将栈回滚，则会减少很多干扰调试的调用信息。 stackful目前来看C系的协程基本上都是stackful的，也就是可以在其他函数内部触发： 123456789101112function some_function() &#123; yield &quot;OK&quot;;&#125;function async_call() &#123; // stackless 则必须在该函数栈帧内触发yield，比如javascript some_function();&#125;function do() &#123; await async_call();&#125; 在语言本身并没有相关的特性的时候，我们很难检查目前方法是否支持协程，特别是整个链路比较长的时候，更加难以知道。一些规范也只是较弱的约定，依然无法保证在一个复杂的应用中是否会出现一些遗漏的问题。 如果我们只允许其中的async/await与promise特性，则会将影响面控制在一定范围内，应该会好一些。实际上我们依然无法规避这种问题。 多线程个人认为这是我们应用协程最大的挑战，这里的问题往往已经颠覆了我们的平常认知，这里可以看一个例子： 12345// on Thread 1await do_something1()// on Thread 2await do_something2()// on Thread 3 我们无法预知在await函数之后会在哪个线程！这给多线程开发带来了非常大的挑战，因为这里几乎必然会发生竞争问题！ 虽然在一个过程中，我们的调用是有顺序的，是不会产生什么问题，但是我们的场景往往不会只触发一次那么简单。我们需要在每个await调用上思考多线程问题，这个反而给我们的开发带来了更大的麻烦。 当然我们可以约定，回调必须发生在主线程等，但是约定始终是约定，无法作为强制性的禁止，完全依赖个人的开发能力。 总结可以看到，协程作为C系语言的扩展，依然存在巨大的缺陷，C++标准组委会到目前为止，也依然没有将其作为一个特性。协程的目的是为了化异步为同步，简化我们的开发和理解，但在真实的多线程环境中，反而对开发者的要求更高了，已经脱离了初衷。 参考Glibc armasm_user_guide IHI0055C_beta_aapcs64 https://www.boost.org/doc/libs/1_57_0/libs/coroutine/doc/html/index.html https://en.wikipedia.org/wiki/Setjmp.h https://en.wikipedia.org/wiki/Setcontext https://en.wikipedia.org/wiki/Iterator https://en.wikipedia.org/wiki/Continuation https://en.wikipedia.org/wiki/Coroutine C Generator C++ Generator Boost fiber C++ stackful coroutines C++ Coroutine A C++ await/yield emulation library for stackless coroutine Stackless vs. Stackful Coroutines n3985","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"coobjc","slug":"coobjc","permalink":"http://djs66256.github.io/tags/coobjc/"},{"name":"coroutines","slug":"coroutines","permalink":"http://djs66256.github.io/tags/coroutines/"}]},{"title":"C++虚函数表一探","date":"2019-02-03T11:39:14.000Z","path":"2019/02/03/2019-02-03-C-虚函数表一探/","text":"虽然iOS中对C++的要求并不是必须的，但是很多基础都是用C++写的。我们都说C++难学，除了众多的特性以及为了兼容底层语言的一些妥协，导致特性极其复杂，虽然经过C++11之后的标准，已经更加完善和易用了，但我们还是需要去了解一些C++的实现原理及特性，才能避免掉入坑中。 这里将不会一一说明C++的基础知识，我相信有很多人应该比我说的更好。 虚函数C++的虚函数实现是通过虚函数表，这是大家都知道的。那么虚函数表是一个什么样的结构呢？ 这里我们用类C语言的描述来说明一下。 123456789class A &#123;public: virtual void f() &#123;&#125;&#125;;class B : public A &#123; void f() override &#123;&#125; virtual void g() &#123;&#125;&#125;; 以上用C结构表示大概是这样的： 12345678910111213141516struct vtable_A &#123; void f(A *this) &#123;&#125;&#125;struct A &#123; vtable_A *__vtable;&#125;;struct vtable_B &#123; vtable_A _super; void g(B *this) &#123;&#125;&#125;struct B &#123; vtable_B *__vtable;&#125;; 编译器会在类中自动生成一个指向虚函数表的指针，并在构造类的时候帮我们把对应的虚函数指针填上。那么如果我们重写了某个基类的虚函数的时候，我们的虚函数表相对应的虚函数会改写为子类的函数指针，如下： 12345vtable_A: | A::f() |如果没有重写f()，B的虚函数表应该如下：vtable_B: | A::f() | B::g() |如果重写了f()，B的虚函数表则会变为：vtable_B: | B::f() | B::g() | 所以我们从表中查找出来的将会是B::f。这也解释了为什么C++类，只含有虚函数的class，size也是需要有一个指针的大小。 当有多个基类的时候，这时候为了分辨多个来源的时候，将会采用多个虚函数表结构： 123456789101112class A &#123; virtual void f() &#123;&#125;&#125;;class B &#123; virtual void f() &#123;&#125; virtual void g() &#123;&#125;&#125;;class C &#123; void f() override &#123;&#125;&#125; 这时候的C的虚函数表将会是这种感觉： 123456vtable_A: | C::f() |vtable_B: | C::f() | B::g() |class C &#123; vtable_A *__vtable_a; vtable_B *__vtable_b;&#125; 而更复杂的情况也是这目前的扩展，这里就不赘述了。 函数参数我们都知道，C++能和C无缝链接，其实就是对C语言的一个扩展，其大部分机制，比如参数传递都是和C语言一模一样的。而C语言是不支持this这种语法的，那么C++是如何传递参数的呢？ 虽然我们看来A::f()就是该函数定义，但实际上我们是有一个this的隐式参数，也就是说A::f(A *this)才是该函数的真正定义。 结合上节，那么我们就可以动态的取出vtable内的函数指针，进行调用，实现类似“动态语言”的某些特性。 1234567typedef void (*Fun)(void*);C c;uintptr_t cptr = reinterpret_cast&lt;uintptr_t&gt; (&amp;c);uintptr_t *vtable = reinterpret_cast&lt;uintptr_t *&gt; (cptr);Fun *vtc = reinterpret_cast&lt;Fun *&gt;(*(vtable + 0));Fun f = *(vtc);f(&amp;c); 多基类的this指针上节我们知道this指针将会是一个隐式参数，那么出现多个基类的时候，又是如何处理的呢？ 123456789101112131415161718192021222324252627class A &#123;public: virtual void f() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125; virtual void g() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;;class B &#123;public: virtual void f() &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125; virtual void k() &#123; this-&gt;f(); std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;;class C : public A, public B &#123;public: void f() override &#123; std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; &quot; this: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125;&#125;; 如果我们调用 12C c;c.k() 此时调用的是子类的C::f()还是自己的B::f()呢？ 按照我们对面向对象语言的理解和要求，最终调用的肯定是C::f()。但是按照vtable的布局要求，B::f()中this所指向的是&amp;c+8的地址，那么基类又是怎么知道最终需要调用C::f()并且找到子类的地址&amp;c呢？ 以上代码的打印为： 123class Cvirtual void C::f() this: 0x7ffeefbff560virtual void B::k() this: 0x7ffeefbff568 可以看到this指针的确是真实的vtable指针，概括为C语言大概是这样的： 12345678struct C c;B::k( &amp;c + 8 /* sizeof(B::f) */ );// 而k()中的调用可以解释为void B::k(B *this) &#123; func_ptr p = vtable_get(this, B::f); p(this);&#125; 要知道编译器具体为我们做了什么魔法操作，那么我们就需要看看其汇编结果了。 在this-&gt;f()单步跟踪，我们会发现他会进入一个奇怪的函数。 12345670x100001620 &lt;+0&gt;: pushq %rbp0x100001621 &lt;+1&gt;: movq %rsp, %rbp0x100001624 &lt;+4&gt;: movq %rdi, -0x8(%rbp)0x100001628 &lt;+8&gt;: movq -0x8(%rbp), %rdi0x10000162c &lt;+12&gt;: addq $-0x8, %rdi0x100001630 &lt;+16&gt;: popq %rbp0x100001631 &lt;+17&gt;: jmp 0x100001540 ; C::f at main.cpp:103 说明我们虚函数表里面的C::f()并不是我们所写的那个方法，而是编译器帮我们封装了一层，专门进行了this-8这样的还原指针地址的操作。 可以说这一顿操作真的是很厉害，我们平时用的时候都不曾注意这些，也不曾深入了解为什么C++中有些方法必须是虚函数，或者有些时候虚函数存在设计缺陷。 不过在debug的过程中，xcode中this指针永远是显示的子类的指针，不知道做了如何的处理。 最后C++依然是一门比较复杂的语言，虽然我个人还是比较喜欢C++的特性，拥有非常大的灵活性，但是不得不说要用好还是非常难的。","categories":[{"name":"C++","slug":"C","permalink":"http://djs66256.github.io/categories/C/"}],"tags":[{"name":"vtable","slug":"vtable","permalink":"http://djs66256.github.io/tags/vtable/"}]},{"title":"CPU分支预测","date":"2019-01-28T18:27:04.000Z","path":"2019/01/29/2019-01-29-CPU分支预测/","text":"CPU在我们不知道的情况下做了很多的优化，下面我们就来看看。 Case如下，有一个n长度的数组，内容为0~256的随机数。 1234567int array[i];int sum = 0;for (int i = 0; i &lt; n; i++) &#123; if (array[i] &lt; 128) &#123; sum += array[i]; &#125;&#125; 如果该数组是一个排好顺序的数组，那么同样条件下执行该逻辑。 我们会发现排序的会比未排序的执行效率高很多，甚至是其几倍的关系，这是为什么呢？ 这就涉及到CPU在执行条件语句的时候所做的优化了，也就是分支预测。 Why?分支预测是指在执行条件分支前，就去猜测其条件结果。其目的是为了提升CPU流水线的执行效率。在现代CPU中，分支预测扮演着一个非常重要的，提升效率的角色。 如果没有分支预测，那么CPU需要等待条件执行完后才能知道下一步的跳转地址。为了消除之间的等待时间，CPU会去预测其条件结果，是更倾向于true，还是更倾向于false。在预测错误的情况下，需要忽略之后的指令，并且重新加载正确的指令。 重新加载指令所造成的时间浪费取决于流水线架构CPU的层级。比如下图最简单的4级流水线。现代CPU往往拥有非常大的流水线级别，很容易造成10~20时钟周期的浪费。所以就更需要更智能的分支预测了。 流水线架构流水线架构CPU在执行指令的时候一般有如下几个过程： 取指 Fetch 译指 Decode 执行 Execute 回写 Write-back Static branch prediction / 静态分支预测静态分支预测是一个非常简单的策略，不依赖执行环境和执行过程中的状态。比如某些CPU，总是会预测一个条件是false的，有些则会对向前条件和向后条件做不同的预测，甚至有些架构允许插入预测代码。但总的来说，静态预测永远是编译器就已经做好了。 Dynamic branch prediction / 动态分支预测动态分支预测则是在运行期间来决定我们的预测结果。接下来我们要分析的均是动态分支预测。 前提在做分支预测前，我们所确定的是，所有分支都是有偏好的，即可能80%都会是true，或是false。 向前条件 / Forward conditional branches123for (int i = 0; i &lt; n; i++) &#123; if (condition) continue;&#125; 向后条件 / Backward conditional branches12if (condition) &#123;&#125; 无条件跳转 / Unconditional branches 动态分支预测 / Dynamic Conditional Branch Prediction动态分支预测相比于静态分支预测，最大的区别就是在运行的时候进行预测。一般对于结果的预测都是依赖于历史结果，也就是该条件前几次的执行结果进行统计。 这里描述几个简单的方案： 分支历史表 / Branch History Table (BHT) BHT中记录历史结果大小，可以为 1-Bit Prediction Quality1 bit只能记录 taken 和 not taken 两种结果，在很多场合下会降低预测准确率，特别是在循环中。 2-Bit Branch-Prediction2 bit就能记录4中状态： Strongly not taken Weakly not taken Weakly taken Strongly taken 这就需要2次不同的结果才能反转当前预测。当然可以选择更多 bit，但实验表明 2 bit 和 4096 个存储单元已经能够覆盖 82% - 99% 的场景了。 Two-Level Predictors and the GShare Algorithm另外还有一些更为复杂的方案，比如2层的预测算法，这里就不做描述了。 Branch Target Buffer (BTB)另一种是BTB，这个表内存的是地址映射，也就是能够让我们在取指的时候就知道这是一个条件指令，那么下一个取指就可以根据该表得到预测的分支地址了。 一般情况下，我们需要在译码阶段才能知道该指令是否是条件指令，才能决定下一个指令是否需要分支预测，利用BTB可以继续提前一步。","categories":[{"name":"CS","slug":"CS","permalink":"http://djs66256.github.io/categories/CS/"}],"tags":[{"name":"CPU","slug":"CPU","permalink":"http://djs66256.github.io/tags/CPU/"},{"name":"Branch Prediction","slug":"Branch-Prediction","permalink":"http://djs66256.github.io/tags/Branch-Prediction/"}]},{"title":"Objc类型推断","date":"2018-11-24T15:42:04.000Z","path":"2018/11/24/2018-11-24-Objc类型推断/","text":"Objc是一门非常啰嗦的语言，而且历史悠久，背靠C语言，发展缓慢。自从苹果有了新宠swift，更是对他不管不顾了，所以有很多现代语言拥有的优秀特性，Objc都无法享受到。其中一项就是类型推断。 每次我们在定义变量的时候，都需要先写类型，而Objc中类型名字又往往非常的长，所以很多时候一行初始化代码就让我们感到非常冗长。 1MYDoSomethingViewController *viewController = [[MYDoSomethingViewController alloc] init]; 而大部分时间，这些变量的含义相当明确，我们也并不需要去知道具体的类型，而我们却要每次去声明一次，显得非常多余。 得益于C语言的发展，在2015年，GCC和LLVM都先后的支持了类型推断，这样我们可以用于日常开发来增加代码可读性和简洁性。 首先我们定义两个类型推断关键字： 12#define var __auto_type#define let __auto_type const 以下是两者的对比： 12345678910111213141516171819- (void)t &#123; let view = [UIView new]; view.backgroundColor = UIColor.redColor; let dict = @&#123; @&quot;view&quot;: view &#125;; __weak let wself = self; __block var num = 0; let block = ^(UIView *view, NSDictionary *dict) &#123; __strong let self = wself; num = 1; [self func]; &#125;; block(view, dict); for (var i = 0; i &lt; 5; i++) &#123; &#125;&#125; 123456789101112131415- (void)t &#123; UIView *view = [[UIView alloc] initWithFrame:CGRectZero];; view.backgroundColor = UIColor.redColor; NSDictionary *dict = @&#123; @&quot;view&quot;: view &#125;; __weak typeof(self) wself = self; __block NSInteger num = 0; void(^block)(UIView *view, NSDictionary *dict) = ^(UIView *view, NSDictionary *dict) &#123; __strong typeof(wself) self = wself; num = 1; [self func]; &#125;; block(view, dict);&#125; 遗憾的是，由于这个特性是C语言的特性，所以目前无法识别oc中的一些特定语法，比如forin和容器模板类型。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"}]},{"title":"roadmap之objc","date":"2018-09-25T17:33:55.000Z","path":"2018/09/26/2018-09-26-iOS-roadmap之objc/","text":"objc是iOS的首要开发语言，在很多厂还是以objc为主，所以我们需要对objc更深入的了解，这里主要分为3个难点进行总结，runtime，runloop和block。 RuntimeObjc runtime是Objc运行的核心，我们都知道Objc是一门动态语言，为了实现其特性，必须需要一些动态的初始化。这里从几个方面进行介绍。 概念首先我们在了解runtime之前，必须要知道几个objc中重要的概念，才能更好的理解接下来的一些内容。 Class / Meta Class / isa在面向对象中，非常重要的一个概念就是类。在objc中，我们需要除了需要知道类的概念，还要知道元类的概念，以及他们之间的关系。 Class代表着一个对象的原型，所有对象都是在此模板上“复制”出来的。 而Meta Class可以认为是Class的原型，而Meta Class的原型则是NSObject。为什么需要这么设计呢？主要为了区分实例方法和类方法，也就是-和+方法。所有的实例方法均取自Class中，而类方法均取自元类中。 一个对象如何确定所属的类呢？是通过isa指针来实现的。在对象的第一个内存地址中就是isa指针，会指向其对应的类。而类中的isa指针则指向其元类。下图就能表示相互间的关系。 propertyproperty一般代表的是一个类的成员，也有一些特殊情况，我们会重写他，但是其含义都是一样的，都表示了这是一个成员对象，并且拥有getter或者setter方法。同时property会拥有部分特殊含义的标识，比如assign/strong/weak, readonly, class, non/atomic, setter/getter等，编译器会根据其标识自动生成不同的代码。在老版本的objc中还需要自已去绑定其成员对象@synchronize，现在则会默认生成一个_开头的同名对象，或者可以通过该方法重新命名一个名字。 在运行时，property也有一个对应的数组进行保存其名字与属性。 ivarivar在这里是真正的代表了一个成员对象的信息，包括其类型，大小，以及对应基址的偏移量。 一个实例对象，可以认为就是一个struct，我们需要访问成员就必须知道其偏移量才行。ivar的作用，就是记录其偏移量。 在我们访问成员变量的时候，并不是通过简单的self+offset来实现的，而是通过self+ivar-&gt;offset来实现的。这么做的原因是在objc中会有一个ivar rebase的过程，就是会通过父类的信息去重新推导出子类的偏移量。这样的好处是我们在编译上就不需要强依赖了，同时在升级过程中，也不会出现修改父类导致子类偏移量不对的问题了。 selector这是我们熟悉的方法对象，在实现上可以认为SEL就是常量字符串const char *，但是是由一个全局表所管理的字符串，其内容都是唯一的。所以我们再比较SEL的时候，是可以使用==来判断是否相等的，但是我们在传递SEL的时候不能简单的使用C字符串来表示。同时不同类上的同名方法也是指向了同一个地址的。 IMPselector代表的是这个方法的名字，而IMP则是这个方法的函数指针（关于函数指针可以去了解下C语言）。 在objc中方法名SEL和其具体实现IMP是分离的，也就是说我们是可以改变这两者的映射关系的。 IMP我们也是可以直接调用的，但是由于其隐去了参数等信息，所以相对来说是比较危险的，不太符合我们强类型的一些要求。 tagged point在64位系统中，有一种优化的指针类型，叫做tagged point，这种指针不会申请新的内存，而是把数据保存在指针中。由于64位系统的指针范围非常大，而我们的设备物理内存远远达不到这个量级，所以会有很多位是永远空余出来的，为了充分利用这一部分内存，就会把小数据写入这部分空闲区域，最常见的就是短字符串了。这类指针的最高位为1，所以可以通过判断&lt;0来确定是否是tagged point。 objc_msgSend这是objc种最核心的一个方法，是由汇编写成，为的是参数和返回值的透传，也可以去掉objc_msgSend的调用栈。 这个方法还有一些神奇的内容，这里就不细究了，建议自己学习汇编和C abi来研读这段简短的代码，\b这里做一个简单的流程介绍。 \b如果是nil，返回0 通过SEL指针，在cache中查找。这里的cache是hash table，并且保留了一定的容量，hash key是指针值，所以查找速度还是很快的。 如果没有找到，则到class的method_list中查找，这是一个数组的顺序遍历过程，所以会比较慢。这里可能会触发class的initialize。 找到对应方法，会更新到缓存中，然后再返回，以方便下次缓存中就能命中。另外这个缓存是没有过期一说的，也就是说会越加越多。 通过找到的这个函数指针，直接进行直接调用。 动态特性我们都说objc是一门动态语言，那么动态体现在什么地方呢？个人认为主要体现在2个地方，分别是类的动态性和方法的动态性。 类的动态性一般来说，类的创建只能是在编译期就已经确定好的，但是由于objc的特性，类的创建其实是在\b\b动态库加载的时候，这个特性很像一些脚本语言。 在全局有一个类的表保存着所有的类，如果我们导入一个动态库，那么\blibobjc会在其\b加载之后去读取其中的类的信息，并且创建\b\b一个类加入这个全局表中，这个加载过程我们之后再讨论，这里我们要知道objc的类并不是我们\b认知的那样，在编译的时候就固定了的。 当然，我们也可以手动通过代码来动态的创建一个类，并且加入\b全局表中，\b比如KVO就是这样实现的。 当然我们无法对已经存在的类进行修改，可以想象，一旦修改了会发生什么严重的后果。 方法的动态性方法的动态特性\b应该都很熟悉了，为什么会有这样特性，归功于objc_msgSend的机制，类并不会和函数指针绑定，而是通过SEL间接绑定的。 应用我们知道了objc的动态特性，也要知道他被应用于哪些地方。 category category是一些面向对象语言的特例，很少有强类型语言是支持这种写法的。那么为什么objc可以这么写呢？这还是要归功于objc类的创建是在运行期的。在加载完类后，会去遍历该macho中的category，并找到所对应的类，将其方法拷贝到类的method_list头部，这也是为什么category方法会覆盖原始类中的方法的原因了。而不同category之间，由于其加载顺序的不确定，所以不能确保谁的方法优先级会更高。如果想要通过这种方法来重写原本的方法，是强烈不推荐的，至于原因也不用多说了。 weak weak属性也是我们平时使用非常多的，weak属性虽然不在动态特性里，但是由于和associate非常相似，所以也拿出来说说。 weak的实现方式是将该对象和weak属性的指针的指针加入一个全局weak表中（源码中是SlideTable），如果该对象释放了，则会去weak表中清除所有指针所指向的内容，也就是把该指针置为nil了。 associate 我们都奇怪，为什么category能够增加方法，却不能增加成员呢？这也是由objc的特性所导致的，一旦category可以增加成员，那么会导致一个类的大小和成员偏移量都是不固定的，一旦载入了某个动态库，导致这些信息发生改变，对已经存在的对象是无法处理的，所以无法对已经存在的类进行ivar相关的修改了。 associate的实现和weak非常类似，也是在一个全局的表中，加入该对象，在释放的时候会去遍历该表，并将其内容进行释放清理。 method swizzle 这个应该是我们最先意识到其动态能力的功能了，很多库都用到了该实现。其原理也很简单，改变了SEL和IMP的映射关系而已。 网上有很多人讨论是否需要使用该特性。个人的观点是能不用则不用。如果你是一个小团队开发，大家天天都能面对面讨论，那么这个问题不会特别大，但是如果这个项目庞大到必须进行模块拆分，很有可能就会给项目带来不可控因素。由于objc runtime是一个全局的东西，你无法把风险只控制在一个模块内，一旦出了问题就会非常严重。 比如很多项目可能都会去改写objectAtIndex:，去除其越界的可能和NSNull对象，但是很有可能就因为表面上不会产生crash了，但是问题依旧存在，逻辑上的问题也依旧存在，如果这是一个支付功能，可能就会变成错误的金额导致严重的线上问题。 KVO 这是苹果后来新加入的一个特性，他会动态的为被观察对象创建一个子类，并且重新其观察属性的setter方法，并将该对象的isa指向新的子类。 这个子类在使用过程中并没有被察觉是因为他还重写了他的- class方法，如果你使用objc runtime方法获取，则会得到其真正的类型。 所以在setter方法中，我们就不需要再去写willChangeValueForKey了，写了反而会导致触发两次。 JSPatch， RN 这一类都是通过其方法的动态特性实现的，通过方法名来反射其真正的方法，这里就不在详细赘述了。 初始化为了更加了解objc，就需要了解其整个加载与初始化的过程。以及+load和+initialize的调用时机。（+load方法苹果官方已经不推荐使用，个人认为主要有2个原因，1是影响启动时间，2是加载的顺序太早，也早于C/C++的constructor方法，可能会导致一些初始化顺序上的错误。我们也尽量避免使用吧。） load / initialize我们要知道这两个方法被调用的条件是什么。 load方法是类被初始化的时候调用，也就是在内存构建出全局类表之后，再统一调用其+load方法，当然，在加载依赖动态库的时候会先调用动态库的+load方法。 initialize是类被实例化的时候会被调用，他和+load没有直接连接，也没有先后顺序关系。 objc_init这个是libSystem初始化objc runtime的入口，在这里比较重要的就是他会注册一个回调_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);。在动态库加载的生命周期中会进行objc类的初始化和+load方法的触发。值得注意的是这个回调的调用时机非常早。 然后会遍历macho文件中的objc信息，读取Class信息，并且将创建好的Class加入全局类表中，读取注册所有的SEL，读取并注册所有的protocol。 然后开始realizeClass，主要就是准备各种状态，基类元类信息和protocol，property等信息。 然后开始读取category信息，并且将其方法列表拷贝到class的method_list头部。 此后，开始调用+load方法 message forward当objc接收到不存在的SEL的时候，这时候会触发message forward，也就是系统给予我们一次机会，重新定向消息，比如转发给第三者。有些实现就是利用这个特性实现其proxy的功能。 除了发生不能响应消息会触发forward外，其实我们也能够直接手动通过_objc_msgForward来实现。 forward转发需要生成invocation来实现，这会导致性能的大幅下降，所以尽量不要使用这种特性。也有些地方介绍将其导向到一个空方法来避免这类crash，但这也会带来一些不可预期的错误，比如返回值问题，可能会产生一些随机值，带来更大的影响，所以个人不太建议这种方式去处理奔溃率的问题，这就是一种偷懒的自欺欺人方式。 Runloop接下来我们来看看另一个非常重要的概念，runloop。runloop对于我们来说非常重要，可以说在我们刚入门的时候就已经在使用它了。 runloop其实就是一个死循环，在新的任务进入前一直保持等待状态，同时保证加入的任务按照顺序执行，这个在其他平台也有对应的实现。其目的有3个： 保证线程不会直接退出 保证线程内的子任务按照顺序执行 用于线程间通信，也就是异步调用 线程要了解runloop和线程之间的关系，两者并不是等同的，runloop并不属于多线程的技术，只是在一个线程内保持一个事件队列来保证线程等待。 runloopMode需要理解不同mode对应的触发时机，什么时候需要使用不同的mode。 timertimer需要结合mode来理解和使用。 autorelease pool为什么要把autorelease pool放到这里说呢，主要是因为他触发的时机和runloop相关。他会注册两个observer在runloop中，分别为BeforeWaiting和Exit的时候，这能增加我们对于程序运行的理解，虽然现在arc很少碰到autorelease对象，但也要明白什么时候进行内存回收的。 BlockBlock内容比较简单，首先我们要知道我们平时所使用的block分为3种，也是从其内存所处位置来区分的： malloc block stack block global block 了解上述几种类型的区分主要是为了能够更清楚的处理内存循环引用的问题，知道哪些情况下会出现循环引用。在arc中，一般很少存在stack block，因为一旦被赋值则会自动进行拷贝操作。 strong和copy属性对于block来说其实都是一样的，最终转化为_Block_copy，但习惯和约定上我们都使用copy属性。 block按照生命周期来看，可以分为逃逸型(ESCAPE)闭包和非逃逸(NONESCAPE)型闭包，逃逸型闭包往往会引发内存泄露问题。 内存泄露特别需要注意隐式self的循环引用。 需要了解block, weak, __strong之间的区别和作用。 进阶block其实就是一个struct对象，其结构和objc对象布局类似，不过会有一个固定的void (*invoke)(void *, ...);成员，可以了解下这个方法的参数分别是什么，和objc_msgSend有什么类同和区别。 然后会把所有捕获的参数拼在结构最后，也可以看看block对象是如何实现其功能的，这里简单说一下，block对象是直接在堆上生成的，所以不受栈的限制。 既然是按照objc对象布局的，所以也就可以接收objc消息，和像objc对象一样使用了。 具体实现可以自行研读libclosure源码。 总结要了解这些基础知识非常建议自己去读读源码，而他需要很多的基础编程知识，才能够读通其源码。 这里介绍了一些关键点，但并没有很详细的对每个点进行讨论，我仅仅作为抛砖引玉，个人还是建议亲自研读源码或者官方文档。 可以前往github查看其思维导图。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"roadmap","slug":"iOS/roadmap","permalink":"http://djs66256.github.io/categories/iOS/roadmap/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"http://djs66256.github.io/tags/runtime/"},{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"},{"name":"objc","slug":"objc","permalink":"http://djs66256.github.io/tags/objc/"},{"name":"runloop","slug":"runloop","permalink":"http://djs66256.github.io/tags/runloop/"}]},{"title":"iOS-roadmap之前言","date":"2018-09-24T16:25:37.000Z","path":"2018/09/25/2018-09-25-iOS-roadmap之前言/","text":"在经历了这么多年的iOS开发，当初一个什么也不懂的大学生，也通过自身的努力，慢慢的有了一些心得和体会，所以这里准备将自己这么多年在iOS方面的经验进行一个总结。 做这件事的主要目的有两个： 这么多年零碎的学习，却没有一个比较完整的总结，形成不了一个体系，我也感到比较遗憾，所以这里进行一些总结和归纳，让自己能更系统更全面的审视iOS开发。 自己在iOS开发的道路上几乎都是自己摸索，也走了不少弯路，所以想能够给新的开发者一些建议和引导。 这里会涉及的东西并没有那些控件的使用，类的使用，我认为这些东西官方文档才是最清楚和正确的，所以我不会去讨论如何编码这么细节的内容。 同时这里可能会涉及一些比较底层的内容，也有一些比较生僻的东西，可能需要读者拥有一定的基础。 并不想单纯的罗列这些知识点，可能会详细讨论某些问题，或者按照一定的顺序去讲解内容，尽量保证我们对于知识的理解是有条理的，全面的。 内容的会持续更新，我会在博客和github同时更新。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"roadmap","slug":"iOS/roadmap","permalink":"http://djs66256.github.io/categories/iOS/roadmap/"}],"tags":[]},{"title":"程序在执行main方法之前都在做什么","date":"2018-09-19T14:40:34.000Z","path":"2018/09/19/2018-09-19-程序在执行main方法之前都在做什么/","text":"我们很少关注应用启动前，系统会给我们做些什么事情，可能知道+ load和constructor会在main方法之前执行。那么这次我们来看看main方法之前都做了哪些事情。 以下代码均经过摘取简化。 1. _dyld_start系统启动应用的入口是_dyld_start，是用汇编写的。 12345// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)bl __ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm// LC_MAIN case, set up stack for call to main()br x16 首先dyld会调用dyldbootstrap::start，该方法会返回main函数的函数指针，并将其保存到x16中，然后才会继续调用main方法。但是调用这两个方法的方式是不一样的，bl是真正意义上的方法跳转，是会产生堆栈信息的，而br则相当于long jump，是不会产生新的栈帧信息的，所以我们在断点的时候，只能看到main作为程序入口的栈信息了。 那么接下来我们来详细看看dyldbootstrap::start里面做了些什么。 2. dyldbootstrap::start12345678910// if kernel had to slide dyld, we need to fix up load sensitive locations// we have to do this before using any global variablesrebaseDyld(dyldsMachHeader, slide);// allow dyld to use mach messagingmach_init();// now that we are done bootstrapping dyld, call dyld&#x27;s mainuintptr_t appsSlide = slideOfMainExecutable(appsMachHeader);return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); 首先，我们都知道系统为了安全性，其实每个程序都会有一个随机的偏移值的，那么这里首先要对应的去除这个偏移量，以及初始化mach内核。 然后调用dyld::_main，这个最终会返回main函数地址。 3. dyld::_main123456//// Entry point for dyld. The kernel loads dyld and jumps to __dyld_start which// sets up some registers and call this function.//// Returns address of main() in target program which __dyld_start jumps to// 12345678910111213141516171819202122232425262728293031// add dyld itself to UUID listaddDyldImageToUUIDList();// instantiate ImageLoader for main executablesMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);// load any inserted librariesloadInsertedDylib(*lib);link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);// link any inserted libraries// do this after linking main executable so that any dylibs pulled in by inserted// dylibs (e.g. libSystem) will not be in front of dylibs the program useslink(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);// only INSERTED libraries can interpose// register interposing info after all inserted libraries are bound so chaining worksimage-&gt;registerInterposing();// apply interposing to initial set of imagessImageRoots[i]-&gt;applyInterposing(gLinkContext);// run all initializersinitializeMainExecutable();// notify any montoring proccesses that this process is about to enter main()notifyMonitoringDyldMain();// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getThreadPC(); 我们按照注释所说的，首先会加载inserted libraries，这个是通过运行参数中的配置，加载其中的lib，我们一般用不到。 然后是链接，也就是macho文件的初始化，绑定一些符号表等，这个在下面进行详细说明。 interpose在iOS中是被禁用的，其功能相当于swizzle，这里我们也不去详细说明了。 然后是执行初始化工作，包括oc的运行时初始化，c++的静态对象初始化，c的constructor方法。 最后返回main方法的地址。 3.1 dyld::link这里我们来看看link都做了些什么。 12345678910// add to list of known images. This did not happen at creation time for bundlesif (image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked()) addImage(image);// we detect root images as those not linked in yetif (!image-&gt;isLinked()) addRootImage(image);// process imagesimage-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); 3.2 ImageLoader::link12345678this-&gt;recursiveRebase(context);this-&gt;recursiveBind(context, forceLazysBound, neverUnload);if ( !context.linkingMainExecutable ) this-&gt;weakBind(context);// interpose any dynamically loaded imagesthis-&gt;recursiveApplyInterposing(context); 3.3 ImageLoader::recursiveBind12345678910111213// Normally just non-lazy pointers are bound immediately.// The exceptions are:// 1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately// 2) some API&#x27;s (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately// bind lower level libraries firstfor(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload);&#125;// bind this imagethis-&gt;doBind(context, forceLazysBound); 在绑定的时候会先递归绑定其依赖的动态库，然后再来绑定自身。 3.4 ImageLoaderMachOCompressed::doBind没啥好说的，看注释吧。 1234567891011121314151617// run through all binding opcodeseachBind(context, &amp;ImageLoaderMachOCompressed::bindAt);// if this image is in the shared cache, but depends on something no longer in the shared cache,// there is no way to reset the lazy pointers, so force bind them nowif ( forceLazysBound || fInSharedCache ) this-&gt;doBindJustLazies(context); // this image is in cache, but something below it is not. If// this image has lazy pointer to a resolver function, then// the stub may have been altered to point to a shared lazy pointer.if ( fInSharedCache ) this-&gt;updateOptimizedLazyPointers(context);// set up dyld entry points in image// do last so flat main executables will have __dyld or __program_vars set upthis-&gt;setupLazyPointerHandler(context); 3.5 eachBind12345// resolve symbolsymbolAddress = this-&gt;resolve(context, symbolName, symbolFlags, libraryOrdinal, &amp;targetImage, last, runResolver);// do actual updatereturn this-&gt;bindLocation(context, addr, symbolAddress, type, symbolName, addend, this-&gt;getPath(), targetImage ? targetImage-&gt;getPath() : NULL, msg); 4. dyld::initializeMainExecutable我们回到初始化这里来。经过上面的macho绑定工作以后，虽然已经是一个完整的程序结构了，但是仍需要完成一些运行时的初始化。 12345// run initialzers for any inserted dylibssImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]);// run initializers for main executable and everything it brings upsMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); 5. ImageLoader::runInitializers1234567// Calling recursive init on all images in images list, building a new list of// uninitialized upward dependencies.this-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);// If any upward dependencies remain, init them.if ( ups.count &gt; 0 ) processInitializers(context, thisThread, timingInfo, ups); 此时依赖的动态库会递归的调用初始化方法。 12345678910111213141516// initialize lower level libraries firstfor(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) &#123; // don&#x27;t try to initialize stuff &quot;above&quot; me yet if ( libIsUpward(i) ) &#123; uninitUps.images[uninitUps.count] = dependentImage; uninitUps.count++; &#125; else if ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123; dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps); &#125;&#125;// initialize this imagebool hasInitializers = this-&gt;doInitialization(context); 这里可以看出来，动态库的初始化方法是早于自身被执行的。 12345678bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); return (fHasDashInit || fHasInitializers);&#125; 而初始化方法主要就是macho中被标识为S_MOD_INIT_FUNC_POINTERS的section中的方法，详细可以去了解下macho相关知识。 6. libSystem_initializer以上其实就已经是整个初始化过程了，这里主要讲下一个非常重要的初始化方法。位于libSystem动态库中的libSystem_initializer。 大家都知道，在iOS中所有的系统基础库均出自libSystem，所以这个库一般都是第一个被初始化的。接下来我们来看看他具体做了什么。 12345678910111213141516171819__libkernel_init(&amp;libkernel_funcs, envp, apple, vars);__libplatform_init(NULL, envp, apple, vars);__pthread_init(&amp;libpthread_funcs, envp, apple, vars);_libc_initializer(&amp;libc_funcs, envp, apple, vars);// TODO: Move __malloc_init before __libc_init after breaking malloc&#x27;s upward link to Libc__malloc_init(apple);_dyld_initializer();libdispatch_init();_libxpc_initializer();_container_init(apple);__libdarwin_init(); 这里我们可以根据名字看到其初始化都做了些什么，有个关键的libdispatch_init，我们再来看看。 12345678910111213void libdispatch_init(void)&#123; _dispatch_hw_config_init(); _dispatch_time_init(); _dispatch_vtable_init(); _os_object_init(); _voucher_init(); _dispatch_introspection_init();&#125;void _os_object_init(void)&#123; _objc_init();&#125; 最终他会去调用objc的运行时初始化。 12345678910111213141516171819void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_2_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; 在这个初始化中，会注册一个动态库初始化完成的回调。 12345678910111213141516171819/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/const char *load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; // Discover load methods load_images_nolock(state, infoCount, infoList); // Call +load methods (without runtimeLock - re-entrant) call_load_methods(); return nil;&#125; 在这个回调中，会去初始化objc的运行时，并且与当前objc运行时合并，这里的合并可能会导致一些方法被覆盖等问题，category会覆盖原本的方法，主应用会覆盖动态库的方法，当然你也可以利用这个特性，做一些黑科技（个人不建议这样去覆盖方法，尽可能使用runtime来做，或者不要去做）。这些都是题外话了。 然后才是调用load方法。load方法和其他constructor方法一样都是被依赖的动态库中的方法是早于依赖方调用的。 注意，dyld_image_state_dependents_initialized这个事件是在自己doInitialization之前被调用的，所以一个动态库中load方法会早于自己的其他constructor类型的方法，在做某些黑科技的时候不要搞错了。 最后这里我们主要需要注意的就是初始化方法调用的顺序问题，在做一些初始化的时候不要出现违反顺序的情况。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"dyld","slug":"dyld","permalink":"http://djs66256.github.io/tags/dyld/"}]},{"title":"函数式编程思想简介","date":"2018-09-16T08:15:38.000Z","path":"2018/09/16/2018-09-16-函数式编程思想简介/","text":"在平时的iOS开发中，我们大部分还是依靠着最早的MVC的思想开发着，最多也是进行了部分变种，比如MVP，MVVM，这些都是完全的面向对象的思想，在处理一些简单的场景的时候还是非常有效的，但是在某些场合，我们总会觉得难以解耦，难以进行模块化拆分，这是由于目前大部分架构中，在业务逻辑部分依然是过程性的，整个过程中还是需要依赖大量的其他模块，这次我们来看看函数式编程的思想，以另一种角度来看问题是否能够去解决部分问题。 概念函数式编程对于我们这种熟悉了面向对象的人来说，是非常别扭和难以理解的。首先我们需要了解几个概念，这里不讨论严格的概念，可以说这是我结合iOS开发的部分特性所做的一些理解。 函数是一等公民这是函数式编程中最重要的思想基础。万物都是对象，包括函数。这个思想的引入，让我们可以将函数作为参数、返回值这一类原本对象才可以做的事情。在objc中的block，swift中的closure都可以认为是函数式编程的基础。 高阶函数参数或者返回值中存在函数对象的，都认为是高阶函数。可以说高阶函数是函数式编程中的连接器，他同样也可以实现比如函数修饰器这样的功能。 纯函数没有副作用的函数，简单的说就是给以相同的输入，必定有相同的输出。这也是函数式编程思想中非常重要的一个点，因为没有副作用可以让我们的设计变得更加简单。 monad关于monad这个概念，很多人都有不同的理解，但基本上都是把纯函数连接起来的一种设计模式，同时这也是纯的。这个概念在业务开发中基本上不太可能实现，但是在业务的部分场景还是可以做到的。 优势由于函数式编程中要求大量的纯函数，那么我们就可以很容易的进行单元测试。 同时在多线程编程中，由于其独立性和无副作用，我们也不需要思考数据竞争，死锁等这类问题。也能更灵活的进行功能拆分和执行分配。 函数式编程是一套比较全面的编程思想，对于我们面向对象比较熟悉的人来说，有些地方确实会比较奇怪。虽然说我们也可以用面向对象来实现类似的功能，但是函数式编程会更加简单和直接。 框架函数式编程是专门为了计算这类场景而生的，目前由于脚本语言的兴盛，这类思想也同时融入了很多面向对象语言中。 promisepromise可以说是我最早接触到的函数式编程相关框架。promise的初衷是为了解决异步callback的多次调用而开发的。 123456789step1(function (err) &#123; if (err) print(err) else step2(function (err) &#123; if (err) print(err) else step3(function (err) &#123; // go on ... &#125;) &#125;)&#125;) 那么通过promise，我们可以改写为： 12345step1().then(step2).then(step3).then(/* go on ... */).catch(print) ReactiveX同样类似的ReactiveX也具有相同的效果，不过RX把注意点更加放在了对数据的处理上面，这也就正式的把我们从逻辑的思维中脱离开来，从而关注数据的流动上。后面会来讨论这种思维的变化给我们带来了什么。 RX中signal, observer, observable, subject主要负责数据的流动，scheduler负责执行线程相关操作。 Redux参考ReSwift 可以说这是我接触到的第一个以函数式编程为基础的，专注于数据流动的框架。 关于这个框架的详细介绍，我相信有很多人都比我更加了解，也比我讲的好，所以这里就不做介绍了。 数据流动一个请求的例子在我们平时的开发过程中，基本上关注的是业务的流程实现，按照逻辑的顺序进行思考和设计，如果我们按照标准的面向对象来设计一个请求，那么很有可能是这样的。 12345678910111213141516171819- (void)request &#123; Request *req = [Request new] req.delegate = self; [req start];&#125;- (void)requestComplete:(Request *)req &#123; Request *req = [Request new]; [req startWithComplete:^(Request *req) &#123; if (req.error == nil) &#123; NSDictionary *json = [JSON parse:req.data]; ClassA *a = [ClassA from:json]; // ... &#125; else &#123; &#125; &#125;]&#125; 这是一个非常典型的设计方式，当我们只有一个请求的时候这样做也非常简单，但是一旦拥有多个请求的时候，事情就变得很复杂。那么如果我们使用函数式来改写，就比如AF所做的那样。 12345678910111213- (void)request &#123; Request *req = [Request new]; [req startWithComplete:^(Request *req) &#123; if (req.error == nil) &#123; NSDictionary *json = [JSON parse:req.data]; ClassA *a = [ClassA from:json]; // ... &#125; else &#123; &#125; &#125;]&#125; 这样在出现多个请求的时候，回调也能保证其唯一性。但是这个依然还是有一些问题。 数据解析和model化等操作依然需要在回调时自己去调用，如果将这些放入Request中，又难以保持低耦合性。 自动化测试困难，因为请求返回后必然是接着视图的更新或者业务逻辑的执行，自动化测试一旦涉及这些会显得很臃肿。 当多个请求在需要并发，而回调需要保持同步的时候。 流量控制只能依赖于网络层的来控制，同时线程控制依然需要手动控制，可能GCD会让这类操作稍微简单一点。 那么如果我们只关注数据来改写呢，可能会是这样的，为了更适合函数式编程，这里采用js来改写： 1234567Request().then(data =&gt; &#123; let json = JOSN.parse(data) let a = ClassA.from(json) // ...&#125;).catch(err =&gt; &#123;&#125;) 那么我们来看看如何解决上述的几个问题。 为了保证低耦合性，我们不希望将解析等操作放入网络层中，但也不希望在业务层过多的出现这类代码。 12345Request().then(JSON.parse).then(ClassA.from).then(a =&gt; &#123;&#125;).catch(err =&gt; &#123;&#125;) 而其中分离出来的中间过程，由于是纯函数，是可以完全的单元测试的，这也就增强了单元测试的粒度。如果你说客户端业务代码的单元测试是否有这个必要，那么我觉得很多时候没有这个时间和必要，但是当我们做一些基础库，或者SDK时，涉及的面非常广时，我们不得不去考虑单元测试的必要性，而且覆盖率越高越好。 如果要实现并发这种呢？按照数据的角度去思考其实就非常的简单。 1234567let req1 = Request().then(JSON.parse).then(ClassA.from)let req2 = Reqeust().then(JSON.parse).then(ClassB.from)Promise.all([req1, req2]).then(ab =&gt; &#123; // reload data&#125;).catch(err =&gt; &#123;&#125;) 由于中间过程是纯函数，那么我们要将他们放入子线程也就非常的简单，甚至RX自己就提供了这样的接口。 函数修饰器这是某些语言的特性，所以拿出来简单说说。 一个函数修饰器的参数中必然至少有一个是函数，返回的也依然是函数。这个比较难以理解，我们来举一个例子： 123456function needLogin(f) &#123; if (login) return f else return function () &#123; print(&#x27;error&#x27;) &#125;&#125; 那么我们需要为某个函数增加这个检查的时候，只需要增加一层修饰即可： 12let NewRequest = needLogin(Request)NewRequest().then(...) python: 1234@needLogindef Request() # ... pass 这种方法的优势在于，我们不需要在请求里去增加这种业务代码，同时也不需要在业务层里进行复杂的校验，同时这样表示也会更加接近自然语言。 最后这里简单介绍了函数式编程思想，和我们平时开发所使用的方法都不一致，也没有哪一种方法更好的定论。但是这一种以数据作为主体的方法却是非常值得我们思考的，因为可以认为数据是不会存在高耦合这样的问题，这也给我们提供了一种新的解决问题的思路。 这是一种新的思考方式，可以说这里的一些内容是无法让你真正改变的，很多还是需要靠自身的理解和感悟，才能将其应用于平时的开发之中。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"functional","slug":"functional","permalink":"http://djs66256.github.io/tags/functional/"}]},{"title":"资源竞争与死锁检测","date":"2018-04-12T14:52:12.000Z","path":"2018/04/12/2018-04-12-资源竞争与死锁检测/","text":"多线程编程一直是一个非常难的话题，而资源竞争和死锁问题则是比较常见的多线程问题，这里我们来看看如何检测这些问题。 LLVM其实llvm项目自身就有这两者的检测方法。而在xcode中也集成了该功能，要使用也非常简单，选中Thread Sanitizer，并且重新编译运行即可。 那么接下来我们来看看使用情况以及他们是如何实现的。 Data Race数据竞争是我们非常容易犯的一个错误，而且出现问题了也非常难解决。因为出现的概率并不高，而且出现了问题也不会直接表现出来，而可能是通过其他方式表现出来。 首先我们来看一个非常简单的数据竞争问题： 123456789101112131415161718char g_char;- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self setCharB]; &#125;); [self setCharA];&#125;- (void)setCharA &#123; g_char = &#x27;a&#x27;;&#125;- (void)setCharB &#123; g_char = &#x27;b&#x27;;&#125; 虽然更新一个字节这种操作非常简单，但依然需要在这里加上锁，如果没有加上则会报告如下错误： 1234567891011121314151617181920==================WARNING: ThreadSanitizer: data race (pid=62345) Write of size 1 at 0x0001032e0f10 by thread T2: #0 -[ViewController setCharB] ViewController.m:35 (MallocTest:x86_64+0x100001499) #1 __29-[ViewController viewDidLoad]_block_invoke ViewController.m:26 (MallocTest:x86_64+0x1000013da) #2 __tsan::invoke_and_release_block(void*) &lt;null&gt;:2136816 (libclang_rt.tsan_iossim_dynamic.dylib:x86_64+0x622bb) #3 _dispatch_client_callout &lt;null&gt;:2136816 (libdispatch.dylib:x86_64+0x3847) Previous write of size 1 at 0x0001032e0f10 by main thread: #0 -[ViewController setCharA] ViewController.m:32 (MallocTest:x86_64+0x100001472) #1 -[ViewController viewDidLoad] ViewController.m:28 (MallocTest:x86_64+0x100001381) #2 -[UIViewController loadViewIfRequired] &lt;null&gt;:2136816 (UIKit:x86_64+0x1ce190) #3 start &lt;null&gt;:2136816 (libdyld.dylib:x86_64+0x1954) Location is global &#x27;g_char&#x27; at 0x0001032e0f10 (MallocTest+0x000100003f10) Thread T2 (tid=1422519, running) is a GCD worker threadSUMMARY: ThreadSanitizer: data race ViewController.m:35 in -[ViewController setCharB]================== 同时在左边的导航栏里会显示如下结果： 那么LLVM是怎么实现的呢？ 资源竞争的检测其实分为两部分，一部分是编译期的处理，另一部分是运行期的监控。 编译期，编译器会在数据访问的时候插入一段代码，来告诉检测器具体的数据访问情况。这个效果可以看具体的汇编： 1234567891011-[ViewController setCharA]: 0x106bd4448 &lt;+0&gt;: pushq %rbp 0x106bd4449 &lt;+1&gt;: movq %rsp, %rbp 0x106bd444c &lt;+4&gt;: movq 0x8(%rbp), %rdi 0x106bd4450 &lt;+8&gt;: callq 0x106bd4798 ; symbol stub for: __tsan_func_entry 0x106bd4455 &lt;+13&gt;: leaq 0x2afc(%rip), %rdi ; g_char 0x106bd445c &lt;+20&gt;: callq 0x106bd47bc ; symbol stub for: __tsan_write1 0x106bd4461 &lt;+25&gt;: movb $0x61, 0x2af0(%rip) ; lock + 63 0x106bd4468 &lt;+32&gt;: callq 0x106bd479e ; symbol stub for: __tsan_func_exit 0x106bd446d &lt;+37&gt;: popq %rbp 0x106bd446e &lt;+38&gt;: retq 运行期的监控则是靠动态库来导入的（在早期是依赖于静态库）。 可以看到，需要做到在编译期插入代码，不禁会想已经编译好的二进制该怎么办？这里我们来看两个例子： 1234CoreFoundation`-[__NSArrayM addObject:]: ... 0x10e5b0d82 &lt;+18&gt;: leaq 0x3a3fa7(%rip), %rax ; __cf_tsanWriteFunction ... 在NSMutableArray的代码中，我们发现有一个方法很可疑__cf_tsanWriteFunction，这个方法似乎就是上面的__tsan_write1方法的objc版。同时这个方法在真机上是没有的。 pthread_mutex_lock(&amp;lock)在该模式下实际对应的方法是libclang_rt.tsan_iossim_dynamic.dylib wrap_pthread_mutex_lock，同时dispatch_sync对应的方法是libclang_rt.tsan_iossim_dynamic.dylib wrap_dispatch_sync，可以知道他们都来源于一个非标准的动态库，这也就是说明在该模式下，系统会给我们链接一个已经编译好的，插入相应代码的动态库。这也代表着如果你引用了第三方二进制库，不一定能够检测出其中的竞争问题。 这里还需要检测到线程的状态，则是使用了pthread的一个公开接口： 12345678910typedef void (*pthread_introspection_hook_t)(unsigned int event, pthread_t thread, void *addr, size_t size);enum &#123; PTHREAD_INTROSPECTION_THREAD_CREATE = 1, PTHREAD_INTROSPECTION_THREAD_START, PTHREAD_INTROSPECTION_THREAD_TERMINATE, PTHREAD_INTROSPECTION_THREAD_DESTROY,&#125;;pthread_introspection_hook_install(pthread_introspection_hook); 算法这个的检测算法较为复杂，这里简单的来描述一下。 首先每一个数据根据其内存地址与访问线程id都会有一个对应的内存区块来保存其访问数据，一般是8 bytes映射为1 bytes，所以这里的内存分配器也是需要进行相应的修改。 将当前状态和已保存的数据进行比较。 如果是非同一个线程，并且已保存的数据访问时间是在当前访问时间之后。 那么认为这是一次资源竞争。 Dead lock死锁的检测相对比较简单了，他并不需要编译期的介入，而是纯运行时的检测。不过遗憾的是xcode上并没有集成，可能是觉得死锁本身就会严重阻碍程序运行，容易被察觉吧。 主要需要做的是hook掉所有锁相关的api，掌管willLock和didLock的消息，LLVM提供默认hook了pthread的相关接口。 每次加锁之前都会产生一个锁-线程的匹配，加锁之后释放该锁-线程的匹配。 如果A锁被某线程持有，同时B锁也被该线程持有，那么就形成了A=&gt;B的一个关联，如果这样的关联形成了一个环，那么就说明产生了死锁。该方法可以利用邻接二维矩阵来实现高效的查找。 如果恢复产生的死锁问题呢？这里我没有找到更好的办法，只能做以下两种处理： 杀死某个非主线程的线程，这样能够解除死锁，但会引起资源泄露和逻辑缺失的问题。 直接返回，可能会引起资源竞争的问题。 参考The “Double-Checked Locking is Broken” DeclarationFinding races and memory errors with compiler instrumentation.ThreadSanitizerAlgorithmllvm-compiler-rtvalgrind Dynamic Race Detection with LLVM CompilerThreadSanitizer – data race detection in practiceAddressSanitizer: A Fast Address Sanity Checker","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"data-race","slug":"data-race","permalink":"http://djs66256.github.io/tags/data-race/"},{"name":"dead-lock","slug":"dead-lock","permalink":"http://djs66256.github.io/tags/dead-lock/"},{"name":"muti-thread","slug":"muti-thread","permalink":"http://djs66256.github.io/tags/muti-thread/"}]},{"title":"深入理解内存分配","date":"2018-04-04T13:04:19.000Z","path":"2018/04/04/2018-04-04-深入理解内存分配/","text":"相信大家在学习C语言的时候，malloc是最早遇到的几个方法之一，这里就来深入的了解下，macOS/iOS中用户空间的内存分配。 引言首先，我们来看几个有意思的例子，以下几个在x86_64或者ARM64中的运行情况。 123char *str = malloc(32);free(str);str[0] = &#x27;a&#x27;; 123char *str = malloc(32);free(str);str[12] = &#x27;a&#x27;; 123char *str = malloc(32);free(str);str[18] = &#x27;a&#x27;; 这里先说一下结果，之后再来分析为什么，看看你有没有猜对。 这里均不会在str[x] = &#39;a&#39;;这一行崩溃，而可能在下次内存分配的时候崩溃。 第一个会报malloc: *** error for object 0x60000003cfa0: Invalid pointer dequeued from free list。 第二个会触发BAD_ACCESS的错误。 第三个运行一切正常，不会崩溃。 内核内存申请malloc方法并不止提供了向内核申请内存（syscall）的功能，它还提供了一整套用户态的内存管理。比如linux-2.3之后使用的ptmalloc，FreeBSD使用的jemalloc，以及macOS/iOS使用的malloc_zone及libmalloc。 向内核申请内存，触发系统调用，比较通用的接口有sbrk和mmap。在mac上，sbrk已经被废弃，而所有内存申请的内核调用最终都会转到 1234567kern_return_t mach_vm_allocate( vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags); 这个内核方法，我们可以通过vm_allocate去间接的调用它。 有人建议使用系统自带的malloc来构建自己的内存管理程序，这样就不用考虑不同平台的差异性；也有人认为在别人的管理系统上创建，不能达到更好的性能。这些还是具体情况具体分析吧，后面会简单介绍下如何构建自己的内存管理系统。 回到内核内存，内核内存都是按页管理的，你不可能向内核申请1byte的内存，所有的内存申请都需要经过round，否则会导致申请内存失败，其定义如下： 12345extern vm_size_t vm_page_size;// These macros assume vm_page_size is a power-of-2.#define trunc_page(x) ((x) &amp; (~(vm_page_size - 1)))#define round_page(x) trunc_page((x) + (vm_page_size - 1)) 用户态内存申请用户态的内存管理方案实在太多了，这里主要说一下大家都比较通用的部分，以及libmalloc的实现。 由于系统提供的内存，最少是一页，那么程序如果申请小块内存，特别像Objc这种含有大量小内存的情况，我们总不可能为一个指针分配一页内存吧。 这里几乎所有的内存分配库都采用了相同的做法，即将内存分为不同大小来管理，某些地方称为size class，某些地方称为chunk，而mac中就是malloc_zone了。 mac中的malloc_zone大致分为以下几种： nano zone. &lt;256 tiny zone. &lt;同nano small zone. &lt;1024 bytes (64-bit), &lt;512 bytes (32-bit) large zone. 申请不同大小的内存将会被派分到对应的zone，而各自的zone会采取不同的策略，比如nano, tiny, small是在内存页链表中寻找到一块拥有足够空闲空间的页，在这个页中分配该大小的内存；而large则是直接分配多个内存页，销毁的逻辑也完全不一样。 这里看到nano和tiny是重合的，他们之间有什么区别呢？这个问题放到下面多线程中去详细描述。 为什么需要将内存分配做这样的切分呢。由于我们平时使用到的内存大部分为小内存（这个在之后我会给一个统计结果），特别像是Objc这种语言，由于所有对象存在都是heap中的，所以基本都是以小指针对象，可能会导致大量小内存的申请和销毁，那么作为一个较为通用的内存分配器，那么肯定要考虑到优化小指针的分配效率。 这里再看一下Google的tcmalloc的划分策略。 The size-classes are spaced so that small sizes are separated by 8 bytes, larger sizes by 16 bytes, even larger sizes by 32 bytes, and so forth. 可以看到它对size-class的划分更为细致，而且它会在运行时根据具体情况具体可能会调整这个粒度，同时不会在同一页中分配任意size-class的内存，这样做是为了避免碎片。更高细粒度的划分会让程序在划分的时候更为简单，从而增加了效率，但这样也会增加缓冲内存的大小，个人觉得正是这个原因导致tcmalloc并没有考虑移动设备。 用户态内存销毁以上说明了内存申请的方式，现在来看看如何销毁内存的。 如果是大块内存(large zone)，那么视系统有没有指定内存页的缓存，否则就直接归还给系统。 那么如果是小内存（nano除外），在调用free之后 会先根据配置情况是否需要将内存重置为0x55，正常情况下不会执行这一步。 由于最小内存为2 * sizeof(void *)，所以会将第一个指针位置更新成为一个token。 合并旁边的空闲内存。 将第二个指针位置更新为下一个空闲内存的地址或者NULL。 将当前空闲内存加入free-list缓存，当下次申请新内存的时候，会优先在缓存中寻找是否有适合的空闲内存段，没有才会向系统申请新的内存页。 这里和我们的理解上有些偏差了，free并没有第一时间把我们的内存还给系统，也就是说free之后的内存其实还是在用户空间的，我们有可能还是可以任意读写该段内存的。这也就是引言中的例子。 但是如果我们修改了小内存的第一个指针位置，会导致我们的token失效，结果在复用该free-list中的缓存时候，会去校验当前缓存的token，导致Invalid pointer dequeued from free list错误。就如下所示： 1234typedef struct chained_block_s &#123; uintptr_t double_free_guard; struct chained_block_s *next;&#125; *chained_block_t; 12345void free(nanozone_t *nanozone, void *ptr) &#123; // ... ((chained_block_t)ptr)-&gt;double_free_guard = (0xBADDC0DEDEADBEADULL ^ nanozone-&gt;cookie); // ...&#125; 而如果我们修改的是第二个指针位置的数据，则会导致该指针非NULL，导致查询下一个空闲内存块的时候内存访问错误。 而如果我们去修改其他位置的数据，则不会有任何问题。 这里我们看到，一些非常奇怪的崩溃，有可能是由于这种写入释放后指针引起的。 tcmalloc可以看到上面的free过程中，是会有空闲内存的合并问题，这些当然也就会产生内存碎片。 123| 64 | 64 | || null | 64 | || 48 | null | 64 | v 如上图所示，中间的16byte可能就无法进行新的利用，好在我们的objc对象几乎都是几个指针的大小，加之malloc也会进行一次round，所以利用率还不错。 那么tcmalloc是怎么来进行优化的呢？由于tcmalloc在设计之初就不存在一个chunk中存在多个size-class的情况，所以一旦free，只需要将其丢进free-list中就可以了，在需要的时候再进行GC，将多余的空闲内存出让给别人或者还给系统。这样就避免了合并的性能开销。 多线程安全问题现在的应用都是多线程的，按照我们上面所述的，均没有涉及到线程安全问题，那么最简单的方法就是对所有内存申请及销毁进行加锁。但是锁是一种相对比较耗资源的东西，普通锁可能会涉及到系统调用，spinlock又可能会导致优先级反转等问题，那么大家都是怎么解决这个问题的呢？ libmalloc的解决方式比较传统，也就是加锁，但是在nano malloc中会有特别的优化。 每个CPU都会分配一个属于自己的分配器，也就是说每个CPU都有属于自己的内存缓存。 内存划分和tcmalloc类似，一个slot（size-class）中只有一种大小的对象，这样就不存在内存合并的问题了。 在修改free-list的时候采用的是原子操作，而不是传统意义的锁。 只在需要扩展堆，也就是增长空闲内存的时候，才使用真正的锁。 64位系统才开始支持，因为需要指针长度达到64位。 所有的指针均有相同的开头，比如x86_64上一定是0x00006nnnnnnnnnnn，arm上这个值会不一样。 所有的slot（size-class）最大容量均为0x20000大小，而里面存在的对象个数会不一样。 当申请对象个数超过对应slot的最大个数的时候（slot_exhausted），会fall through进入scalable zone进行申请。 造成以上几个魔法数字的原因是nona分配器使用指针储存了部分free-list的信息： 12345678910111213struct nano_blk_addr_s &#123; uint64_t nano_offset:NANO_OFFSET_BITS, // locates the block nano_slot:NANO_SLOT_BITS, // bucket of homogenous quanta-multiple blocks nano_band:NANO_BAND_BITS, nano_mag_index:NANO_MAG_BITS, // the core that allocated this block nano_signature:NANO_SIGNATURE_BITS; // the address range devoted to us.&#125;;// 这个是指针，也是该内存对象的信息typedef union &#123; uint64_t addr; struct nano_blk_addr_s fields;&#125; nano_blk_addr_t; 可以说nano_malloc_zone是专门为了OC而优化的。 而tcmalloc和部分其他分配器(jemalloc)，则是采取每一个线程上都独立拥有一个分配器，那么在该线程上进行free-list的操作时（申请内存的时候从缓存读取，及释放内存的时候直接加到缓存），就实现了无锁。当然，增长缓存以及GC等需要和其他线程交互的时候，还是需要锁的。这么做也会减少空闲内存的利用率。 思考之前看到过如何解决一些主线程大量释放对象的问题，为了优化释放所消耗的时间，将所有释放工作都放到子线程中，这是否真的是一种好的方案呢？ 内存分配优化根据我们上面的分析，可以看到这些分配器都是通用型分配器，它考虑了各种长度大小的性能，但是没有考虑过一些对象的生命周期等。 在一些特殊的场景和应用中，比如音乐、视频、人工智能、游戏等，可能会出现大量特定长度的对象，也可能会出现一些常驻内存，而这些对象会导致通用内存分配器的性能降低，以及重复利用率降低。 如果我们要做到极致性能的内存管理，那么我们就需要进行分析应用的内存分配情况，以及性能。然后根据需要自定义内存管理模块，并与通用管理进行对比。 替换系统默认内存分配方式替换默认malloc的方法很多，如果是使用的C++，替换new的方式也比较常见，鉴于默认new都是基于malloc实现的，这里只看替换malloc的方法。 define1#define malloc(size) my_malloc(size) 这种方法很傻瓜，只能替换可以被宏替换的地方，在部分场景替换还是很方便。 alias12void my_malloc () &#123; /* Do something. */; &#125;void malloc () __attribute__ ((alias (&quot;my_malloc&quot;))); 利用编译器进行符号的替换，这样可以替换本身以及静态库中的malloc。得益于MachO文件的二级命名空间，并不会替换动态库中的方法。 符号覆盖123void *malloc(size) &#123; dlsym(RTLD_NEXT, &quot;malloc&quot;);&#125; 在项目内可以直接定义新的malloc方法，链接器会将自身和静态库的malloc链接到自己的方法，如果需要调用原本的方法，可以使用dlsym(RTLD_NEXT, &quot;malloc&quot;)。同样无法替换动态库的malloc。 mac上可行1__attribute__ ((section(&quot;__DATA, __interpose&quot;))) iOS上被禁用的特性。 动态库符号链接替换fish_hook提供了一种修改动态库符号链接的方法，前提是替换的被替换的对象需要在动态库中，也是只能替换映射到自身的malloc，无法替换动态库的方法。 但是这种方式比较灵活，可以根据情况动态的打开关闭。 malloc_zone影响面最大的就是替换malloc_default_zone了，这样动态库的malloc也会使用新的内存管理。 系统并没有公开方法给我们替换default_zone的方法，其实私有方法也没有替换的方法，这里就用到了一个技巧，malloc_zone_unregister的时候，会将unregister_zone和zone列表最后一个zone交换来填补zone数组，所以就可以用以下方式来替换。 1234malloc_zone_register(my_zone);malloc_zone_t *default_zone = malloc_default_zone()malloc_zone_unregister(default_zone);malloc_zone_register(default_zone); 替换完以后必须把unregister的注册回去，不然可能会导致某些对象释放时找不到对应的zone。 同时这些方法之间无法保证线程安全，由于内部的锁并未公开，所以这里需要在程序运行之前，也就是main函数开始时，或是更早进行替换。 这样我们就得到了一个完全属于自己的内存管理方案。 应用内内存使用分析在进行替换之前，我们需要去分析当前内存使用状况，以及性能状态，从而才可以得知我们替换的内存管理方案有效。 为了做这个脚手架，也耗费了我相当长的时间。这里来看看如何去实现收集内存使用状况。这里就不能使用task_info，host_statistics和sysctl这样粗略的统计方法了。 由于性能以及Objc对象无法完全摆脱malloc_zone（会导致统计的死循环），所以这里使用C++来实现统计分析。 线程安全首先，需要考虑到的是线程安全，这里可以使用锁来简单的解决这个问题，但是这样同时也会大大影响性能，甚至可能会影响统计结果，所以这里采用ThreadLocal的方案。 每一个线程都有自己独立统计数据存放池，这样在新增数据等操作的时候就不需要加锁了，也尽量避免对性能有太大的影响。 malloc死循环我们统计malloc，在生成统计数据的时候依然可能会调用到malloc，这样我们就可能形成了一个死循环，那么我们需要解决这种循环有两种方法。 在统计过程中修改标志位，统计结束重置该标志位，在这之间的malloc不进入统计。如果上面选择使用的是锁，那么这里也要加锁，如果上面选择的是ThreadLocal，那么这里每个线程也需要一个独立的标志。 修改内存申请方式，不用malloc，使用系统底层实现vm_allocate。 这里，我选用第2中方案，为此需要C++的Allocator： 1234567891011121314151617181920212223242526template &lt;class _Tp&gt;class VMAllocator : public std::allocator&lt;_Tp&gt; &#123;public: typedef typename std::allocator&lt;_Tp&gt;::pointer pointer; typedef typename std::allocator&lt;_Tp&gt;::size_type size_type; pointer allocate(size_type __n, std::allocator&lt;void&gt;::const_pointer = 0) &#123; size_type n = round_page(__n * sizeof(_Tp)); vm_address_t addr; kern_return_t rt = vm_allocate(mach_task_self(), &amp;addr, n, VM_FLAGS_ANYWHERE); if (rt != KERN_SUCCESS) &#123; throw std::bad_alloc(); &#125; vm_protect(mach_task_self(), addr, n, true, VM_PROT_READ|VM_PROT_WRITE); return reinterpret_cast&lt;pointer&gt;(addr); &#125; void deallocate(pointer __p, size_type __n) noexcept &#123; size_type n = round_page(__n); kern_return_t rt = vm_deallocate(mach_task_self(), reinterpret_cast&lt;vm_address_t&gt;(__p), n); if (rt != KERN_SUCCESS) &#123; &#125; &#125;&#125;; 获取每一个内存申请数据那么我们如何去获取这样详细的统计数据呢？只能去hook malloc的方法了，这里我们需要去hook malloc_zone-&gt;malloc的方法。 我们如何才能获得malloc_zone的真正对象呢，其实这些对象都是有全局的名字的。 12extern &quot;C&quot; malloc_zone_t **malloc_zones;extern &quot;C&quot; int32_t malloc_num_zones; 其中malloc_zones[0]就是default_zone。 由于malloc_zone是readonly状态，我们需要先修改权限才能继续hook。同时由上面所说的，这些都是非线程安全的操作，所以需要在启动的时候就完成，并且运行过程中不能修改。 123mprotect(orig_zone_ptr_, sizeof(malloc_zone_t), PROT_READ|PROT_WRITE);orig_zone_ptr_-&gt;malloc = Wrap::malloc;mprotect(orig_zone_ptr_, sizeof(malloc_zone_t), PROT_READ); logger其实系统也开放了两个钩子对象，分别给我们统计系统调用和malloc调用的情况： 123456789// For logging VM allocation and deallocation, arg1 here// is the mach_port_name_t of the target task in which the// alloc or dealloc is occurring. For example, for mmap()// that would be mach_task_self(), but for a cross-task-capable// call such as mach_vm_map(), it is the target task.typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *__syscall_logger; 123456789// We set malloc_logger to NULL to disable logging, if we encounter errors// during file writingtypedef void(malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *malloc_logger; 由于这里我们不需要统计malloc的数据（我们更关心OC对象），但是我们还是希望了解系统调用发生的次数（系统调用是一种比较慢的操作）。 启动这里我做了一个不完整的工具放在github，欢迎大家进行补充。只需要将动态库导入，并在程序开始的时候配置就可以了。 12345678910111213#import &lt;MallocDetector/MallocDetector.h&gt;int main(int argc, char * argv[]) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; malloc_detector_show_inspector(); &#125;); malloc_detector_attach_zone(true); malloc_detector_start(); @autoreleasepool &#123; return UIApplicationMain(argc, argv, NSStringFromClass([Application class]), NSStringFromClass([AppDelegate class])); &#125;&#125; 统计结果下面就来看看我在我们app里面统计得到的结果。 设备iPhone 7。在此期间系统调用12898次。这里是内存申请大小之和按照时间顺序的情况，其中size作log2处理。 可以看到主线程都比较平稳，而ui线程则是和用户行为相关，网络更是和网络请求密切相关。 下面是内存size-class的分布，这里粒度比较低（2^n)，个数(/1000) 可以看出来，我们对于256 bytes以下的对象占有绝对的比例，其中32 - 64 bytes最多。每个线程的分布也不一致，说明特定的业务场景会拥有不同的内存需求。 下面是不同大小耗费时间的分布，时间的单位为time_t。 可以看出来256 bytes一下的时间消耗具有优势。 以上统计结果可能并不能代表所有，统计的样本也不够多，但也能代表部分真实状况。 替换default_zone本来想替换为tcmalloc，但是它没有支持iOS系统，所以这里转而替换为jemalloc，由于时间有限，我也没有成功移植到arm上，所以这里看看模拟器的情况： 其中左边为苹果默认的分配器，右边为jemalloc。 在内存分布相近的情况，jemalloc看似略微好于苹果默认分配器，但这种差距似乎很小，可能在误差之内。 最后在移动应用中，内存的管理似乎并没有起到非常重要的地位，也不可能出现服务器那样的长时间运行，所以目前没有人做过这方面的优化处理。但是从这些点可以了解内存分配的一些情况，给我们一些不同的视角，具体情况下可以做一些特殊的优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"malloc","slug":"malloc","permalink":"http://djs66256.github.io/tags/malloc/"},{"name":"malloc_zone","slug":"malloc-zone","permalink":"http://djs66256.github.io/tags/malloc-zone/"}]},{"title":"原子性内存栅栏问题简述","date":"2018-03-28T17:09:17.000Z","path":"2018/03/29/2018-03-29-内存栅栏问题简述/","text":"内存栅栏(Memory fence)，也称为内存屏障(Memory barrier)，以前碰到这类概念都是基于锁的理解，比如dispatch_barrier。在看bmalloc的源代码时，发现其在使用原子性(atomic)的时候，出现了一种memory_order的概念，所以这里来简单看看原子性方面的问题。 Atomic方法在iOS中，我们平时最常用的原子特性大部分来自于OSAtomic，可是当我打开这个文件的时候，却发现这些方法已经被弃用了。 123OSATOMIC_DEPRECATED_REPLACE_WITH(atomic_compare_exchange_strong)__OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0)bool OSAtomicCompareAndSwap32( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue ); 很好奇这个新的方法，它来自于C标注库stdatomic.h中，而这个头文件是C11才引入的，说明这是一个非常新的方法。而在C++11中，STL增强了C++的多线程编程能力，所以也是这个时候引入的std::atomic。 atomic和volidate，atomic是真正的原子性，而volidate则仅标记对象为易变，提交给编译器优化使用的，并不能确保原子性。 Memory Order12345678typedef enum memory_order &#123; memory_order_relaxed = __ATOMIC_RELAXED, memory_order_consume = __ATOMIC_CONSUME, memory_order_acquire = __ATOMIC_ACQUIRE, memory_order_release = __ATOMIC_RELEASE, memory_order_acq_rel = __ATOMIC_ACQ_REL, memory_order_seq_cst = __ATOMIC_SEQ_CST&#125; memory_order; 关于memory_order这个概念，非常的令人困惑。其关键就是atomic能够保证单个的操作的原子性，但不能保证两个原子操作之间的顺序，这涉及到CPU对缓存刷新时进行的顺序重排。这里看两个简单的例子就可以理解了： 和我们平时的理解完全不一样，内存的修改顺序和实际的顺序居然可能不一致，这就是为什么会引入memory_order这个概念了。 Spin lock最后再来看看SpinLock的实现，所有SpinLock都是基于原子操作进行的，目前我碰到的大致分为两种： 比较无赖，强制for循环等待 比较友善，在超过一定循环次数，会放弃当前时间片 伪代码： 12345atomic flagwhile flag: loop_count++ if loop_count &gt; MAX_LOOP_COUNT: yield // iOS中可以是thread_swtich 所以当某些调度算法，即使是在优先级高的线程中yield放弃时间片，依然不能分配给优先级低的线程，就会导致优先级反转而死锁。 参考A Tutorial Introduction to the ARM and POWER Relaxed Memory Models","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"内存栅栏","slug":"内存栅栏","permalink":"http://djs66256.github.io/tags/%E5%86%85%E5%AD%98%E6%A0%85%E6%A0%8F/"},{"name":"内存屏障","slug":"内存屏障","permalink":"http://djs66256.github.io/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"},{"name":"fence","slug":"fence","permalink":"http://djs66256.github.io/tags/fence/"},{"name":"barrier","slug":"barrier","permalink":"http://djs66256.github.io/tags/barrier/"}]},{"title":"如何判断block回调未被调用","date":"2018-03-20T14:44:58.000Z","path":"2018/03/20/2018-03-20-如何判断block回调未被调用/","text":"在处理异步过程中，我们经常会碰到这种情况，需要异步处理并异步回调completionHandler，但是有些场景下，如果你在处理完异步逻辑，而不回调completion的时候，会产生逻辑上的bug或者内存泄露问题，那么我们就需要知道调用方是否调用了completion。 这里举几个比较典型的例子，比如WKUIDelegate中的回调： 1234- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler; 如果不回调其completionHandler，会导致其逻辑上的错误，那么这里我们来看看如何动态监测completionHandler是否被调用过。 这里说一下，WK是通过WTF的C++模板来实现的，我这里采用C语言来实现，其思路是大致相同的。 Block首先我们来看看Block是什么。虽然我们平时可以像OC对象那样去使用它，但它严格意义上来说并不是一个OC对象，或者说它是一中极为特殊的OC对象。 1234567891011121314struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void *, ...); Descriptor *descriptor; // imported variables&#125;;struct Descriptor &#123; uintptr_t reserved; uintptr_t size; void (*copy)(void *dst, const void *src); void (*dispose)(const void *);&#125;; 上面就是Block的内存布局，其中Block_layout是一个不定长的结构体，我们平时看到的捕获变量都会存在结构尾部。这里我们看到和OC对象一样，也有isa指针，但是这里的指针永远只会指向几个地方，这个之后会说。 其实我们在调用Block的时候，实际上调用的是block-&gt;invoke()，第一个参数是Block本身，然后是入参按顺序排下去，这一部分编译器都会给我们做好，所以一个block调用实际是这样的： 1block-&gt;invoke(block, arg1, arg2, arg3); 可以看到和OC的objc_msgSend方法相同的是第一个参数是对象本身，但是不同的是第二个参数不再是SEL。 既然知道了Block的结构，那么我们就可以自定义block了。 Block类型Block定义的类型有： 12345678910111213BLOCK_EXPORT void * _NSConcreteGlobalBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteStackBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteMallocBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteAutoBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32] __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2); 其中只有前2种是公开的，而我们平时会碰到的基本都是前3种类型，其中Global是永远不会被释放的，Stack是在栈上，所以只要栈销毁了就会被释放，Malloc和普通OC对象一样，采用引用计数来决定生命周期的。 那么我们回到最初的目的，如何判断是否被调用了呢？因为这个调用有可能是异步的，所以不可能通过__block bool called这样的临时对象来判断，也不能通过其是否由Stack拷贝成Malloc来判断，因为copy了并不一定会被调用。 Block Wrap这里要判断Block是否被调用，肯定是需要在原始Block基础上包裹一层可以计数调用次数的Block。C++会方便的多，可以直接通过模板来构造一个签名一样的Block。 这里我们利用了MallocBlock在未被任何人引用的时候会销毁的特性，在其被释放之前，来监测计数是否为0。如果是0则说明从来没有被调用过，不是0则说明被调用了。 那么接下来我们来看看如何动态构建这样一个Block，以及如果去包裹其实现体。 动态构建Block123456789101112struct Block_layout &#123; void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void); void *descriptor; // imported variables void *block; int64_t called; char *message;&#125;; 首先我们将我们所需要的几个参数定义在Block末尾，分别是原始的Block，调用计数，以及错误信息（这个在报错的时候使用，和该方案关系不大）。 然后，我们需要定义自己的descriptor。这里重写了dispose方法，我们需要在这里判断是否计数为0，同时也要在这里将对象释放掉（由于在C环境中，所以block也需要手动将其释放）。 123456789101112131415161718192021222324void block_call_assert_wrap_dispose(const void * ptr) &#123; struct Block_layout *self = (struct Block_layout *)ptr; if (!((struct Block_layout *)ptr)-&gt;called) &#123; if (exception_handler) &#123; if (self-&gt;message) &#123; char *buf = (char *)malloc((strlen(self-&gt;message) + 64) * sizeof(char)); sprintf(buf, &quot;ERROR: Block must be called at %s!\\n&quot;, self-&gt;message); exception_handler(buf); free(buf); &#125; else &#123; exception_handler(&quot;ERROR: Block must be called at %s!\\n&quot;); &#125; &#125; &#125; Block_release(self-&gt;block); if (self-&gt;message) free(self-&gt;message);&#125;static const struct Descriptor descriptor = &#123; 0, sizeof(struct Block_layout), NULL, block_call_assert_wrap_dispose&#125;; 接下来就是将我们的所有数据内容填入Block_layout，来合成一个Block对象。 12345678910111213141516171819202122232425void *block_call_assert_wrap_block(void *orig_blk, char *message) &#123; struct Block_layout *block = (struct Block_layout *)malloc(sizeof(struct Block_layout)); block-&gt;isa = _NSConcreteMallocBlock; enum &#123; BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), &#125;; const unsigned retainCount = 1; block-&gt;flags = BLOCK_HAS_COPY_DISPOSE | BLOCK_NEEDS_FREE | (retainCount &lt;&lt; 1); block-&gt;reserved = 0; block-&gt;invoke = (void (*)(void))block_call_assert_wrap_invoke; block-&gt;descriptor = (void *)&amp;descriptor; block-&gt;block = (void *)Block_copy(orig_blk); block-&gt;called = 0; size_t len = strlen(message)*sizeof(char); char *buf = (char *)malloc(len); memcpy(buf, message, len); block-&gt;message = buf; return block;&#125; 其中invoke方法被我们的新方法block_call_assert_wrap_invoke所替换，在这个方法里面，会更新计数，并且调用原始block的invoke方法。 block_call_assert_wrap_invoke的实现block的方法是非常灵活的，参数个数以及返回值不一样的时候，经过前几篇内容，我们知道不能简单的通过方法调用来实现参数的传递，而且在这里我们也无法知道参数的个数以及类型。那么我们要怎么做才能简单而又实用呢？ 这时候，我们想到objc_msgSend方法，它就实现了非常技巧的实现了arguments forward的功能（其功能特性可以参考C++模板的多参传递template &lt;typename Args...&gt;）。 由于这里找不到i386的系统和arm32的系统了，所以只给出x86_64和arm64的实现方案。 123456789101112131415161718#if __x86_64__.align 4.global _block_call_assert_wrap_invoke_block_call_assert_wrap_invoke:mov %rdi, %r10movq $1, 0x28(%r10) // calledmovq 0x20(%r10), %r11 // blockmovq %r11, %rdimovq 0x10(%r11), %r11 // block-&gt;block-&gt;invokejmp *%r11#endif 123456789101112131415161718192021#ifdef __arm64__.align 4.global _block_call_assert_wrap_invoke_block_call_assert_wrap_invoke:mov x9, x0add x10, x9, #0x20 // &amp;blockadd x11, x9, #0x28 // calledmov x12, #1str x12, [x11]ldr x12, [x10] // blockadd x12, x12, #0x10 // block-&gt;invokeldr x12, [x12]mov x0, x11br x12ret#endif 这里简单的说明一下段汇编的逻辑。 取出block-&gt;called，并置为1（可能改为真正的计数会比较好）。 取出原始block block-&gt;block，并放到第一个参数位置。 调用原始block的invoke call block-&gt;block-&gt;invoke。 这样我们就非常简单的包裹了原始invoke方法，并且插入了自己的逻辑。 使用首先我们需要设置上述的exception_handler。 1234void exception_log(const char *str) &#123; NSLog(@&quot;%s&quot;, str);&#125;block_call_assert_set_exception_handler(exception_log); 这里我只是让他打印出错误，更好的应该是直接抛出异常[NSException raise:]。 在此基础上，定义一个宏以方便使用，以及可以加入#if DEBUG，来禁用线上环境的该功能，并且把当前的位置传递给exception_message： 123456789#define BLOCK_CALL_ASSERT(x) (&#123; \\ typeof ((x)) blk = x; \\ char *message = (char *)malloc(512); \\ memset(message, 0, 512); \\ sprintf(message, &quot;(%s:%d %s)&quot;, __FILE__, __LINE__, __FUNCTION__); \\ typeof (blk) ret = (__bridge_transfer typeof(blk))block_call_assert_wrap_block((__bridge void *)blk, message); \\ free(message); \\ ret; \\&#125;) bridge，恩我们是支持的ARC，所以在此为了防止类型转换的warning和error，在此使用宏来定义。（好像Objc++会有警告） 那么在使用的时候就是这样： 12345678910- (void)doAsyncWithCompletion:(block_t)completionBlock &#123; dispatch_async(..., ^&#123; completionBlock(...) &#125;);&#125;[self doAsyncWithCompletion:BLOCK_CALL_ASSERT(^&#123; do_after_completion(); do_clear();&#125;)]; 那么在此时，如果被调用者没有调用过completionBlock()时，就会触发exception_handler。这样我们就可以检测到是否出现可能的逻辑错误和内存泄露了。 1ERROR: Block must be called at (BlockCallAssert/BlockCallAssert/BlockCallAssert/ViewController.mm:41 -[ViewController test2])! 最后一般来说，我们一旦设计了包含completionBlock这样的接口，基本是需要回调方100%的回调的，如果可以不用回调，那么我们为什么不改变设计方案呢。 当我们的调用方是自己的时候，我们可以确保，而如果是SDK，我们就很难确保，文档这个东西是不靠谱的，那么我们就让调用方在忽略了回调的时候给他一个重拳吧（exception）。 这个方案的实现我放在github，和cocoaPods BlockCallAssert。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"}]},{"title":"C语言的动态调用","date":"2018-03-03T17:05:22.000Z","path":"2018/03/04/2018-03-04-C语言的动态调用/","text":"我们都认为C语言是一种非常静态的语言，几乎没有什么动态特性，同时往往在编译器就决定了整个运行方式，运行期是很难改变其运行状态的。其实C语言也是可以比较动态的，只是由于C语言是一个跨平台兼容语言，每个平台都有不同的实现，其动态化很难统一。这里我们看看在AArch64平台上的动态化实现。 其他语言的动态化脚本语言是非常具有动态特性的，其中典型的js就可以如下方式动态调用方法。 1234function hello() &#123; console.log(&#x27;hello world&#x27;)&#125;eval(&#x27;hello()&#x27;) 平时开发常用的Objc也有一定的动态特性，比如NSInvocation和 1- (id)performSelector:(SEL)aSelector; 都可以通过方法名称来调用。 那么我们来看看C语言的表现。 C语言的动态化根据上两篇内容，我们了解了iOS/Mac系统的执行文件格式MachO，而linux常用的ELF也是类似，执行代码都在TEXT段，如果我们要执行对应的方法，我们只需要拿到对应的地址（也就是函数指针）就行了。 那么如何从字符串找到对应的地址呢？这就涉及到函数符号表了，根据上篇的内容，不难找到其对应的函数指针，这里系统也给我们提供了一个封装好的方法。 1234567891011NAME dlsym -- get address of a symbolSYNOPSIS #include &lt;dlfcn.h&gt; void* dlsym(void* handle, const char* symbol);DESCRIPTION dlsym() returns the address of the code or data location specified by the null-terminated character string symbol. Which libraries and bundles are searched depends on the handle parameter. 有了函数指针之后，只需要将我们的参数填入对应位置，我们就可以实现方法调用了。如何填入参数呢？根据之前的讨论和aapcs64ARM官方文档的说明，我们可以按照这种思路去填入参数。 这里我们简单的把所有参数都认为是int64（或者说void *)类型，这样我们可以把以上逻辑简化为： 按x0-x7顺序填入寄存器 剩下的都放入栈中 这里设计个简单的动态调用接口： 12345extern void dynamic_call_func_name(const char *func, int64_t argc, int64_t *args) &#123; void *funcPtr = dlsym(RTLD_DEFAULT, func); dynamic_call_func((uintptr_t)funcPtr, argc, args);&#125;extern void dynamic_call_func(uintptr_t func, int64_t argc, int64_t *args); 以及测试函数： 12345678void one_arg(int64_t a1);void two_arg(int64_t a1, int64_t a2);void eight_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);void nine_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9);void ten_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10);void eleven_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t a11);void more_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t aa1, int64_t aa2, int64_t aa3, int64_t aa4, int64_t aa5, int64_t aa6, int64_t aa7, int64_t aa8); 那么动态调用可以写作： 1234int64_t args[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;dynamic_call_func_name(&quot;eleven_arg&quot;, sizeof(args)/sizeof(int64_t), args); 这样我们就实现了C语言的动态调用了。比如可以从其他端获得方法名和参数列表，就可以直接调用C方法了。这也是一些高级语言调用C语言的实现方式（cpython），以及一些rpc的实现方案。 接下来我们来看看如何填入参数，dynamic_call_func的实现方式。 动态设置参数这里我们只能通过汇编来设置参数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122.align 4// C方法会自动加上前缀`_`.global _dynamic_call_func_dynamic_call_func:// if func == NULL then returncbz x0, DCReturnZero// 申请栈空间，0x10用于缓存fp和lr，剩下的用于临时变量// 这里不能确定调用的方法是否会用到栈空间来传递参数，所以这里暂不考虑，fp == spsub sp, sp, #0x20stp x29, x30, [sp]mov x29, sp// 栈参数长度，初始化为0mov x15, #0str x15, [x29, #0x18]// 缓存一些入参，需要给下个方法腾出寄存器// x9 = func// x10 = x11 = argc// x12 = x13 = argsmov x9, x0mov x10, x1mov x11, x1mov x12, x2mov x13, x2// 没有参数直接 CALLcbz x11, DCCallFunc// 第一个参数ldr x0, [x12]sub x11, x11, #1cbz x11, DCCallFunc// 第二个参数ldr x1, [x12, #0x8]sub x11, x11, #1cbz x11, DCCallFuncldr x2, [x12, #0x10]sub x11, x11, #1cbz x11, DCCallFuncldr x3, [x12, #0x18]sub x11, x11, #1cbz x11, DCCallFuncldr x4, [x12, #0x20]sub x11, x11, #1cbz x11, DCCallFuncldr x5, [x12, #0x28]sub x11, x11, #1cbz x11, DCCallFuncldr x6, [x12, #0x30]sub x11, x11, #1cbz x11, DCCallFunc// 第八个参数ldr x7, [x12, #0x38]sub x11, x11, #1cbz x11, DCCallFunc// 栈参数// 开始计算栈空间，由于我们的参数都是int64类型// 所以栈空间x15 = x11(剩余参数个数) * 8mov x16, #8mul x15, x11, x16// The NSAA is rounded up to the larger of 8 or the Natural Alignment of the argument’s type// 这里需要对齐，我也不明白为什么and x16, x15, #0x8cbz x16, DCNoFixAlignDCFixAlign:add x15, x15, #0x8DCNoFixAlign:// 现在开始重新申请参数栈空间，并将栈空间大小存入临时变量`fp + 0x18`DCStoreStackArgsLength:str x15, [x29, #0x18]sub sp, sp, x15mov x15, spadd x13, x12, #0x38// 循环剩下的参数，逐个将其入栈:// for arg in args+8:// push(arg)DCPushStackArgs:add x13, x13, #0x8ldr x14, [x13]str x14, [x15]sub x11, x11, #1add x15, x15, #0x8cbnz x11, DCPushStackArgs// CALLDCCallFunc:blr x9// 这里首先销毁参数栈空间ldr x15, [x29, #0x18]cbz x15, DCRestoreStackDCRestoreStackArgsLength:add sp, sp, x15// 然后还原fp, lr// 销毁当前栈空间DCRestoreStack:ldp x29, x30, [sp]add sp, sp, #0x20ret// ReturnZero:DCReturnZero:mov x0, 0ret 经过测试，可以看到所有参数都被正确的传递过去了，说明这种思路是正确的。 总结那么C语言动态调用能给我们一些什么好处呢。这是一种rpc的思想，而且这不需要额外的rpc支持，就可以直接调用几乎所有C方法，但是这样也给我们的程序带来了一定的风险，包括权限，参数类型等问题。 同时也是快速实现，或者说兼容C实现高级语言的一种方式，比如cpython就是利用了这种思想。 由于不同平台的差异性，可能会导致兼容工作非常庞大，那么我们可以设计几种类型的参数，或者固定几个参数，来简化我们的兼容工作，比如将所有的对象都放到堆上，使用指针来传递。 开源项目libffi实现了多平台的动态调用，有兴趣的人可以自己去了解其实现。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[]},{"title":"运行时获取函数调用栈","date":"2018-01-20T18:02:57.000Z","path":"2018/01/21/2018-01-21-运行时获取函数调用栈/","text":"在之前做debug工具的时候，就有一个想法，在页面产生卡顿的时候，如果能够获取主线程的函数调用栈就好了，就可以分析出哪里出现了性能瓶颈。由于当时对这部分内容还不是很了解，就没有继续下去，现在重新来实践一次。 原理上篇说到的C方法的参数调用时，描述了C函数调用的大致流程，我们也知道通过BL跳转的函数调用会将返回地址存在LR寄存器中，如果还有后续的函数调用，则会把LR存入栈帧进行保存。 还是拿出我们的栈帧分布图： FP当前位置储存的是上一个FP所在的地址，也就是FP = &amp;FP0，而LR被储存在FP的下一个，由于栈是向上增长的，所以LR = *(FP + 1)。也就是说我们如果能拿到当前的FP就可以依次获得所有的二进制中的调用顺序： 1234while(fp) &#123; pc = *(fp + 1); fp = *fp;&#125; 以上就是我们此次遍历调用栈的最重要的思路，如果你了解汇编，这一部分应该很简单。 MachOMachO是MAC和iOS的可执行文件格式，包括动态库静态库。想要从调用地址获得方法名称，就必须要了解MachO的基本结构，这次我们不需要了解每个字段和数值都代表什么，只需要关心特定的几个字段。（苹果官方有关MachO的文档特别少，我们能够获得的相关文档 MachORuntime 也是非常的古老，甚至现在在官网上已经搜不到了，所以MachO是比较难以理解的一部分。） 关于MachO内容查看和解析，官方有几个命令行工具： The file-type displaying tool, /usr/bin/file, shows the type of a file. For multi-architecture files, it shows the type of each of the images that make up the archive. The object-file displaying tool, /usr/bin/otool, lists the contents of specific sections and segments within a Mach-O file. It includes symbolic disassemblers for each supported architecture and it knows how to format the contents of many common section types. The page-analysis tool, /usr/bin/pagestuff, displays information on each logical page that compose the image, including the names of the sections and symbols contained in each page. This tool doesn’t work on binaries containing images for more than one architecture. The symbol table display tool, /usr/bin/nm, allows you to view the contents of an object file’s symbol table. 这里我们使用GUI工具MachOView来说明，使用上更加简单方便。 一个MachO大致分为三部分： Header Load Commands 数据段 headerHeader中保存了CPU架构，load commands的个数等信息，这次我们都在ARM64的基础上进行分析： 12345678910struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; load_commands紧接着Header的就是load command了，这里存着一些加载信息，动态库，main函数和数据段等一些信息。所有的结构前两位都是一样的： 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 这次我们会遇到的有segment, symbol table相关的load commands。这里我们先不说明每个字段的作用，之后在使用过程中再来说明。 12345678910111213141516171819202122struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;struct symtab_command &#123; uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; /* symbol table offset */ uint32_t nsyms; /* number of symbol table entries */ uint32_t stroff; /* string table offset */ uint32_t strsize; /* string table size in bytes */&#125;; 数据段数据段包括了很多内容，也是最复杂的部分，大致包含了 TEXT可执行代码，DATA数据段，符号表，字符表等内容，这里我们需要了解的是Section(_TEXT,__text)和Symbol Table。 其中TEXT段就是我们的代码执行部分，可以直接进行反汇编。比如下面就是从微信SDK中获取的一段反汇编代码： 123456789-[AppCommunicateData MakeCommand:]:0000000000001e94 stp x29, x30, [sp, #-0x10]!0000000000001e98 mov x29, sp0000000000001e9c adrp x8, #0x40000000000000001ea0 ldr x1, [x8, #0x998]0000000000001ea4 bl _objc_msgSend0000000000001ea8 orr w0, wzr, #0x10000000000001eac ldp x29, x30, [sp]!, #0x100000000000001eb0 ret 而符号表就是保存了我们代码中全部的公开符号，包括动态链接的符号。比如下面就是一个解析后的符号表内容： 这里我们简单的介绍了一下MachO和本次所需要了解的内容，由于MachO是一个非常庞大而且复杂的结构，这里就不再深入了。接下来我们来简单看看一个函数的动态调用过程，来理解如何通过符号（也就是函数名称），来获取执行的地址（也就是下一个PC的位置）。 函数调用我们以上面+[ObjcException test]来进行说明。 首先我们从load_command中获取到符号表的位置。 然后在符号表中查找，得到上图的结构，其中value字段代表着在该文件中的偏移量0x1AF0。 我们找到在(__TEXT,__text)段中的这一行： 那么，要实现开头所说的符号查找，也就是该过程的一个逆过程，也就打通了道路。 LR查找符号我们从堆栈中获取的LR值并不是该函数的起始位置，也就是符号表中所记录的位置，而是函数返回地址，我们再来看看微信SDK的这一段代码： 123456789-[AppCommunicateData MakeCommand:]:0000000000001e94 stp x29, x30, [sp, #-0x10]!0000000000001e98 mov x29, sp0000000000001e9c adrp x8, #0x40000000000000001ea0 ldr x1, [x8, #0x998]0000000000001ea4 bl _objc_msgSend0000000000001ea8 orr w0, wzr, #0x10000000000001eac ldp x29, x30, [sp]!, #0x100000000000001eb0 ret 这里bl _objc_msgSend，LR所记录的应该是0000000000001ea8，而不是开头的0000000000001e94，那么我们要怎么定位该符号呢？ 我们知道，在执行代码区域，每个符号之间是连续的，而且符号会全部保存在符号表中，那么我们可以遍历符号表，查找到小于LR位置，并且距离LR最近的一个符号，那么我们就可以认为我们的函数跳转发生在该函数内部。 这样就找到了我们所需要的符号名称了。 下面就从实现角度来说明。 实现这里我们用纯C/C++来实现这部分，使用lambda来让代码更容易理解。这里的实现并不是完美的，只是作为说明整个流程。 准备工作在获取调用栈之前，我们最好将对应线程暂停： 123456789pthread_t thread;pthread_create(&amp;thread, nullptr, [](void *p) &#123; thread_suspend(main_thread); // generate symbols of (main_thread); thread_resume(main_thread); void *ptr = nullptr; return ptr;&#125;, nullptr); 获得线程当前状态MachO提供了获取暂停线程上下文环境的接口thread_get_state 1234567891011121314151617#if defined(__x86_64__) _STRUCT_MCONTEXT ctx; mach_msg_type_number_t count = x86_THREAD_STATE64_COUNT; thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&amp;ctx.__ss, &amp;count); uint64_t pc = ctx.__ss.__rip; uint64_t sp = ctx.__ss.__rsp; uint64_t fp = ctx.__ss.__rbp;#elif defined(__arm64__) _STRUCT_MCONTEXT ctx; mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT; thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;ctx.__ss, &amp;count); uint64_t pc = ctx.__ss.__pc; uint64_t sp = ctx.__ss.__sp; uint64_t fp = ctx.__ss.__fp;#endif 可以看到不同架构的获取方式是完全不一样的，这是由于不同平台底层实现的不同所导致的，但是对于C语言层面上来说，都是一致的，都有最基本的几个概念PC, SP, FP, LR。 遍历调用栈依照我们开头所说的方法来遍历: 12345do &#123; // print symbol of (pc); pc = *((uint64_t *)fp + 1); fp = *((uint64_t *)fp);&#125; while (fp); 查找符号一般来说，我们一个应用内会有多个动态库，也就是会有多个MachO被映射到内存空间，所以我们不是简单的查找某个Image就可以了，而是要遍历所有已载入的Images。 123456uint64_t count = _dyld_image_count();for (uint32_t i = 0; i &lt; count; i++) &#123; const struct mach_header *header = _dyld_get_image_header(i); const char *name = _dyld_get_image_name(i); uint64_t slide = _dyld_get_image_vmaddr_slide(i);&#125; 这里我们就能够拿到各自的mach_header了，计算其相对于image的地址时，需要进行矫正： 1uint64_t pcSlide = pc - slide; 在查找符号前，我们定义一个快捷的函数，来遍历load commands，因为之后会多次查找load commands： 1234567891011121314void enumerateSegment(const mach_header *header, std::function&lt;bool(struct load_command *)&gt; func) &#123; // \b这里我们只考虑64位应用。第一个command从header的下一位开始 struct load_command *baseCommand = (struct load_command *)((struct mach_header_64 *)header + 1); if (baseCommand == nullptr) return; struct load_command *command = baseCommand; for (int i = 0; i &lt; header-&gt;ncmds; i++) &#123; if (func(command)) &#123; return; &#125; command = (struct load_command *)((uintptr_t)command + command-&gt;cmdsize); &#125;&#125; 回到上面，首先我们需要遍历segment，来确定当前pc是否落在这个image的区域内。由于一个程序空间内，虚拟地址都是唯一的，动态库也会被映射到一段唯一的地址段，所以如果pc不在当前的地址段内，就可以确定不属于该MachO的方法。 1234567891011121314151617bool found = false;enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SEGMENT_64) &#123; const struct segment_command_64 *segCmd = (struct segment_command_64 *)command; uintptr_t start = segCmd-&gt;vmaddr; uintptr_t end = segCmd-&gt;vmaddr + segCmd-&gt;vmsize; if (pcSlide &gt;= start &amp;&amp; pcSlide &lt; end) &#123; std::cout &lt;&lt; segCmd-&gt;segname &lt;&lt; std::endl; found = true; return true; &#125; &#125; return false;&#125;);if (!found) continue; 定位符号我们需要遍历符号表，首先要从load_command中定位到符号表的位置，而symtab_command并没有给我们一个绝对的位置信息，只有一个stroff和symoff，也就是字符串表偏移量和符号表偏移量，所以我们还需要找出其真正的内存地址。而我们可以从LC_SEGMENT(__LINKEDIT)段中获取到绝对位置vmaddr和偏移量fileoff，所以就可以得到： 12345uint64_t baseaddr = segCmd-&gt;vmaddr - segCmd-&gt;fileoff;// 符号表nlist_64 *nlist = (nlist_64 *)(baseaddr + slide + symCmd-&gt;symoff);// 字符串表uint64_t strTable = baseaddr + slide + symCmd-&gt;stroff; 这里我们就可以按照上面的想法，在nlist中找到最符合的符号字符串了。综合起来如下： 12345678910111213141516171819202122232425262728293031323334353637383940enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SYMTAB) &#123; struct symtab_command *symCmd = (struct symtab_command *)command; uint64_t baseaddr = 0; enumerateSegment(header, [&amp;](struct load_command *command) &#123; if (command-&gt;cmd == LC_SEGMENT_64) &#123; struct segment_command_64 *segCmd = (struct segment_command_64 *)command; if (strcmp(segCmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; baseaddr = segCmd-&gt;vmaddr - segCmd-&gt;fileoff; return true; &#125; &#125; return false; &#125;); if (baseaddr == 0) return false; nlist_64 *nlist = (nlist_64 *)(baseaddr + slide + symCmd-&gt;symoff); uint64_t strTable = baseaddr + slide + symCmd-&gt;stroff; uint64_t offset = UINT64_MAX; int best = -1; for (int k = 0; k &lt; symCmd-&gt;nsyms; k++) &#123; nlist_64 &amp;sym = nlist[k]; uint64_t d = pcSlide - sym.n_value; if (offset &gt;= d) &#123; offset = d; best = k; &#125; &#125; if (best &gt;= 0) &#123; nlist_64 &amp;sym = nlist[best]; std::cout &lt;&lt; &quot;SYMBOL: &quot; &lt;&lt; (char *)(strTable + sym.n_un.n_strx) &lt;&lt; std::endl; &#125; return true; &#125; return false;&#125;); 结论\b我们再模拟器上实验，最后的结果来说是完全符合预期的，除了有部分系统符号不能打出来。这里整理一部分结果： 123456789101112131415161718192021222324252627282930313233343536373839404142Found: cfunction.app/cfunctionSYMBOL: -[ViewController viewDidLoad]Found: UIKit.framework/UIKitSYMBOL: -[UIViewController loadViewIfRequired]Found: UIKit.framework/UIKitSYMBOL: -[UIViewController view]Found: UIKit.framework/UIKitSYMBOL: -[UIWindow addRootViewControllerViewIfPossible]Found: Frameworks/UIKit.framework/UIKitSYMBOL: -[UIWindow _setHidden:forced:]Found: /UIKit.framework/UIKitSYMBOL: -[UIWindow makeKeyAndVisible]......Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopDoSource0Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopDoSources0Found: CoreFoundation.framework/CoreFoundationSYMBOL: ___CFRunLoopRunFound: CoreFoundation.framework/CoreFoundationSYMBOL: _CFRunLoopRunSpecificFound: GraphicsServices.framework/GraphicsServicesFound: UIKit.framework/UIKitSYMBOL: _UIApplicationMainFound: cfunction.app/cfunctionSYMBOL: _main 和xcode所展示的调用关系： 以上是在模拟器的环境下，那么在真机上是什么表现呢？很遗憾，在真机上，很多私有API的符号都被去掉了，只能显示&lt;redacted&gt;，但是部分公开的API和自己的符号均能被打印。所以还是能帮助我们对问题的分析。 最后MachO还是一个非常庞大的知识点，而且官方资料也特别少，和很多业务层代码不同，这些内容对开发能力的影响可能不大，毕竟平时业务层的东西很少需要这些东西。但是这些东西有时候能够产生一些新奇的想法和不同的思路。下面简单说几个相关的内容。 C方法的method swizziling，Facebook的fishhook。 __attribute__(section(&quot;__DATA,custom&quot;))，自定义全局对象，React就是采用这种方式自动采集方法列表的。这个思路可以简化很多编码方式，但是可移植性会降低。 C方法的动态调用，我们可以运行时去调用指定的C方法。这个方式危险程度较高，但却是很多高级语言的基础。 参考KSCrashMachORuntime","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"调用栈","slug":"调用栈","permalink":"http://djs66256.github.io/tags/%E8%B0%83%E7%94%A8%E6%A0%88/"},{"name":"卡顿分析","slug":"卡顿分析","permalink":"http://djs66256.github.io/tags/%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90/"},{"name":"crash","slug":"crash","permalink":"http://djs66256.github.io/tags/crash/"},{"name":"stack","slug":"stack","permalink":"http://djs66256.github.io/tags/stack/"},{"name":"KSCrash","slug":"KSCrash","permalink":"http://djs66256.github.io/tags/KSCrash/"}]},{"title":"C方法的调用参数与ARM汇编","date":"2018-01-11T12:43:57.000Z","path":"2018/01/11/2018-01-11-C方法的调用参数与ARM汇编/","text":"在平时开发和调试中，经常遇到C调用栈和汇编，所以这里来统一的了解下这部分内容，本章需要一定的汇编基础才能更好的理解。 函数签名在JavaScript中，我们定义函数和调用函数都是相当自由的： 12345function func(a, b, c) &#123; console.log(a, b, c)&#125;func(1)func(1, 2, 3, 4, 5, 6) 这样做完全没有问题。但是在C语言中，方法调用却是非常严格的，如果参数类型或者个数不对，就会直接编译失败（隐式转换除外）。 123456789int arg1_func(int a) &#123; return a;&#125;int arg2_func(int a, int b) &#123; return a+b;&#125;arg1_func(1, 2);arg2_func(1); 以上C语言将会直接编译不通过，原因之后再说。这里我们把int(*)(int)称为这个函数的函数签名。 为什么我们要了解函数签名呢？由于C方法的参数传递是和函数签名相关的，而且是编译期就需要确定的。他决定了参数是如何传递给具体方法，并且返回参数是如何返回的。 那么接下来就让我们来了解C语言的参数传递方式。由于不同架构平台拥有不同的处理方式，但大同小异，这里我们就用AArch64架构来做介绍。 Registers在了解底层之前，我们需要一点ARM的预备知识，这里做一个简单的介绍，具体ARM汇编可以参考官方文档armasm_user_guide和ABI。 ARM_ASM (4.1节)In AArch64 state, the following registers are available: Thirty-one 64-bit general-purpose registers X0-X30, the bottom halves of which are accessible asW0-W30. Four stack pointer registers SP_EL0, SP_EL1, SP_EL2, SP_EL3. Three exception link registers ELR_EL1, ELR_EL2, ELR_EL3. Three saved program status registers SPSR_EL1, SPSR_EL2, SPSR_EL3. One program counter. ABI (9.1节)For the purposes of function calls, the general-purpose registers are divided into four groups: Argument registers (X0-X7) These are used to pass parameters to a function and to return a result. They can be used as scratch registers or as caller-saved register variables that can hold intermediate values within a function, between calls to other functions. The fact that 8 registers are available for passing parameters reduces the need to spill parameters to the stack when compared with AArch32. Caller-saved temporary registers (X9-X15) If the caller requires the values in any of these registers to be preserved across a call to another function, the caller must save the affected registers in its own stack frame. They can be modified by the called subroutine without the need to save and restore them before returning to the caller. Callee-saved registers (X19-X29) These registers are saved in the callee frame. They can be modified by the called subroutine as long as they are saved and restored before returning. Registers with a special purpose (X8, X16-X18, X29, X30) X8 is the indirect result register. This is used to pass the address location of an indirect result, for example, where a function returns a large structure. X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers. These can be used by call veneers and similar code, or as temporary registers for intermediate values between subroutine calls. They are corruptible by a function. Veneers are small pieces of code which are automatically inserted by the linker, for example when the branch target is out of range of the branch instruction. X18 is the platform register and is reserved for the use of platform ABIs. This is an additional temporary register on platforms that don’t assign a special meaning to it. X29 is the frame pointer register (FP). X30 is the link register (LR). 根据官方文档，这里我们需要知道的是X0-X30个通用寄存器，D0-D31个浮点寄存器，堆栈寄存器SP，和独立不可直接操作的PC寄存器。 其中通用寄存器在C语言的ABI定义中，X29作为栈帧FP，X30作为函数返回地址LR，X0-X7作为参数寄存器，X8为Indirect result location（和返回值相关），X9-X15为临时寄存器。其他的寄存器和目前我们的内容没有太大的关系，所以不做介绍了。这里有个官方的简要图： 在阅读以下内容需要明确上述的几个寄存器，特别是LR=X30，FP=X29，其中W0和X0代表同一个寄存器，只是W是32位，X是64位。 需要了解的存取指令是LDR（load），STR（store），其他存取指令都是以这两个为基础。相关运算可见ABI 6.3.4节，这里介绍下下面会遇到的运算： Example Description LDR X0, [X1, #8] Load from address X1 + 8 LDR X0, [X1, #8]! Pre-index: Update X1 first (to X1 + #8), then load from the new address LDR X0, [X1], #8 Post-index: Load from the unmodified address in X1 first, then update X1 (to X1 + #8) Stack Frame在C语言调用过程中，SP和LR是成对出现的，他们代表了一个函数的栈区域，也称为栈帧。 一个栈帧的大概结构如下： 这个结构对我们来说非常重要，也是本次我们讨论的重点。 少参数调用对于一个函数的调用，入参会放入X0-X7中，返回参数会放在X0中返回，那么我们就来分析下一个简单的例子： 123int lessArg(int arg1, char *arg2) &#123; return 0;&#125; 调用前： 1234567891011caller: 0x100791c6c &lt;+20&gt;: mov w9, #0x0 0x100791c70 &lt;+24&gt;: stur w9, [x29, #-0x14] 0x100791c74 &lt;+28&gt;: stur w0, [x29, #-0x18] 0x100791c78 &lt;+32&gt;: str x1, [x8, #0xa0] 0x100791c7c &lt;+36&gt;: mov x1, #0x0 ; // 第二个参数 arg2 = 0 0x100791c80 &lt;+40&gt;: mov x0, x9 ; // 第一个参数 arg1 = 0 0x100791c84 &lt;+44&gt;: str x1, [sp, #0x88] 0x100791c88 &lt;+48&gt;: str x8, [sp, #0x80] 0x100791c8c &lt;+52&gt;: str w9, [sp, #0x7c] 0x100791c90 &lt;+56&gt;: bl 0x100791a60 ; CALL &#x27;lessArg&#x27; 12345678cfunction`lessArg: 0x104491a98 &lt;+0&gt;: sub sp, sp, #0x10 ; 由于栈是向下增长的，所以 SP = SP - 0x10 0x104491a9c &lt;+4&gt;: mov w8, #0x0 0x104491aa0 &lt;+8&gt;: str w0, [sp, #0xc] 0x104491aa4 &lt;+12&gt;: str x1, [sp] 0x104491aa8 &lt;+16&gt;: mov x0, x8 ; 返回值 X0 = 0 0x104491aac &lt;+20&gt;: add sp, sp, #0x10 ; 销毁栈 0x104491ab0 &lt;+24&gt;: ret 由以上结果看的确按照ABI所描述的，在&lt;=8个参数的时候，参数是放在寄存器中传递。 多参数调用那么如果参数超过8个呢？据ABI描述是通过堆栈的形式来传递，我们来看下结果： 123int moreArg(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10, int arg11, int arg12, int arg13, char *arg14) &#123; return 0;&#125; 12345678910111213141516171819202122232425262728caller: 0x100791c9c &lt;+68&gt;: mov x1, sp ; x1 = SP 0x100791ca0 &lt;+72&gt;: ldr x30, [sp, #0x88] 0x100791ca4 &lt;+76&gt;: str x30, [x1, #0x18] 0x100791ca8 &lt;+80&gt;: orr w9, wzr, #0xc 0x100791cac &lt;+84&gt;: str w9, [x1, #0x10] ; SP+0x10 = arg13 0x100791cb0 &lt;+88&gt;: mov w9, #0xb 0x100791cb4 &lt;+92&gt;: str w9, [x1, #0xc] ; SP+0xc = arg12 0x100791cb8 &lt;+96&gt;: mov w9, #0xa 0x100791cbc &lt;+100&gt;: str w9, [x1, #0x8] ; SP+0x8 = arg11 0x100791cc0 &lt;+104&gt;: mov w9, #0x9 0x100791cc4 &lt;+108&gt;: str w9, [x1, #0x4] ; SP+0x4 = arg10 0x100791cc8 &lt;+112&gt;: orr w9, wzr, #0x8 0x100791ccc &lt;+116&gt;: str w9, [x1] ; SP = arg9 0x100791cd4 &lt;+124&gt;: orr w2, wzr, #0x2 ; w2 = arg3 0x100791cd8 &lt;+128&gt;: orr w3, wzr, #0x3 ; w3 = arg4 0x100791cdc &lt;+132&gt;: orr w4, wzr, #0x4 ; w4 = arg5 0x100791ce0 &lt;+136&gt;: mov w5, #0x5 ; w5 = arg6 0x100791ce4 &lt;+140&gt;: orr w6, wzr, #0x6 ; w6 = arg7 0x100791ce8 &lt;+144&gt;: orr w7, wzr, #0x7 ; w7 = arg8 0x100791cec &lt;+148&gt;: ldr w10, [sp, #0x7c] 0x100791cf0 &lt;+152&gt;: str w0, [sp, #0x78] 0x100791cf4 &lt;+156&gt;: mov x0, x10 ; w0 = arg1 0x100791cd0 &lt;+120&gt;: orr w9, wzr, #0x1 0x100791cf8 &lt;+160&gt;: mov x1, x9 ; w1 = arg2 0x100791cfc &lt;+164&gt;: str x8, [sp, #0x70] 0x100791d00 &lt;+168&gt;: str w9, [sp, #0x6c] 0x100791d04 &lt;+172&gt;: bl 0x100791a7c ; moreArg at main.mm:16 从上面可以看出来，arg9以上的入参被存在了SP ~ (SP+0x10)的位置，也就是当前栈的栈底，下一层栈帧的栈顶。 123456789101112131415161718192021222324252627282930cfunction`moreArg: 0x104491ab4 &lt;+0&gt;: sub sp, sp, #0x40 ; 申请栈空间，这里我们将原来的sp记作&#x27;SP0&#x27; ; 那么 SP = SP0 - 0x40 0x104491ab8 &lt;+4&gt;: ldr x8, [sp, #0x58] 0x104491abc &lt;+8&gt;: ldr w9, [sp, #0x50] ; w9 = SP + 0x50 = SP0 - 0x40 + 0x50 = SP0 + 0x10 ; 也就是w13 = arg13 ; 按照这样的推导，下面依次为arg9 ~ arg12 0x104491ac0 &lt;+12&gt;: ldr w10, [sp, #0x4c] 0x104491ac4 &lt;+16&gt;: ldr w11, [sp, #0x48] 0x104491ac8 &lt;+20&gt;: ldr w12, [sp, #0x44] 0x104491acc &lt;+24&gt;: ldr w13, [sp, #0x40] ; w13 = SP + 0x40 = SP0 - 0x40 + 0x40 = SP0 ; 也就是w13 = arg9 0x104491ad0 &lt;+28&gt;: mov w14, #0x0 0x104491ad4 &lt;+32&gt;: str w0, [sp, #0x3c] 0x104491ad8 &lt;+36&gt;: str w1, [sp, #0x38] 0x104491adc &lt;+40&gt;: str w2, [sp, #0x34] 0x104491ae0 &lt;+44&gt;: str w3, [sp, #0x30] 0x104491ae4 &lt;+48&gt;: str w4, [sp, #0x2c] 0x104491ae8 &lt;+52&gt;: str w5, [sp, #0x28] 0x104491aec &lt;+56&gt;: str w6, [sp, #0x24] 0x104491af0 &lt;+60&gt;: str w7, [sp, #0x20] 0x104491af4 &lt;+64&gt;: str w13, [sp, #0x1c] 0x104491af8 &lt;+68&gt;: str w12, [sp, #0x18] 0x104491afc &lt;+72&gt;: str w11, [sp, #0x14] 0x104491b00 &lt;+76&gt;: str w10, [sp, #0x10] 0x104491b04 &lt;+80&gt;: str w9, [sp, #0xc] 0x104491b08 &lt;+84&gt;: str x8, [sp] 0x104491b0c &lt;+88&gt;: mov x0, x14 0x104491b10 &lt;+92&gt;: add sp, sp, #0x40 ; =0x40 0x104491b14 &lt;+96&gt;: ret 由此可见，大于8个的参数会被放入栈中SP ~ (SP + count - 8)，和预期的一样。 struct参数及返回上面说了基本类型的传递情况，在C语言中，还有一类不定长数据类型可以直接传递，那就是struct。那么我们来看看struct参数是怎么传递的。 小struct12345678struct SmallStruct &#123; int arg1;&#125;;struct SmallStruct smallStructFunc(int arg1, struct SmallStruct arg2) &#123; struct SmallStruct s = arg2; return s;&#125; 12345678caller: 0x100791d24 &lt;+204&gt;: ldur w9, [x29, #-0x30] 0x100791d28 &lt;+208&gt;: mov x1, x9 ; x1 = arg2 ! ; 这里struct内容直接赋值给了x1，因为x1的容量完全够用！ 0x100791d2c &lt;+212&gt;: ldr w9, [sp, #0x7c] 0x100791d30 &lt;+216&gt;: str w0, [sp, #0x64] ; w0 = arg1 0x100791d34 &lt;+220&gt;: mov x0, x9 0x100791d38 &lt;+224&gt;: bl 0x100791b04 ; smallStructFunc at main.mm:32 123456789101112cfunction`smallStructFunc: 0x1003b5b04 &lt;+0&gt;: sub sp, sp, #0x20 ; =0x20 0x1003b5b08 &lt;+4&gt;: mov x8, x1 ; x8 = arg2 0x1003b5b0c &lt;+8&gt;: str w8, [sp, #0x10] 0x1003b5b10 &lt;+12&gt;: str w0, [sp, #0xc] 0x1003b5b14 &lt;+16&gt;: ldr w8, [sp, #0x10] 0x1003b5b18 &lt;+20&gt;: str w8, [sp, #0x18] 0x1003b5b1c &lt;+24&gt;: ldr w8, [sp, #0x18] 0x1003b5b20 &lt;+28&gt;: mov x0, x8 ; x0 = x8 = arg2 ; 这里直接将x0作为struct返回值 0x1003b5b24 &lt;+32&gt;: add sp, sp, #0x20 ; =0x20 0x1003b5b28 &lt;+36&gt;: ret 可见，小型struct，可以直接放在寄存器中传递，和普通基本类型的传递没有太大的区别。 大struct那么struct足够的大呢，导致不能简单的用寄存器容纳struct的数据？ 这里就要涉及到X8的一个特殊身份了(XR, indirect result location)，这里我们将X8记作XR。 1234567struct BigStruct &#123; int arg1; int arg2; int arg3; int arg4; int arg5; int arg6; int arg7; int arg8; int arg9; int arg10; int arg11; int arg12; int arg13; char *arg14;&#125;;struct BigStruct bigStructFunc(int arg1, struct BigStruct arg2) &#123; struct BigStruct s = arg2; return s;&#125; 1234567891011121314151617181920caller: 0x100791d3c &lt;+228&gt;: mov x9, x0 0x100791d40 &lt;+232&gt;: stur w9, [x29, #-0x38] 0x100791d44 &lt;+236&gt;: ldr x8, [sp, #0x80] 0x100791d48 &lt;+240&gt;: ldur q0, [x8, #0x78] 0x100791d4c &lt;+244&gt;: str q0, [x8, #0x30] 0x100791d50 &lt;+248&gt;: ldur q0, [x8, #0x68] 0x100791d54 &lt;+252&gt;: stur q0, [x29, #-0xa0] 0x100791d58 &lt;+256&gt;: ldur q0, [x8, #0x58] 0x100791d5c &lt;+260&gt;: stur q0, [x29, #-0xb0] 0x100791d60 &lt;+264&gt;: ldur q0, [x8, #0x48] 0x100791d64 &lt;+268&gt;: stur q0, [x29, #-0xc0] ; 以上是将临时变量arg2赋值到Callee的参数栈区 ; 这样子函数修改就不会改动原始数据了 ; 为方便，后面将已拷贝的数据成为 arg2 0x100791d68 &lt;+272&gt;: add x8, sp, #0xb0 ; XR = SP + 0xb0 ; Callee save area ; 这是一个空的区域，用作返回的临时存储区 0x100791d6c &lt;+276&gt;: sub x1, x29, #0xc0 ; x1 = FP - 0xc0 = &amp;arg2 0x100791d70 &lt;+280&gt;: ldr w0, [sp, #0x7c] ; w0 = arg1 0x100791d74 &lt;+284&gt;: bl 0x100791b2c ; bigStructFunc at main.mm:36 123456789101112131415cfunction`bigStructFunc: 0x1003b5b2c &lt;+0&gt;: sub sp, sp, #0x20 ; 申请栈空间 SP = SP0 - 0x20 0x1003b5b30 &lt;+4&gt;: stp x29, x30, [sp, #0x10] ; 这里和以上几个不同，是因为这里有函数调用，所以需要把LR和FP压栈 0x1003b5b34 &lt;+8&gt;: add x29, sp, #0x10 0x1003b5b38 &lt;+12&gt;: orr x2, xzr, #0x40 ; struct 的 size = 0x40，作为第三个参数 0x1003b5b3c &lt;+16&gt;: stur w0, [x29, #-0x4] 0x1003b5b40 &lt;+20&gt;: mov x0, x8 ; dst = x0 = XR = SP0 + 0xb0 ; 第一个入参dst为caller的临时存储区 ; 第二个参数为x1，也就是caller的 &amp;arg2 0x1003b5b44 &lt;+24&gt;: bl 0x1003b62f0 ; symbol stub for: memcpy ; void *memcpy(void *dst, const void *src, size_t n); ; 这里居然直接调用了memcpy，赋值！ 0x1003b5b48 &lt;+28&gt;: ldp x29, x30, [sp, #0x10] 0x1003b5b4c &lt;+32&gt;: add sp, sp, #0x20 ; =0x20 0x1003b5b50 &lt;+36&gt;: ret 这样返回值就放在了*XR所在的位置，caller只需要再拷贝到临时变量区中即可。 可以看到，在处理大型struct时，就会出现多次内存拷贝，会对性能造成一定影响，所以这类方法尽量不要直接传递大型struct，可以传递指针或者引用，或者采用inline的方案，在优化期去除函数调用。 struct参数的分界线根据AAPCS 64的Parameter Passing Rules节所述： If the argument is a Composite Type and the size in double-words of the argument is not more than 8 minus NGRN, then the argument is copied into consecutive general-purpose registers, starting at x[NGRN]. The argument is passed as though it had been loaded into the registers from a double-word- aligned address with an appropriate sequence of LDR instructions loading consecutive registers from memory (the contents of any unused parts of the registers are unspecified by this standard). The NGRN is incremented by the number of registers used. The argument has now been allocated. 大致说的是如果X0-X8中剩余的寄存器足够去保存该结构，那么就保存到寄存器，否则保存到栈。 If the type, T, of the result of a function is such that void func(T arg) would require that arg be passed as a value in a register (or set of registers) according to the rules in §5.4 Parameter Passing, then the result is returned in the same registers as would be used for such an argument. 返回值也遵守以上规则。 这个文档不是最新的，而且是beta版，暂时没有找到正式版本。而且这里还涉及到很多其他的因素，所以这里也就不深究了。 va_list以上都是确定参数，那么如果是不确定参数，又是怎么传递的呢？ 在AAPCS 64文档里有明确的说明，但是这里我们从汇编的角度来看这个问题。 1234567891011int mutableAragsFunc(int arg, ...) &#123; va_list list; va_start(list, arg); int ret = arg; while(int a = va_arg(list, int)) &#123; ret += a; &#125; va_end(list); return ret;&#125;mutableAragsFunc(1, 2, 3, 0); 在函数入口打断点，打印参数寄存器： 12345678x0 = 0x0000000000000001x1 = 0x000000016fce7930x2 = 0x000000016fce7a18x3 = 0x000000016fce7a90x4 = 0x0000000000000000x5 = 0x0000000000000000x6 = 0x0000000000000001x7 = 0x00000000000004b0 可以发现除了x0是正确的第一个参数，其他都是随机的，那么说明参数肯定被放到了栈上。 12345678910111213141516171819cfunction`main: 0x100121be4 &lt;+0&gt;: sub sp, sp, #0xa0 ; =0xa0 0x100121be8 &lt;+4&gt;: stp x29, x30, [sp, #0x90] 0x100121bec &lt;+8&gt;: add x29, sp, #0x90 ; =0x90 0x100121bf0 &lt;+12&gt;: mov w8, #0x0 0x100121bf4 &lt;+16&gt;: stur w8, [x29, #-0x4] 0x100121bf8 &lt;+20&gt;: stur w0, [x29, #-0x8] 0x100121bfc &lt;+24&gt;: stur x1, [x29, #-0x10] 0x100121c00 &lt;+28&gt;: mov x1, sp 0x100121c04 &lt;+32&gt;: mov x9, #0x0 0x100121c08 &lt;+36&gt;: str x9, [x1, #0x10] ; 压栈 0 0x100121c0c &lt;+40&gt;: orr w8, wzr, #0x3 0x100121c10 &lt;+44&gt;: mov x9, x8 0x100121c14 &lt;+48&gt;: str x9, [x1, #0x8] ; 压栈 3 0x100121c18 &lt;+52&gt;: orr w8, wzr, #0x2 0x100121c1c &lt;+56&gt;: mov x9, x8 0x100121c20 &lt;+60&gt;: str x9, [x1] ; 压栈 2 0x100121c24 &lt;+64&gt;: orr w0, wzr, #0x1 ; arg = 1 0x100121c28 &lt;+68&gt;: bl 0x1001218d8 ; mutableAragsFunc at main.mm:67 也就是表明被明确定义的参数，是按照上面所说的规则传递，而...参数全部按照栈方式传递。这从实现原理上也比较容易理解，在取va_arg的时候，只需要将栈指针+sizeof(type)就可以了。 错误的函数签名那么现在，我们回过头来看看第一个问题。C语言为什么会有函数签名？ 函数签名决定了参数以及返回值的传递方式，同时还决定了函数栈帧的分布与大小，所以如果不确定函数签名，我们也就无法知道如何去传递参数了。 那么错误的函数签名会导致什么样的后果呢？运行时是否会崩溃？我们来看： 123456789101112131415int arg1_func(int a) &#123; return a;&#125;int arg2_func(int a, int b) &#123; return a+b;&#125;void arg_test_func() &#123; int ret1 = ((int (*)(int, int))arg1_func)(1, 2); int ret2 = ((int (*)(int))arg2_func)(1); int ret3 = ((int (*)())arg1_func)(); int ret4 = ((int (*)())arg2_func)(); printf(&quot;%d, %d, %d, %d\\n&quot;, ret1, ret2, ret3, ret4);&#125; 首先说结果，结果是一切运行正常，只是结果值有部分是错误的。那么我们来看看汇编代码： 1234567891011121314151617181920212223242526cfunction`arg_test_func: 0x1003462cc &lt;+0&gt;: sub sp, sp, #0x50 ; =0x50 0x1003462d0 &lt;+4&gt;: stp x29, x30, [sp, #0x40] 0x1003462d4 &lt;+8&gt;: add x29, sp, #0x40 ; =0x40 ; 以上都是处理栈帧 0x1003462d8 &lt;+12&gt;: orr w0, wzr, #0x1 ; w0 = 1 0x1003462dc &lt;+16&gt;: orr w1, wzr, #0x2 ; w1 = 2 0x1003462e0 &lt;+20&gt;: bl 0x100346298 ; arg1_func at main.mm:87 0x1003462e4 &lt;+24&gt;: orr w1, wzr, #0x1 ; w1 = 1 0x1003462e8 &lt;+28&gt;: stur w0, [x29, #-0x4] ; 将结果存入临时变量 ret1 ; 按照寄存器的状态，这里相当于调用了 arg1_func(1) ; 其结果是正确的，只是可能没有符合预期 0x1003462ec &lt;+32&gt;: mov x0, x1 ; x0 = 1 0x1003462f0 &lt;+36&gt;: bl 0x1003462ac ; arg2_func at main.mm:90 0x1003462f4 &lt;+40&gt;: stur w0, [x29, #-0x8] ; 将结果存入临时变量 ret2 ; 相当于 arg2_func(1, 1) = 2 ; 第二个参数取决于上一次x1的状态 ; 所以结果应该是随机的 0x1003462f8 &lt;+44&gt;: bl 0x100346298 ; arg1_func at main.mm:87 0x1003462fc &lt;+48&gt;: stur w0, [x29, #-0xc] ; 相当于 ret3 = arg1_func(2) = 2 0x100346300 &lt;+52&gt;: bl 0x1003462ac ; arg2_func at main.mm:90 0x100346304 &lt;+56&gt;: stur w0, [x29, #-0x10] ; 相当于 ret4 = arg2_func(2, 1) = 3 所以结果应该是1, 2, 2, 3。 这里的结果不能代表任何在其他环境下的结果，可以说其结果是难以预测的。这里没有奔溃也只是随机参数并不会带来奔溃的风险。 所以我们是不能用其他函数签名来传递参数的。 obj_msgSend接下来，我们来说说iOS中最著名的函数obj_msgSend，可以说，这个函数是objc的核心和基础，没有这个方法，就不存在objc。 根据我们上面的分析，理论上我们不能改变obj_msgSend的函数签名，来传递不同类型和个数的参数。那么苹果又是怎么实现的呢？ 以前我们一直说obj_msgSend用汇编来写是为了速度，但这并不是主要原因，因为retain，release也是非常频繁使用的方法，为什么不把这几个也改为汇编呢。其实更重要的原因是如果用C来写obj_msgSend根本实现不了！ 我们翻开苹果objc的源码，查看其中arm64.s汇编代码： 12345678910111213141516171819202122232425262728293031 ENTRY _objc_msgSend MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x9, x13, #ISA_MASK // x9 = class LGetIsaDone: CacheLookup NORMAL // calls imp or objc_msgSend_uncachedLNilOrTagged: b.eq LReturnZero // nil check // tagged adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x9, [x10, x11, LSL #3] b LGetIsaDoneLReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret END_ENTRY _objc_msgSend 看出于上面其他C方法编译出来的汇编的区别了吗？ 那就是obj_msgSend居然不存在栈帧！同时也没有任何地方修改过X0-X7,X8,LR,SP,FP！ 而且当找到真正对象上的方法的时候，并不像其他方法一样使用BL，而是使用了 12.macro CacheHitbr x17 // call imp 也就是说并没有修改LR。这样做的效果就相当于在函数调用的时候插入了一段代码！更像是c语言的宏。 由于obj_msgSend并没有改变任何方法调用的上下文，所以真正的objc方法就好像是被直接调用的一样。 可以说，这种想法实在是太精彩了。 objc_msgSend对nil对象的处理大家都知道，向空对象发送消息，返回的内容肯定都是0。那么这是为什么呢？ 还是来看obj_msgSend的源代码部分，第一行就判断了nil： 12cmp x0, #0 // nil check and tagged pointer checkb.le LNilOrTagged // (MSB tagged pointer looks negative) 其中tagged pointer技术并不是我们本期的话题，所以我们直接跳到空对象的处理方法上： 123456789LReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 MESSENGER_END_NIL ret 他将可能的保存返回值的寄存器全部写入0！（为什么会有多个寄存器，是因为ARM其实是支持向量运算的，所以在某些条件下会用多个寄存器保存返回值，具体可以去参考ARM官方文档）。 这样我们的返回值就只能是0了！ 等等，还缺少一个类型，struct！如果是栈上的返回，上文已经分析过是保存在X8中的，可是我们并没有看到任何有关X8的操作。那么我们来写一个demo尝试一下： 12345678void struct_objc_nil(Test *t) &#123; struct BigStruct retB; printf(&quot;stack: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6); retB = ((struct BigStruct(*)(Test *, SEL))objc_msgSend)(t, @selector(retStruct)); printf(&quot;msgSend: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6); retB = [t retStruct]; printf(&quot;objc: %d,%d,%d,%d,%d,%d,\\n&quot;, retB.arg1, retB.arg2, retB.arg3, retB.arg4, retB.arg5, retB.arg6);&#125; 首先我们打开编译优化-os(非优化状态，栈空间会被清0)。其结果居然是： 123stack: 50462976,185207048,0,0,0,0,msgSend: 1,0,992,0,0,0,objc: 0,0,0,0,0,0, struct类型两者的返回并不一致！按照我们阅读源码来推论，随机数值才是正确的结果，这是为什么呢？ 我们还是来看汇编，我将关键部分特意标注了出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778cfunction`struct_objc_nil: 0x10097e754 &lt;+0&gt;: sub sp, sp, #0x90 ; =0x90 0x10097e758 &lt;+4&gt;: stp x20, x19, [sp, #0x70] 0x10097e75c &lt;+8&gt;: stp x29, x30, [sp, #0x80] 0x10097e760 &lt;+12&gt;: add x29, sp, #0x80 ; =0x80 0x10097e764 &lt;+16&gt;: bl 0x10097e9d4 ; symbol stub for: objc_retain 0x10097e768 &lt;+20&gt;: mov x19, x0 0x10097e76c &lt;+24&gt;: adr x0, #0x1730 ; &quot;stack: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e770 &lt;+28&gt;: nop 0x10097e774 &lt;+32&gt;: bl 0x10097e9f8 ; symbol stub for: printf 0x10097e778 &lt;+36&gt;: nop 0x10097e77c &lt;+40&gt;: ldr x20, #0x262c ; &quot;retStruct&quot; 0x10097e780 &lt;+44&gt;: add x8, sp, #0x30 ; =0x30 0x10097e784 &lt;+48&gt;: mov x0, x19 0x10097e788 &lt;+52&gt;: mov x1, x20 0x10097e78c &lt;+56&gt;: bl 0x10097e9b0 ; symbol stub for: objc_msgSend 0x10097e790 &lt;+60&gt;: ldp w8, w9, [sp, #0x30] 0x10097e794 &lt;+64&gt;: ldp w10, w11, [sp, #0x38] 0x10097e798 &lt;+68&gt;: ldp w12, w13, [sp, #0x40] 0x10097e79c &lt;+72&gt;: stp x12, x13, [sp, #0x20] 0x10097e7a0 &lt;+76&gt;: stp x10, x11, [sp, #0x10] 0x10097e7a4 &lt;+80&gt;: stp x8, x9, [sp] 0x10097e7a8 &lt;+84&gt;: adr x0, #0x170f ; &quot;msgSend: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e7ac &lt;+88&gt;: nop 0x10097e7b0 &lt;+92&gt;: bl 0x10097e9f8 ; symbol stub for: printf //////////////////////////////////////////////////////////-&gt; 0x10097e7b4 &lt;+96&gt;: cbz x19, 0x10097e7d8 ; &lt;+132&gt; at main.mm:134 ; 这里的意思是： ; IF X19 == NULL THEN ; GOTO 0x10097e7d8 ; 而 0x10097e7d8 就是内存清0的地方！ ; X19 在 0x10097e768 被赋值为 objc 对象 &#x27;nil&#x27; ; 而在第一次调用 &#x27;obj_msgSend&#x27; 就没有这一段！ ; （由于优化，有些逻辑和代码中有变化） ////////////////////////////////////////////////////////// 0x10097e7b8 &lt;+100&gt;: add x8, sp, #0x30 ; =0x30 0x10097e7bc &lt;+104&gt;: mov x0, x19 0x10097e7c0 &lt;+108&gt;: mov x1, x20 0x10097e7c4 &lt;+112&gt;: bl 0x10097e9b0 ; symbol stub for: objc_msgSend 0x10097e7c8 &lt;+116&gt;: ldp w8, w9, [sp, #0x30] 0x10097e7cc &lt;+120&gt;: ldp w10, w11, [sp, #0x38] 0x10097e7d0 &lt;+124&gt;: ldp w12, w13, [sp, #0x40] 0x10097e7d4 &lt;+128&gt;: b 0x10097e800 ; &lt;+172&gt; at main.mm:135 ; 这里有一段清0的代码！正好就是返回值的局部变量地址 0x10097e7d8 &lt;+132&gt;: mov w13, #0x0 0x10097e7dc &lt;+136&gt;: mov w12, #0x0 0x10097e7e0 &lt;+140&gt;: mov w11, #0x0 0x10097e7e4 &lt;+144&gt;: mov w10, #0x0 0x10097e7e8 &lt;+148&gt;: mov w9, #0x0 0x10097e7ec &lt;+152&gt;: mov w8, #0x0 0x10097e7f0 &lt;+156&gt;: stp xzr, xzr, [sp, #0x60] 0x10097e7f4 &lt;+160&gt;: stp xzr, xzr, [sp, #0x50] 0x10097e7f8 &lt;+164&gt;: stp xzr, xzr, [sp, #0x40] 0x10097e7fc &lt;+168&gt;: stp xzr, xzr, [sp, #0x30] 0x10097e800 &lt;+172&gt;: stp x12, x13, [sp, #0x20] 0x10097e804 &lt;+176&gt;: stp x10, x11, [sp, #0x10] 0x10097e808 &lt;+180&gt;: stp x8, x9, [sp] 0x10097e80c &lt;+184&gt;: adr x0, #0x16c8 ; &quot;objc: %d,%d,%d,%d,%d,%d,\\n&quot; 0x10097e810 &lt;+188&gt;: nop 0x10097e814 &lt;+192&gt;: bl 0x10097e9f8 ; symbol stub for: printf 0x10097e818 &lt;+196&gt;: mov x0, x19 0x10097e81c &lt;+200&gt;: bl 0x10097e9c8 ; symbol stub for: objc_release 0x10097e820 &lt;+204&gt;: ldp x29, x30, [sp, #0x80] 0x10097e824 &lt;+208&gt;: ldp x20, x19, [sp, #0x70] 0x10097e828 &lt;+212&gt;: add sp, sp, #0x90 ; =0x90 0x10097e82c &lt;+216&gt;: ret 0x10097e830 &lt;+220&gt;: b 0x10097e834 ; &lt;+224&gt; at main.mm 0x10097e834 &lt;+224&gt;: mov x20, x0 0x10097e838 &lt;+228&gt;: mov x0, x19 0x10097e83c &lt;+232&gt;: bl 0x10097e9c8 ; symbol stub for: objc_release 0x10097e840 &lt;+236&gt;: mov x0, x20 0x10097e844 &lt;+240&gt;: bl 0x10097e98c ; symbol stub for: _Unwind_Resume 到这里我们就能够明白了，为什么struct返回值也会变成0。是编译器给我们加入了一段判定的代码！ 那么’objc空对象的返回值一定是0’这个判定就需要在一定条件下了。 总结对这一部分的探索一直持续了很久，一直是迷糊状态，不过经过长时间的多次探索，慢慢思考，总算有一个比较清晰的认识了。可以说底层的东西真的很多很复杂，这里只是其中很小的一方面，其他方面等有时间了另外再写吧。 参考资料armasm_user_guide ABI AAPCS GNU C &amp; ASM Apple ASM","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"C","slug":"C","permalink":"http://djs66256.github.io/tags/C/"},{"name":"ARM","slug":"ARM","permalink":"http://djs66256.github.io/tags/ARM/"},{"name":"ASM","slug":"ASM","permalink":"http://djs66256.github.io/tags/ASM/"}]},{"title":"2017年总结","date":"2017-12-29T18:36:29.000Z","path":"2017/12/30/2017-12-30-2017年总结/","text":"2017年很快就过去了，在这期间发生过很多事情也明白很多事情，这里就来做个年终总结吧。 职业能力以前，总以为自己要多了解些东西，多掌握点其他方面的技术，认为成为一个多面手或许更为有用。对于一个创业小团队或者小公司，事事都要你去涉及的情况下，或许是对的，但是对于一些成熟的稳定的团队来说，是根本不需要的，他们所看重的，所需要的仅仅是你所对应职位的技能。 在一个团队，掌握一方面开发技能的人比比皆是，根本不需要别人去插足，而能够真正深入一项技能，并且有所想法的人却少之又少，而能把想法实现并且能够推广实用的人更是凤毛麟角。 虽然简单的说深入，可是真正实施起来确是非常的困难。因为平时能够碰到的都是基本逻辑，根本不会遇到这些更加深入的技能。就算是遇到了，也是这其中非常片面的一方面，要让一个更为资深的人来评价你，由于双方的知识体系并不一致，也很难在短时间内给出非常准确的判断。 在这一年中，深刻的感觉到了深入是多么的困难，很多东西和概念都是全新的，完全区别于上层，而且这类东西的资料极少，没有很多可以参照的东西。而且越是深入，越是发现各种知识体系的相关性，所以往往在了解某一种技术的时候，会涉及的越来越多，越来越复杂。 拥有一些想法并不是难事，但是要将这些想法实现出来就需要更多的知识，这就不仅仅需要深入的技能，也需要更为广泛的技能。然而这些事情也并不是做出来就是成功了，很多的场景下或者业务下，这些东西有用，但并不被需要，也不被别人所信服，能够解决他们的需求，所以也就不了了之了。 所以很多时候，目前的职位决定了自己的能力定位。 对事很多事情，并不是你认为的就是别人所相信的，别人想要的只是他们想要的答案，而不是你真实的东西。 如果别人认为你的月薪是1万，那么你告诉对方5千，对方会认为你在骗他，告诉对方5万，对方依然会认为你在骗他，对方所需要的只是对方心里所认知的，所能理解的答案罢了。 所以很多时候，我们能给的，需要给的并不是正确的答案，而是对方满意的答案。很多时候在你看来是对的东西，在不同的立场不同的场景下，或许就是错误的，你可以保持你的正确性，但也无力去改变别人的正确性。 未来发展对于未来的发展，以前我一直比较看好物联网，到如今，物联网已经基本成熟了，被小米玩的特溜，所以也就不存在未来了，已经是进行时了。那么我们来预测下接下来几年的发展。 今年忽然间火起来的是机器学习和AI，我认为这两个仅仅是个表象，真正越来越重要的还是数据，只是以前的数据更加简单精准，而目前的数据更为庞大，所以才产生了这些技术来处理这些人为已经处理不了的数据了。 既然看好数据在未来的发展，那么今后就需要向这方面努力，虽然可能做不到数据研究人员那么专业，但也不能落后于时代啊。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"高性能计算","date":"2017-12-17T08:09:44.000Z","path":"2017/12/17/2017-12-17-高性能计算/","text":"我们平时在做业务的时候很少会有性能上的瓶颈，偶尔产生的UI层的卡顿也是我们对程序结构设计的不合理产生的。但是性能优化却是一个好的程序员所应具备的，而且在某些特殊的场景下，我们还要有能力去解决很多极限的性能问题，这里就来聊聊高性能计算方面的问题。 首先我们将这类问题分为两种： 减少计算量 加快单位时间的计算量 减少计算量对于减少计算量来说，大家都是最熟悉的，也是平时碰到的最多的方法。 算法优化最常见的要属算法优化，比如查找算法，用二分法代替顺序查找，排序用快速排序代替冒泡排序。 另一个比较典型的例子就是高斯模糊算法，将一次二维矩阵的乘法转化为两次一维矩阵的乘法，虽然看似改变很小，但是在整个图片的计算量上出入非常的大。以3*3大小的矩阵来看，一次二维矩阵乘法需要9次浮点乘法，而两次一维矩阵仅需要2*3次浮点乘法，如果是6*6的矩阵，这个比例将会达到36/12。 数据结构优化在我们需要更高性能的时候，我们不太可能一个方案能够满足所有的情况，往往需要特定的场景使用特定的方案。 在随机读取远大于随机写入的时候，数组的确是一个好方案，但是如果随机写入远大于随机读取的时候，链表的性能就会优于数组。如果读取和写入都比较频繁，那么树的结构可能会是你的首选，根据所需不同可以采用平衡二叉树，B/B+树，跳跃链表等。 如果需要大量写入磁盘，顺序的读取，比如日志系统这种，那么Google的LevelDB也是一个非常好的选择。 总之，根据需要来选择适合的数据结构也能大量的提升性能。 空间换取时间要知道，很多的计算是重复的，而这些重复的计算可能会消耗我们大量的时间，那么我们在空间充足的情况下，何不缓存这一部分的数据的？ 其实很多的第三方库都使用了这种思想的，索引也可以认为是这种思想。这里举个简单的例子。 在图片处理的过程中，卷积的计算量是非常大的，而乘法占了很大一部分比例。而根据我的了解，ARM在处理乘法的时候，可能需要6个时钟周期，而加法只需要一个，如果能将乘法的结果缓存下来，通过加法访问是不是一种可行的方案呢？一个颜色的色值只有0~255的区间，是一个可以穷举的范围，所以缓存这部分结果，通过偏移量（也就是加法）来访问结果，是否也可以减少计算时间呢。 这种方法一般都会有一个阈值，超过这个阈值之后才会有明显的性能差距，所以在使用之前需要评估好自己的场景是否会处于优化的阈值内。 低等语言实现很多高级语言在实现的时候，会附加一部分高级语言的特性，比如内存回收机制等，越是底层的语言我们越是能够控制其计算量。 极端的例子就是采用汇编方案，这样能够最为极限的控制其性能。当然这样的问题是兼容性问题，需要为多个平台分别写汇编代码。其中OpenCV中的部分计算过程就是采用了汇编语言实现的。 这种方案对于其他高级语言（JAVA，JS等），采用C来实现其底层，或许是个好的尝试。但是使用汇编这种方法虽然有效，但是不太建议，毕竟在晦涩程度和兼容性上考虑，带来的性价比并不高，只有在极少数的特定情况下，才会考虑。 加快单位时间的计算量除了从计算量上来优化，我们还可以通过一些其他手段，包括更优秀的硬件来帮助我们。 并行计算目前的大部分CPU都不是单核的了，包括很多移动设备上的。但是如此高的性能我们往往不能很充分的利用。 在iOS中就有一个适合并发计算的接口dispatch_apply。采用多线程可以最大限度的开发出CPU的潜能。 CPU层面上的浮点计算很多场景下，都是浮点乘法运算消耗了大量的时间，特别是对于ARM系列，但是新型的ARM特别设计了关于浮点及向量的优化（VFP或者称NEON）。 在iOS中，vImage就是利用了这一特性进行了优化，如果有少量的图片运算可以使用vImage来加快我们的速度。 ARM流水线优化ARM系列的CPU一般都有采用流水线的架构，因为每一条指令的执行都需要经过取址-译码-执行这几个步骤，采用流水线架构可以增加执行效率。 但是这也有一个反例，就是在B相关跳转指令的时候，需要清空流水线，重新加载，这也会带来一定的性能损耗。 也就是说： 1234567891011int i = 0; x += i; i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i;i++; x += i; 比 1for (int i = 0; i &lt;= 10; i++) x += i; 效率要高很多。当然这里有点吹毛求疵了，一般情况下我们还是不需要考虑这部分内容的。 GPU其实目前来说，影响最大的莫过于图像的处理，普通的业务慢一点和快一点其实很难分辨出来，也没有必要去如此极限的优化，而图像的计算量之庞大，很容易就可以感觉出来，同时图像处理速度还制约着视频的帧率问题，所以问题的严重程度要高很多。 那么说到图像处理，就不得不涉及到GPU了。目前移动端基本都支持OpenGL2.0或OpenGL3.0，所以如果要跨平台使用可以考虑OpenGL来优化。但是如果只考虑iOS平台，让我们来看看iOS平台有哪些特定的利用GPU进行优化的方案。 GPUImage这是一个利用OpenGL的开源库，是一个跨平台的第三方库，里面封装了很多滤镜，同时也支持图片、视频的处理，对于自定义和扩展也比较方便，是一款非常好用的开源库。 CIContextCore Image是苹果官方提供的一款图像处理库，里面包含了众多的滤镜。其中CIContext可以指定为glContext，就是GPU环境了。一般来说，我们平时开发使用，CIImage已经足够了。 CImage的扩展也非常方便，有一种类似于openGL的GLSL的语言，KLSL。有兴趣的人可以自己去研究研究。 MetalMetal是苹果比较新的一个库，专门为了替代OpenGL而做的，降低了OpenGL的学习成本。 据官方称，加入了众多的优化。其中一个比较明显的就是，将shader的编译过程放到了编译期，而不是运行期，也就是说，比起OpenGL，少了一步glCompileShader。 同时Metal也和iOS的特性结合的比较好，使用起来也比OpenGL简单很多。当然这些都是iOS平台的特性，不支持跨平台。 OpenCL这个是对应于mac系统的，其他系统上也有实现，目前还不支持移动端。 多缓冲FrameBuffer的GPU对于视频这类连续的计算，以上的方案已经非常的优秀了，但是我们还是没有榨干机器的性能。:D 一张图片的处理流程可以表示为上图，CPU需要将数据参数准备好，然后拷贝到GPU内存空间，然后等待GPU执行。GPU执行完之后，需要等待CPU准备好下一张图片的数据并拷贝到GPU空间，在这之间是留了很多的空白时间的。 我们知道OpenGL并不是线程安全的，也就是说GPU空间是可以多线程同时访问的，那么我们可以通过多个缓冲区来解决上述空白时间的问题。 上图就是我们想要达到的效果，而下图是我们采用3个缓冲区，实际上的效果。 最后以上是对高性能计算几种方式的一个简单概括，具体的情况需要根据自己的实际情况来选择。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://djs66256.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"property的系统实现分析","date":"2017-12-08T13:20:51.000Z","path":"2017/12/08/2017-12-09-property的系统实现分析/","text":"我们在使用@property这个快捷定义的时候，都没怎么注意系统是怎么实现的，那么我们来看看系统实现的，和我们自己写的setter方法是否一致呢？ Strong我们来分析一下最简单的strong类型的实现。 1@property (nonatomic, strong) NSString *str; 如果是我们自己写setter方法大概是： 123- (void)setStr:(NSString *)str &#123; _str = str;&#125; 如果是MRC的话，可能是这样的： 123456- (void)setStr:(NSString *)str &#123; if (_str != str) &#123; [_str release]; _str = [str retain]; &#125;&#125; 当然系统的方法是经过优化的，直接调用的C方法，所以这里不再考虑MRC的写法，直接来对比ARC的结果。 store strong首先我们来看下objc是如何实现strong的，根据objc的源码可以知道，强引用是通过一个objc_storeStrong的方法来实现的。其实现入下： 12345678910void objc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); *location = obj; objc_release(prev);&#125; 这和我们上面MRC的写法类似，只不过是通过C方法来实现了retain和release。 转换为C语言大家都知道objc的方法其实都是通过send message的方式转换为C语言调用的，所以一个基本的setter方法的最终结果应该是这样的： 1void setter(id self, SEL selector, NSString *str); 具体实现根据反汇编结果，其中系统默认的实现汇编如下： 12345678910111213141516171819sub sp, sp, #0x30 ; 申请栈空间stp x29, x30, [sp, #0x20]add x29, sp, #0x20 adrp x8, 17add x8, x8, #0xfc0 stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x2, [sp, #0x8]ldr x0, [sp, #0x8]ldur x1, [x29, #-0x8] ; x1 = selfldrsw x8, [x8] ; 偏移量add x8, x1, x8 ; x8 = self + 偏移量str x0, [sp] mov x0, x8 ; x0 = x8ldr x1, [sp] ; x1 = strbl 0x1000bcad8 ; objc_storeStrong(self + 偏移量, str)ldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; 退栈ret 翻译为C语言大概就是这样的： 123void setStr(id self, SEL sel, NSString *str) &#123; objc_storeStrong(self + delta, str);&#125; 而我们自定义的setter方法 123- (void)setStr:(NSString *)str &#123; _str = str;&#125; 的反汇编结果却比系统的结果多出一些函数调用 12345678910111213141516171819202122232425262728sub sp, sp, #0x30 ; =0x30stp x29, x30, [sp, #0x20]add x29, sp, #0x20 ; =0x20add x8, sp, #0x8 ; =0x8mov x9, #0x0 ; stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x9, [sp, #0x8]mov x0, x8mov x1, x2bl 0x104d14ad8 ; symbol stub for: objc_storeStrongadrp x8, 17add x8, x8, #0xfc8 ; =0xfc8ldr x9, [sp, #0x8]ldur x0, [x29, #-0x8]ldrsw x8, [x8]add x8, x0, x8mov x0, x8mov x1, x9bl 0x104d14ad8 ; symbol stub for: objc_storeStrongmov x8, #0x0add x9, sp, #0x8 ; =0x8mov x0, x9mov x1, x8bl 0x104d14ad8 ; symbol stub for: objc_storeStrongldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; =0x30ret 翻译成C语言大概是这样的： 123456void setStr(id self, SEL sel, NSString *str) &#123; id tmp = nil; objc_storeStrong(&amp;tmp, str); objc_storeStrong(self + delta, tmp); objc_storeString(&amp;tmp, nil);&#125; 可以看到这里多出一个临时变量，而且即使编译优化为-os，也是同样的结果。这里不清楚为什么会产生一次临时变量，从结果上来看，是不如系统的默认行为的。 Weak在objc的源码中，weak是通过objc_storeWeak来实现的，这个方法的实现比较复杂，涉及到了全局的弱引用表，这里就不作介绍了。 同样，我们来对比下系统默认实现的weak类型，和我们重写的setter方法，从结果上来看也是产生了一个strong类型的临时变量。 1234567891011121314151617181920sub sp, sp, #0x40 ; =0x40stp x29, x30, [sp, #0x30]add x29, sp, #0x30 ; =0x30adrp x8, 17add x8, x8, #0xfd0 ; =0xfd0stur x0, [x29, #-0x8]stur x1, [x29, #-0x10]str x2, [sp, #0x18]ldr x0, [sp, #0x18]ldur x1, [x29, #-0x8]ldrsw x8, [x8]add x8, x1, x8str x0, [sp, #0x10]mov x0, x8ldr x1, [sp, #0x10]bl 0x104f38ae4 ; symbol stub for: objc_storeWeakstr x0, [sp, #0x8]ldp x29, x30, [sp, #0x30]add sp, sp, #0x40 ; =0x40ret 1234567891011121314151617181920212223242526272829sub sp, sp, #0x30 ; =0x30stp x29, x30, [sp, #0x20]add x29, sp, #0x20 ; =0x20add x8, sp, #0x8 ; =0x8mov x9, #0x0stur x0, [x29, #-0x8]str x1, [sp, #0x10]str x9, [sp, #0x8]mov x0, x8mov x1, x2bl 0x1044d8ad8 ; symbol stub for: objc_storeStrongadrp x8, 17add x8, x8, #0xfc8 ; =0xfc8ldr x9, [sp, #0x8]ldur x0, [x29, #-0x8]ldrsw x8, [x8]add x8, x0, x8mov x0, x8mov x1, x9bl 0x1044d8ae4 ; symbol stub for: objc_storeWeakmov x8, #0x0add x9, sp, #0x8 ; =0x8str x0, [sp]mov x0, x9mov x1, x8bl 0x1044d8ad8 ; symbol stub for: objc_storeStrongldp x29, x30, [sp, #0x20]add sp, sp, #0x30 ; =0x30ret","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"property","slug":"property","permalink":"http://djs66256.github.io/tags/property/"}]},{"title":"数据埋点与视图控件的反馈式定位","date":"2017-12-07T13:42:49.000Z","path":"2017/12/07/2017-12-07-数据埋点与视图的反馈式定位/","text":"我们想要做一个插件，能够直接在界面上就能显示该页面和该事件的pv和uv（据说淘宝就有这种功能），那么就必须将埋点数据和控件进行一一对应。然而我们是行为埋点，很多东西并不会直接绑定控件，所以如果要做这种效果则必然需要对埋点架构进行重新设计，所以这里采用了一个小技巧，来实现大部分控件与埋点的绑定。 埋点方案一般来说，数据埋点可以分为两种。自动化埋点和手动埋点，各有各的好处和缺点。 自动化埋点一般来说，自动化埋点都是依据界面层次结构或者控件标签等来进行区分与标记的。 这种方式的好处是避免了大量人工埋点带来的繁琐和错误，也减少了代码的复杂度，同时又保证了非常详细的用户行为。 但是这种方式的缺点也是比较明显，对于功能不是那么稳定的情况下，埋点标记可能会经常变动，不易于后期的统计。同时这种方式对于埋点数据的整理也比较麻烦，可能就需要借助开篇所说的工具来获取。同时对于一些需要数据参数的场景，可能需要人为或者特殊场景下的处理。这种方式对于一个复杂的交互动作，则不能很好的统计，需要后期根据多个连续的统计点来确定一个动作。 对于这种方案的一个优化建议是，限制其自动采集的范畴，弱化和简化其全局性的采集，将自动化限制在一个特点的范围内或者框架内，这样会减少很多的垃圾数据以及更加精准的采集。这种方式就急需要一种工具来整理和归纳埋点数据了。 手动行为埋点手动行为埋点不需要任何的标记或者swizzle，是非常简单与灵活的一种，在需要的地方，比如事件触发的地方，加入埋点就可以了。但这也存在非常大的问题。 埋点数据的整理，随着时间的推进，数据将是非常庞大与混乱的。 代码的侵入性，可能会在代码的很多地方都充满着这种恶性的统计代码，导致难以重用以及难以抽离成组件。 维护性低，经历多个版本以及多个人员的迭代，维护会越来越困难，可能会出现埋点数据错误的情况，而且无法对线上的数据进行修复。 插件需求以上的两种方案各有优劣，自动埋点可以直接将控件和埋点绑定，那么我们就很容易的可以将一个页面上所有的埋点给“扫描出来”，并且标记出各个控件，个人猜想阿里的方案就是这样的。 但是由于我们的项目变动较大，界面也不稳定，所以采用的是手动行为埋点的方案，那么事实上控件与埋点是完全独立的，也就不能“扫描出来”。我们也不可能对目前埋点方案进行如此大规模的重构，那么如何将控件与埋点进行绑定呢？这里用到一个小技巧。 首先我们分析我们的场景： 大部分埋点都是在点击后才触发的。 点击，和埋点触发是顺序关系，且这中间一般不会有其他的点击操作了，也就是说可以认为是同步关系。 这种场景满足了我们90%以上的需求，也就是很少有比这种更加复杂的埋点了。 那么我们可以想到首先记录点击的控件，然后观察埋点数据，如果产生顺序的关系，那么我们就可以认为两者是绑定关系。那么我们就可以通过一次自己的点击来获取该控件的埋点信息了。 思路 hook UIWindow的hitTest方法，将得到的视图记录下来。 在埋点方法中增加监听点，等待用户点击触发埋点。 将最近的两者绑定起来，可以使用弱引用表来保存，以防内存泄露。 这里需要注意的几个问题是埋点要过滤掉一些比较常见的非点击事件，来避免出现很多的误判。 在UICollectionView和UITableView中会比较特殊，为了避免reuse view给我们的视图绑定带来错误的结果，需要hook - prepareForReuse，在这里移除绑定关系。 有些点击可能会打开新的页面，那么我们也可以增加一个锁定页面跳转的功能，hook Controller的push和present方法成为空操作，就可以禁用跳转了。重新恢复也很简单，再次swizzle就可以替换回来了。 最后这种方法简单对目前的代码结构几乎没有影响，虽然有可能出现部分误判的情况，但作为一个debug的测试工具已经足够了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"埋点","slug":"埋点","permalink":"http://djs66256.github.io/tags/%E5%9F%8B%E7%82%B9/"}]},{"title":"讨论Gif的一些问题","date":"2017-11-19T08:58:45.000Z","path":"2017/11/19/2017-11-19-讨论Gif的一些问题/","text":"gif是我们平时非常常见的图片格式，同时也是一种非常古老的动画图片格式。在我们平时使用的过程中也会有相应的问题，这里我们来看看Gif所带来的一些问题以及解决方式。 压缩率gif的压缩率其实是非常低的，一小段动画图片远比一般的视频格式要大很多。 这里我分别对gif以及h264编码的视频进行对比 Gif 视频 496KB 192KB 4.4MB 1.4MB 由此可见两者之间的差距还是非常大的。 内存占用如果你使用的是UIImage自身的animatedImage来展示Gif，那将是会非常恐怖的。假设我们有一个100帧400*300的Gif，那么我们完全解析成位图放在内存中将是100*400*300*4 = 45MB。而目前主流的设备分辨率都在1080级别的了，所以如果遇到了非常大的gif图，这种方式肯定是承受不住的。 目前处理gif比较有名的开源库是FLAnimatedImage。但是在内存占用过高的时候，不会缓存所有帧，有需要的时候再去载入，如果播放速度和载入速度不能匹配，那么就会丢弃该帧，导致掉帧的现象发生。这种方案对于帧数多，但是像素低的图片比较好，如果是非常大的图片，那么这种方案的效果不会特别好。 新的方案基于以上的分析，这里提出一种新的方案，来解决大型gif的播放问题。那就是将gif转换为视频格式，由于视频播放是由系统优化的，所以不会产生性能方面的问题。这里来简单描述下。 gif由ImageIO来实现读取操作，视频采用AVFoundation来实现写入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162AVAssetWriter *assertWriter = [[AVAssetWriter alloc] initWithURL:url fileType:AVFileTypeMPEG4 error:nil];NSDictionary *writerSettings = @&#123; AVVideoCodecKey: AVVideoCodecTypeH264, AVVideoWidthKey: @(gif.width), AVVideoHeightKey: @(gif.height) &#125;;AVAssetWriterInput *writerInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writerSettings];[assertWriter addInput:writerInput];NSDictionary *pixelBufferAttributes = @&#123; (id)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA), (id)kCVPixelBufferWidthKey: @(gif.width), (id)kCVPixelBufferHeightKey: @(gif.height) &#125;;AVAssetWriterInputPixelBufferAdaptor *writerInputAdaptor = [[AVAssetWriterInputPixelBufferAdaptor alloc] initWithAssetWriterInput:writerInput sourcePixelBufferAttributes:pixelBufferAttributes];NSEnumerator&lt;CIImage *&gt; *enumerator = gif.CIImageEnumerator;CIContext *ctx = [CIContext contextWithOptions:@&#123; kCIContextPriorityRequestLow: @YES &#125;];double frameHZ = gif.delayTime == 0 ? 10 : 1/gif.delayTime;__block CMTime time = CMTimeMake(0, frameHZ);CMTime frameTime = CMTimeMake(1, frameHZ);NSInteger loopCount = gif.loopCount;if ([assertWriter startWriting]) &#123; [assertWriter startSessionAtSourceTime:time]; [writerInput requestMediaDataWhenReadyOnQueue:dispatch_get_global_queue(0, DISPATCH_QUEUE_PRIORITY_DEFAULT) usingBlock:^&#123; while (writerInput.isReadyForMoreMediaData) &#123; CIImage *ciImage = [enumerator nextObject]; if (ciImage == nil) &#123; [writerInput markAsFinished]; [assertWriter finishWritingWithCompletionHandler:^&#123; [[DDVideoCache defaultCache] setLoopCount:loopCount forKey:name]; DDVideoData *video = [[DDVideoData alloc] initWithPath:path]; complete(video); &#125;]; return ; &#125; CVPixelBufferRef pixelBuffer; CVReturn ret = CVPixelBufferPoolCreatePixelBuffer(NULL, writerInputAdaptor.pixelBufferPool, &amp;pixelBuffer); if (ret != kCVReturnSuccess) &#123; DDDebugInfo(@&quot;[Error] CVPixelBuffer create error with code (%zd)!&quot;, ret); complete(nil); if (pixelBuffer) CVPixelBufferRelease(pixelBuffer); return; &#125; if (pixelBuffer) &#123; [ctx render:ciImage toCVPixelBuffer:pixelBuffer]; if (![writerInputAdaptor appendPixelBuffer:pixelBuffer withPresentationTime:time]) &#123; DDDebugInfo(@&quot;[Error] Assert write error!&quot;); complete(nil); CVPixelBufferRelease(pixelBuffer); return; &#125; CVPixelBufferRelease(pixelBuffer); time = CMTimeAdd(time, frameTime); &#125; &#125; &#125;];&#125; 这里使用CIImage来实现图片的转换，如果需要裁剪缩放，或者其他滤镜处理，都可以在这里处理。 这种方案有一个缺点，那就是转换过程比较花时间，需要一定的转换时间，那么我们就需要缓存转换后的视频文件。 这种方案可以处理非常大型的gif文件，但仅仅是一种退而求其次的方法，如果是小型gif文件，完全没有必要使用这样的方法。这里只是提出一种优化的思考方式。 这里我实现了一套简单的带有缓存的方案，具体参考DDGif2Video。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"gif","slug":"gif","permalink":"http://djs66256.github.io/tags/gif/"}]},{"title":"浅析GPUImage的设计思想","date":"2017-10-31T14:32:34.000Z","path":"2017/10/31/2017-10-31-浅析GPUImage的设计思想/","text":"在移动端图片处理时，往往因为大量的计算导致需要较长的时间，为了充分利用设备的潜能，所以产生了利用GPU来处理计算的方案。其中最有名的开源方案就是GPUImage。 结构GPUImage的设计思路参考了流式的结构，所有东西都被概括为input或者output，其中最重要的filter则既是input也是output。这样设计统一了整个流程，但让整个结构变的更加死板和复杂。大概的流程如下： 1Image &gt;&gt; Input &gt;&gt; Filter_1 &gt;&gt; Filter_2 &gt;&gt; Filter_x &gt;&gt; Output 当存在多个Filter的时候，整个结构上就会变的比较难以理解，所以个人认为，需要分开的结构还是分开比较好： 1234Image &gt;&gt; Dispatch &gt;&gt; Output / \\ / \\ Filter_1 ... Filter_x 性能优化GPUImage自身在设计的时候就考虑到了优化，所以有些时候你可能会感觉某些结构上有些奇怪。 比如GPU内存申请基本上是在输入端就创建好了，在Filter中是不会新申请内存的，都是重用了开始就申请好的内存，除非改变了画布大小。 Filter最好进行重用，因为OpenGL es首先需要利用CPU将GLSL编译为GPU可执行的代码，最好的情况是能够重用这部分已经编译完成的代码。 当我们利用GPUImage来处理图片时，一般不会有什么性能问题，但是如果我们利用他来处理视频时，就需要考虑到极限下的性能问题。我们来模拟下多个Filter情况下的GPU处理1帧的情景： 123Image &gt;&gt; Input &gt;&gt; Filter_1 &gt;&gt; Filter_x &gt;&gt; Output / \\ Prepare(CPU) &gt;&gt; Process(GPU) 可以看到每个Filter之间是同步执行的，所以无法很好的利用CPU多线程的能力。理想状况下应该是这样： 12345Image &gt;&gt; Input &gt;&gt; Filter_1 ... Filter_x | | Prepare(CPU) &gt;&gt; Prepare(CPU) | | Progress(GPU) &gt;&gt; Processor(GPU) &gt;&gt; Output 这样就可以将串行执行改为CPU和GPU并发执行，不过GPUImage目前无法改造为这样的结构。 OpenGL es目前iOS平台支持的GPU平台编码主要有2种方式，一种是OpenGL es，另一种就是Metal。按照官方说法，Metal的性能会比OpenGL更好，好像是因为在编译期就进行了一次初期编码，将代码转化为一种类似于bitcode一样的中间码。 OpenGL的基本流程如下： 12345CPU: 创建FrameBuffer + GLSL | drawGPU: main() | readPixelCPU read to RAM GLSL想要了解GPUImage就必须先学会使用OpenGL，那么就离不开学习GLSL，如果你使用CIImage，你也可能会需要KISL，是GLSL的一种子集。 GLSL并不复杂，是一种非常类似于C语言的DSL，但是要与程序进行交互则会变得麻烦。 总结要实现自己的Filter，则首先需要学习OpenGL以及GLSL，这是一个比较大的障碍点。 如果仅仅是为了图片处理，那么GPUImage已经足够了。如果你需要高分辨率高帧率的视频渲染，GPUImage可能就满足不了你，优化思路是并发和利用空间去换取时间。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"GPUImage","slug":"GPUImage","permalink":"http://djs66256.github.io/tags/GPUImage/"},{"name":"OpenGL es","slug":"OpenGL-es","permalink":"http://djs66256.github.io/tags/OpenGL-es/"}]},{"title":"被滥用的category","date":"2017-10-10T17:26:16.000Z","path":"2017/10/11/2017-10-11-被滥用的category/","text":"objc的最大一个特性就是动态性，利用动态特性，我们可以做很多事情，包括对已有的类和对象添加替换方面属性。但是这也给我们带来了一些隐藏的风险，以及让人很不愉快的一些体验。 绝对不能做的事情假如我们定义一个category，如下面： 12345678@interface UIView (My)@end@implementation UIView (My)- (void)setFrame:(CGRect)frame &#123;&#125;@end 那么会发生什么事情？ 系统方法会被替换。这是什么原因呢？是因为主类被先加载，然后才会去加载category，然后会导致原来的方法被替换。 那么我们是不是可以利用这种特性来屏蔽一些我们不能修改的类的方法呢？答案是绝对不能这么做。首先，我们替换了方法，可能会导致一些未知的问题。其次，这种替换是不能保证顺序的，在另一个地方也做了这样的处理，我们无法预知最后是哪一个方法。 所以我们绝对不能使用category来替换原有的方法，真的要替换可以使用method_exchange。 隐藏的风险有些时候在使用category给第三方类增加方法时，也有可能不小心替换了原有的私有方法，从而导致了一些未知的问题。所以也就是为什么大家提倡在方法名前面增加扩展，以最大可能的避免重名。 理解性下降越多的扩展就会引入越多的概念，很多api并非系统api，可能会产生一些意义相近，但是有细微区别的情况，这些都会对我们的理解产生不好的影响。 当我们大量引入这类文件的时候，会产生一大串扩展的方法。特别是当我们把这类util方法作为pch文件全局引入的时候。 性能降低越多的category，会让一个类的方法变多，使方法调用所产生开销也会越大，缓存命中失效的概率也会变大。虽然这些多余的开销微不足道，但是在比较常用的对象上，比如UIView，就会累积。当然这些性能都不是问题。 丑陋的api方法名前加前缀的确是一种解决方案，至少尽可能的减少了冲突的可能，但并不代表不会冲突。 然而这种api却是极其丑陋。 12- (id)my_property;- (void)my_setProperty; 同时这种api使用KeyPath也会非常的麻烦。 甚至可能会出现这样的情况，大家都为同一个功能添加了一个方法： 123- (CGFloat)my_height;- (CGFloat)daniel_height;- (CGFloat)jack_height; 改善那么我们就要讨论如何改善这种情况了。 第三方帮助类这种方式可以说是最优雅的，虽然有点破坏面向对象。 其中系统就提供了几种关于frame的帮助方法： 12CGRectGetHeight()CGRectGetMaxY() 其中React Native中应用了比较多的转换类： 12[Convert stringValue:obj];[Convert integerValue:obj]; 这样就避免了在原有类中添加方法了。实际情况是，很多场景我们也不应该把这些方法加入到扩展中，因为从逻辑上来说，某些方法也不应该出现在这个类中，我们不要单纯的因为方便给一个内容引入太多概念。 属性扩展另一种方式是通过第三方对象转换到自身的方法。比如上面height属性可以改为： 123view.my.heightview.daniel.heightview.jack.height 这样也会带来一些优点，比如可以按照功能设计不同的第三方对象： 12obj.convertor.stringValue()obj.builder.string(@&quot;a&quot;).integer(1) 同时这样做还有一个好处就是可以动态的替换第三方转换对象，从而实现更灵活的控制： 12345protocol Convertable &#123; stringValue()&#125;date.convertor.stringValue() 只要我们把上面的convertor替换掉，就可以更换时间的format方式了。 这样做的缺点是增加了一个对象的生成，但这并不会产生太多的负面影响。 保持私有化如果你真的需要使用扩展方法，那么尽量的保持这类方法的私有化，特别是对一些第三方库来说。 然后通过import来部分载入我们所需要的方法。如果一开始就让这些方法暴露在外，那么会形成比较恶性的情况。 比如我们在NSObject上添加了一个关于model的方法，然而我们在UIView上也将会看到，并可以使用了，我们需要尽量去避免这样的设计。 最后说了这么多，是想建议第三方库的作者不要仅仅为了方便从而滥用category，好好的思考如何才能更好的表达意义。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"category","slug":"category","permalink":"http://djs66256.github.io/tags/category/"}]},{"title":"自定义KVO的一些错误使用方式","date":"2017-10-04T12:51:23.000Z","path":"2017/10/04/2017-10-04-KVO的一些错误使用方式/","text":"很多时候我们讲KVO，使用的时候需要注意移除监听，循环引用等问题，但是在自定义KVO的时候，却容易忽视几个问题。 12345678910111213141516171819202122232425@interface KVOObject : NSObject@property (strong, nonatomic) NSString *a;@property (strong, nonatomic) NSString *b;@property (strong, nonatomic) NSString *c;@end@implementation KVOObject@dynamic c;- (void)setB:(NSString *)b &#123; &#125;- (void)setC:(NSString *)c &#123; [self willChangeValueForKey:@&quot;c&quot;]; [self didChangeValueForKey:@&quot;c&quot;];&#125;- (NSString *)c &#123; return nil;&#125;@end 如果是上述对象，分别对a,b,c监听，其结果是怎么样的呢？ 结果是a是正常的，b触发一次，但是其变化的结果都是nil，c触发2次，其结果都是nil。我们来分析下这样的结果吧。 首先，系统KVO的实现是什么？是自动创建一个虚拟对象，并重写set方法，那么这就和这个属性是不是真的存在实现（比如空，或者associate object）无关了。所以当我们再次去调用willChangeValueForKey和didChangeValueForKey就产生了2次调用，很多在set方法中再次重申变化是一个错误。 那么我们什么时候需要用到这两个方法呢？当在非set方法里面，通过非set方法变更了属性的值时，就需要手动去触发了。这包括了self-&gt;_a这样的调用。 然后，KVO变化的值是怎么取出来的呢？依据willChangeValueForKey的接口来看，并没有传入值的参数，那么显而易见，值是从get方法中取出来的。所以如果set和get方法不是对称的，比如- (id)c所返回的并不是对应c的内容，可能就会出现一些问题，变化的时候并没有触发KVO，触发KVO的时候内容并没有变化。 以上两个在平时碰到的应该比较少，比较自己自定义KVO的场景就比较少。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"KVO","slug":"KVO","permalink":"http://djs66256.github.io/tags/KVO/"}]},{"title":"内存循环引用算法","date":"2017-09-30T13:28:56.000Z","path":"2017/09/30/2017-09-30-内存循环引用算法/","text":"平时我们最容易犯的一个错误就是循环引用，而且难以察觉，而FBRetainCycleDetector则是专门在运行期来检查循环引用，那我们来看看他是怎么做到的。 开始首先，我们来看看在arc环境下，什么时候会发生强引用。 自身属性，被定义为strong类型的变量，都会产生一次强引用。 associate object，被定义为retain类型的也会被强引用。 block，在被闭包捕获的时候，strong类型对象也会被强引用。 特殊对象，比如NSTimer的target，集合类型的addObject。 associate object如何记录associate object的持有情况呢？这里要说一下C语言的hook，也就是在链接的时候替换掉objc_setAssociatedObject方法，然后记录源对象和持有对象。关于hook可以参考fishhook这个库。 propertyobjc的对象会有自身的布局记录（layout），取出每个类中的Ivar的属性，就可以知道哪些属性是强引用的，也就可以知道每个对象所持有的对象了。 block和property一样，每个block也是有对应的layout的。 其他其他一些特殊情况，则需要特殊考虑，细节这里就不说明了。 算法首先，我们将每个需要检测的对象视作一颗颗树，叶子是每个强引用的对象。 作者使用了堆栈来替换递归实现路径点的查找，基本原理是： 1234567891011121314151617181920212223242526// 堆栈用于保存所遍历过的路径NSMutableArray&lt;FBNodeEnumerator *&gt; *stack = [NSMutableArray new];// 集合用于保存该路径上的所有对象，用于判断是否有对象相等，也就是循环引用了。NSMutableSet&lt;FBNodeEnumerator *&gt; *objectsOnPath = [NSMutableSet new];// ...while ([stack count] &gt; 0) &#123; // ... if ([objectsOnPath containsObject:firstAdjacent]) &#123; // 发现循环引用并记录 ... &#125; else &#123; // ... shouldPushToStack = YES; &#125; [objectsOnPath addObject:top]; // 如果没有发现循环引用，则查找其子节点，并push进堆栈 if (shouldPushToStack) &#123; if ([stack count] &lt; stackDepth) &#123; [stack addObject:firstAdjacent]; &#125; &#125; else &#123; // 如果已经没有子节点了，就退出堆栈，开始判定父节点的下一个节点 [stack removeLastObject]; [objectsOnPath removeObject:top]; &#125;&#125; 算法其实很简单，源码也就100行以内。 最后这种方式给予我们一种能够在运行时检查循环引用的方法，但是这并不代表完全正确，比如CFArray，NSHashMap我们就无法判断子元素的引用情况。还有一些虽然形成了循环引用，但在整个流程的结尾，是必定会解除的，会形成误判。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"FBRetainCycleDetector","slug":"FBRetainCycleDetector","permalink":"http://djs66256.github.io/tags/FBRetainCycleDetector/"}]},{"title":"操作符重载和隐式转换的思考","date":"2017-09-29T08:10:11.000Z","path":"2017/09/29/2017-09-29-操作符重载和隐式转换/","text":"从刚开始工作的时候，就有很多人批判C++的操作符重载和隐式转换，我也是一直坚持显式调用的，但是最近看了一些C++相关的库后，发现其实这两者并没有那么的恐怖，反而在某些方面是一颗近乎完美的银弹！ 在iOS开发中有一个描述算法的NSPredicate，关于这个类的使用方式，就相当的复杂。 在sql中，有些很复杂的判断逻辑，比如a &gt; b AND a &lt; 100之类的，但是这些并没有严格的类型限制，如果a是一个时间类型，那么&lt; 100这个条件可能就是一个无效或者未知行为。虽然可以在运行的时候发现这个问题，但却不能在编译期就发现这样的问题。而C++就能很好的解决上面的问题，有严格的类型判定，以及一些类型转换。 在Objc中，有太多的api都非常的啰嗦，虽然说好听点能够表意，但很多时候简单的事情都会让代码非常的复杂。比如： 12[string stringByAppendingString:@&quot;string&quot;];[a isEqualToString:b]; 而我们默认的几种方式并不会产生任何认知上的歧义： 12string + &quot;&quot;;a == b; 在现在很多的计算并不是在CPU中执行的，而是需要放到GPU中执行，比如机器学习、渲染图片。那么如何定义GPU中的运算方式呢？著名的OpenGL就定义了自己的一套GLSL语言，iOS的CIImage也定义了一套类似的语言。但是这些都有同样的问题，那就是运行期进行编译和执行，依然不能在编译器发现问题。那么如果要放到编译期就必然需要利用语言的特性了，最简单的一个向量运算如果不能重载操作符，那么描述一个最简单的运算vec2 = vec1 * 2 + 2也将是灾难性的。 所以，在某些场合下，利用这样的特性是非常方便而且对代码的可读性也有提高。 iOS中就有部分库是利用这样的特性，比如realm和wcdb。 当然这里说的优势并不代表没有劣势，但是利用好这种特性也能给可读性带来更高的提升。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://djs66256.github.io/tags/C/"}]},{"title":"navigation-bar的黑魔法","date":"2017-09-26T17:31:39.000Z","path":"2017/09/27/2017-09-27-navigation-bar的黑魔法/","text":"平时我们在处理页面跳转的时候有一个非常难受的情景，就是当两个页面的导航栏背景色不一致的时候，系统不能很好的处理这两者间的交互动画，这就导致整个导航栏的背景转换非常的生硬，那么这里就来看看现在的一些主流的处理方式。 自定义navigationBar在每个Controller的内部自己实现一个navigation bar，来替代系统UINavigationController的bar。 这种方式最简单直接，也不需要考虑太多的兼容措施和特殊情况。但是这种方式太繁琐，同时和系统的特性相差比较多，不太利于以后的移植和扩展。 要简化这种方式可以定义一个基类，包含实现navigationBar，其他都继承于该基类: 123@interface BaseViewController: UIViewController@property (readonly, strong, nonatomic) UINavigationBar *navigationBar;@end 转换NavigationBar的background像微信这种，导航栏的按钮等动效还是和系统一致，但是背景动效却是跟随页面的。其实是伪装了部分navigationBar。 12345678\\----------------\\ \\ navigation bar \\ \\----------------\\\\------------------------\\ \\ navigation bacckground \\ \\------------------------\\ \\ view \\ \\------------------------\\ 在每次设置navigation background相关属性的时候，自动为其转入到一个第三方的background view中实现。而系统的navigation bar永远是透明的，所以看到的永远是在下面的假的背景。这里要注意的是，需要将这个background永远放在最上层的视图。 这里background有两种方式实现，比如微信，是直接生成一个UINavigationBar，而有些库则是截屏然后渲染为image对象来展示。不管哪种方式，其思想都是一致的。 这种方式和第一种方式类似，只是将部分（背景）放到了view中实现，这种方式既符合了系统的编写方式，又简化了实现的方式，是一种比较好的方式。甚至可以两者结合起来，设置背景的时候不要调用self.navigationController.navigationBar，而调用上面的self.navigationBar。 多层嵌套NavigationController上面的方式都是制造了一个假的navigationBar来解决这类问题，这个方式是完全的使用系统特性来解决这个问题，比如云音乐就是这样的。 既然UINavigationController自带navigationBar，那么我们为什么不利用这个特性呢。我们每次push进去的不是一个单纯的UIViewController，而是一个UINavigationController。 1234- (void)pushViewController:(UIViewController *)controller animated:(BOOL)animated &#123; UINavigationController *navi = [[UINavigationController alloc] initWithRootController:controller]; [super pushViewController:navi animated:animated];&#125; 这样我们虽然使用的是系统方式，然而我们push进去的是一个UINavigationController。 这种方式所得到的navigation bar是真正的系统特性，无需做任何的适配。但这种方式也给整个结构带来了破坏，这里来说说： push进去的是一个controller，而从self.navigationController.viewControllers中取出来的却并不一致，也就产生了api含义的不对称性。如果你要判断上一个Controller是什么页面就会比较麻烦了。当然这种不对称性可以通过重写方法来解决，但还是在使用者无感知的情况下，破坏了其整体结构： 12345- (NSArray *)viewControllers &#123; return [[super viewControllers] map:^(UINavigationController *navi)&#123; return navi.rootController; &#125;];&#125; 总结就以上几种方式来看，本人更倾向于第二种方式，既按照系统的特性来，有避免了改动系统结构，对系统api的含义转换我还是比较谨慎的，副作用会让人感到疑惑和难以察觉。 如果你还有其他的方式，可以告诉我。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"navigationBar","slug":"navigationBar","permalink":"http://djs66256.github.io/tags/navigationBar/"}]},{"title":"数据存储的一些思考","date":"2017-09-09T13:49:43.000Z","path":"2017/09/09/2017-09-09-数据存储的一些思考/","text":"上篇主要讲述了我们在平时iOS开发中常见的一些缓存及其区别，虽然这已经满足了绝大多数的场景，但是当我们遇到特殊场景的时候，又该如何呢。 缓存策略一般来说，客户端使用LRU的缓存策略就已经足够，但是在特定场合就不是那么适用了。比如淘宝每秒百万级别的查询，如果使用LRU，那么可能有些热门商品就会被清理出缓存，从而得不偿失了。 First In First Out (FIFO) Last In First Out (LIFO) Least Recently Used (LRU) Time aware Least Recently Used (TLRU)拥有过期时间的LRU，常见的比如http缓存 Most Recently Used (MRU) Random Replacement (RR) Segmented LRU (SLRU) Least-Frequently Used (LFU) Least Frequent Recently Used (LFRU) LFU with Dynamic Aging (LFUDA) 如果真的有如此特殊的场景，就需要我们去选择最优的策略来保证缓存的命中率了。 memory map其中很多方案都提到了内存映射的技术。 内存映射会少去很多的解析编码、内存拷贝操作，所以性能上会优于普通的文件读写。 但是内存映射本身就存在一些缺陷，比如32/64操作系统的兼容性，大端小端的兼容性，字节对齐问题。所以并不是任何情况下都适合使用内存映射。如果需要保证兼容性，则需要在设计的时候就要考虑到这样的问题。 搜索优化作为数据存储最频繁的当然是查询功能，那么如何保证查询的性能呢，那么就涉及到索引了。 操作系统本身的文件系统就带有B/B+数所做的索引，所以我们在目录下查找一个文件其实是很快的，就算这个文件夹下内容非常的多。所以一般情况下我们并不需要为文件系统做额外的索引优化。 如果是内存中的缓存，那么使用hash表是最通用的一种方式了。如果是数组则要考虑好承载能力了，少量的数据可能没有问题，当数量到达一定程度后就会暴露出来。这时候可以使用自平衡二叉树、B树、跳跃链表等来做优化了。 sqlite是我们使用最多的一种数据存储方式，提升sqlite搜索速度的方式就是对某列增加索引，具体需要根据具体情况来分析。默认的sqlite索引是B树，也可以配置为R树索引，在坐标数据库表可能会表现更优秀。 存储格式数据的存储格式也是非常关键的一个部分。 像UserDefault这种全量更新的方式，在单一数据变化的时候就需要全部重新序列化并且全部保存，所以如果拥有大量数据或者数据非常庞大的时候，就会变得效率低下。 像ImageCache这种按照单文件保存，如果是小数据，每次都需要去读磁盘，反而效率会降低。由于磁盘的读取和写入并不是单字节的，都是按块读写是最有效率的，所以多个小数据可以一次性读取和写入。 如果是像sqlite那样按照chunk来局部更新文件，则需要非常小心的处理每个数据存储模块，同时也要非常小心处理多线程的问题。另外也需要添加索引来确保效率。 如果是随机读为主的情况下，sqlite能够完成这个任务，但是如果是以写为主，那么sqlite就可能出现性能问题（虽然按照移动客户端来说不太可能有这么大的写的需求）。 最后如何去选择缓存和存储方案，还是需要根据实际情况，通常一个通用的方案已经足够，但是在某些特殊场景还是需要我们去自己设计这一套方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"http://djs66256.github.io/tags/Cache/"},{"name":"数据库","slug":"数据库","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"realm","slug":"realm","permalink":"http://djs66256.github.io/tags/realm/"},{"name":"leveldb","slug":"leveldb","permalink":"http://djs66256.github.io/tags/leveldb/"}]},{"title":"选择你所需要的缓存","date":"2017-08-30T10:02:24.000Z","path":"2017/08/30/2017-08-30-选择你所需要的缓存/","text":"我们在处理数据的时候，第一步就会接触到缓存。这里就来看看应该选择什么样的缓存来解决你的问题。 在一般的场景下，我们并不会去考虑缓存的所带来的优化与损耗，因为大部分场景这一点损耗都可以忽略不计，但是在某些极限情况下，这就不能被忽略了。那么我们就需要来思考采用什么样的方式去缓存数据。 首先，缓存可以被分为两类： 内存缓存 磁盘缓存，也可以称为持久化 那么我们按照这两者来分析下，现在比较流行的几种方式。 Memory CacheNSCache官方提供的缓存一般来说已经足够使用了，线程安全，功能也特别完善，拥有灵活的控制，在内存不足时也会回收内存。底层应该是基于hash表的，所以性能表现也十分优秀。 但是系统实现的缓存失效策略却是未知的，无法保证是LRU策略。同时NSCache会在系统回到后台的时候清空缓存，如果你希望在app的生命周期内都可以缓存，那么NSCache难以做到。 一般来说NSCache是首选，除非需要一些特殊的要求。 NSArray &amp; NSDictionary这两者是系统内置集合类型，可以用作缓存数据，但是是非线程安全的，在使用中需要特别小心，同时需要自己去控制缓存失效。 在数据量比较小的时候，这两者都是没有问题的，但是在数据量变得庞大的时候就会有一定的性能问题。 由于NSArray是数组实现，位置查找的效率为1，内容查找的效率为n，所以在大量频繁的内容查找中，会降低其性能。这时候推荐NSSet或者NSOrderedSet来替代NSArray。NSSet的底层是hash表。 在使用hash表的时候，如何来更好的实现其查找性能呢，就需要保持key的hash随机分布。一般来说我们都会使用string作为key，在自己实现的key值别忘了重写hash。 在某些情境下，使用集合类型也非常有效。 其他也可以根据自己的需求来设计自己的容器类，比如自平衡二叉树、B树等。不过首先要了解上述几种是否已经满足自己的需求。 Persistent持久化缓存拥有多种不同的数据格式和存储方式，这里按照几种方式和开源库来看看各自的方案。 NSUserDefaults这是系统提供的最简单的一种保存数据的方式，自带了缓存和同步机制，利用的是NSCoding的方式，所以NSCoding拥有的缺陷UserDefault也会拥有。 当数据量增多变大，会导致plist文件太大，从而影响加载性能，所以只能保存少量的小型数据。 NSCoding这是系统提供的持久化方案，不仅仅保存了数据，同时也保存了类别信息。但这也带来了部分缺陷，那就是数据兼容问题。 当软件升级时，修改了类名，或者改动了内部成员实现，就可能导致数据错误设置崩溃。所以需要小心控制数据版本信息。 由于这种方式是一次性的读取与写入，在数据量大的时候也会产生一些问题。同时这种方式并不适合部分读取部分修改的场景，如果数据比较大需要重新考虑。 JSON另一种代替NSCoding的方式便是使用JSON来保存，虽然在数据兼容性上会比NSCoding稍微优秀一些，但依然没有根本解决这个问题，所以这是一个可选方案。 YYKitYYKit使用了LRU策略，明确了缓存失效策略。 内存缓存使用了线性链表+NSDictionary来实现，由于LRU的特性，插入永远在开始，而删除永远在结尾，所以拥有较高的性能。但是查找还是依赖于hash表来实现。这样在插入和查找都避免了对方的缺陷，实现了更加高效的结果。缺点是需要同时保存和修改两份数据索引。 磁盘缓存使用了sqlite来保存文件缓存信息（filename, last_modify_time)，所以在读写小数据的时候（20KB）会直接在sqlite中读写，而不会生成一个独立的文件。所以在小文件和未命中的情况下效率会高很多。而读写大文件时，效率会降低一些，考虑到sqlite的缓存和执行，并不会降低太多。由于sqlite对时间创建了索引，所以在缓存过期查找上面会优秀一些。这种设计解决了小文件和未命中的效率问题，但是并不能实现高并发读写文件。 这种按照数据量来区分数据存储方式的方法解决了大文件和小文件之间的性能差别，但也给缓存系统带来了一定的复杂性。同时如果sqlite的索引失效会导致查找效率的降低。 YYCache带来了一种通用型的存储方式，但在很多时候还是需要自己来实现特定的需求。 PINCache使用了大量的Lock来处理多线程读写，拥有异步读写接口，没有太多的特别优化。 磁盘缓存单纯使用了文件缓存，在初始化的时候就把整个目录及其元素的属性读到内存，来提高效率，但是使用的是数组存储，效率一般。 SPTPersistentCache他将数据信息通过memory map的方式写到了文件头部，说是为了并发读写，但这也时每次更新updateTime需要写整个文件，这样必定会导致性能降低。个人建议还是把文件信息写到另一个文件中，方便内存缓存。 这种方式比较适合的场景是只读数据，对于经常变化的数据反而可能会降低性能。 Haneke &amp; SDWebImage这两者非常相似，Haneke功能更少，但是更加紧凑，代码结构也更加好。而SDWebImage功能非常完善，使用的人也非常的多。但也并非没有瑕疵。 图片缓存读取全部在一个子线程中进行，导致在高并发读取的时候会阻塞线程，同样下载和解码也会有类似的问题。这么设计同时也是为了保证线程安全，所以采用了顺序队列的操作，但是对于单文件来说，这样是正确的，对于多文件来说没有必要这样做。在目前移动端以及pc端来看，性能的瓶颈还不在这个地方，依然在IO上面，所以除非特殊情况，不会出现性能问题。 图片的二次处理能力不够（比如手动加圆角，裁剪，滤镜），需要自己去处理并且缓存，这对于一个图片库来说是一个遗憾，好在目前大部分工作CDN都会帮我们做掉。 预加载图片无法和正常加载使用同一套机制，预加载和正常加载如果同时触发会加载2次。SD没有考虑到预加载和正常加载使用同一个Operation缓存，导致双方都会触发真实的下载，从而浪费了流量。 作为一个图片库，图片一般内容都比较大，所以采用了文件缓存的机制，使用key作为文件名。由于文件系统自身拥有的缓存，所以在查找的效率上并不低。 FastImageCache这也是一个图片缓存方案，增加了处理图片的一些中间件。 该作者认为效率问题主要出现在图片从磁盘读取到内存，再进行解压，以及渲染前的内存拷贝。解决这类问题的最好方法就是进行memory map，将处理好的内容直接写入文件，这样在下一次载入的时候就不需要重新处理了。 作者也指出了这种方式会导致一张高压缩率的图片，进行内存映射后会变得很大，这一非常大的缺陷。 内存映射也是一种很好的方案，在存储资源丰富，而处理需要很长时间的情况下，是最简单的处理方式。随着现在设备性能的提高，一般不会存在处理的性能瓶颈，所以也需要按情景来判断。 最后这里分析了几种内存缓存和磁盘缓存的情况，一般内存缓存较为简单，不会有太多的性能问题，而磁盘缓存拥有很多的方案，每种方案都有各自的适用场景，需要根据自身的实际情况来选择。 这里所列的几种磁盘缓存都比较简单，之后会介绍一些比较复杂的存储方案。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://djs66256.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"Cache","slug":"Cache","permalink":"http://djs66256.github.io/tags/Cache/"}]},{"title":"Hybrid简介","date":"2017-08-19T19:07:47.000Z","path":"2017/08/20/2017-08-20-Hybrid简介/","text":"现在的中大型app中，为了满足快速迭代以及动态更新的需求，就往往需要使用混合架构，来达到动态更新的目的。这里就来简单介绍下目前比较主流的混合框架及其优劣。 目前的框架我大致将他归为为3种： X-native web-native template / DSL X-native这个目前最具有代表性的就是js-native了，还有一些像lua-native等，由于很久没有人维护了，就不做介绍了。 自从前端框架出现了virtual dom这个技术，就给我们的native化创造了先决条件，下面的技术都是根据virtual dom来驱动的。 react-native这是一个非常热门的项目了，贡献者就达到了1.4k，是其他项目无法比拟的，可以说是目前世界上最热门的项目之一了。 功能强大，可以说项目本身就基本包含了所有app功能。你可以不用写一行native代码，就能写一整个应用。也可以单独去渲染部分页面，非常灵活。作为一个需要快速迭代和动态更新的页面，往往也不需要特别高的交互性，所以单纯的展示已经足够了，react-native本身所提供的功能其实已经远大于渲染一个页面了。目前我尝试下来也没遇到什么坑。 正因为热门，所以社区支持非常完善，遇到什么问题，google、Stack Overflow上都有答案。所以不用担心遇到什么无法解决的问题。文档和例子也非常完善，有大量优秀的开源组件支持，很多功能都被封装为单独的组件，不需要自己去重新写了。 debug功能非常强大，而且非常好用。而且有非常多第三方的debug tools。比如专门对redux的react-dev-tools。 但是react本身就是一个非常大的话题，需要一定的学习成本。同时react-native的目标并不是统一多平台实现，而是把多平台实现转化到react，所以难以只写一份代码就能兼容所有平台，所以还是需要很多的兼容代码。这样就需要写代码的人对多平台都有所了解，同时又要理解前端技术，可以说这样的人才其实还是很少的。当然，如果只是写比较简单的页面，使用各平台通用的一些组件，还是比较简单的。 这里就有一个例子，之后也会用这个列子来验证： 这里的图片是动态显示的，有才会显示。布局如下 123456 ------------------| Title | || SubTitle | Image | ------------------| name | ------------------ 实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React from &#x27;react&#x27;import &#123; View, Text, Image, StyleSheet&#125; from &#x27;react-native&#x27;import Sep from &#x27;./seperator&#x27;export default class Answer extends React.Component &#123; render() &#123; let &#123;data&#125; = this.props return ( &lt;View style=&#123;style.container&#125;&gt; &lt;View style=&#123;style.content&#125;&gt; &lt;View style=&#123;style.textContent&#125;&gt; &lt;Text style=&#123;style.title&#125; numberOfLines=&#123;2&#125;&gt;&#123;data.question.title&#125;&lt;/Text&gt; &lt;Text style=&#123;style.subTitle&#125; numberOfLines=&#123;3&#125;&gt;&#123;data.description&#125;&lt;/Text&gt; &lt;/View&gt; &#123; data.images &amp;&amp; data.images.length &amp;&amp; &lt;Image style=&#123;style.image&#125; source=&#123;&#123;uri: data.images[0]&#125;&#125; /&gt; &#125; &lt;/View&gt; &lt;View style=&#123;style.textSep&#125;&gt;&lt;/View&gt; &lt;Text style=&#123;style.nickName&#125;&gt;&#123;data.author.nickname&#125;&lt;/Text&gt; &lt;Sep style=&#123;style.sep&#125;/&gt; &lt;/View&gt; ) &#125;&#125;let style = StyleSheet.create(&#123; container: &#123; marginLeft: 20, marginRight: 20, alignItems: &#x27;stretch&#x27; &#125;, content: &#123; marginTop: 20, width: &#x27;100%&#x27;, flexDirection: &#x27;row&#x27; &#125;, textContent: &#123; flexDirection: &#x27;column&#x27;, flexShrink: 1 &#125;, image: &#123; marginLeft: 10, width: 100, borderRadius: 2, aspectRatio: 1 &#125;, textSep: &#123; height: 1, width: 20, backgroundColor: &#x27;#ccc&#x27;, marginTop: 10 &#125;, title:&#123; fontSize: 16, lineHeight: 20, fontWeight: &#x27;600&#x27;, marginTop: 0 &#125;, subTitle: &#123; marginTop: 8, fontSize: 13, lineHeight: 17, color: &#x27;#999&#x27; &#125;, nickName: &#123; marginTop: 14, fontSize: 12, color: &#x27;#999&#x27; &#125;, sep: &#123; marginTop: 20 &#125;&#125;) 在使用下来，没有任何的问题，不论布局还是元素内容。由于使用的是js和jsx，和前端的编码非常类似，所以如果从前端转过来的学习成本会非常低。同时css布局使用的是flex，几乎完全兼容web端的布局方式。 官方的debug工具如下： weex现在来看下非常相似的weex，由阿里出品。号称能多平台使用一份代码。那么真实情况是怎么样的呢？我也去尝试了下。 weex使用的是vue框架，所以更像web的编码方式，所以学习成本会低一些。 weex的文档也比较完整，但是开源组件显然就少了很多。 虽然weex号称能够统一多平台，但是能够使用的特性只有多平台共有的特性，这一点其实react-native也能做到。这样就导致weex被限定在一个比较小的方面了。 同时weex说能够无缝降级为h5实现，然而我实践下来发现其实并不能做到完全的无缝，因为两者之间有些东西并不能等价。react-native降级会更为麻烦一些，还要考虑多平台的原生组件。所以实际上weex的降级方案并没有他说的那么好用。 布局系统，虽然三方（h5，weex，react-native）都可以使用flex布局来实现，但还是有部分出入。react-native和web的flex兼容的最好，上面就是按照web的方式来写的，但是有部分是web没有的。weex比较奇怪，他实现了部分flex功能，同时又自己自创了几个，所以说降级并没有那么好用。下面的例子就是就可以看出来，如果按照web的写法会有一些错乱。 可以这么认为：1react-native flex (Yoga) &gt; web flex &gt; weex flex weex的社区支持比较小，也就国内的几个厂家在使用，所以能获得的帮助也会少一些。 下面就是使用weex来实现的例子，css和上面的保持一致，发现有些布局已经发生错乱： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div class=&#x27;container&#x27;&gt; &lt;div class=&#x27;content&#x27;&gt; &lt;div class=&#x27;textContent&#x27;&gt; &lt;text class=&#x27;title&#x27;&gt;&#123;&#123;answer.question.title&#125;&#125;&lt;/text&gt; &lt;text class=&#x27;subTitle&#x27;&gt;&#123;&#123;answer.description&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;image v-show=&quot;cover&quot; class=&#x27;image&#x27; :src=&#x27;cover&#x27; &gt;&lt;/image&gt; &lt;/div&gt; &lt;div class=&#x27;textSep&#x27;&gt;&lt;/div&gt; &lt;text class=&#x27;nickName&#x27;&gt;&#123;&#123;answer.author.nickname&#125;&#125;&lt;/text&gt; &lt;div class=&#x27;sep&#x27;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; answer: Object &#125;, computed: &#123; cover() &#123; return this.answer.images &amp;&amp; this.answer.images.length &amp;&amp; this.answer.images[0] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .container &#123; margin-left: 40; margin-right: 40; align-items: stretch; &#125; .content &#123; margin-top: 40; flex-direction: row; &#125; .textContent &#123; flex-direction: column; flex-shrink: 1; flex-grow: 1; &#125; .image &#123; margin-left: 20; width: 200; height: 200; border-radius: 4; flex-shrink: 0; /* aspect-ratio: 1; */ &#125; .textSep &#123; height: 2; width: 40; background-color: #ccc; margin-top: 20; &#125; .title &#123; lines: 2; font-size: 32; line-height: 40; font-weight: 600; margin-top: 0 &#125; .subTitle &#123; lines: 3; margin-top: 16; font-size: 26; line-height: 34; color: #999; &#125; .nickName &#123; margin-top: 28; font-size: 24; color: #999; &#125; .sep &#123; margin-top: 40; height: 2; background-color: #ccc; &#125;&lt;/style&gt; 官方提供的工具可以看下： js-native如果你要问我选用哪个框架，根据上面的两个例子，心里应该就有选择了。react-native是一个非常大型的完善的项目，如果你不想折腾，那么就选择react-native吧。如果你想要极致的选择，你可以尝试下weex。而多平台支持并不是你选择的理由，react-native的子集完全可以做到多平台支持。 H5这是一个非常古老，但是非常有效的策略了。而且不需要更多的学习成本。缺点当然就是没有native那么的高效。 最有名的当然就是cordova这个开源项目了。他把很多native的功能通过module的方式暴露给web，让web能够使用很多的原生功能。而事实上很多情况下web只是作为一个app的附加功能，并不会给web如此多的权限。所以如果整个app是架构在web的基础上的话，可以尝试下cordova这类的项目。而仅仅是内嵌web，则需要考虑到控制不同的web需要拥有不同的权限。 另外一个非常有名的项目是JSWebviewBridge，他可以让我们定制化的注入几个功能，提供web端调用。这种定制比较简单，也没有module的概念，不能够构建复杂的功能。 h5最为常用和成熟，而且和原生系统关系不大，所以这里就简单介绍下。 Template / DSL剩下的基本就可以概括为模板技术和DSL技术了。这两者的应用面更加狭窄，往往作为并不要求那么灵活多变的场景。但是这种方式更为稳定和搞笑。 Tangram淘宝首页的模块化技术。可以想到，淘宝首页对动态化的要求没有那么高，首页的运营都是非常稳定的，样式也是非常稳定的，只有内容变化非常大，那么模板技术就是最适合的了。 其实很多app都在用这种方案，只是做的更加的简单些，比如： 12345678910[ &#123; &quot;type&quot;: 1, &quot;data&quot;: &#123;&#125; &#125;, &#123; &quot;type&quot;: 2, &quot;data&quot;: &#123;&#125; &#125;] 这种数据结构，type所对应的就是模板的代号。只是Tangram将这个更加的泛化了而已，并且增加了很多后台配置和管理的功能。 官方的例子： Jasonette这是一个依赖于JSON的DSL，包括布局、事件处理都可以在JSON中配置完成。 布局使用UITableView，UICollectionView，UIStackView来实现，所以也有部分的兼容问题。 同时对于新的DSL，学习成本比较大，也缺乏debug和开发工具，手写JSON太不友好了。 这是我用Jasonette写的例子： 基本的布局可以实现，但有些布局还是不能很好的完成。 官方的例子： samurai-native / BeeFramework这是利用xml或者html来布局的框架，虽然可以做到绑定事件，但并不能处理事件，所以局限非常大。这两者已经很久没人维护了。 总结可以看到目前这类想法除了模板技术，其他的都已经被X-native所替代了，因为这种技术的局限性实在是太大了。所以也建议大家慎重考虑这种局限比较大的方案。 最后以上介绍了目前比较热门的几种hybrid方案，就目前的情况来说，除了h5，其他都在向javascript-native方向发展，可能因为javascript这门语言的火热，同时又有大量前端开发。可见一个方案的优劣还是需要从更大的方面来看待，而不是从功能的实现上来看待，易用和学习成本还是非常重要的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"hybrid","slug":"hybrid","permalink":"http://djs66256.github.io/tags/hybrid/"},{"name":"weex","slug":"weex","permalink":"http://djs66256.github.io/tags/weex/"},{"name":"cordova","slug":"cordova","permalink":"http://djs66256.github.io/tags/cordova/"},{"name":"Jasonette","slug":"Jasonette","permalink":"http://djs66256.github.io/tags/Jasonette/"},{"name":"Tangram","slug":"Tangram","permalink":"http://djs66256.github.io/tags/Tangram/"}]},{"title":"javascript-native调用实现","date":"2017-08-19T14:54:55.000Z","path":"2017/08/19/2017-08-19-javascript-native调用实现/","text":"在现在流行的多元框架中，最常见的就是JavaScript的应用了。这里就来分析下react-native的实现。 react-native并不是只有一种实现。因为他不仅仅支持JavaScriptCore来实现交互，也考虑到了某些场景下需要使用WebView来实现，同时也有很多debug工具，需要将JavaScript的执行环境转移到浏览器。大概的结构如下： 1234567891011 ------------------------------| native | ------------------------------ | bridge ⅴ|------------------------------|| Executor ||------------------------------|| JSContext | WebView | Chrome ||------------------------------| 其中执行器部分（Executor）可随意替换为不同实现。这里我们来分析下JSContext中的实现。 Module要实现react-native这样大型的框架，javascript就不能被散乱的放置，那么就必须进行分模块。调用模块时需要使用CommonJS或者ES6的方式。 12var module = require(&#x27;module&#x27;)import * as module from &#x27;module&#x27; 同时也需要考虑到如此多的模块，一次性载入所带来的性能损耗，就必须采用惰性加载的方式。 队列和其他项目的实现方式类似，react-native依然使用了message queue来实现通信，而不是JavaScriptCore自带的绑定功能，这是为了兼容上面说的多Executor。 与其他方案不太相同的是，react-native在module，module-method和callback都使用了id: number来取代名字，个人猜测可能是为了性能考虑。 那么我们就JSContext这种情况来说下整个通信实现的过程。 实现这里使用console来作为例子，这里使用JavaScriptCore的c接口是为了和react-native保持一致，同时忽略了内存问题。 模块表观察发送给JSContext的数据发现会有很多类似这样的JSON数据： 12345[ &quot;WebSocketModule&quot;, null, [&quot;connect&quot;,&quot;send&quot;,&quot;sendBinary&quot;,&quot;ping&quot;,&quot;close&quot;,&quot;addListener&quot;,&quot;removeListeners&quot;]] 可以看出来，[0]表示的是module名字，而[2]表示的是module的方法，正式这一份表，才对应了javascript和native双方的indexId，所有的通信都是对应于这一份表来进行的。 所以双方都会有一份自己维护的模块，而js的模块表我们这里定义为 1234// id =&gt; module 这是native调用js module时，传递的是idvar nativeModuleByIds = &#123;&#125;// name =&gt; module 这是js调用js module时，传递的是namevar nativeModules = &#123;&#125; 载入模块在javascript端，如果需要载入模块，那么我们会使用 1var console = require(&#x27;console&#x27;) 那么在JSContext还没有console模块的情况下如何进行初始化呢？这里就需要一个NativeRequire，来载入native模块，结合上面的模块配置表，require的实现如下： 1234567var NativeRequirefunction require(moduleName) &#123; if (nativeModules[moduleName]) &#123; return nativeModules[moduleName] &#125; return NativeRequire(moduleName)&#125; NativeRequire在初始化JSContext时，我们就需要为通信做好连接的准备，直接注入3个方法。(这里react-native其实还有另外一个方式触发require，通过nativeModuleProxy对象的getProperty来触发，这里讨论最原始的require方式) 1234567891011121314151617181920JSClassDefinition definition = kJSClassDefinitionEmpty;JSClassRef global = JSClassCreate(&amp;definition);g_ctx = JSGlobalContextCreate(global);JSObjectRef globalObj = JSContextGetGlobalObject(g_ctx);&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeRequire&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeRequire); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125;&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeFlushQueueSync&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeFlushQueueSync); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125;&#123; JSStringRef name = JSStringCreateWithCFString(CFSTR(&quot;NativeFlushQueueAsync&quot;)); JSObjectRef obj = JSObjectMakeFunctionWithCallback(g_ctx, name, NativeFlushQueueAsync); JSObjectSetProperty(g_ctx, globalObj, name, obj, kJSPropertyAttributeNone, nil);&#125; 关于NativeFlushQueueSync和NativeFlushQueueAsync到下面再解释。 这里native的模块表就不实现了，直接使用[&quot;console&quot;, null, [&quot;log&quot;, &quot;getName&quot;], [1]]。 1234567891011121314151617181920212223242526272829303132333435JSValueRef NativeRequire ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 1) &#123; JSValueRef jsModuleName = arguments[0]; if (JSValueIsString(g_ctx, jsModuleName)) &#123; char buffer[128] = &#123;0&#125;; JSStringGetUTF8CString(JSValueToStringCopy(g_ctx, jsModuleName, nil), buffer, 128); // 0. 当js调用&quot;NativeRequire(&#x27;console&#x27;)&quot;的时候 // 1. 我们会在本地的模块表里根据名字去查找 // 这里就简单的strcmp来表示 if (strcmp(buffer, &quot;console&quot;) == 0) &#123; CFStringRef config = CFSTR(&quot;[\\&quot;console\\&quot;, null, [\\&quot;log\\&quot;, \\&quot;getName\\&quot;], [1]]&quot;); // 2. 构造js对应的模块表，这里的顺序必须和native是一一对应的 // [ moduleName, constants, methods, async indexes ] JSValueRef jsonConfig = JSValueMakeFromJSONString(g_ctx, JSStringCreateWithCFString(config)); JSObjectRef global = JSContextGetGlobalObject(g_ctx); JSValueRef genNativeModules = JSObjectGetProperty(g_ctx, global, JSStringCreateWithCFString(CFSTR(&quot;genNativeModules&quot;)), nil); JSValueRef args[] = &#123;JSValueMakeNumber(g_ctx, ConsoleModuleId), jsonConfig&#125;; // call JS =&gt; genNativeModules(moduleId, config) // 3. 调用js，初始化native模块，将函数表中的string转换为function实现 // 这里接下节 JSValueRef module = JSObjectCallAsFunction(g_ctx, JSValueToObject(g_ctx, genNativeModules, nil), global, 2, args, nil); return module; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 这里会同步调用初始化模块方法，并且将模块返回给JSContext。 但是可以发现模块表中的方法都是string，也就是方法名，我们如何去使用console.log()这样的方法呢？这里就需要中间的初始化模块这个作用了。 初始化模块回到上节的第三步，此时native传给js一个模块表，让js去构造这个模块。让我们回到js： 123456789101112131415function genNativeModules(moduleId, config) &#123; let [name, constants, methods, asyncs] = config let module = &#123;&#125; // 这里将所有的方法名都转换为function methods.forEach(function(method, methodId) &#123; module[method] = function (args) &#123; // call native flush &#125; &#125;, this); nativeModules[name] = module nativeModuleByIds[moduleId] = module return module&#125; 这样便把string转换为function了，可以像正常的js方法那样使用了。 到这里注册js模块已经完成，下面来说说调用的过程。 同步方法的调用同步方法的调用对于JSContext来说会简单很多，而对于很多基于webview的实现来说就会麻烦一些，因为参数不能直接编码在url中，最后我们来讨论下这个问题。 上节说到将方法名转换为function，那么function具体实现是怎么样的呢？ 首先来看看同步方法的实现： 123module[method] = function (args) &#123; return NativeFlushQueueSync(moduleId, methodId, ...args)&#125; 这里的NativeFlushQueueSync方法就是一开始我们注入的方法，作用是执行对应模块的对应方法。 1234567891011121314151617181920212223242526JSValueRef NativeFlushQueueSync ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 3) &#123; // 这里通过查找native的模块表，查找到对应的方法，并执行 if (JSValueIsNumber(g_ctx, arguments[0]) &amp;&amp; JSValueIsNumber(g_ctx, arguments[1])) &#123; if (JSValueToNumber(g_ctx, arguments[0], nil) == ConsoleModuleId) &#123; if (JSValueToNumber(g_ctx, arguments[1], nil) == 0) &#123; // call Native &lt;= console.log if (JSValueIsString(g_ctx, arguments[2])) &#123; // console.log转换为NSLog NSString *str = (__bridge NSString *)JSStringCopyCFString(NULL, JSValueToStringCopy(g_ctx, arguments[2], nil)); NSLog(@&quot;%@&quot;, str); &#125; &#125; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 然而react-native并没有完全严格上的同步执行方法。因为很多调用UI层的功能必须在主线程上，而JSContext是在自己的线程中执行，所以如果需要严格的同步执行，需要阻塞JS线程。而几乎所有功能都是不需要执行结果的（return void），所以只要触发native去执行该方法就行了，无需等待执行完再返回。而需要有返回值的接口都被设计成异步的了。 异步回调说到异步回调，大家用的方案好像都是一样的，那就是callbackId。 1234567891011121314var messageQueue = &#123;&#125;var messageQueueId = 0function JsMessageQueueAdd(args) &#123; messageQueueId ++ messageQueue[messageQueueId] = args return messageQueueId&#125;function JsMessageQueueFlush(queueId, args) &#123; let callback = messageQueue[queueId] if (callback &amp;&amp; typeof(callback) === &#x27;function&#x27;) &#123; callback(args) &#125;&#125; 创建异步module方法的方式会有点不一样： 1234module[method] = function (args) &#123; let queueId = JsMessageQueueAdd(args) NativeFlushQueueAsync(moduleId, methodId, queueId)&#125; 然后来看看native的实现： 12345678910111213141516171819202122232425262728293031JSValueRef NativeFlushQueueAsync ( JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception) &#123; if (argumentCount == 3) &#123; if (JSValueIsNumber(g_ctx, arguments[0]) &amp;&amp; JSValueIsNumber(g_ctx, arguments[1])) &#123; if (JSValueToNumber(g_ctx, arguments[0], nil) == ConsoleModuleId) &#123; if (JSValueToNumber(g_ctx, arguments[1], nil) == 1) &#123; // call Native &lt;= console.getName JSValueRef queueId = arguments[2]; NSInteger queueIdCopy = JSValueToNumber(g_ctx, queueId, nil); dispatch_async(dispatch_get_main_queue(), ^&#123; JSObjectRef global = JSContextGetGlobalObject(g_ctx); JSValueRef flush = JSObjectGetProperty(g_ctx, global, JSStringCreateWithCFString(CFSTR(&quot;JsMessageQueueFlush&quot;)), nil); JSValueRef args[] = &#123; JSValueMakeNumber(g_ctx, queueIdCopy), // callback queueId JSValueMakeString(g_ctx, JSStringCreateWithCFString(CFSTR(&quot;My iPhone&quot;))) &#125;; // call JS =&gt; JsMessageQueueFlush(queueId, args) JSObjectCallAsFunction(g_ctx, JSValueToObject(g_ctx, flush, nil), nil, 2, args, nil); &#125;); &#125; &#125; &#125; &#125; return JSValueMakeNull(g_ctx);&#125; 可以看到和同步方式的区别是就是回调会缓存在队列里。 应用123456var console = require(&#x27;console&#x27;)console.log(&#x27;Hello Javascript!&#x27;)console.getName(function (name) &#123; console.log(`Hello $&#123;name&#125;`)&#125;) 123// output:Hello Javascript!Hello My iPhone 装饰实际情况不会这么简单，js也不会直接使用native提供的模块的，一般会包装一层。比如像这样 1234567var nativeLog = NativeRequire(&#x27;NSLog&#x27;)var console = &#123; log: (args) =&gt; NSLog(args), info: (args) =&gt; NSLog(&#x27;[INFO]&#x27;, ...args), error: (args) =&gt; NSLog(&#x27;[ERROR]&#x27;, ...args)&#125;export default console 实际真实情况不会像上面那么简单，需要考虑到多线程，每个module的运行线程，js消息队列等保证js的安全顺序执行。 WebView其他项目的方案也是类似的，但也有少许的不同。 比如NativeRequire，在Web里面除了通过iframe来实现，还可以通过script标签来导入模块文件。 123var script = document.createElement(&#x27;script&#x27;)script.setAttribute(&#x27;src&#x27;, &#x27;file://module.js&#x27;)document.head.appendChild(script) 同时由于web通过url传递参数的限制，所以web的参数传递是通过native去主动拉取的。大概的流程如下： 1234[web] call native --&gt; push &lt;call info&gt; --(iframe url)--&gt;[native] get &lt;call info&gt; --(executeJs)--&gt;[web] pop &lt;call info&gt; --&gt;[native] call *** 同时很多方案，会使用名字来传递模块和方法，这样做最简单也最直接。但是如果存在频繁交互的过程可能会降低性能。 最后总的来说，javascript-native交互还是挺简单的，只要在初始的设计上比较符合现在与未来的发展，还是可以做到很灵活的。至于使用哪种方案，做到什么样的程度，可以依据自身的需求来判断。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://djs66256.github.io/tags/javascript/"},{"name":"react-native","slug":"react-native","permalink":"http://djs66256.github.io/tags/react-native/"},{"name":"JSWebviewBridge","slug":"JSWebviewBridge","permalink":"http://djs66256.github.io/tags/JSWebviewBridge/"}]},{"title":"谈谈程序员","date":"2017-08-06T12:48:44.000Z","path":"2017/08/06/2017-08-06-谈谈程序员/","text":"在很多人印象里，程序员总是那些呆板的形象。那么什么才是真正的程序员，什么才是优秀的程序员呢？ 国内的互联网蓬勃发展，但是却很多程序员在吐槽，这是为什么呢，程序员在国内的环境究竟如何呢？ 能力能力在程序员的世界里其实是非常容易衡量的，而且是非常容易区分的。我曾经面过一些人，也被面过很多次，这里来简单说下。 差的程序员学习别人教给他们的，学会需要使用到的，能够运用学会的知识，解决一些简单的问题。 这也是为什么近些年这么多培训机构，然而程序员的职位依然短缺的原因。没有一定的知识基础，大学学的一些其他辅助学科，仅仅学会一门语言，一种编程模式，是没有什么太大意义的。就如培训机构所说的，几个月就让你学会Java开发。这种量产出来的东西终究不能成为一名合格的程序员。 合格程序员会自主的学习新的知识，学习别人的项目，学会使用别人的功能。 这种人员能够自我提高和更新，主要体现在技术的体量和深度上。一个合格的程序员不仅仅知道自己项目中存在的一些功能，还知道其他人也实现了类似的功能，以及之间的区别优劣。他能完成很多分派的任务，也不需要去担心太多的风险。 可以说，很多公司其实就是要这样的人，这也是没有办法的事实，毕竟所有公司的目的是为了盈利，而不是为了更好的程序。对于他们来说，足够就行，而不是足够优秀。 优秀程序员除了会主动学习，更多的是会主动思考。思考如何让一个项目更稳定，更加完美。 这是一种完美主义者的追求，所以很多时候经常捣腾点东西。可能有时候会给项目带来一点点小麻烦，也有可能会给项目带来极大的提升。但总的来说是往好的方向发展。 这个非常依赖个人的主观意见，每个人的理解并不一致，有些人可能觉得知识的体量和深度是衡量的标准，也有人可能认为创造性是一个标准。总而言之，这一区段的人员很难从合格中区分开来，需要有一定的见地，才能比较有效的衡量。 特别优秀程序员这是一个可以影响这个行业的人，将在优秀期间的思考升华，创造出拥有足够影响力的东西。 这个阶段的人也特别容易区分，往往已经成为业界的大佬。当然，也是寥寥几人。 做人以下可能有些会让人觉得不愉快，如果你觉得我说错了，就当我在胡说吧。 标准上面说到一名优秀的程序员是比较难以被辨识出来的，而且每个人在不同的角度来看也是不同的。 之前看到有一条动态，有人在嘲笑阿里p8的员工去面试，连基础的几个概念都搞不明白，在嘲笑阿里的技术水平。我们再从第三者的角度来看看这个问题。先不论这位阿里员工技术水平，招人方肯定是以技术能力来衡量的，面试官问一些细节、生僻的问题，来体现自己的厉害，但是这有意义吗？他们需要的是一个可以干活的合格程序员，又不是一个管理者或者架构师。 然而这个现象在招聘中依然非常普遍，因为其他方面的能力真的太难只经过一场面试就看出来了，所以只能通过技术来考察。而越是厉害的人可能更有所专精，通用的技术考察往往又不能达到他们的深度，可能他们的面试结果还不如某些刷了很多面试题的人呢。 所以现在就有很多人抱团取暖，相互贴金。 做人程序员这个群体都太过于自信和高傲了。这种自信对于写代码来说是必要的，可是在做人方面是完全失败的。 用通俗一点的话来说，你不干了，公司可以找一百个，一千个人来替代你，你又不是行业的大佬，这些人完全可以比你做的更好。不像其他的职位，做的久了，会建立很多关系，会有很多的回头客。这种现实又导致这个行业的极度缺乏安全感和安定。 就像现在的网络直播一样，有多少技术高超，甚至是世界冠军的人，在开播的时候还有些人来捧场，可是时间一长，身上的光环退去，也只能被淹没在众多的播主中间。 所以在学会做一件事之前，更多的去学会如何做一个人吧。 淘汰同时，程序员之间的竞争是非常残酷的。技术的更新迭代实在太快了，几乎每年都会有新的技术出现，所以程序员需要不停的去学习。只要你停下来了，就会有很多努力的人会超越你。 这样的现象更加严重的加剧了上述的一些现象，也更加压缩了程序员的时间。 有很多故事，都是碰到领导空降，赶跑了一大群老员工。不敢说是不是老员工真的能力不行，或者是反抗新领导。很大程度上是新领导为了自己的业绩，从而牺牲一些无关痛痒的老员工吧，谁让你是这么容易就可以被替代呢？不论老员工如何的哭诉，在老板那里肯定也是尽是老员工的不是吧。 那么，等年纪大了，不能达到公司产出的要求了，各方面能力都不及从前了，是不是就很容易被公司所抛弃了呢。 最后现在的互联网行业还是非常年轻的，但也是竞争非常严峻的，很多事情也不像代码这般清晰。所以程序员，收起你的自负，去学习如何做一个人吧。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://djs66256.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"完备路由系统","date":"2017-07-30T12:58:58.000Z","path":"2017/07/30/2017-07-30-完备路由系统/","text":"现在很多应用都在内部跳转中使用了路由系统，这种从web搬过来的东西。但是功能却并不完善，就像比较有名的JLRouter和MGJRouter。这里就来聊聊更加完善的系统的几个部分。 前言现在很多的应用都在一个非常大的量级了，已经不可能由几个人的小团队来开发了，那么模块化就非常必要了。相比很多人说的组件化（Component），我觉得模块化（Module）更为贴切一点。 说到模块化，那么模块间的通信就非常重要了，如果仅仅是通过api来做通信，就不够灵活，而且可能会增加了集成成本。一旦涉及到接口变更就需要修改多个模块。这样路由系统便是页面间跳转的一个非常重要模块，可以说他承载了整个最核心的部分。一个好的，完善的路由系统可以让一个系统更加稳定和开发简单。而一个功能欠缺的路由系统则有可能将整个应用带入一个泥潭。 目前比较有名的几个实现，都非常简单，而且非常好用。但这是对一个整体的应用来说的，如果是一个多团队开发的应用，就有部分缺陷了。所以为了应对这种缺陷，蘑菇街和京东都开发了一个管理平台，来专门管理这些路由系统，解决这种缺陷。 这些路由实现在目前已经基本满足需求了，但是在未来可能会进行的模块拆分，则需要功能更加强大的路由系统。所以我提出一种更加完备的路由系统。可能这里有过度设计的成分，但是作为未来的扩展性，我觉得还是有必要的。 完备路由既然我们是从web那里抄过来的想法，那么为什么不抄的完整一些呢？ 回溯 history目前的几个路由系统都没有提供这个功能，而这个功能我觉的是非常非常重要的一个功能。当我们需要判断上个页面是什么页面的时候，只能通过判断controller队列中的类型！这完全违背了黑箱这种原则。 同时我们可能需要回退多个页面或者回退到某个页面的时候，没有历史记录的支持，在合作开发的时候绝对是个灾难。 history给我们的功能好处也是非常多的。除了上述几个场景中特别需要以外，对我们的debug以及分析也是非常有帮助的。甚至我们可以记录和导出history来查看用户的操作流程，虽然不能代表所有的动作，但也可以展示用户的一系列行为，或者在crash分析中自动带上该信息。 自定义进入退出我们的每个页面都不是固定的push的，也可能是present的，所以相应的返回也是不一样的，然而目前几个路由系统都只有进入的方式，并没有退出的方式。那么只能交给人来处理这种事情，当某个模块成为黑箱的时候，外部又怎么去判断呢？ 所以进入(push)和回退(pop)操作都需要有对应的行为，这就承接了上一个history的必要性了。这样我们同样是进入(push)和回退(pop)，当行为是present时，就对应为present和dismiss。 甚至在内嵌的网页中也可以接入native的路由系统，那么这样的push和pop就对应了网页的跳转和返回了。同时这样也屏蔽了模块内部的具体行为，模块修改展示方式也不会影响外部的处理逻辑。更好的形成一个黑盒模块。 子路由这个在web中是不存在的，但是在native的app中我觉得有必要。每个模块，或者内嵌的网页都应该是个子路由系统。 为什么需要子路由系统呢？这里举一个例子： 12345Root --[push]-&gt; VC | [present] \\ --&gt; VC2 --[push]-&gt; VC3 --&gt;... 当我们需要去完成一个系列的完整动作的时候，往往会present出一个新的navigation来处理这一系列动作，而这些行为在任意一个节点都可能会返回，同时又可能在任意的一个地方present出来。那么如果要满足这种情景又需要人为的去处理很多逻辑，这就埋下了隐患。 如果我们把present出来的这一系列行为定义为子路由，那么如果需要返回时，只需要退出子路由中所有的history就可以了。 黑盒路由如果项目变大以后，可能就会存在上百个路由，那么这些路由中实际有效的（其他模块可用，或者公开的）路由又有多少呢？我觉得应该会很少吧，因为外部进入一个其他模块的入口基本是固定的，所以我们为什么需要暴露这么多不必要的路由给外部呢。蘑菇街和京东为了管理这些路由干脆搞了一个管理系统，来防止路由冲突。那么为什么我们不让一个模块内的路由成为一个黑箱呢，只暴露外部需要的路由，而其他路由都经过保护不能随意访问。这样也防止外部访问不该访问的功能。 这个功能是承接子路由的实现，我们保持每个子路由内部的黑盒，可以减少我们的错误。 保持子路由的黑盒性的一个简单做法就是base url。依照restful来设计路由，不同子路由系统给与一个base url，比如登录模块的路由可以增加base url /auth。那么内部和外部的行为可以概括为： 12345678910// 外部push(&quot;/auth&quot;)push(&quot;/auth/password&quot;)// 内部push(&quot;~&quot;)push(&quot;~/phone&quot;)push(&quot;~/verify&quot;)push(&quot;~/password&quot;)// 退出整个模块pop(&quot;~&quot;) 重定向有些页面在某些条件下是不能进入的，这时候需要重定向去特定模块来完成这个条件，完成后再次进入该模块。所以我们需要重定向的功能，否则就会增加很多依赖项，导致不能真正的模块分离。 比如某个功能需要登录模块，在我们没有集成登录模块的时候就难以完成功能，而集成了登录模块又会导致模块化仅仅只是个表面上的分离了，可能在真正开发的时候还是把一大堆其他模块给搞进工程，那么这样的模块化有什么意义？如果拥有重定向就可以伪造一个重定向，让他自动放回需要的结果就可以了。这样就可以排除其他模块的干扰了和依赖了。 路径依赖这个其实时承接上个需求的，可以相当于一个语法糖。 按照上个场景，我们如何去注册一个需要重定向的路由呢。那么我们可以引入一个路由依赖的功能，可以标记每个路由的依赖选项。比如登录的@requireLogin。 这算是一个扩展的功能吧。 中间件目前主流的几个路由还有一个非常欠缺的功能就是中间件。我们无法去从路由系统内部知道我们经过了哪些操作，是否需要过滤某些操作。 这个话题其实也关系着黑盒路由和重定向的问题。依照服务端的中间件设计方式，我们应该需要为路由系统留出控制以及debug的入口。 拥有了中间件我们可以做什么？ debug，打印所有的入口和出口，完善我们的日志 分模块开发的时候，可以mock其他有依赖的模块 监视，是否调用了非法的接口或者使用了非法的参数 个人觉得中间件是一个系统所必须的功能，可以提供外部实现更多的功能和更灵活的控制。 热插件这是一个额外的话题。由于我们的路由注册基本上是在+load方法里面做的，所以当我们的路由越来越多的时候，启动性能也会越来越差，那么提供热插拔的功能是最好的。同时热插拔功能也相对应的提高了路由的黑盒性。 做成热插件的形式还有一些好处。比如abtest的时候，可以加载不同的插件来进入不同的页面。又或者在某个页面出了线上问题，需要降级为web来实现，也可以通过替换插件来替换不同的页面。 这是一个锦上添花的功能，所以我把他列到了最后。 总结以上说的几个点可能给我们的编码增加一些复杂度，而且还需要去理解这些概念才能很好的运用。但这里的规划完全是以模块化为前提的，并且独立为一个系统，不去依赖UIKit。所以从长远来看这样的实现是绝对有好处的，如果有时间可以把这个想法实现出来。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Router","slug":"Router","permalink":"http://djs66256.github.io/tags/Router/"},{"name":"路由","slug":"路由","permalink":"http://djs66256.github.io/tags/%E8%B7%AF%E7%94%B1/"},{"name":"蘑菇街","slug":"蘑菇街","permalink":"http://djs66256.github.io/tags/%E8%98%91%E8%8F%87%E8%A1%97/"}]},{"title":"单向数据流之用户行为统计","date":"2017-07-28T14:32:34.000Z","path":"2017/07/28/2017-07-28-单向数据流之用户行为统计/","text":"这几年的开发中，最让人头疼的事情之一就是数据统计。这里就来看看以单向数据流的角度如何改进统计系统的设计。 面向切面埋点我非常的反对使用面向切面埋点来处理用户行为，理由有三个： 统计数据极度依赖视图结构，或者需要将每个数据绑定到视图上。 不能完成复杂的交互统计，仅能实现简单的事件数据。 视觉上的修改会影响统计结果。 以前在使用切面埋点的时候，就遇到很多的问题，虽然说每个数据点都不可能漏埋或者错埋，但是每次上线后数据分析都需要跑过来让开发给他们看看这些行为的埋点数据是怎么样的。这样也很难实现一个多期的版本对比。 用户行为统计那么按照标准的用户行为统计又有哪些问题呢？ 每个数据深入业务底层。需要统计要么把事件层层代理到Controller，要么在底层这些看似不合理的地方埋点。 复用问题。业务虽然一样，但是埋点信息并不能完全保持一致，而且有些场景下也无法保持一致，因为可能会有重复场景。 埋点数据回归测试。由于是人工埋点，所以可能会漏埋错埋的情况发生。 目前目前我们的埋点方案主要有3点： 数据尽量保持统一。相同的业务埋相同的点，然后根据页面区分。这样就能够实现重用，缺点是有少部分需要特殊化的场景。 代理到业务层，然后再埋。缺点是如果中间层次过多，会出现多级代理，而仅仅是为了埋点。 子类化。专门子类化该页面的专有子类。缺点是子类的目的就是为了区分埋点，有点多余。 以上都没有一个很好的方案能够解决数据回归测试的问题。而回归测试也只能靠人工执行。 单向数据流方案统计即是数据，那么当然也非常符合数据流模型，那么我们就用数据流模型来简化埋点方案，增加每个模块的独立性和复用性，同时也把埋点放到一个地方去做，减少埋点数据在整个应用内的散乱分布。 以上就是这套方案的大概结构。用户触发行为时，和之前直接统计行为不同，而是创建一个Action对象，将统计所需要的参数，或者自身包含数据包装在Action内，发送给Store。Store作为一个数据中心，负责接收和分发数据，他将收到的数据分发给订阅者Subscriber，最后由Subscriber完成统计数据，并上报服务器。 Store、Action是完全可复用的，同时这两者并不关联实际业务，所以完全可以模块化，同时只要行为足够完整，也不需要关系具体业务方统计数据的样式。这样就可以让其他模块完全的复用了。 那么如何提升复用性，我们来关联下之前讨论过的MVP。 这里，红色框内的部分都是逻辑性的，是完全可复用的；View也是独立与逻辑的，也是可复用的；只有Subscriber和Controller是和业务强相关的，是不可复用的。那么我们就可以知道需要把哪些东西放到不可复用的地方，哪些东西放到可以复用的地方了。 同时我们也需要考虑下测试的问题，来解决埋点数据的完整性和正确性。 只要我们mock了Store部分，就可以轻易的检查发生的Action，或者向订阅者发送对应的Action，这样就可以比较简单的去回归测试数据了。只不过这样做的收益可能并不高。 实现这里我们来看看实现的方式。 首先定义基础的Store和Action 1234567891011121314class StatAction &#123; var type: String? var params: [String: Any]?&#125;protocol StatSubscriber &#123; func newStatAction(action: StatAction)&#125;class StatStore &#123; func dispatch(_ action: StatAction) &#123;&#125; func subscribe(_ subscriber: StatSubscriber) &#123;&#125; func subscribe(_ subscriber: (StatAction)-&gt;Void) &#123;&#125;&#125; 那么在ViewController里就可以这样配置。 1234567891011func viewDidLoad() &#123; super.viewDidLoad() self.store = StatStore() self.store?.subscribe(&#123; action in // ... switch case action.type. // Track &#125;); self.submodule.store = self.store&#125; 而子模块中只需要使用store来分发行为就可以了。 12let action = StatStore(type: &quot;star&quot;, params: [&quot;id&quot;: &quot;1234&quot;])self.store?.dispatch(action) 这里订阅者甚至可以自己创建独立的类来处理这些情况，这样就更加的分离了行为统计这种不能划分为任何模块的内容了。 最后这个方案将行为统计从整个app中剥离出一个单独的模块，同时实现了高度可复用性，而且使得统计也成为可以单元测试的了。唯一的缺点是在具体统计的时候需要大量switch…case…来区分不同的行为。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"统计","slug":"统计","permalink":"http://djs66256.github.io/tags/%E7%BB%9F%E8%AE%A1/"},{"name":"用户行为","slug":"用户行为","permalink":"http://djs66256.github.io/tags/%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA/"}]},{"title":"单向数据流的应用与特性","date":"2017-07-25T16:47:00.000Z","path":"2017/07/26/2017-07-26-单向数据流的应用与特性/","text":"上次介绍了单向数据流的结构，这次来简单讨论下单向数据流的应用场景。 特性单向数据流从设计模式上看，应用了大量的命令模式，而命令模式的特定是行为通过命令来驱动，也就是说我们可以缓存命令，或者mock命令，来驱动整个流程和模块。 这就诞生了一个非常有意思的插件，录像功能。这里的录像并不是指的是用户的行为，而且录制整个app的行为。由于所有命令都会经过store，那么可以在中间件中设置一个序列化功能，将所有动作都记录下来，这样我们就可以回溯用户的操作了，比如在crash的时候。有些crash分析会去录制屏幕，来看用户当前操作，但是这样只能查看用户的操作，并不能恢复现场，往往我们去复现的时候，就没有问题了，因为数据以及不一样了。但是通过录制Action的方式录制的行为，数据也会一并被录制，这样就能完全的恢复现场了。 同时利用上述特性，我们还能跟踪用户行为。这里的跟踪就不仅仅是简单的用户事件统计了，而是把用户一连串的行为都记录下来，形成一个完整的流程。虽然这样做目前来说，还没有太大的意义，但是引入机器学习之后，对于用户推荐和喜好可能会有比较大的意义。 可以灵活的替换中间件，来处理一些额外的逻辑。比如上述的记录功能。 回溯功能在React中，有个工具React-Dev-Tools，他就是按照这种思路来做的。当你发生错误时，你可能回退几步操作，等功能修复好了，直接热部署，就可以进行接下去的操作。这都是依赖了记录Redux内部Action行为。iOS由于自己的原因实现热部署可能会有点困难，但是依然可以利用这种特性来做一些记录。 应用那么现实情况，我们可以在什么场景下按照这种思路进行开发呢？ 首先，这种方式是一种及其繁琐的形式，而且也不是一种非常主流的模式，在应用之前必须考虑到这点，并且考虑到团队内对于这种方式的接受程度，理解程度，不然可能会变得更糟。 其次，应用范围。我们有必要整体的使用吗？在目前的大部分开发中，都是敏捷开发和数据展示，使用这种方式反而显得累赘了。所以我认为，在某些场合下可以考虑使用这种模式： 模块间相互影响，且交互复杂 较高层面，处于整个app层面的，比如router系统","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"ReSwift","slug":"ReSwift","permalink":"http://djs66256.github.io/tags/ReSwift/"},{"name":"Redux","slug":"Redux","permalink":"http://djs66256.github.io/tags/Redux/"}]},{"title":"美学架构演化之路","date":"2017-07-22T18:33:55.000Z","path":"2017/07/23/2017-07-23-美学架构演化之路/","text":"项目发展到现在已经有一年的时间了，在这一年里，我们的crash free一直都保持的很好(99.5%+)。随着功能的不断增加，已经老代码的缺乏维护，逐渐陷入一个难以维护的地步，所以需要进一步去改善目前的架构，所以这里谈谈以前的架构和未来将要改善的一些方式。 开始最开始的阶段是完全的MVC，这种结构下最明显的问题就是massive controller。当然我们也遇到了这个问题。 此时我们要解决的问题主要有两点： 庞大的数据量，超长的页面，以及数据列表间的不同组合 不同页面相同数据列表的复用 好在在开始的时候我们就根据我们项目的一些特殊性进行了思考，以及尝试的几种组件化方案。所以在1.1的时候已经明确并且解决了这个问题。 C-MVCs在美学的表现层组件化之路文章中描述了我们使用DDComponent拆分组件化的方式。 这一次解决了单个页面的多功能模块拆分问题，增加了复用性，也奠定了未来半年的稳定开发基础。 组件统一化随着时间的推移，组件越来越多，导致同一种资源（比如User）拥有多种不同的component，每个人不同地方都使用了不同的代码，导致维护越来越困难。 所以需要将同一种类型的组件进行统一化和规范化。将目前所使用的组件分为特例组件和通用组件，并尽量在这两个范围内取用。同时每个组件都是经过几轮黑盒测试的，所以基本上不太可能出现bug。 但是这样依然会有问题，在目前应用调整的期间，很多组件都需要重写，重写的质量就很依赖个人了，那么我们统一后的组件依然难以保持很高的质量和通用性。 单元测试虽然经过上述几次的改善，目前已经没有太大问题。但其中的隐患一直没有被消除，而且在功能的大量增加和人员的变动，这种隐患就更加明显了。所以想要在我们的逻辑层加上单元测试。 关于实现方式之前的文章已经讨论过了，思路就是拆分Controller层，基本上是采用MVP，是否需要辅助Re方案还要继续观察。 那么最后我们的结构理想中应该是这样 这样我们将一整个ViewController拆分为多个子组件，子组件保持可测性。 这是目前我们需要去改进的。 模块化相信，经过上述的改善之后，我们的应用应该会趋于一个比较稳定的时期。那时的功能也会比现在多很多，那么就需要模块化管理，这是后话了，在一段时间内应该还到达不了如此量级。","categories":[],"tags":[]},{"title":"Aspect实现与应用","date":"2017-07-21T18:33:08.000Z","path":"2017/07/22/2017-07-22-Aspect实现与应用/","text":"在swift里面有个非常有意思的特性，那就是AOP，可以为协议增加默认实现。那么在Objc里面也有个类似的工具类Aspect，虽然还是有很多缺陷。这次我们来看看Aspect的实现方式。 第一想法Aspect就是通过method swizzling来实现方法的替换的，然而实际上并不是这样的。让我们来考虑几种场景： 对已有的类进行hook方法。 对一个实例对象hook方法。 如果是单纯的method swizzling，以上两者是一模一样的结果的。那么Aspect是如何实现的呢？ 对象Aspect的类型主要分两种： 对类层面进行的hook。包括类和元类(meta class)，也就是-方法和+方法。在Objc中类和元类的实现是一致的，所以采用的方式也是一致的。 对实例层面进行的hook。这里的实现比较像KVO的实现方式，也就是会利用runtime自动生成一个子类，子类来实现消息的转发，这样就不会影响到其他实例了。 方法Aspect并不直接method swizzling具体的方法，而是利用了forward message的特性。 12345/* Message Forwarding Primitives * Use these functions to forward a message as if the receiver did not * respond to it. */ void _objc_msgForward(void /* id receiver, SEL sel, ... */ ) Aspect将所有消息都转发到这个方法，然后统一从forwardInvocation:中处理。这样就可以统一管理，并且统一处理多种不同类型的消息了。 强校验Aspect还对hook方法进行了强校验，避免不同参数的方法调用导致的crash。 应用最大的应用场景就是单元测试了，和其他测试库一起配合使用还是非常方便的。当然也可以用于应用内的method swizzling，如果你的需求够大的话。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"Aspect","slug":"Aspect","permalink":"http://djs66256.github.io/tags/Aspect/"},{"name":"AOP","slug":"AOP","permalink":"http://djs66256.github.io/tags/AOP/"}]},{"title":"从数据流动角度解决测试难题","date":"2017-07-21T15:36:20.000Z","path":"2017/07/21/2017-07-21-从数据流动角度解决测试难题/","text":"上篇讲述了增强逻辑功能测试而改进MVC为MVP，但是这样做可能还不够彻底，现在来讨论另一个纯粹从测试角度设计的框架。 首先我们来明确一下，测试中最核心的东西是什么。当然是数据，我们永远是围绕着数据来的，那么之前一些架构的问题是什么。无论哪个框架，数据的流通都是双向的，当数据流通成为单向了会怎么样呢？ 1in data ==&gt; Module ==&gt; out data 这样我们伪造数据进行测试就会非常方便了。按照这个思想就有了数据单向流通的架构。 数据单向流通的实现这个概念最早是在web中提出的，应用在React里，官方的方案是Redux。现在swift也提出了一种实现ReSwift。 我在之前写React的时候使用过这种方案，从开发角度来说，这种方案会大大增加开发难度，代码量也会大量增加，而且开发思路也需要从以前的思考方式转换过来。但是如果我们把这个思路转换过来，其实对整个流程是更加简化和分离的。 从测试角度看，我觉得无疑是我知道的最可测的一种框架，甚至可以测试部分视图的逻辑。 那么总的来说，很难说这种结构的好坏，就算不考虑增加的开发时间，也是一种难以给以一种评价的方案。 (Redux/ReSwift)框架介绍方案的几个核心是： 数据的单向流通 每个视图都可以看做一个状态机 pure function 关于pure function，我就不做太多介绍了，简单的说，就是同一输入必定会有相同的输出，是非常容易测试的一种函数。 首先，我们来看一下官方的架构图。 可以看到，数据流动方向都是朝一个方向进行的。那么下面从每个模块来介绍下，还是以star button为例子。 State视图状态机，也是所有会更新界面数据保存的地方，可以认为相当于ViewModel。 首先我们star会有以下几种视觉样式 123456enum StarButtonState &#123; case star case staring case unstar case unstaring&#125; 所以State可以定义为 1234struct StarState: StateType &#123; var state: StarButtonState var starCount&#125; Action首先我们定义几种状态机转换的Action类型 1234struct StarAction: Action &#123; &#125;struct StaringAction: Action &#123; &#125;struct UnstarAction: Action &#123; &#125;struct UnstaringAction: Action &#123; &#125; 以及相应的功能以及状态变更，这里异步请求采用延迟来代表。 12345678910111213141516func star(id: String) -&gt; Store&lt;StarState&gt;.ActionCreator &#123; return &#123; state, store in DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; store.dispatch(StarAction()) &#125; return StaringAction() &#125;&#125;func unstar(id: String) -&gt; Store&lt;StarState&gt;.ActionCreator &#123; return &#123; state, store in DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; store.dispatch(UnstarAction()) &#125; return UnstaringAction() &#125;&#125; View视图层其实很简单，只需要根据State的不同来更新就可以了。注意的是，更新都是无状态的，和上一个状态无关，所以view层是个无状态层。 1234567891011121314class StarButton: UIButton, StoreSubscriber &#123; let store = Store&lt;StarState&gt;(reducer: starReducer, state: nil) override init(frame: CGRect) &#123; super.init(frame: frame) self.store.subscribe(self) &#125; func newState(state: StarState) &#123; // update UI &#125;&#125; Reducer状态转换器，唯一可以更新State的地方。 123456789101112131415161718192021222324func starReducer(action: Action, state: StarState?) -&gt; StarState &#123; var state = state ?? StarState(state: .star, starCount: 0) switch action &#123; case _ as StarAction: state.state = .star state.starCount += 1 case _ as StaringAction: state.state = .staring case _ as UnstarAction: state.state = .unstar state.starCount -= 1 case _ as UnstaringAction: state.state = .unstaring default: break &#125; return state&#125; 数据传递那么最重要的就是数据如何传递的了。首先要明确的是每个模块能够修改的，或者说是传递的，只能是下个模块。 比如，用户star button触发了一个事件： 12345678func onButton(sender: StarButton) &#123; if (store.state.state == .unstar) &#123; store.dispatch(star(id: id)) &#125; else if (store.state.state == .star) &#123; store.dispatch(unstar(id: id)) &#125;&#125; 此时会创建Action，也就是将view事件转换为Action。然后会传递到store中，store会调用Reducer进行处理。Reducer更新state之后又会触发store的subscribe事件，回到view的func newState(state: StarState)。 1234View (User Event)==(create)==&gt; ActionCreator/Action==(dispatch)==&gt; Store &lt;--(Update State)--&gt; Reducer \\==(subscribe)==&gt; View (newState) 大概的一个流程就是这样了。 接下来说说这样做的模块化的优势。 模块化和测试性首先，我们需要有函数式编程的概念，函数也是一等公民，所以ActionCreator和Reducer都是独立的模块。 作为使用者，我们在不需要像MVC一样知道这些api所代表的操作功能，相对应的，我们需要去了解一个模块的动作（Action），比如以上例子就是 12func star(id: String)func unstar(id: String) 这样的划分比MVC要友好的多，真正的把逻辑功能从原本的C中分离开。需要触发这个行为也非常简单store.dispatch(star(id: id))。相比MVP，行为更加的独立，每个行为之间完全没有联系，也不会产生干扰影响。同时因为每个行为的独立性，可复用程度也就越高。 Reducer则代表了view层的更新，也可以非常明确的知道每个状态的变更发生了什么。相比其他模式，将界面更新完全交给view或者Controller，Reducer是最明确也是最清晰的。同时Reducer也是独立的，可以替换的。 对于UIkit层面我们无法单元测试，所以测试的主要部分是Action和Reducer。这两个模块可以说都是pure function或者在某些条件下是pure function的，所以测试也非常的简单。 对比和这个模式比较像的有状态机模式和Reactive。 状态机模式也是实现对应功能，以及对应状态，然后通过子类化的方式去实现Reducer的功能。 Reactive则比较像ActionCreator，只是Reactive返回的是信号量。 使用场景从上面可以看出这是一套非常优秀的模块划分方案，但同时也会大大增加代码量，而且需要改变以前的思维模式。而对于目前国内的现状来看，很难有这么多时间和精力让整个项目都使用这种模式。 但是这种模式的特点也非常的明显，在处理比较复杂的交互行为，并且存在较多的视图状态的时候，会是一种比较好的方案。比如视频播放界面。 所以个人认为，在一些简单的场景下并不需要使用该方案，但是在一些复杂的交互页面，而且又非常想要引入单元测试的场景，可以酌情考虑下这种方案。这种方案要求人们的思维方式的改变，需要有一定的函数式编程的概念。 虽然不一定会直接使用ReSwift，但是这种思想有很多值得借鉴的地方，利用这种思想做出类似的效果，以便达到可以容易进行白盒测试的目的。 最后以上虽然说不会全部使用该方案，但也可以部分使用。比如独立的小模块，亦或是app层面的一些东西。下次可以讨论下app层面如何来利用单向数据流来简化流程。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ReSwift","slug":"ReSwift","permalink":"http://djs66256.github.io/tags/ReSwift/"},{"name":"Redux","slug":"Redux","permalink":"http://djs66256.github.io/tags/Redux/"},{"name":"测试","slug":"测试","permalink":"http://djs66256.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"换个角度来看MVC与MVP","date":"2017-07-14T13:04:28.000Z","path":"2017/07/14/2017-07-14-换个角度来看MVC与MVP/","text":"之前了解架构的时候，虽然能够看得懂MVC和MVP这些概念，但是却没有实感，总感觉很多地方其实并没有那么的明确。最近想起之前的讨论TTD的文章，忽然想到，为什么不从另一个角度来看待这两种模式呢，所以忽然醒悟，现在来讲讲这两种模式解决的问题。 无法解决的单元测试最近在开发过程中，虽然大部分场景都比较简单，逻辑也非常清晰，但是也有部分场景的逻辑比较多，一些隐藏逻辑还难以通过造数据来进行测试，自然QA也基本覆盖不到这种测试场景，那么自然想到了单元测试，但是以目前我们项目的架构来说，单元测试基本不可能，业务逻辑、事件界面等揉合在一起，无从下手。 我们目前的架构来看，并不差，无论从实用性，易用性和复用性上来说。但是网上众多大神都极力推崇MVP和MVVM，我一直都没有太明白别人所说的优点真的如此神奇吗？直到最近想要对部分业务复杂的页面做单元测试，然后从TDD的角度再去看这些问题，才豁然开朗，下面就来简单介绍下。 架构之间的模糊性我们来探讨一下，现在官方推荐的MVC架构在实战中的情况，真的能够分的如此清楚吗？ 也有很多人把这种架构表示为这样： 123--------------------- ---------| view | controller | ----&gt; | model |--------------------- --------- 在现实中，view和controller往往是紧密而不可分的，事实上view也很难在不同的应用间（iPhone，iPad）复用。 很多时候为了模块的内聚性，需要映射view &lt;- model，这就是有人提出的增加一个helper类，来负责这样的映射，但我不是非常认同，我更倾向于创建一个中间viewModel来做，事实上很多时候我们把model就直接作为viewModel。 12345678910// Helper 方式Helper.apply(view:view, withModel:model)// ViewModel 方式class ViewModel &#123; init(model: Any)&#125;class View: UIView &#123; var viewModel: ViewModel &#123; set &#125;&#125; 那么按照这么做，MVC的界限就真的清楚了吗？其实并没有，所以让我们忘了MVC的分层吧，这仅仅是一种思路，抽象后的概念，真正在实践中去探索才是最好的。 之前看过百度的一位大神，他曾经嘲笑那些把请求放到view层的设计，但后来想不到自己也这么做了。那么这里我举个例子，我们就拿最常用的star功能来说吧。功能很小很简单，一个按钮一个请求就可以搞定，那么如果我们要严格按照MVC的方式来写，那么就至少需要在每一个V和C中都写逻辑，而这部分逻辑虽然都是一样的，但却很难以复用，那么就很容易出现’copy-paste’的情况，那么为了增加这种功能模块的内聚性该如何做呢？最简单的做法那就是直接在view里写逻辑！！！如下： 12345678910class StarButton: UIButton &#123; var id: String init(id: String) &#123; self.id = id self.addTarget(self, action: #selector(onStar(sender:)), for: .touchUpInside) &#125; func onStar(sender:UIButton) &#123; // request ... &#125;&#125; 使用时不需要关心具体逻辑，只要传入id就可以了。是不是比MVC写法更加的聚合？如果你说要在多平台复用，那么可以稍微改下，将逻辑部分改为策略模式，将创建改为工厂方法，这是题外话了。 所以接下来要忘掉所有所掌握的架构的知识，来看待这些问题，就如同张无忌学习太极剑法一样。 从结构上看的MVC我们先举一个非常简单的例子，登录页面。 1234567-----------------------| || name: [_______] || password: [_______] || [Login] || |----------------------- 基本功能是校验用户名密码，和登录。 那么我们想当然的就可以明白，所需要的两个方面： 1234class User &#123; var name: String? var password: String?&#125; 12345class View: UIView &#123; var nameTextField var passwordTextField var loginButton&#125; 那么这两者之间之间的交互逻辑呢，全部丢到一个第三方类中处理，这也就是我们的MVC结构中的Controller。 所以可以了解到，MVC是最符合我们了解一项功能的思维方式，所看到的东西抽象成view，所需要保存的数据结构抽象成model，那么剩下的所有东西都被丢到了controller中。这种方式非常容易理解，一个刚入门的新手也能很容易开始编码。但这也是噩梦的一个开始。 我相信大家所经历过的项目中，肯定一些controller超过1k行，甚至更多的，谁都不想去碰一下这类代码。这就是把其他东西全部丢进一个垃圾桶的缘故。最可悲的是这个垃圾桶很少会有人去清理，导致垃圾越来越多。 解决MVC中C的问题大家所说的Massive Controller的问题其实也很好解决，也有很多人来论述这种问题。 基本思路是细化MVC，将结构变成C-[MVCs]。比如上面可以拆分为 1234567891011121314151617class NameController &#123; var textField func validate() -&gt; (Bool, Error)&#125;class PasswordController &#123; var textField func validate() -&gt; (Bool, Error)&#125;class LoginController &#123; var button func login()&#125;class LoginViewController: UIViewController &#123; let nameController: NameController let passwordController: PasswordController let loginController: LoginController&#125; 注意Controller仅仅是一个概念上的划分，并不等于UIViewController。 如果是列表型可以参考DDComponent或者IGListKit的做法。 按照这种思路，我相信完全解决这类的问题。但是这样需要有经验的人士，或者在重构的时候进行拆分。 总的来说，MVC是一个非常简单，非常容易理解的架构。苹果选择MVC作为官方推荐架构应该也是有他的道理，毕竟要兼顾所有程序员，并且还要让大家能够容易的交流。但是要做好MVC也需要有一定的经验和思考。 从TDD来看MVP好，让我们忘了上面所说的东西，同样做一个登录的功能，但是这次我们从TDD的思路来进行。 首先，界面层是比较容易变化的，而且也是难以被单元测试的，亦或者说白盒测试view是没有什么意义的。其次数据层，单纯的测试model也没有特别大的意义，除非涉及到存储等这些功能。那么我们需要测试哪些东西呢，可以测试哪些东西呢，当然是我们的业务逻辑。 那么我们来理一下登录页面的业务逻辑 123func validateName(name: String) -&gt; (Bool, Error)func validatePassword(password: String) -&gt; (Bool, Error)func login(name: String, password: String) 然后可能有些内容需要更新回视图 1func applyView(view: UIView) 那么以上的内容我们称为Presenter 1234567891011121314protocol LoginView &#123; var name: String? var password: String?&#125;class Presenter &#123; var user: User var view: LoginView func validateName() -&gt; (Bool, Error) func validatePassword() -&gt; (Bool, Error) func login() func applyView()&#125; 这样就顺理成章的拥有了MVP的模式，那么UIViewController属于哪一层呢。按照我们测试的思路，UIViewController代表的是视图的行为，是不可测试的，当然就是属于View层的了。 从上面可以看出来，所谓的P特别像View-Model，其实两者可以说就是同一个概念。 MVP中P的问题首先，我看了很多人的文章，他们理解并不一致，都有部分的偏差，哪些属于P，P的概念也可大可小。虽然这种偏差并不影响这个架构的实现，但是让人感觉一种为了实现这种架构而实现的味道。而单纯的实现MVP并没有任何意义。 然后，MVP对人员的要求太高了。必须大家都是以测试优先来思考问题，而TDD本身就是一件非常困难的事情，对于整个团队的要求也非常高。 还有，MVP增加的代码量太大了，因为很多事件和逻辑都经过了一层转发，各个模块间的交互也增加了。 同样MVP也会遇到Massive Presenter的问题，解决方式与MVC也是类似的。 MVC与MVP那么Controller与Presenter的差别是什么呢？可以说如果代码写的好，两者几乎是一样的，仅仅是我们看问题的角度变化。当我们看问题的角度不一样时，所写的代码与逻辑就会产生差异，这种差异可能并没有我们想象的那么大，但在白盒测试这个环节上却是致命性的。 是否需要使用MVP结构，个人觉得很多情况下并不需要MVP，在结构良好的MVC中，完全可以解决大部分问题。在MVC中出现的一些问题，并不是单纯使用MVP就能解决的。 那么MVC和MVP能否结合使用？这个就像解决Massive Controller的方案一样，C-[MVPs]应该是较好的一种结合使用方式。 使用MVP改写StarButton的例子1234567891011121314151617181920212223242526272829303132333435363738394041protocol StarView: NSObjectProtocol &#123; var stared: Bool &#123; get set &#125;&#125;class StarPresenter &#123; var id: String weak var view: StarView? init(id: String, view: StarView) &#123; self.id = id self.view = view &#125; @objc func star() &#123; Request.request &#123; if let view = view &#123; view.stared = view.stared &#125; &#125; &#125;&#125;class StarButton: UIButton, StarView &#123; var id: String private var presenter: StarPresenter! var stared: Bool &#123; get &#123; return self.isSelected &#125; set &#123; self.isSelected = newValue &#125; &#125; init(id: String) &#123; self.id = id super.init(frame: .zero) presenter = StarPresenter(id: id, view: self) self.addTarget(presenter, action: #selector(StarPresenter.star), for: .touchUpInside) &#125;&#125; 可以感受下，这种方案和策略模式其实是非常类似的。不同点是MVP把界面更新这一步逻辑也移到了P中，对于白盒测试的可测性也更高。 最后从TDD的角度来看MVP，的确和MVC有着很大的不同，但是这些不同并不是单纯的代码上，而是思考的方式上，如果用这种思想去写MVC，我相信最后的结果和MVP也会趋于一致，所以请忘了我上面的胡诌。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"MVC","slug":"MVC","permalink":"http://djs66256.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"http://djs66256.github.io/tags/MVP/"},{"name":"MVVM","slug":"MVVM","permalink":"http://djs66256.github.io/tags/MVVM/"}]},{"title":"KVOController简析","date":"2017-07-13T13:03:47.000Z","path":"2017/07/13/2017-07-13-KVOController简析/","text":"关于KVO的使用，最常用的一个类库就是FB的KVOController了，还有一个HTBKVObservation，是解决了FB的循环引用的问题，但是后来FB的循环引用问题解决了。现在我们来简单看看这两者的实现方式。 实现其实两者的思想都是一样的，都是增加一个第三者，将消息处理和清理工作交给第三者进行。其中FB是利用了associate object是随着本身对象的释放而释放的特性来清理KVO的，而HTB则是利用hook dealloc方法进行清理的。 HTB的实现比较简单，所有东西都被放在了HTBKVObservation中，而FB则分为3个部分FBKVOController，_FBKVOSharedController，_FBKVOInfo。为什么FB会分为这么多部分，我认为是为了分离职责，但是个人觉得没有必要进行集中管理，除非想要撤销所有KVO的功能，但是我觉得不可能会有这个功能吧。 清理FB存在一个问题，那就是被观察对象被释放了，观察者可能并没有被移除，因为外部可能会持有KVOController，但是这样好像并没有什么大问题，因为被观察者释放了也就不会有KVO的消息了。 HTB则是在被观察者dealloc的时候强制移除所有KVO。 ReactiveReactive中也有类似的实现，思想其实还是一致的，只是把释放交给了dispose这个单独概念。 总结在这几个方案中，可以想到很多类型的问题都可以利用这种第三者的思路来解决，其实还有很多开源库也是利用该方案解决的。 另外在扩展的时候也不要一股脑的往NSObject上堆方法，利用第三者来处理这些方法可能会更加的优雅。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"KVO","slug":"KVO","permalink":"http://djs66256.github.io/tags/KVO/"},{"name":"KVOController","slug":"KVOController","permalink":"http://djs66256.github.io/tags/KVOController/"}]},{"title":"从应用角度看ReativeX","date":"2017-07-09T16:50:29.000Z","path":"2017/07/10/2017-07-10-从应用角度看ReativeX/","text":"这篇从我个人的角度聊聊ReactiveX这种思想的应用场景。 首先不论MVVM的使用场景，我也没有特别丰富的MVVM的使用经验。那么什么场景更加适合呢？ 请求如果只是单独的请求，那么也没有Reactive什么事情，但是当多个请求的时候，那么问题就来了。 多个请求就涉及到多次返回，那么如何组织这多次返回呢？可能有些场景要求按照发请求的顺序返回，有些场景可能仅需要任一个请求返回，又或者有些需要所有都返回的时候才触发回调，甚至可能有些请求存在依赖。 如何比较好的处理这些需求，那么Reactive本身就给我们一个很好的解决方案，可以说就是为了处理这种场景而生的。 流程很多时候，我们的一个流程会非常长，比如注册、首次登陆等等，而这些流程可能中间的某些步骤是可以复用的，然而很多不同的步骤所需要的参数可能也会稍有不同，那么如何表示这种流程比较好呢？ 把每一个步骤都做成Signal，那么这个问题就非常简单的解决了，不管流程的走向和分支是怎么样的，Reactive都能很好的解决，也不需要每一步都精心做好回调，然后把事件传递的到处都是。 总结这就不得不提一下monad这个概念了，只要符合pure function操作的所有行为，其实都可以定义为signal，并且利用各种组合来解决一定的时序问题。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"Reactive","slug":"Reactive","permalink":"http://djs66256.github.io/tags/Reactive/"}]},{"title":"从实现角度看ReativeX","date":"2017-07-09T09:42:34.000Z","path":"2017/07/09/2017-07-09-从实现角度看ReativeX/","text":"有很多在给人介绍Reactive的几个开源项目(ReactiveCocoa, RxSwift)的使用，我就不想在这个方面写什么了。我是一个实践主义者，所以我从我的角度来谈谈这种方案：解决了什么样的问题，怎么实现的，以及适合应用的场景。同时也加深自己对Reactive的理解。 这里我们来看看是怎么实现的，关于pure function和monad的部分我也不准备介绍了，毕竟我在这方面还不是特别熟悉。 signal observer首先我们来想一下一个最简单信号的流程。当一个信号被订阅时(subscribe)，发出信号后会触发订阅者(observer)执行下一步(sendNext)。那么一个最简单的信号(signal)和订阅者(observer)的协议就如下。 123456789protocol Observer &#123; func send(next: AnyObject) func send(error: NSError) func sendComplete()&#125;protocol Signal &#123; func subscribe(_ observer: \u0010Observer)&#125; 那么现在实现一个最简单的UIButton的信号。 12345678910111213141516171819202122232425262728293031class ButtonSignal: Signal &#123; var observer: Observer? init(button: UIButton) &#123; button .addTarget(self, action: #selector(onButton(sender:)), for: .touchUpInside) &#125; @objc func onButton(sender: UIButton) &#123; self.observer?.send(next: sender) &#125; func subscribe(_ observer: Observer) &#123; self.observer = observer &#125;&#125;class ButtonSignal: Signal &#123; var observer: Observer? init(button: UIButton) &#123; button .addTarget(self, action: #selector(onButton(sender:)), for: .touchUpInside) &#125; func onButton(sender: UIButton) &#123; self.observer?.send(next: sender) &#125; func subscribe(_ observer: Observer) &#123; self.observer = observer &#125;&#125; 然后实现一个最简单的订阅者。 1234567891011class ButtonObserver: Observer &#123; func send(next: AnyObject) &#123; print(&quot;send next!&quot;) &#125; func sendComplete() &#123; print(&quot;send complete&quot;) &#125; func send(error: NSError) &#123; print(&quot;send \\(error)&quot;) &#125;&#125; 最后连接起来 12signal = ButtonSignal(button: button)signal?.subscribe(ButtonObserver()) 那么问题来了，难道我们要为每个信号都创建一个类吗。当然不是，我们可以创建一个通用的信号和订阅者。 123456789101112131415161718192021222324252627282930313233343536373839class BlockSignal: Signal &#123; typealias CreateBlock = (Observer)-&gt;Void var block: CreateBlock init(block:@escaping CreateBlock) &#123; self.block = block &#125; func subscribe(_ observer: Observer) &#123; self.block(observer) &#125;&#125;class BlockObserver: Observer &#123; var next: (AnyObject)-&gt;Void var complete: ()-&gt;Void var error: (NSError)-&gt;Void init(next: @escaping (AnyObject)-&gt;Void, complete: @escaping ()-&gt;Void, error: @escaping (NSError)-&gt;Void) &#123; self.next = next self.complete = complete self.error = error &#125; @objc func send(next: AnyObject) &#123; self.next(next) &#125; func sendComplete() &#123; self.complete() &#125; func send(error: NSError) &#123; self.error(error) &#125;&#125; 同时在使用的过程时通过block来创建具体信号。 1234567891011121314signal = BlockSignal(block: &#123; (observer) in self.button.addTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside)&#125;)observer = BlockObserver(next: &#123; (sender) in print(&quot;send next!&quot;)&#125;, complete: &#123; print(&quot;send complete&quot;)&#125;) &#123; (error) in print(&quot;send error&quot;)&#125;signal?.subscribe(observer!) 以上就是最简单的信号量和订阅者实现。这里为了简洁的说明问题，所以没有考虑到内存方面的问题。 dispose上节说了内存方面的问题。还有一个问题就是如何取消订阅呢。那么这里需要有模块负责释放(dispose)。 那么将接口改为 1234567protocol Disposable &#123; func dispose()&#125;protocol Signal &#123; func subscribe(_ observer: Observer) -&gt; Disposable&#125; 实现也按照block形式 1234567891011121314151617class BlockDisposable: Disposable &#123; var block: ()-&gt;Void init(block: @escaping ()-&gt;Void) &#123; self.block = block &#125; func dispose() &#123; self.block() &#125;&#125;class BlockSignal: Signal &#123; func subscribe(_ observer: Observer) -&gt; Disposable &#123; return self.block(observer) &#125;&#125; 使用时和上面基本一致 12345678910signal = BlockSignal(block: &#123; (observer) in self.button.addTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside) return BlockDisposable(block: &#123; self.button.removeTarget(observer, action: #selector(BlockObserver.send(next:)), for: .touchUpInside) &#125;)&#125;) 需要解除订阅的时候 12self.disposable = signal?.subscribe(observer!)self.disposable?.dispose() 之后到目前为止，可以说signal-observer部分已经完全实现了。 其中冷信号和热信号也非常简单 1protocol Subject: Observer, Signal &#123;&#125; Scheduler也比较简单，将执行放到对应的队列中即可。 下篇结合我的角度来聊聊应用场景。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"ReativeX","slug":"ReativeX","permalink":"http://djs66256.github.io/tags/ReativeX/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"ReativeCocoa","slug":"ReativeCocoa","permalink":"http://djs66256.github.io/tags/ReativeCocoa/"}]},{"title":"全局数据同步（三）终极方案","date":"2017-07-06T18:39:17.000Z","path":"2017/07/07/2017-07-07-全局数据同步（三）终极方案/","text":"在全局数据同步系列文章中（一）（二）分别解决了model和view的全局同步，但是依然有一些问题，所以在这里给一个终极解决方案DDKeyPathChannel。 Star 重新来说明下解决的问题由于各种原因，目前有两个表示同一种类型的model。 123456789101112131415@interface UserModel1 : NSObject@property (strong, nonatomic) NSString *id;@property (strong, nonatomic) NSString *name;@property (assign, nonatomic) NSInteger age;@end@interface UserModel2 : NSObject@property (strong, nonatomic) NSString *id;@property (strong, nonatomic) NSString *nickName;@property (assign, nonatomic) NSInteger age;@end 现在需要其中一个属性修改了，或者第三方要求更新属性，如何更好的同步各个不同model之间的属性呢？ 另一个问题，又如何把这个状态更新到UI上呢？ 以前方案的问题首先，来看看之前解决方案的几个问题。 所有基类都需要实现特定接口协议。这对于model来说会比较简单，但是对于UIView来说就比较麻烦。 使用上，实现上比较麻烦，需要注意的地方比较多，容易犯错误。 那么有没有不影响到原来的类的方式呢？ 新思路既然现有的类去实现这个协议比较麻烦，那么找一个第三方类，永久的实现这个接口，并且把消息转发到现有的类不就可以了吗。 我们都知道有一个类不继承于NSObject，功能就是代理，那么我们利用这个类来做消息转发。 接口如下 1234567891011121314151617181920212223242526272829303132@interface DDKeyPathChannelBaseProxy : NSProxy &lt;DDKeyPathChannelProtocol&gt;// 以下两个属性确定对象唯一性@property (readonly, nonatomic) NSInteger channelType;@property (readonly, nonatomic) NSString *channelId;// 原本的对象@property (weak, readonly, nonatomic) __kindof NSObject *target;- (instancetype)initWithChannelType:(NSInteger)channelType channelId:(NSString *)channelId target:(NSObject *)target;@end// 这是一个通过keyPath+白名单的实现，可以通过mapper来映射真正的keyPath@interface DDKeyPathChannelProxy : DDKeyPathChannelBaseProxy@property (strong, nonatomic) NSArray&lt;NSString *&gt; *whiteList;@property (strong, nonatomic) NSDictionary&lt;NSString *, NSString *&gt; *keyPathMapper; // messageKeyPath : realKeyPath@property (strong, nonatomic) void(^valueWillChangeBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@property (strong, nonatomic) void(^valueDidChangeBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@end// 这是一个block的实现，可以在同步的时候自定义转换与实现@interface DDKeyPathBlockChannelProxy : DDKeyPathChannelBaseProxy@property (strong, nonatomic) NSString *keyPath;@property (strong, nonatomic) void(^valueChangedBlock)(__kindof NSObject *target, NSString *keyPath, __kindof id newValue);@end 转发的核心在于消息的传递 123456789101112131415// keyPath- (void)setValue:(id)value forKey:(NSString *)key &#123; if (self.valueWillChangeBlock) self.valueWillChangeBlock(self.target, key, value); [self.target setValue:value forKey:key]; if (self.valueDidChangeBlock) self.valueDidChangeBlock(self.target, key, value);&#125;// block- (void)setValue:(id)value forKey:(NSString *)key &#123; if ([key isEqualToString:self.keyPath]) &#123; if (self.valueChangedBlock) &#123; self.valueChangedBlock(self.target, key, value); &#125; &#125;&#125; 那么我们怎么去挂载这个代理对象呢，想到associate object，那么我们也很容易的控制自己的生命周期了。 这样，我们就不需要在现有类中实现方法来支持该功能了，而且这样也更好的封装屏蔽了这些比较特殊的功能。在实践中感觉这种方式的使用成本是最低的，大家也比较容易接受。 12345678910111213141516[self.user1 bindChannelType:ChannelTypeUser channelId:self.user1.id];[self.user2 addChannelProxyWithChannelType:ChannelTypeUser channelId:self.user2.id config:^(DDKeyPathChannelProxy *proxy) &#123; proxy.keyPathMapper = @&#123; @&quot;name&quot;: @&quot;nickName&quot; &#125;;&#125;];// 更新属性[[DDKeyPathChannelManager sharedChannel] emitChannelType:ChannelTypeUser channelId:@&quot;1&quot; value:@&quot;Tom&quot; forKeyPath:@&quot;name&quot;];[[DDKeyPathChannelManager sharedChannel] emitChannelType:ChannelTypeUser channelId:@&quot;1&quot; value:@(30) forKeyPath:@&quot;age&quot;]; UI层更新也可以通过这种方式，也可以选择使用KVO。 题外话关于这个功能，很多人肯定想到了ReactiveX，关于这点，两者的确有部分相似的场景，但也有很多不同的地方。 关于更新UI这点，两者从效果上来看的确是一致的 1object -&gt; (signal, keyPath) -&gt; UI 两者最大的不同在于，ReactiveX是monad的思想，是有输入输出，拥有明确的输入对象和观察对象，行为流程是从上游到下游。而本套方案是一个中间人模式，是一个星状结构，更像通知一点。 但是两者思想是类似的，ReactiveX是把各种行为封装成Signal，而我们是把消息使用keyPath来承载与转发。 如果想要使用ReactiveX来实现这个功能也不是不可以，创建一个全局的热型号(subject)，控制好回收(dispose)，也是可以实现该功能，但总感觉和RX的概念有点偏差了。 总结从第一篇方案，到现在最终比较完美的一套方案，也是因为我们的需求在一步一步的变化，要求我们使用更好、更灵活的方案才能满足的结果。这个过程是一个不断思考不断反思的过程，从这个方案的演化中，我深有感悟，很多东西在创造出来的时候看似完美，但实际上还有很大的完善空间，同时别人的方案也会对自己的想法有很多的帮助。所以多了解别人的实现方案对自己的提升还是很有帮助的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"DDKeyPathChannel","slug":"DDKeyPathChannel","permalink":"http://djs66256.github.io/tags/DDKeyPathChannel/"},{"name":"ReativeX","slug":"ReativeX","permalink":"http://djs66256.github.io/tags/ReativeX/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://djs66256.github.io/tags/RxSwift/"},{"name":"ReativeCocoa","slug":"ReativeCocoa","permalink":"http://djs66256.github.io/tags/ReativeCocoa/"}]},{"title":"部分LLVM编译优化与宏定义优化","date":"2017-06-23T17:08:16.000Z","path":"2017/06/24/2017-06-24-部分LLVM编译优化与宏定义优化/","text":"整理部分我用到的简单的宏定义以及编译优化。 字符串常量化平时可能会需要使用selector作为string来使用，通常使用的是NSStringFromSelector，但是却不知道在使用这种方法的时候产生了一次内存拷贝。为了能够充分利用内存，这里可以做一个优化。 12345#if DEBUG#define SelStr(sel) NSStringFromSelector(sel)#else#define SelStr(sel) @#sel#endif 这里和RAC比有个缺点就是不能处理sel1.sel2这样的keypath，但是不需要依赖变量。 同样，class也可以这么做。很多时候在register cell的时候，我习惯使用class name，这样可以确保唯一性，也可以减少定义常量的麻烦。 12345#if DEBUG#define ClassStr(cls) NSStringFromClass(cls)#else#define ClassStr(cls) @#cls#endif 这种方法简单，而且在开发的时候能够自动补全和校验正确性，但也存在着一些小问题，注意不要错误使用。比如： 12345SEL sel = @selector(action:)NSString *selName = SelStr(sel)Class cls = [self class]NSString *clsName = ClassStr(cls) Super保护super的调用 1NS_REQUIRE_SUPER Objc final关键字禁止子类化 1__attribute__((objc_subclassing_restricted)) constructor &amp; destructor12__attribute__((constructor))__attribute__((destructor)) 在程序或动态库载入和退出的时候调用，时机比main()要早。 __DATA, name1__attribute((used, section(&quot;__DATA,sectname&quot;))) 可以将全局变量数据放到sectname数据段，以区分其他数据段。可以通过getsectiondata取出。 format1__attribute__((format(printf, m, n))) 能够编译期识别format，提供warning信息 Assertion平时开发的时候很多人不注意的一点是不标明入参是否为空，或者其他一些临界情况，这是非常不好的一种习惯，而且很容易导致问题。 一种方法是使用编译器自带的检查nonull，但是这个需要在所有方法以及属性中标明，需要一定工作量，而且不能在.m中使用。 另一种方法是直接使用assert来断言参数，这种方法简单，而且只要看到第一行就能知道参数情况。并且能够在运行时帮助解决不合理调用的情况。而官方就提供了这类定义。 12NSParameterAssert(param != nil)NSCParameterAssert(param != nil) 使用非常简单，实现也是非常巧妙。 编译优化有时候考虑到性能，往往需要把函数定义为inline，编译器对于inline函数的行为是不确定的，也就是说inline函数最终编译结果可能不是inline的，这里可以强制使他成为inline。这种场景虽然少见，但也是一个优化点。 1__attribute__((__always_inline__)) 对于像工厂方法，创建对象的方法，如果返回值没有被使用也是一种浪费，这里可以让编译器直接报警告。 1__attribute__((warn_unused_result)) 宏编译上面提到了很多宏，平时使用过程中可能也会产生很多宏。在开发宏的过程尤为痛苦，这里就需要编译器的预编译宏功能来帮助我们了。 1clang -E 可以将宏编译为代码，这样就可以省去很多调试时间。","categories":[],"tags":[]},{"title":"数据源Diff算法分析","date":"2017-06-22T16:04:12.000Z","path":"2017/06/23/2017-06-23-数据源Diff算法分析/","text":"在IGList中有一个非常神奇的功能，就是可以根据数据源直接算出列表变化，采用update的方式更新列表，不需要每次都调用reloadData。我也想将这个功能引入DDComponent，所以就对diff功能稍微看了看。 由于IGList是数据驱动的，所以他有着天然的前提可以利用，而DDComponent是基于结构来组合的，所以需要一些额外的接口来暴露数据源。这些都是题外话了，现在来看看diff的两种实现。 恰好最近看到一篇文章介绍数据源diff的，他所介绍的是Doppelganger。现在就Doppelganger和IGList里面的算法进行分析。 Doppelgangerdiff的结果使用如下结构，这个设计其实有部分冗余，可能作者是为了返回结果的统一性才做成这样的。 12345678910111213typedef NS_ENUM(NSInteger, WMLArrayDiffType) &#123; WMLArrayDiffTypeMove, WMLArrayDiffTypeInsert, WMLArrayDiffTypeDelete&#125;;@interface WMLArrayDiff : NSObject@property (nonatomic, readonly) WMLArrayDiffType type;@property (nonatomic, readonly) NSUInteger previousIndex;@property (nonatomic, readonly) NSUInteger currentIndex;@end 算法部分 1234// delete和insert都比较简单，我们来看moveNSArray *moveDiffs = [self _moveDiffsWithDeletedObjects:deletedObject insertedObjects:insertedObjects];NSArray *deletionDiffs = [self _deletionsForArray:self.previousArray deletedObjects:deletedObject];NSArray *insertionDiffs = [self _insertionForArray:self.currentArray insertedObjects:insertedObjects]; 1234567891011121314151617181920212223242526__block NSInteger delta = 0;// 这里的delta代表了被删除的个数，realIndex = originalIndex - deltaNSMutableArray *result = [NSMutableArray array];[self.previousArray enumerateObjectsUsingBlock:^(id leftObj, NSUInteger leftIdx, BOOL *stop) &#123; if ([deletedObjects containsObject:leftObj]) &#123; delta++; return; &#125; NSUInteger localDelta = delta; // 同时新增一个的个数也会产生偏移, realIndex = originalIndex - deletedDelta + insertDelta for (NSUInteger rightIdx = 0; rightIdx &lt; self.currentArray.count; ++rightIdx) &#123; id rightObj = self.currentArray[rightIdx]; if ([insertedObjects containsObject:rightObj]) &#123; localDelta--; continue; &#125; if (![rightObj isEqual:leftObj]) &#123; continue; &#125; NSInteger adjustedRightIdx = rightIdx + localDelta; if (leftIdx != rightIdx &amp;&amp; adjustedRightIdx != leftIdx) &#123; [result addObject:[WMLArrayDiff arrayDiffForMoveFromIndex:leftIdx toIndex:rightIdx]]; &#125; return; &#125;&#125;]; 作者认为他的算法是o(n^2)，真的是这样吗？ 一眼看去这里出现了两个for循环，应该就是o(n^2)，但是别忘了[insertedObjects containsObject:rightObj]，很遗憾这里的复杂度应该为o(n)，所以最终他的算法应该是o(n^3)。 同时在计算delete和insert的时候，复杂度也不是o(n)的。而且在整个算法中大量调用isEqual:也会导致效率降低。 可以说这个如果是少部分场景使用是没有问题的，但是大量内容的时候可能会出现性能问题。 IGList很多时候，算法优化都是用空间来换取时间，这里来简要说明一下IGList的做法。 维护一个局部表table用来保存所有的元素，包括新的和旧的。 遍历一次新旧dataSource，加入1中的table，并且再生成两份包含位置信息的对应数组newArray, oldArray。 遍历一次newArray，由于元素包含新、旧的位置信息，所以不需要去old查找就可以直接根据index取出，这样就可以判断移动的元素了。 同样为了解决insert和delete导致的index偏移，IG采用的方式是创建一个数组，分别存储每个元素位置所对应的insertOffset和deleteOffset，这样也只需要for循环一次就够了。 如果不算table的复杂度，结果为o(n)，如果算table的复杂度，那么就是table的复杂度。 缺点是需要使用hash table，需要一个唯一的key(特定情况下可以是指针值)。 同时IG是用c++编写，大大降低了调用开销。以后DDComponent需要增加auto diff的功能的时候可以参考IG的实现方式。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"IGList","slug":"IGList","permalink":"http://djs66256.github.io/tags/IGList/"},{"name":"DDComponent","slug":"DDComponent","permalink":"http://djs66256.github.io/tags/DDComponent/"},{"name":"diff","slug":"diff","permalink":"http://djs66256.github.io/tags/diff/"}]},{"title":"dispatch备忘录","date":"2017-06-22T15:08:13.000Z","path":"2017/06/22/2017-06-22-dispatch备忘录/","text":"记录一些平时不会注意到的dispatch点 dispatch_groupdispatch_group的底层实现是怎么样的呢？ 在阅读官方源码的时候发现一个很有意思的地方，dispatch_group居然和semaphore是同一个东西。dispatch_group可以说是semaphore的一个特定扩展实现。 我们从业务需求上来说，的确group也是可以用semaphore来实现相同的功能。 dispatch_once以前一直以为dispatch_once是一个单纯的经过系统优化的锁而已，然而官方实现上要复杂很多，运行时会维护一个链表来执行，这样做可能是为了减少使用锁的情况。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"dispatch","slug":"dispatch","permalink":"http://djs66256.github.io/tags/dispatch/"}]},{"title":"DDSkin做更好的换肤框架","date":"2017-06-18T16:04:12.000Z","path":"2017/06/19/2017-06-19-DDSkin做更好的换肤框架/","text":"在很早的时候，就考虑过换肤功能的实现，一直到现在为止都没有看到特别好的系统化的实现。所以这里自己实现了一套自认为比较好的DDSkin，同时总结一下几种实现方式的利弊。 Star 实现方式总的来说实现方式应该是比较统一的，使用string类型的key来代替各个image, color属性。 最早的时候，考虑过使用Proxy来替换默认的image, color实现，将消息代理到真正的实例，这样就可以动态的替换底层映射的真实对象了。但是这样做有一个问题，真实对象变化后无法主动更新到界面，这个比较难以触发自动更新，所以不太靠谱。 手动模式在更换皮肤的时候发出通知，在各个需要变化皮肤的地方手动注册通知，并且更新UI。 这是最笨的方法，但是在少量场景的时候也是最好的解决方法，简单而且侵入性小。 method swizzling既然我们觉得注册通知并更新UI这种操作比较固定，而且繁琐，可以一次性的解决，那么很容易想到去hook部分接口，自动注册监听。 虽然这样解决了通知注册的问题，但是method swizzling本身就不是一种好的解决方案。 hook的方法是否可以被绕过，通过不同方式创建的对象所调用的方法是不一样的。 每个对象都会参与监听，会导致监听对象非常庞大，并且可能不需要更新的对象也会加入监听。 侵入性大，我们只能hook一些基类的方法，一不小心可能就会注册两次。 associated object同样作为通知的方案，既然method swizzling不行，那么可以让一个第三方对象去监听，然后自动触发更新。 这是一个比较好的解决方案，他减少了侵入性，并且更加灵活以及可靠。但是同样，作为一个修改基类来实现的方案也有很多的缺点。 由于associated object绑定实在基类进行，那么就不能排除子类覆盖了该方法的可能性，同时选定那个基类也是个问题，NSObject, UIView? 同时侵入性虽然小了，但还是存在的，毕竟影响的是基类的行为。 使用了objc runtime，这意味着什么呢？在一个swift为趋势的环境下，这种方案也是一种一般的解决方案。 weak table参考weak属性的实现方式，这里可以使用weak table。将所有有换肤需求的对象注册到一个weak table中，在换肤的时候只需要更新表中的对象即可，这样就不需要通知，同时也分离了换肤这个功能和实际对象之间的联系。 特性既然我们是一个通用型的框架，就必须考虑几点。 通用性既然我们支持了UIView的属性，那么可能我们会需要支持非视图的属性，比如View model，那么考虑到如此的通用性，设计的时候就不能局限于View。 同时，对于swift对象也可以比较好的支持。 扩展性有很多样式，不是简单的配置属性就能够达到效果的，比如富文本等，那么就要求框架能够有一定的扩展性。 DDSkin简介主要分成3部分 core 负责注册对象，并且在样式更新时触发所有注册对象的更新。 handler 对象更新操作，负责具体的更新操作。 storage 皮肤样式存储，可支持继承。 core使用了读写锁来确保线程安全，实际使用时由于UI操作需要在主线程，所以基本上来说都会在主线程操作，这里的锁可能会有点多余。 提供了c和oc两种接口，使用c是为了减少消息调用开销，实际情况应该也不会有太大影响。 1234567891011121314151617181920212223242526272829303132333435363738// 注册配置项void DDSkinRegisterTargetHandler(NSObject *target, DDSkinHandler *handler, BOOL apply) &#123; NSCParameterAssert(target != nil); NSMapTable&lt;NSObject *, NSMutableSet&lt;DDSkinHandler *&gt; *&gt; *mapTable = DDSkinGetTargetHandlerTable(); DDSkinTargetHandlerTableWriteLock(&#123; NSMutableSet&lt;DDSkinHandler *&gt; *handlerSet = [mapTable objectForKey:target]; if (handlerSet == nil) &#123; handlerSet = [[NSMutableSet alloc] init]; [mapTable setObject:handlerSet forKey:target]; &#125; [handlerSet addObject:handler]; &#125;); if (apply) &#123; // When apply is true, must call at main thread? // Usually apply is on the UI thread. // So we make it must be on the main thread! DDCAssertMainThread(); DDMainThreadRun(&#123; [handler handleSkinChanged:DDSkinGetCurrentStorage() target:target]; &#125;); &#125;&#125;// 更新配置void DDSkinRefreshAllTarget() &#123; NSMapTable&lt;NSObject *, NSMutableSet&lt;DDSkinHandler *&gt; *&gt; *mapTable = DDSkinGetTargetHandlerTable(); DDMainThreadRun(&#123; [[NSNotificationCenter defaultCenter] postNotificationName:DDSkinStorageWillChangeNotification object:nil]; DDSkinTargetHandlerTableReadLock(&#123; for (NSObject *target in mapTable.keyEnumerator) &#123; NSMutableSet&lt;DDSkinHandler *&gt; *handlerSet = [mapTable objectForKey:target]; for (DDSkinHandler *handler in handlerSet) &#123; [handler handleSkinChanged:DDSkinGetCurrentStorage() target:target]; &#125; &#125; &#125;); [[NSNotificationCenter defaultCenter] postNotificationName:NSCurrentLocaleDidChangeNotification object:nil]; &#125;);&#125; handler为了保证通用性和可扩展性，这里默认提供了两种实现。keyPath和block。keyPath使用的是setValue接口，属于上层接口，并不涉及oc底层，所以可以支持swift原生类。同时block提供了一种更为灵活的方案。 storage本身不同团队会有不同的数据存储方案，那么这一块的变动应该是框架里最大的，所以这里提供的是协议，并且默认实现了一套以NSDictionary为基础的的方案。 12345678910111213@protocol DDSkinStorageProtocol &lt;NSObject&gt;- (NSObject *)objectForKey:(NSString *)key;- (UIColor *)colorForKey:(NSString *)key;- (NSString *)stringForKey:(NSString *)key;- (NSURL *)urlForKey:(NSString *)key;- (UIImage *)imageForKey:(NSString *)key;- (NSNumber *)numberForKey:(NSString *)key;- (UIFont *)fontForKey:(NSString *)key;- (NSNumber *)booleanForKey:(NSString *)key;- (NSValue *)sizeForKey:(NSString *)key;@end 每种类型设计一个接口是为了确保类型安全，防止因为误操作而出现的类型错误。 关于image，如果我们每次解析完都保存为UIImage对象，会导致内存的浪费，所以这里提供一种lazy-load的方案。这是具体实现上的方案，完全可以自己实现。 123@protocol DDSkinStorageItemLazyLoad &lt;NSObject&gt;- (id)value;@end UI层扩展基于以上几点，那么UI层就不需要在基类中做什么事情了，只需要在支持的类型上增加部分扩展方法即可。 1234567891011121314151617181920@property (strong, nonatomic, nullable) IBInspectable NSString *backgroundColorSkinKey;- (NSString *)backgroundColorSkinKey &#123; DDSkinHandler *handler = DDSkinGetTargetHandlerByKey(self, DDSelStr(backgroundColor)); return handler.storageKey;&#125;- (void)setBackgroundColorSkinKey:(NSString *)backgroundColorSkinKey &#123; DDAssertMainThread(); if (backgroundColorSkinKey) &#123; DDSkinHandler *handler = [DDSkinHandler handlerWithKeyPath:DDSelStr(backgroundColor) valueType:DDSkinHandlerKeyPathValueTypeColor storageKey:backgroundColorSkinKey]; DDSkinRegisterTargetHandler(self, handler, true); &#125; else &#123; DDSkinUnregisterTargetHandler(self, DDSelStr(backgroundColor)); self.backgroundColor = nil; &#125;&#125; 由于大部分场景下这部分代码是重复的，所以这里使用了大量宏定义来解决这个问题。 12// 上述内容可以改为DDSkinPropertyDefine(backgroundColor, BackgroundColor, color, Color); xcode高亮状态： 为什么把key定义成这样，不加前缀是为了在IB中设置的时候不会每个都有个奇怪的前缀。 使用如果使用的是IB或者StoryBoard，可以直接设置属性一样配置 如果使用代码编写也只需要更新属性 12[self.view setBackgroundColorSkinKey:@&quot;red&quot;];self.view.backgroundColorSkinKey = @&quot;red&quot;; storage的默认实现为DDSkinDefaultStorageParser，也可以自定义实现。默认配置文件实现为plist，支持继承，super为父配置。 总结可以看到，虽然DDSkin的出发点是一套换肤方案，但实际上来说概念应该更加的广，应该定义为一套配置化方案。由于其他配置化的数据刷新可能不像UI那么简单，autolayout可以自动更新，使用上会稍显麻烦一点。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"DDSkin","slug":"DDSkin","permalink":"http://djs66256.github.io/tags/DDSkin/"},{"name":"换肤","slug":"换肤","permalink":"http://djs66256.github.io/tags/%E6%8D%A2%E8%82%A4/"},{"name":"夜间模式","slug":"夜间模式","permalink":"http://djs66256.github.io/tags/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"}]},{"title":"IGListKit简析与DDComponent","date":"2017-05-23T13:31:25.000Z","path":"2017/05/23/2017-05-23-IGListKit分析/","text":"在我们的项目中大量使用了列表以及模块化的思想，所以才有了DDComponent，这个的原理在之前的美学的表现层组件化之路详细的说明了使用方式。最近翻了翻IGListKit的代码，发现他的思想和我的思想非常的类似，但也有部分区别，这里就来分析下IGListKit的场景。 Star 首先，来看看IGListKit的使用IGListKit封装了UICollectionView的Api，下面是一个最简单的例子。 1234567891011let dataSource = [1, 2, 3, 4, 5, 6]func objects(for listAdapter: ListAdapter) -&gt; [ListDiffable] &#123; return dataSource&#125;func listAdapter(_ listAdapter: ListAdapter, sectionControllerFor object: Any) -&gt; ListSectionController &#123; return DisplaySectionController()&#125;func emptyView(for listAdapter: ListAdapter) -&gt; UIView? &#123; return nil &#125; 虽然经过封装，但还是逃不过回调布局，我觉得这是IGListKit没有做好的一步。 根据官方说明，这是一个数据驱动(data drive)的组件化实现。 那么数据驱动体现在哪儿呢？ 所有组件均对应于一个viewModel，而每个viewModel均对应于一个controller，每个controller实现视图，所以接口概括起来应该是 1Model -&gt; ViewModel -&gt; Controller &lt;-&gt; View 所有的组件都基于viewModel来组装和实现。所以如果需要更新列表就必须更新dataSource。这样设计有它的优点，也有它的一些缺点，在之后的内容中会展开分析。 IGListKit把各种回调dataSource和delegate都细分成各个组成部分，也就是说具体数据和事件还可以再细分下去（其实经过这一层的切分，每个controller一般不会太笨重）。 对比DDComponent的优劣两者的目的都是一样的，利用UICollectionView来布局一个内容非常多，非常长的页面，以减少复杂度。同时又将数据按照结构进行切分，分散到各个模块，然后加以重用。 IGListKit是一个备受关注的项目，而DDComponent在我们的项目中应用的非常广泛，可以说两者都具备很好的实践检验。 学习成本IGListKit基于系统API自己又封装了一层，目的是为了拆分后的dataSource和index能够一一对应，同时又把各种回调都拆成单个属性。这样做进一步的细化了每个组件的实现。 而DDComponent则完全使用了系统的API，使用上仅需要关心本模块的实现就好了。和UICollectionViewController一样，delegate和dataSource都是自身，可以看做是Controller的拆分。由于采用系统方法，所以暴露的是indexPath，和一个模块内的数据源可能不是一一对应的，这需要使用者自己处理。 总的来说，DDComponent和系统接口相似，学习成本较低。 拆分粒度IGListKit相当于把臃肿的dataSource和delegate移出controller和把UICollectionViewController拆分为多个子controller。所以IGListKit的粒度是要更细一些的。但是我们从实用程度来看看需要什么粒度。 根据我目前项目里的经验，controller中UICollectionView相关的功能都已经已到component中实现，目前只负责部分业务逻辑，所以一般不会超过500行。而每个component也只是负责本模块的展示与业务逻辑，也基本不会超过500行，所以从粒度来看，一次拆分已经足够了，应该能够满足绝大部分场景了。 结构IGListKit就如以上所说的 1Model -&gt; ViewModel -&gt; Controller &lt;-&gt; View 而DDComponent则较为简单，这里的Component对应于IGListKit的Controller+viewModel，这两者的功能都是类似的，相当于子controller，但两者都没有继承于UIViewController。 1Model -&gt; Component &lt;-&gt; View 所以在使用上DDComponent不需要必须为每个组件创建一个对应的viewModel，也就更为方便。 使用上虽然IGListKit将列表拆分为组件，但是依然还是依赖于numberOf和sectionControllerFor这样的回调来映射每个viewModel，这就导致了如果一个列表有太多类型的viewModel，依然会导致回调的代码膨胀。 同时IGListKit仅支持到section，不支持嵌套，也就是不能在组件中再放组件，所以灵活性上来说并不如DDComponent。 DDComponent组装结构依靠的是component数组，同时并没有限定一个component所对应的section或者item的数量，所以可以支持到每个item，并且支持嵌套。所以很容易支持到下面的结构。这种组合方式可以让我们将组件进一步拆分为子组件，使每个组件唯一对应于一种view。 123456RootComponent |-- SectionComponent(1) |-- SectionComponent(2-5) |-- SectionComponent(6) |-- ItemComponent(1) |-- ItemComponent(2-5) 同时DDComponent的思想是组成viewModel-component-view的一一对应，也就是说一个component所负责展示的只有一种类型，像header, footer这种也是完全拆分开来，完全根据配置和组合来建立页面。相比会更加灵活。 出发点IGListKit的思想来源应该是MVVM，核心是数据，界面按照数据来排布。 而DDComponent的思想来源则是传统的MVC，以controller为核心，通过各种形式的组合形成一个整体界面，组合是组件化的关键。 按照数据来切分(IGListKit)的优势在于对于数据的操作处理上会更加简单，比如增加、删除某条数据。而按照结构来切分(DDComponent)则在状态切换(Loading, Error…)，界面组合(Header, Footer)上更方便。 可扩展性两者都可以通过传递方法回调来进行功能扩展，不仅仅是delegate，可以是任意的协议。 两者都需要自己去增加传递的代码，都会比较麻烦，这一点希望未来我能解决DDComponent的消息传递问题。 复用性两者都是为了复用而产生的，所以双方的复用性都非常不错。不同的是IGListKit是强制依赖viewModel和controller两者来进行，而DDComponent必须的是component，当然也可以拆分为viewModel-component。 最后IGListKit我使用的并不多，所以有些地方的观点有些偏颇，可能有办法解决他不能灵活配置的问题。但是从我的观点来说，如果你的应用中有大量相同或者相似的列表模块，同时组合方式又是比较随机，我相信你会更喜欢DDComponent。如果你的列表数据源经常变化，比如编辑功能，IGListKit会做的更好一些。 以上谈到的DDComponent的组件化思想，经过半年时间，以及在自己项目中的使用和积累的心得，其实真正应用的场景比最初设计的场景要少得多，接口可以再进一步的简化和改善（indexPath的问题），将来会再做一次重构。同时解决一些扩展性的问题。相信可以完全媲美并且替代IGListKit。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"DDComponent","slug":"DDComponent","permalink":"http://djs66256.github.io/tags/DDComponent/"},{"name":"IGListKit","slug":"IGListKit","permalink":"http://djs66256.github.io/tags/IGListKit/"}]},{"title":"我们需不需要使用AsyncDisplayKit来优化速度","date":"2017-05-23T12:32:04.000Z","path":"2017/05/23/2017-05-23-我们需不需要使用AsyncDisplayKit来优化速度/","text":"我们项目单个页面比较复杂，内容比较多，对渲染的性能要求也比较高，之前也出现过几个性能问题，所以就去翻了下AsyncDisplayKit的源码，看看是否可以接入项目来优化性能。 AsyncDisplayKit的基本原理很简单，异步绘制图片，然后直接通过layer的contents直接传递给GPU绘制。的确这样永远不会卡在主线程，也不会卡在GPU的性能上，但是这么做也带来了一些不好的影响。 并没有实质性的优化性能。他只是把原本会阻塞主线程的内容，转移到了子线程，或者会阻塞GPU的内容，转移到了CPU中完成。这样做只是表面上帧率达到了很高，但是某些东西移到CPU后，反而不能更好的利用GPU，同时内存在CPU和GPU之间拷贝也会损耗部分性能，所以很多情况下是得不偿失的，界面会呈现空白一小段时间。 内存问题，在reuse view中，Node部分并不会发生重用，所以如果你在Node里面占用了很多内存的话，很容易导致内存上涨加快。 控制复杂，依赖程序员能力。AsyncDisplayKit很大程度是依靠图层的合并来做的，并且需要程序员自己来判断哪些需要合并，这就非常的依赖个人能力以及对AsyncDisplayKit的了解了。 在reuse view里面的表现并不好。在快速滑动时，确实不会有卡顿现象了，但是在快速的reuse过程中，绘制队列可能会进入一个产生小于消费的过程，这时候会导致界面的闪烁（新的库Texture表现好一点）。同时这也会导致空白时间的延长。 所以在绝大部分场景，我们都不应该依赖AsyncDisplayKit来解决我们的卡顿问题。事实上，我们项目经过几次的优化已经拥有了非常良好的体验，也没有使用如此庞大的一个系统，可以说目前的设备性能能够满足我们几户所有的视觉要求。 但是AsyncDisplayKit也有我们可以借鉴的地方。 内存释放。AsyncDisplayKit专门创建了一个子线程去释放内存，这可以给我们一个思路，在需要大量释放非UI内存的时候，完全可以抛给子线程做，这样就不会导致一次性大量释放内存带来的卡顿。参考下Java可怜的GC，一旦发生GC，整个程序都被暂停了。 异步绘制。的确有部分内容需要我们去异步绘制，控制好各个视图的合并和更新重绘能够提升性能。 布局。AsyncDisplayKit嫌弃苹果的AutoLayout太慢，直接自己搞了一套Flex布局，来提升性能。同样我们也可以尝试减少AutoLayout给我们带来的性能损耗，在一些常用控件和复杂场景使用手动布局的方式。 或许我们可以在非常小的范围使用它，但是在我看来，几乎没有需要引入整个开源库的必要，几乎没有那么复杂的视图需要我们如此去绘制。 ps. Texture 发展比较快，可以继续观察下他做了哪些优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://djs66256.github.io/tags/AsyncDisplayKit/"}]},{"title":"关于架构师的杂谈","date":"2017-05-20T13:30:08.000Z","path":"2017/05/20/2017-05-20-关于架构师的杂谈/","text":"看到一些讲架构的文章，和我早期的一些想法一样，有些时候过于的学术派，一定要区分个模块、套上什么模式之类的，所以这里聊聊我的看法。 在我入坑早期的时候，非常的看重设计模式这类的学术型论述，非常的崇拜那些一出来就把层级、架构讲的条条是道的人。曾经有位多年经验的人告诉我，不要太纠结于设计模式这种虚的东西。当时的我还不怎么认同，直到最近，自己从零开始，参与并作为主要开发人员完成了一个项目从无到有的过程，在此期间也遇到并解决了很多问题，由此感受到了之前别人所说的话的意义。 很多东西，比如层级、框架都不是一开始就能够完全的设计好的。在一开始的时候，我也不知道我们的应用会变成什么样子，或者说目前的结构和一开始构思的已经几乎完全不一样了。在不断的需求迭代过程中，我们才慢慢知道，真正需要的是一个什么样的框架。比如是一个快速迭代，功能有比较统一的可以尽量模块化来进行复用，而一个功能稳定的内容则需要设计的简单可靠。所以问你一个功能应该怎么设计是不能判断一个人的能力有多高的，虽然可以刷掉一部分差的。 现在大家说的mvc，mvvm这些模式也是别人总结出来的，我们难道一定需要按部就班的去按照这个模式去写吗。当然不是，人是活的，谁能知道以后会不会由你来创造一个新的模式呢。很多时候去争论某些内容是属于v还是属于m其实也是没有太大的意义的。当不同人从不同的角度去看问题的时候，自然就可能会有不同的理解，所以好用的才是好的。当然这里也不是鼓励不考虑这些框架，而是现实情况下，这些框架都有一部分的缺陷，为了简单可靠的弥补这些缺陷，可能就会有些争论的部分。 那么学术派的理论难道是没用的吗？当然不是，理论是高度概括的实践经验，当你了解了所有的设计模式，需要的不是想套用公式那样套用，而是真正的去理解这样做的是为了解决什么样的问题。就像张无忌学习太极，记住了所有招式，然后又忘记了所有招式。根据实际情况利用模式里面解决问题的方法才是学习理论的目的。不过好像目前iOS端能够使用到的设计模式比较单一，很多人也就停留在单例，工厂这些。 最后再来说说架构师。服务端，如果使用的是一个稳定的开源框架，比如spring，几乎不需要什么二次开发的，几乎所有功能组件都有现成的，仅仅需要按照文档来搭建好就可以了，一般的项目来说这些就足够了，那么什么样的程度才算的上是架构师这个职称呢？同样前端，目前的技术更新比较快速，但目前这些技术框架，比较有名的都来源于国外，国内都在忙这学习。那来说说客户端，客户端的模式基本比较单一，都是按照官方的规范来做，如果自己搞一套，那么简直作死，同时客户端的组件比较分散，既可以用a的组件也可以使用b的组件，但总体来说这些组件都是一些小功能小模块，还不足以按上一个架构的名号，同时国内大部分以业务开发为主的行情来看，如何才能达到架构师这个职称呢？所以在国内很多互联网行业所谓架构师的应该仅仅是技术选型的人员。 综合来说，架构师绝非一蹴而就，需要非常多的项目经验和理论知识，涉及多个编程领域，才能设计的出一个比较好用的东西。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"Flex箱型布局在移动端的应用","date":"2017-05-16T15:27:01.000Z","path":"2017/05/16/2017-05-16-Flex箱型布局在移动端的应用/","text":"在平时开发过程中，用的最多的布局方式当然就是苹果自带的AutoLayout，但是使用的过程中也发现AutoLayout自身也有很多的问题。在我们的项目中，由于展现逻辑比较灵活，视觉每期的变化比较大，在使用过程中，很大一部分时间都在调整视觉中，所以想引入一个更简单的布局方式，这就是大名鼎鼎的Flex，也叫箱型布局。 首先来看看我们在AutoLayout中遇到的几个问题AutoLayout自身的API简直反人类，所以大家使用过程中往往会引入第三方库（Masonry, PureLayout)。Masonry看上去更加直观，但是不太符合OC的编码习惯，PureLayout更符合OC的规范，使用起来也稍复杂点。两者都有很多的使用者。虽然第三方库简化了API，但并没有简化场景。 另一个AutoLayout令人诟病的问题，就是当视图增加的时候，计算复杂度成倍上升。AutoLayout依靠解线性方程组，所以越多的视图性能下降非常大。 在使用场景上，举几个例子。 123|---- View1 ----||---- View2 ----||---- View3 ----| 如果要排上图3个View的时候，AutoLayout必须指定相互间的依赖。 如果仅仅如此还好解决，那么现在告诉你，View1可能是个1行或者2行的Label，那么如何平均分配之间的大小和间隔呢？ 如果这样还是容易解决，那么再告诉你，View2可能是个没有内容的视图，当没有视图的时候1和3之间要保持之前的间距，这时候，不可能简单的解决了，必须修改依赖，一种方式是删除所有的AutoLayout，重新布局一遍，另外一种是保存AutoLayout实例，修改单个属性。无论如何，都不能避免修改依赖。 如果说到这里你都觉得轻松解决，那么下面这种呢 123| |---- View1 ----| | || Image |---- View2 ----| Action1 | Action1 || |---- View3 ----| | | 这是标准的TableViewCell样式，但是如果说View和Action都是动态的，可能会被隐藏，但隐藏的时候不能空着一块，垂直的需要居中，水平的需要拉伸。这时候就彻底的蛋疼了，恰好我们的项目中就有很多类似的场景，由此我们很多时间都浪费在调整UI上，又容易漏掉场景导致一些视觉bug。 在一次次的UI修改中，我终于受不了了在视觉排版这个从印刷术发明就存在的问题，到现在计算机领域，最成熟最靠谱的当然是Web技术，从互联网出现，到现在的响应式界面，web经历了历史的历练，从而产生了一套稳定靠谱的布局方式，而最新的就是不久前被加入标准的Flex布局（也可以称为Box布局）。 关于布局使用，有很多有名的介绍文章，我作为一个半吊子人士，就不做详细介绍了。简单来说，就是把每个视图都看作一个箱子，拥有内边距外边距，然后根据一定顺序排布下去，相互间不会产生依赖，当某个视图的属性display: none，自动忽略该视图。 比AutoLayout好的地方首先，Flex计算简单，不会因为视图的增加性能急剧下降。 同时也可以方便的解决上述的几种场景，可以动态的根据视图来排版，而不需要相对的去设置，同时拉伸和挤压也很好控制(flex-grow, flex-shrink)。 甚至可以解决部分需要UITableView或者UICollectionView才比较好解决的问题。举个例子，微信九宫格图片，如果不是用UICollectionView来做，那么可能你需要保存9个实例，然后在layoutSubview里面做各种判断，计算frame，那简直是太恐怖了！看到这样的代码谁还有兴趣读下去吗。而使用UICollectionView则可以很好的解决布局问题，还能复用，但是很多场景下并不会产生复用，而使用UICollectionView又会新引入很多层视图层级和一些不需要的功能，虽然很好解决了问题，但并不是特别简单。那么这时候Flex布局的优势就特别明显了，只要flex-wrap属性就可以搞定一切。 总的来说，使用简单，学习成本低，性能也很不错，兼容性也高，这也是很多人为什么会嘲笑苹果自己搞了一套复杂无比的布局系统。 缺陷Flex布局最大的缺陷就是视图层级的增加，每个箱子都是一个视图，看web的代码可以发现无数的div，单纯的为了实现一套布局。不过对于移动端来说，一个视图不会拥有太多的元素，可以说这个问题没有那么的严重。 我也在考虑是否可以创建一层virtual view，可以用来代替view作为箱型容器，或者把布局系统移除view作为容器这一web上的逻辑，分离布局和view。无论怎么样这两种方案都会增加复杂度。 同时，由于原生并不提供Flex支持，所以需要自己引入Flex库，并且需要在layoutSubview或者viewDidLayoutSubview中，手动触发计算。关于这个问题，可能自己创建系列Flex根控件比较好。 目前使用Flex的项目，或者类似的功能现在最有名的方案是Facebook的Yoga，遗憾的是iOS端的YogaKit正处于开发阶段，可能不是那么的稳定。 正在使用Yoga的开源项目也有很多，有名的有AsyncDisplayKit, React Native, weex。所以从目前使用场景来看是没有什么问题的。 比较相似的功能其实早有方案，比如Android的LinearLayout和iOS的UIStackView，可以说这两者都是阉割版的Flex。 YogaKit我们来看下YogaKit的一些API。不要问我为什么是swift，老外现在都在玩swift。 1234567root.configureLayout &#123; (layout) in layout.isEnabled = true layout.width = YGValue(containerSize.width) layout.height = YGValue(containerSize.height) layout.alignItems = .center layout.justifyContent = .center&#125; 如果是swift，将会非常简单，枚举的一半都被省略了，但是OC可能会稍微麻烦一点。API也是几乎参考的Masonry，重要的是，再也不会出现依赖了！！！感觉棒棒的。 同时Yoga不是完全的实现了Flex的功能，他是为移动端、客户端专门定制的布局系统，所以也有部分Flex没有的功能，也有部分Flex属性没有效果。 同时Yoga非常的精简，核心代码只有3000多行的c语言，引入成本也非常的低，所以决定在下一期实战型的使用下，来解决一直遗留的问题。 更多的考虑在项目的过程中，作为程序员，都希望代码能够复用，提高稳定性。然而现实是残酷的，其他人并不会替你思考这些问题，所以就有很多场景，明明看着一模一样，但是某几个字体就是不一样，大小就是差那么几个像素。那么要处理这种问题，一般有两种方案。 1，继承，基类写基本成员，子类来写布局和属性。这样会导致很多子类，不熟悉的人会很疑惑这些东西都在哪里用的。 2，增加style属性，使用style来重写布局和属性，这样可能会随着类型的增多switch-case也增加。 同样，这里web也给了我们一个很好的思路。内容-样式分离，我们可以做一套类似于css的系统，使用class来设置布局样式，这样布局样式也可以复用了！ 当然这个思路有部分人已经做好了开源库，css样式直接应用到控件。但是感觉没有那么完美，所以以后可以考虑下如何更好的把样式布局给统一到外部。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://djs66256.github.io/tags/flex/"},{"name":"layout","slug":"layout","permalink":"http://djs66256.github.io/tags/layout/"}]},{"title":"几种圆角处理在列表中的性能测试","date":"2017-04-24T15:41:56.000Z","path":"2017/04/24/2017-04-24-几种圆角处理在列表中的性能测试/","text":"在平时开发中，圆角处理是一个非常常见的场景，光栅化是一个最简单的优化方法，但是你所使用的方法真的如你所愿的在生效吗？这里对几种比较常用的方法对比一下。 首先按照最常用的几种方式设计了几个case，使用CollectionView来测试性能。Github 1. 纯粹的设置layer属性方式1234self.layer.cornerRadius = frame.size.width/2;self.layer.borderColor = [UIColor blackColor].CGColor;self.layer.borderWidth = 1;self.clipsToBounds = YES; 这里不考虑非clipsToBounds的情况，因为大部分场景是需要的，而且非clipsToBounds的话和其他case并不平等。 2. 增加光栅化处理12self.layer.shouldRasterize = YES;self.layer.rasterizationScale = [UIScreen mainScreen].scale; 3. 绘制Image1234567UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);[[UIColor blackColor] setStroke];UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0.5, 0.5, size.width - 1, size.height - 1) cornerRadius:size.width/2];path.lineWidth = 1;[path stroke];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 4. 绘制Image并且加上缓存测试以上case都是在init中就设置好了属性，不会产生reuse的性能问题。为了让效果更加明显，找了一个5s的设备进行测试。 下面是只有一个空的view的结果 从结果来看，似乎有点出乎意料，单纯的设置layer属性居然是表现最好的一个，而增加光栅化的表现明显最差，除去可能产生的误差，1和2的结果相差还是有点大。 打开模拟器的Offscreen-Rendered功能，发现1由于没有子视图，所以clipsToBounds属性无效，并不会发生离线渲染，而一旦指定了光栅化，就会强制执行离屏渲染，导致性能急剧下降。 那么我们在视图上加上一个视图 结果发生了戏剧性的变化。光栅化的视图直接接近0的帧率，而3和4除了初始化的时间有差别外其他基本符合预期，4高一点可能是用了同一份内存，拷贝到GPU的时候系统做了优化。 那么我们把label不要放在圆角view上这时候1和2表现一致，应该都产生了离屏渲染。 所以问题来了我们平时可能用到的光栅化为什么没用了。这要涉及到光栅化cache的策略了，我没有找到详细的官方文档，只找到一段话： 1And if you start setting lots of views with shouldRasterize, you&#x27;re going to overflow the cache and that ends up in a really, really bad situation, ends up being much worse than before because essentially you&#x27;re rendering every single view that you set with shouldRasterize offscreen and the back on the screen and we just talked about how doing that in every frame can really, really hurt your animation performance. 大量的光栅化导致缓存溢出，所以每次还是需要离屏渲染。 另外，该文章还说 1So make sure you don&#x27;t change anything during your view hierarchy while you have shouldRasterize on, otherwise you ended up rendering offscreen without great performance. 这就是我们平时说的“不能经常变动的视图”，但是注意的是，应该是整个视图树，而且是anything，这样的要求太过于严格。所以为什么很多时候的光栅化会让性能问题更加严重。 HOW最好的方式当然是绘制圆角并缓存。 另一种折中方案是使用blend，通过一张有透明通道的图片来遮盖实现圆角效果。 当你觉得你需要的时候，才开始优化。这才是最好的思路，不要做过早的优化。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"圆角","slug":"圆角","permalink":"http://djs66256.github.io/tags/%E5%9C%86%E8%A7%92/"},{"name":"cornerRadius","slug":"cornerRadius","permalink":"http://djs66256.github.io/tags/cornerRadius/"}]},{"title":"web图片下载转为native下载","date":"2017-04-23T15:30:03.000Z","path":"2017/04/23/2017-04-23-web图片下载转为native下载/","text":"早期版本的网易新闻每次点开新闻图片，都会重新去下载新的图片，而在某个版本开始，可以发现点开的时候并不会重新加载了，只有在保存的时候会下载高清图片，那么他是怎么做到的呢。 平时，我们网页基本都是自己负责自己的内容加载。但是有时候却希望能够拿到网页内的图片资源，此时我们不得不自己再去加载一遍，不仅仅浪费流量，而且影响用户体验。 由客户端帮助web下载图片，这样我们就可以让web和本地共用缓存，并且可以自定义缓存了。那么如何做到这样的效果呢？这里提供两种不同的思路来解决这种问题，分别对UIWebView和WKWebView下的运行情况进行分析。Github URLProtocol我们知道URLProtocol可以截获请求，那么我们是否可以直接截获所有URL，然后根据path来判断是否是图片，是否需要自定义下载。 根据demo试验来看，UIWebView可以完美的实现该方案，但是WKWebView却不能被截获，原因是WKWebView拥有自己的URLSession，虽然可以用黑科技获取URLSession并加入代理，但是不能通过苹果审核。 FileURL另一种方式是使用本地文件，这种方式更加符合规范而且更加安全。不过WKWebView支持本地资源的接口是在iOS 9.0才引入的，而且需要指定目录，所以需要先把所有资源拷贝到该目录下。 根据demo的试验来看，UIWebView和WKWebView都完美的支持了。 比较现在来比较下这几种方案。 URLProtocol能够在不改变网页内容的情况下直接对内容进行替换，但是不能支持WKWebView，而且全局的Protocol可能会带来某些隐患。 FileURL能够灵活的定制化下载方式，而且能够支持WKWebView，但是需要将img标签的http链接替换为file链接。 适用场景URLProtocol比较通用，普遍适用于各种网页。 FileURL更加偏向于定制化，这里来详细看看定制化的场景。 比如网易新闻的新闻内容格式大概是这样的： 12&lt;p&gt;正文正文正文&lt;/p&gt;&lt;img src=&quot;http://www.163.com/logo.png&quot; /&gt; 很多情况下，为了优化网络以及渲染，都需要类似的简化html，并且把css，js代码打包到App或者单独下载。那么其实我们有很多情况下是拥有一定固定格式的html代码段。而部分活动等特殊的网页我们一般也不会需要客户端下载资源来优化性能。那么有了这个前提，FileURL的适用面其实还是很广的。 动态创建DOM那么怎么样处理比较合适呢？我们以WKWebView来看，难道我们要首先用拼装好一个网页，然后保存为一个文件进行载入吗？ 当然不需要这么笨重的解决方案，这样做不仅影响了性能，而且特别不灵活，一旦内容需要变更就会特别麻烦。 目前前端技术有两个热门的概念，虚拟DOM和响应式，那么我们也可以利用类似的原理。下面是一个简单的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 在Web端：var imageList = []// 创建一个空的节点，用来占位和展示进度条function appendImage(url) &#123; let dom = document.createElement(&#x27;div&#x27;) dom.style.padding = &#x27;20px 10px&#x27; let img = document.createElement(&#x27;img&#x27;) let p = document.createElement(&#x27;p&#x27;) p.innerText = &#x27;0%&#x27; dom.appendChild(p) dom.appendChild(img) document.body.appendChild(dom) imageList.push(&#123;url, dom&#125;)&#125;function findDomByUrl(url) &#123; let obj = imageList.find(i =&gt; i.url == url) return obj &amp;&amp; obj.dom&#125;function updateText(url, text) &#123; // console.log(`update text at &lt;$&#123;url&#125;&gt; with &quot;$&#123;text&#125;&quot;`) let dom = findDomByUrl(url) if (dom) &#123; dom.firstChild.innerText = text &#125;&#125;// 更新进度条function updateProgress(url, progress) &#123; updateText(url, progress)&#125;// 更新错误状态function updateError(url, error) &#123; updateText(url, error);&#125;// 图片下载完成后，更新图片资源function updateImage(url, fileUrl) &#123; // console.log(`update image url at &lt;$&#123;url&#125;&gt; with &quot;$&#123;fileUrl&#125;&quot;`) let dom = findDomByUrl(url) if (dom) &#123; dom.lastChild.src = fileUrl &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 客户端// 初始化[self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;appendImage(&#x27;%@&#x27;)&quot;, url] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123;&#125;];// 这里为了测试伪造一个进度功能__block NSInteger progress = 0;if ([url hasPrefix:@&quot;http&quot;]) [NSTimer scheduledTimerWithTimeInterval:0.1 repeats:YES block:^(NSTimer * timer) &#123; progress += 5; [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateProgress(&#x27;%@&#x27;, &#x27;%zd&#x27;)&quot;, url, progress] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123; &#125;]; if (progress &gt;= 100) &#123; [timer invalidate]; &#125;&#125;];// 下载图片[[[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:url] completionHandler:^(NSData * data, NSURLResponse * response, NSError * error) &#123; if (error) &#123; // 错误态 [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateError(&#x27;%@&#x27;, &#x27;%@&#x27;)&quot;, url, error.localizedDescription] completionHandler:^(id _Nullable ret, NSError * _Nullable error) &#123; &#125;]; &#125; else &#123; // 保存图片并且更新界面 NSURL * fileUrl = [self.cacheUrl URLByAppendingPathComponent:url.lastPathComponent]; [data writeToURL:fileUrl atomically:YES]; [self.WKWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;updateImage(&#x27;%@&#x27;, &#x27;%@&#x27;)&quot;, url, fileUrl.absoluteString] completionHandler:^(id ret, NSError * error) &#123; &#125;]; &#125;&#125;] resume]; 这样我们就可以动态的更新界面了，而且我们拥有自己创建的dom信息，那么我们可以做更多的事情:) 最后这里讨论了两种把图片转为客户端下载的方式，如果要说如果这么做相当于客户端来编写网页了，还不如直接写原生的呢。但是这样做比原生更加灵活，可以应用不同模板，不同样式，就可以改变外观了。而且具体使用时也不一定需要这么死板的去创建dom，之后我会尝试下不同的方案来简化双方的FileURL实现。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"webView","slug":"webView","permalink":"http://djs66256.github.io/tags/webView/"},{"name":"image","slug":"image","permalink":"http://djs66256.github.io/tags/image/"},{"name":"download","slug":"download","permalink":"http://djs66256.github.io/tags/download/"}]},{"title":"疯狂日志系统","date":"2017-04-17T14:25:36.000Z","path":"2017/04/17/2017-04-18-疯狂日志系统/","text":"在日常的开发过程中，总有很多莫名其妙的问题出现在别人的手机上，就好像上帝开的一个玩笑。然后我们拿着别人的手机连上mac，重新编译后，问题又神奇的消失了，这时候我们只能摇摇头，问题不能重现，但这并不代表问题已经解决。 ExDebug Star 很多时候，比如打点情况，并不能直观的提供给测试人员验证，很多时候需要日志来提供一些验收，而在非联机的情况下日志的输出查看又比较困难。 经常有用户反馈卡顿等情况，而我们的测试机又有限，难以覆盖足够的场景，用户的反馈又比较模糊，并不专业，所以很多卡顿往往在猜测中并没有被解决。 由于我们项目目前的状况，是没有那么多的人力来配合做一套BI系统。所以这里我做了一套小型的日志和系统运行情况手机系统。 功能 设计之初就是设计成一对多的模式，所以可以支持多台手机连接到同一台电脑上，其实还可以更疯狂的连接方式，架构部分会详细描述。 每个设备双击打开都是一个窗口，每个设备只能打开一个窗口。 窗口的首页是几个基本统计项，内存、cpu、FPS，最短1秒就会有一次统计数据。 请求部分是使用URLProtocol来做的，所以只能统计http类型的请求。 这里是每个请求统计的数据，目前还没有好好整理。 这里是对所有请求的一个分析，和上面一样，其实没有好好的利用数据。暂时没有想出来怎么很好的利用这一部分的数据，如果有想法，可以告诉我。 这里统计的是主线程一个runloop运行时间超过1/60s的情况，项目之前有部分卡顿就是因为代码问题，导致主线程产生大量运算形成的。 这里如果时间超过一定阈值（暂定为0.5s），此时会触发截屏，所以在严重卡顿的时候会自动把卡顿的界面保存下来。 这是一个简单的文件管理系统，从应用沙盒的根目录开始。 同时可以选择某个文件进行下载，直接保存到电脑中。 这是连接日志输出系统的。debug日志会输出到3个地方： * xcode console * system log，这个可以从mac的日志查看器里面看 * socket log 同时我们可以选择过滤器，这样就会展示相应的日志。这里的过滤系统是根据我们项目中特定日志格式来做的，实际情况可能需要不同的定制。 在苹果爸爸还没有封杀jspatch的时候，我们为了验证patch真是煞费苦心，需要在工程中加入代码，然后计算md5验证。这里可以直接写patch代码，点击按钮就会直接传输给手机直接应用，非常方便。 架构 大致的架构如上图所示，其中通信方式使用的是socket。可能使用websocket这种比较成熟的方案会更好，但是想自己写网络层，所以就自己写了长连接部分。（目前这部分留下点坑，服务端处理分包粘包偶尔会有问题）。其中socket内容为双方通信，不能按照我们平常客户端-服务端这样的架构来看待，手机端（暂且称为客户端）也需要处理服务端下发的请求。 手机端是一个简单的长连接和部分处理请求的服务，和服务端保持一对一的链接。 服务端服务端其实包含的是两部分，nodejs和pc端，这里先说nodejs。其实这两部分是完全分离的，并没有任何关联。这里服务端就特指nodejs。它包含两种通信模式： 1. rpc 进程间通信，是和`pc端`通信的方式。 2. socket，是和`手机端`与其他`nodejs`端通信的方式，对，是和其他`nodejs`服务，所以这里可以和我们的网络模型一样，组成星状结构、环形结构、网状结构。（没有真实的测试过超过两个端的连接，不能保证性能如何，也没有对此进行优化） 在刚开始的设想中，运作方式有两种： 1. 自己独立和多台手机通信 2. 找一台电脑作为独立服务器，其他人可以连该电脑，这样我们可以把多个数据都集中到一起，可以有人专门管理 pc端是由Electron+React组成，选择这样的技术是因为electron的跨平台特性，同时React又是我比较熟悉的一种前端框架（React-native又是移动端的一种统一化方案）。技术内容没有什么特别的，有部分数据量多的列表会导致卡顿，这个需要做特别优化。 通信数据格式分为3种类型： request-response模式，和我们最熟悉的http请求一样，不过是双方通信模式 register模式，是注册-持续上传的模式，目前已经去除了注册这一步，会把所有数据一直持续上传服务端。 代理模式，是第三方服务端希望通过该服务端访问手机端，会把请求数据包装一层。这是纯粹服务端-服务端之间的通信格式。 总结最初的想法是在debug版本和内测版本都应用该系统，统一收集和处理数据，对部分问题设置报警系统。多个pc端可以直连服务端，这样可以多人同时查看当前所有设备中存在的问题。就能够在上线前尽可能的覆盖各种网络、机型等情况，尽可能早的发现问题，避免上线后才发现bug。由于工作量大，性能也没有评估（node支持的并发数应该还是不错的，瓶颈可能会在带宽），对数据处理的方式也没有什么经验，所以现在还是停留在个人使用中。 有什么好的建议与意见，欢迎给我反馈。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"debug","slug":"debug","permalink":"http://djs66256.github.io/tags/debug/"},{"name":"log","slug":"log","permalink":"http://djs66256.github.io/tags/log/"},{"name":"socket","slug":"socket","permalink":"http://djs66256.github.io/tags/socket/"}]},{"title":"持续重构","date":"2017-04-16T17:05:18.000Z","path":"2017/04/17/2017-04-17-持续重构/","text":"在这一年的开发过程中，从什么都没有到现在的稳定迭代，其中经历了多次的重构工作，这里来聊聊其中的一些看法。 我们的模块，从开始的刚好能够满足需求，到后面能够胜任各种要求，再到最后，简单的调用就可以完美的胜任工作。这是持续根据实际情况思考，经过多次重构而得到的结果。 为什么要重构从出发点来看： 功能缺陷，已经很难修复或者修复导致代码更加混乱，希望通过重构能够彻底的解决问题 功能越来越复杂，代码越来越多，导致维护成本非常大 从最终点来看： 统一结构，将类似的东西统一，模块化，避免重复代码和相同的bug 细分功能，将一个复杂的功能细分，减少开发的复杂度，增加复用性 最终的目的都是为了使用者更加简单可靠 最佳时机这里我把重构最适合的时机概括为两种： 功能爆炸期，当功能复杂化，代码单纯的大量叠加时，必然形成很多复杂逻辑，并且冗余的代码 类爆炸期，当类似的功能经过一定的归类，导致每种类型的子类型随着项目进行而急剧增加的时候 以我们的项目经验来看，在前几期的时候，由于时间紧张，功能的大量累加，导致一个复杂点的页面就有上千行的代码，此时每次改动都会花费大量时间，而且有部分bug不能从根本上解决。这时候我们开始了第一次的大规模重构，主要包含以下几点： 提出组件化框架，拆分页面代码，并把之前的一些功能用组件化改写 统一相似组件，把视觉相似的组件进行统一化，并且对代码结构进行重新归类 归纳部分相似功能，比如导航栏、页面头部的交互变化，网络层重新整理 经过这次的整理拆分后，已经是一个比较同一的整体了，能够很好的复用和修改。 但是经过部多个版本之后，又出现了新的问题。每次对页面和功能的特例化，导致相同资源的组件或者功能越来越多，导致每次使用的时候都不太清楚用哪个组件比较好。而且每个组件的接口也有略微的差异，并不能无缝的切换。以及一些原来就存在的，还没有经过拆分的功能。 这次主要做的主要是统一化工作，比如最简单的点赞按钮，在很多地方使用，同时因为历史原因，很多图标并不是同一个资源，逻辑规则也并不统一，接口也不统一。经过对整个项目的观察，发现其实目前项目中点赞按钮只有大小两种样式，那么使用抽象工厂的方式进行归纳，对外暴露的只有一个类型，那么这样使用者就不需要知道其中具体有几个组件了。 123456public class PraiseButton &#123;+ (instanceType)buttonWithStyle:style;&#125;private class _SmallPraiseButton: PraiseButton;private class _BigPraiseButton: PraiseButton; 而其他组件和功能对同一个资源的描述目前也是比较分散，今后也会按照这样的方式，按照资源类型进行归类与统一。 重构目的目前来说两次重构的目的是： 第一次 拆分功能，让每个模块尽可能的简单，可复用；减少复杂度，减少隐藏的bug；能够给团队其他成员使用。 第二次 合并和归纳功能；统一合并相同资源、功能的接口；减少对外暴露的实现细节；让使用者面对的只有一个对象，使用更加简单；减少理解沟通成本。 犹如读书时候老师说的一件事，刚开始读书的时候，书是薄的；读的久了，书就变厚了；当你已经精通书中所有，书又变薄了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://djs66256.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"横竖屏的一个容易被遗漏的点","date":"2017-04-16T14:01:42.000Z","path":"2017/04/16/2017-04-16-横竖屏的一个容易被遗漏的点/","text":"最近在做横竖屏切换的时候，发现一个crash，是一个平时没有注意到的点。 1UIApplicationInvalidInterfaceOrientation&#x27;, reason: &#x27;preferredInterfaceOrientationForPresentation &#x27;landscapeLeft&#x27; must match a supported interface orientation: &#x27;portrait&#x27;! 从描述上看，错误很明显，我们从方法的描述上看看。 123Returns the interface orientation to use when presenting the view controller.The system calls this method when presenting the view controller full screen. When your view controller supports two or more orientations but the content appears best in one of those orientations, override this method and return the preferred orientation.If your view controller implements this method, your view controller’s view is shown in the preferred orientation (although it can later be rotated to another supported rotation). If you do not implement this method, the system presents the view controller using the current orientation of the status bar. 那么如果supportedInterfaceOrientations和preferredInterfaceOrientationForPresentation返回的内容不符，是不是就会crash，经过试验的确会crash。 但是我们在dismiss的时候呢，经过试验表明，也是会crash的，特别是preferredInterfaceOrientationForPresentation返回的是UIApplication.shared.statusBarOrientation时，是一个非常容易被忽略的问题。 那么push呢？表现是怎么样的？ 经过试验，在pop的时候，如果横竖屏状态不一致，并不会crash，但是转场动画采用了系统默认的了，不会进入转场动画的delegate。 所以，如果需要做流畅的转场以及横竖屏切换，在一些场合下，还是需要使用present方式，并且需要在双方都确保supportedInterfaceOrientations和preferredInterfaceOrientationForPresentation的正确。 自定义动画在做自定义转场动画的时候，可以注意到，如果是从竖屏进入横屏的动画过程中，横竖屏的状态是正确的，但是横竖屏状态只能存在一个，也就是[UIDevice currentDevice].orientation，那么系统是怎么做到的呢。 重写UIViewControllerAnimatedTransitioning中的动画方案- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext，在此时获取屏幕方向[UIApplication sharedApplication].statusBarOrientation，发现已经转换到下一个controller的方向了，那么前一个controller为什么显示正常呢。我们看一下前一个fromController.view.transform，发现他并不是CGAffineTransformIdentity，这样就一目了然了。系统在屏幕转向变化的时候，会把上一个视图自动旋转90度，这样就可以无缝的转场动画。 那么另一个问题是，此时的controller的生命周期会是怎么样的。经过尝试，此时已经在viewWillAppear:和viewWillDisappear之后了，符合我们的预期。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"转场","slug":"转场","permalink":"http://djs66256.github.io/tags/%E8%BD%AC%E5%9C%BA/"}]},{"title":"AVFoundation的一些点","date":"2017-04-16T14:00:59.000Z","path":"2017/04/16/2017-04-15-AVFoundation的一些点/","text":"最近做了一个视频的需求，使用的是AVFoundation。 页面切换的无缝连接主要需要解决的技术点在于，如何在视频的全屏化过程中无缝链接，不会出现视频断裂或者停顿的问题。 view的伪装切换使用view来伪装页面的切换，视频的全屏仅仅是view的transform。 这样做的优点是比较灵活，不需要依赖与苹果的框架，转场动画等都比较好控制。 缺点也比较明显，因为在同一个controller中，代码偶尔度会增加，这个controller的功能也会更加复杂，而且transform并不能控制系统的屏幕方向，所以一些系统的提示不是正确的方向，比如音量，push等。 present方式使用present方式，展示一个新的controller，这样业务也会分离的比较清楚，唯一需要考虑的是如何让两个页面间的视频播放更加平滑。 一开始的考虑是，是否可以把AVPlayer传递给下一级，视图层由各个负责，因为视频的播放位置和缓存信息都以及保存在了AVPlayer。实际发现，把同一个AVPlayer给不同CAPlayerLayer的时候，视频播放停止了，所以传递的时候要把这两者一起传过去。 另外，需要考虑的是转场动画，这里就不详细描述了。 这里查看了其他一些视频app bilibili 在视频切换的时候有明显卡顿 斗鱼、爱奇艺 在视频切换时，转场动画或多或少有些小问题 乐视 没有转场动画 腾讯视频、优酷 表现最好","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"AVFoundation","slug":"AVFoundation","permalink":"http://djs66256.github.io/tags/AVFoundation/"}]},{"title":"聊聊移动客户端开发中的git工作流","date":"2017-04-10T14:03:34.000Z","path":"2017/04/10/2017-04-10-聊聊移动客户端开发中的git工作流/","text":"现在git已经是我们日常开发必备工具，那么在移动客户端的日常开发中，应该怎样去管理git分支呢，是否目前普遍的几种工作流就可以满足目前的情景呢？ git flow最官方的流程，包含的主要分支有如下几个： master 也就是发布分支 develop 也就是开发分支，上线的时候会把develop合并到master feature 特性开发分支，每一个功能都会拉一个分支出去开发，完成后合并到develop，并删除自己 bug fix 日常的bug修复分支，这个是从master分支拉出来的，所以合并的时候要合到develop和master上，比较麻烦 按照以上说法，流程也是比较清晰明确，大致如下 12345678910111213141516171819 develop master * | ---------| | / | |feature1 | * | | |* | *| * /|* / | / || feature2 | bug-fix |* | | | || * | * || * | / \\ || \\ * -------/ \\ | \\ * * --------- * | |\\ | | \\----------- * release | | github flow 和 gitlab flowgit flow还是比较麻烦的，所以后来一些网站并没有推荐。 这两个工作流都是持续集成的模式，大致包含的分支如下： master 主分支，但是作用相当于git flow里面的develop，github flow也是release的分支 feature 或者说 merge request production 发布分支 功能分支和bug fix都是从主分支上拉出来改，再合并回去。流程上比git flow更加简单。 移动端现状但是以上几种真的适合目前我们的开发吗？ 首先来分析下git flow的应用场景。linux这种大型项目，人员分布于世界各地，而每一次发布的功能又非常的多，为了保证所有人的协同工作不会出现任何偏差，所以他们采用了git flow这种工作流。 这类项目有着如下特点： 每一次发布的周期很长，而且其中的bug fix会以单独的小版本或者补丁形式发布出来 每一次发布所更新的功能并不是固定的，哪些feature完成了，才会考虑合并入系统，而没有完成的继续开发，会在下一次版本发布时再考虑 每个feature之间的关系比较独立，相互间不会产生很大的影响 linux为了解决自身庞大的系统的情况，在git flow外面再套了一层git flow，有着相当严格的代码审查制度，这个是后话了。可以看出如果是一个瀑布型开发场景，还是非常合适的，但是我们目前的移动开发几乎都是敏捷开发。 再来看看github flow和gitlab flow 他们自身是一个开放的交流平台，为了增进大家的交流，就必须加快和简化发布，时刻让主分支保持最新 为了给大家共同开发提供条件，发明了merge request，如果被采纳，需要尽快的合并到主分支上 托管的项目大部分是小型项目，没有开发计划和排期要求，所以就很难有如此明确的版本，所以基本上是每个特性都会有一个发布，也就没有必要整一套严格的审查制度 这个比较适合网站这类的开发，当完成新特性后，马上就可以展示给用户，并不需要卡时间点。 目前状况 目前大家一般都是敏捷开发，最长一个月，最短2个星期就会有一个新版本 每一期的新特性多，但是功能点却非常细小，而且会有很多的优化 bug修改完以后一般不会立刻发小版本来专门修复bug，一般会在下一个版本中修复 所以git flow对于现在的情况来说太慢了，而且导致分支间切换太频繁。但是其他几种又不能很好的区分版本，所以我们需要自己的工作流程。 1234567891011121314151617181920 master ---------------- * / | v1.0 | | ------- * * / | / | bugfix |feature-x * | | | * * | * * / * \\ * ---- / | * v1.1 | test * | | \\ | | -----------+-- * release | * * / | test * | \\ | - * release 每个版本都从master上拉一个版本分支，此版本的所有改动都在这个分支上进行，此时这个分支就像是github flow的master，保持持续集成，如果功能点比较大，可以考虑在版本分支上拉功能分支进行开发。 bugfix一般直接修改在版本分支上，也可以从master上拉分支，最后合并到版本分支上，这样做是考虑到版本交替的时候可以方便处理bug。 测试和打包都在版本分支上，发布以后合并到master 这样看上去似乎比其他几个复杂，但是实践下来应该说更加简单。 我们很少存在并行开发的情况，所以每个版本几乎都是串行排列的，很少出现交叉的情况 我们的功能点很小的时候没有必要拉一个新的分支，可以直接修改到版本分支上，不需要专人合并 feture分支一般为个人开发分支，一个人来维护合并和删除，也会简单很多 这样每个版本的代码分支完全独立开来，更直观的区分不同版本间的代码进度 减少了日常工作中需要频繁切换分支的状况 可以让CI系统直接对接版本分支，大家可以第一时间得到该版本的最新包 所以正常的使用中，可见的分支为master和版本分支，会比上图简单很多。 但是这样做的缺点是无法明确的区分feature，如果需要去掉某一个功能的时候会比较麻烦，基于每次的迭代都是相对明确，不太可能出现功能回退的情况，所以不存在这种问题。 总的来说，适合的才是最好的。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://djs66256.github.io/tags/git/"}]},{"title":"自己写的一个埋点管理小工具","date":"2017-04-09T09:29:23.000Z","path":"2017/04/09/2017-04-09-自己写的一个埋点管理小工具/","text":"前言在很多项目中，埋点数据使用表格来统计的，随着项目的进行，数据量越来越复杂，越来越难以维护。所以很多公司都已经开发了一整套系统，从埋点的录入到代码的输出。由于很多时候一套系统对于一个小项目来说太过于复杂了，所以这里我做了一个轻量级的本地管理客户端。https://github.com/djs66256/lily Star 功能简介启动由于我们实现的是一套本地管理的系统，所以我把程序系统和数据分开了，所以启动的时候需要选择对应的数据目录，比如本项目目录下的/demo-data/，以微信为例。关于目录下文件功能格式会在之后说明。 主界面启动之后，我们可以看到我们的埋点数据界面，这里我根据我们的需求把数据分为3类： 事件-数据点 页面 具体参数 数据点包含所有埋点信息，参数是由参数列表选择，可以查看历史和进行编辑。 页面包含了我们的所有页面id，因为一个普通的App拥有的页面不会有太多，所以页面的分级可以少一点。 参数包含了我们埋点过程中所有遇到的参数，考虑到我们项目中所涉及到的参数比较统一，所以就没有进行分类 每行数据的每次改动都会形成一条记录保存在本地，这样我们就可以追溯历史变更了。这里还把所有参数都列了出来，而不是主页面精简后的了。由于性能问题，这里暂时只显示了最近50条记录。 以上所有列表的数据项都是动态可配的。在设计之初，考虑到数据内容可能会根据需要动态调整，所以把所有内容都设计为动态可配的了，又为了在磁盘上的数据的可读性，把所有数据都采用文本json保存，这样也兼容了动态的数据，具体实现后面会详细讲解。 当选择了一个目录后，点击导航栏的创建可以创建一条新的数据，数据格式内容根据根目录属性配置。 点击一行列表后的编辑按钮进入编辑页面，每次保存都会产生一条修改记录。 可选的参数为在根目录为参数内的所有内容，这样设计的原因是为了未来可能对埋点数据的自动化验证，从而需要一个格式化的参数列表，而不是一段文字描述。 为了可以对埋点的整理归类，所以做了简单的搜索功能，可搜索字段也是根据事件目录的配置。 所有搜索字段都是使用正则表达式完成，所以如果需要更复杂精确的匹配，这里也可以输入一段正则来匹配。 点击编译，会把所有事件和页面数据自动生成一份代码，这里是根据需要定制的，所以我只做了iOS的一个样例格式。这里我们从老数据转化过来的时候有重复埋点，所以在转化的逻辑中加入了去重，关于自定义和接入编译系统之后会详细描述。 进阶–配置参数以demo-data数据配置为例。 数据分类在所有的数据中，概念都是节点Node，根据功能分为两类： 目录节点DirNode，负责分级和归类。 数据节点StatNode，负责记录每个数据的具体内容。 文件持久化实现所有数据持久化通过json格式保存为文本文件，所以可以直接查看文件内容。 按照层级结构创建一样的目录层级结构，每个DirNode下面都有一个config.json文件，包含该节点信息。 在最底层每个StatNode会产生一个目录，目录下会根据历史生成1.json，2.json，3.json名字依次递增的文件，保存每次修改后的数据。这里目录名字使用id来命名是为了解决数据埋点id可能存在重名的问题。 只能在目录的最底层可以创建数据，这是为了解决展示时候的难以同时展示数据和目录的问题。 文件持久化格式每个文件中都需要具备一些基础属性： name外部显示的名字，对于目录节点则是目录名字 id要求唯一的id，由于DirNode个数比较少，而且固定，所以没有设计创建的功能，自己修改时需要保证唯一。数据节点则会生成一个MD5来填充。 isDirectory表示是否是DirNode 目录节点格式包含一个columns数组，这是一个非常重要的配置，除了基础属性，所有StatNode里的数据项都是根据该字段动态生成。 这里是一个事件节点例子： 123456789101112131415161718192021222324[ &#123; &quot;type&quot;: &quot;text&quot;, // 字段类型（暂时只支持text和param） &quot;required&quot;: false, // 是否必填 &quot;title&quot;: &quot;描述&quot;, // 展示的列名 &quot;key&quot;: &quot;description&quot;, // 对应于json中的key值 &quot;visible&quot;: true, // 在主界面是否隐藏 &quot;editable&quot;: true, // 是否可编辑，在编辑和创建界面是否可见 &quot;searchable&quot;: true // 是否可以作为搜索参数，影响搜索界面 &#125;, &#123; &quot;type&quot;: &quot;params&quot;, &quot;paramsKey&quot;: &quot;params&quot;, // 如果是param类型，需要指定`DirNode`的id &quot;required&quot;: false, &quot;title&quot;: &quot;参数&quot;, &quot;dataIndex&quot;: &quot;params&quot;, &quot;key&quot;: &quot;params&quot;, &quot;visible&quot;: true, &quot;editable&quot;: true, &quot;searchable&quot;: false &#125;] 可以动态增加或者修改数据项，这样会非常灵活而且可以不通过修改代码就配置数据内容。 节点间的columns是可以被继承的，也就是说子目录的columns必定包含父目录的所有数据内容。可惜目前的使用场景并没有这个要求。 所有其他目录的配置都是类似的。 数据节点格式同样看一个例子 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;点赞&quot;, &quot;statId&quot;: &quot;onPraise&quot;, &quot;description&quot;: &quot;包括3D touch页面&quot;, &quot;version_iOS&quot;: &quot;1.0&quot;, &quot;version_Android&quot;: &quot;1.1&quot;, &quot;createTime&quot;: &quot;2017-04-03T12:22:38.372Z&quot;, &quot;params&quot;: [ &#123; &quot;name&quot;: &quot;用户ID&quot;, &quot;description&quot;: &quot;&quot;, &quot;createTime&quot;: &quot;2017-04-03T11:59:13.467Z&quot;, &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;814db1c837ac436ebb569d3554b51fb1&quot;, &quot;paramId&quot;: &quot;userId&quot; &#125;, &#123; &quot;name&quot;: &quot;朋友圈状态&quot;, &quot;createTime&quot;: &quot;2017-04-03T12:14:06.676Z&quot;, &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;866982e498224b15aa4602f2893f7995&quot;, &quot;paramId&quot;: &quot;timelineId&quot; &#125; ], &quot;isDirectory&quot;: false, &quot;id&quot;: &quot;9b538d5bee1c40ed979e5a38143a9829&quot;&#125; 所有数据都是根据上述配置生成，其中param比较特殊，是把选择的数据节点直接拷贝了一份，这样做的原因是怕其他地方修改或者删除了导致数据不一致的问题，这样做更符合埋点这个需求。 接入编译系统目前编译系统还是做在了代码中，由于系统本身是有NodeJS实现的，所以要动态配置编译系统还是非常简单的。 编译系统比较开放，这样可以开放更多的功能，但同时也引入了数据风险，之后需要改进下，让编译系统可以动态接入，并且屏蔽内部数据和编译系统的直接联系。 目前代码放在/script目录下。 开发者这里对整个系统的代码逻辑进行说明。 设计理念 最基本的功能，需要能够在团队内共享数据，其中最方便的就是利用git系统了，所以在每次修改数据的时候除了本地持久化以外，会自动同步git上的数据文件，这也是为什么要数据分离的一个原因。 如果能够接上埋点系统，那么可以通过该系统去分析结果，这个工作量可能会比较大，是一个设想。 如果能够接上自动化测试或者设备，就能够验证埋点数据是否正确，这个的工作量也可能会比较大。 目前完成了最基础的管理埋点和生成代码功能。 运行环境nodejs Mac可以通过brew install nodejs来安装 需要electron和webpack 1npm install -g electron webpack 运行代码首先npm install 然后需要链接本地库 1234cd dd-statnpm linkcd ../statnpm link dd-stat 最后 12npm run dev #开启webpack -wnpm run app #启动应用 代码简介dd-stat是系统的数据层，包含了数据结构和持久化。 stat是界面层，为了实现简单，目前所有逻辑都是在渲染层做的，因为我们的数据量按照我们的需求是不太可能达到如此大的数目，是不太可能出现性能问题的。 stat依赖支付宝的ant design框架来搭建，最初是用redux来组织(/lib)，后来发现太过于复杂，应用本身就是个简单的场景，所以后来改为react-router来组织(/lib2)。 /script是数据编译的代码，是导出编译后代码或者导出其他格式的一个出口，可以根据需要扩展。 TODOgit接入最初的想法是让程序来自动同步git，因为应用的使用场景比较简单，不太可能出现多人同时编辑同一个数据的问题，所以让程序来自动同步数据是最好的，由于时间问题，暂时没有加入。 编译系统完善现在编译系统是和应用代码捆绑在一起的，最好能够脱离代码，并且可以动态配置编译模板。 更多可配的数据类型增加对bool，枚举单选，枚举多选，时间等的支持，项目暂时还没有这样的需求。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"埋点","slug":"埋点","permalink":"http://djs66256.github.io/tags/%E5%9F%8B%E7%82%B9/"},{"name":"工具","slug":"工具","permalink":"http://djs66256.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"美学的表现层组件化之路","date":"2017-04-09T09:21:49.000Z","path":"2017/04/09/2017-04-09-美学的表现层组件化之路/","text":"在很多以内容为主的应用中，比如考拉、严选，以及我们美学，界面内容通常比较复杂丰富，一个页面通常分为多个模块，各个模块之间独立性强，这样势必一个controller里面会有很多很多代码与逻辑来处理模块组合，导致代码日益膨胀。 这是一个表现层模块化组件，按照页面视觉结构，将一个页面划分为多个模块，然后通过模块间的简单组合，来实现复杂页面。并且将部分逻辑功能放到了对应组件，以达到复用与使用简单的效果。 目前，我们大部分展示型页面controller只有请求相关代码，基本能够控制在200行左右。 后来发现IGListKit和我们的思想非常类似。IGListKit简析与DDComponent 背景：由于我们的项目处于一个比较早期的阶段，所以我们需要很多的尝试来改良我们的方案。所以在这期间的页面结构极不稳定，内容以及位置顺序等，都可能会发生较大变化。事实上，在1.0之后的3个版本中，每个版本的首页都在大改。 如下我们的一个首页版本，模块非常明显，并且在其他页面也会使用到类似模块。 用户内容的高自由性，大部分内容为用户选填，如果内容缺省，需要删掉该行，所以需要动态计算布局也是非常麻烦。如下除了用户和产品，都是可选内容，不可控因素太多。 可以看出，我们的内容可能会达到一个非常大的级别，此时性能也会是一个问题，必须采用视图重用才可以避免内存问题。 同时，不同模块的加载可能是异步的，返回结果也可能不同，需要部分显示空态、错误等提示，这样又进一步导致了页面的复杂性。 接下来，我们一个个的解决这样的问题。 方案布局选型与重用问题：一种是tableView来实现这些类似于列表的功能，另外一种是使用CollectionView来实现同样的功能。 虽然分别实现了这两种对应方案，但是最终使用最多的还是CollectionView，有几个原因： CollectionView的布局是一次性算出来的，会有缓存，相当于性能优化 模块间的间距控制，CollectionView更加灵活，不需要调整cell就可以改变间距 可以看到我们的模块并不一定一行只有一个元素（比如首页），也不一定一个模块只有固定行数（比如上图的标签模块），如果使用tableView，还是会需要复杂的计算，而使用CollectionView，我们可以控制每个cell为最小的单位。 组件间组合与顺序问题有需求是服务器控制组合与顺序，所以这是我们首先需要解决的问题。所以这里引入两个概念： 1，视图组件： 只负责视图展示，比如一个包含小列表的模块，或者仅仅只有一个元素的模块。只负责职责内的视图展示。2，容器组件： 只负责组件间的组合，比如按照顺序或者空态等组合模式，当然最顶层的一个组件也是一个容器类组件。 这里容器类组件可以包含任意视图组件及容器类组件，而视图组件不能作为组合使用（这里有个特例HeaderFooterSectionComponent，其实提供了部分容器的概念，可以配置header和footer，一个细化）。 职责明确之后，我们就可以通过这种从属关系来任意组合我们的组件，如果不需要显示该视图，可以从容器组件中移除该组件或者将numberOf返回0个。 空态页、错误页等有了上一个的两个概念，处理这两个问题就变得简单了。抽象的来说，就是组件依据不同状态，而分别展示不同的子组件。相当于增加一层组件，该组件的功能是控制展示当前子组件。 那么设计一个状态与组件间对应的字典，在需要的时候切换该状态就行了，这就是后来增加的StatusComponent。 布局的多样化可能有些页面需要内容元素需要居中显示，或者FlowLayout默认的居左显示（多行的时候，除最后一行外为两端对齐模式），又或者需要永远居左显示（比如我们的标签）。 当选择了CollectionView作为方案时，这个问题就很好解决了，不需要改动component代码，只需要创建的时候输入自定义的Layout就可以轻松改变布局了。 实现按照以上的分析结果，最终实现了一套组件化实现方案（TableView结构类似，这里不做说明），源码大家自己看吧，就不介绍了： 上图蓝色的是视图组件，黄色的是容器组件。Group类型为顺序组合，Status组件为状态型组合。 请不要问我组件该怎么写，和写一个只有该模块内容的CollectionView一模一样，不会请参考苹果官方事例吧~ 使用流程 其中红色部分为日常开发需要真正关心的，可能需要写代码的部分，其他均由组件化解决，减少了开发一个新页面的成本。 Demo以我们的首页推荐为例，虽然我们的首页内容多而且复杂，但是Controller代码也在200行左右。下面来看看一个主要流程： 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // 外层容器结构 self.sectionGroupComponent = [DDCollectionViewSectionGroupComponent new]; self.statusComponent = [MZCollectionViewStatusComponent defaultComponent]; self.statusComponent.normalComponent = self.sectionGroupComponent; self.componentArray = @[self.statusComponent];&#125;MZHomeRecommendRequest *request = [[MZHomeRecommendRequest alloc] init];[request startWithBlock:^(MZHomeRecommendRequest *request, NSError *error) &#123; // 网络请求回来后首先判断状态，来切换空态页或者错误页，其实这里还可以加入loading页 if (!error) &#123; if (request.response.banners.count &gt; 0 &amp;&amp; request.response.groups.count &gt; 0) &#123; self.statusComponent.currentState = MZCollectionViewStateNormal; // 正常数据会根据数据来生成对应的component self.sectionGroupComponent.subComponents = [self componentFromData:request.response.groups]; &#125; else &#123; self.statusComponent.currentState = MZCollectionViewStateNoData; &#125; &#125; else &#123; self.statusComponent.currentState = MZCollectionViewStateError; self.statusComponent.errorComponent.title = error.localizedDescription; self.statusComponent.errorComponent.delegate = self; // 这里点击重新加载 &#125; [self.collectionView reloadData]; &#125;]; 再来看看单个component的结构，和一个单一元素的collectionView非常相似。1234567891011121314151617181920212223242526272829303132333435- (void)prepareCollectionView &#123; [super prepareCollectionView]; // 由于依赖collectionView，所以还是需要注册 [self.collectionView registerClass:MZRepoNormalStyleCollectionViewCell.class forCellWithReuseIdentifier:NSStringFromClass(MZRepoNormalStyleCollectionViewCell.class)];&#125;#pragma mark - UICollectionView- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return 1;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return self.repos.count;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; MZRepoNormalStyleCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass(MZRepoNormalStyleCollectionViewCell.class) forIndexPath:indexPath]; // config... return cell;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath &#123; return size;&#125;- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; [collectionView deselectItemAtIndexPath:indexPath animated:YES]; // push detail view controller&#125; 如何控制组件的顺序以及显示特性呢？ [self componentFromData:request.response.groups]，在我们组装视图组件时，可以随意调整组件的顺序，控制组件的显示，而无需关系兄弟组件的情况。 123456789- (NSArray *)componentFromData:(NSArray *)data &#123; NSMutibleArray *retArray; forEach switch (data[index].type) &#123; case type1: // add to array ... case type2: // add to array ... &#125;&#125; 扩展性在一些场景下，我们需要额外的delegate方法来满足我们的需求，比如我们的居左对齐和左划删除，需要把这些事件传入最终的视图component也很简单，只要扩展上面几个容器类组件的方法即可： 1234567891011@protocol MZRepoAlignLeftCollectionFlowLayoutDelegate &lt;UICollectionViewDelegateFlowLayout&gt;@interface DDCollectionViewSectionGroupComponent (MZRepoAlignLeftCollectionFlowLayout) &lt;MZRepoAlignLeftCollectionFlowLayoutDelegate&gt;- (BOOL)collectionView:(UICollectionView *)collectionView shouldAlignLeftAtSection:(NSInteger)section &#123; DDCollectionViewBaseComponent *comp = [self componentAtSection:section]; if ([comp respondsToSelector:@selector(collectionView:shouldAlignLeftAtSection:)]) &#123; return [(id&lt;MZRepoAlignLeftCollectionFlowLayoutDelegate&gt;)comp collectionView:collectionView shouldAlignLeftAtSection:section]; &#125; return NO;&#125; 按照这样的思想，就具有了高度的可扩展性。 一个对比 Facebook ComponentsKitFacebook 优点： 完全实现了自己的一套布局系统，粗略的看了下，反正没看懂(⊙﹏⊙) 能够很好的实现流式布局，类似于iOS的stack，或者说更像网页的flex布局（视图重用性应该不好） 缺点： 完全颠覆了原生的布局方式和代码习惯，学习成本高 C++编写而成，所以需要Objective-C++来编写，必须承认C++还是很难掌握的 美学 优点： 和原生CollectionView代码保持一致，学习成本低 从以前代码的转换成本低，我们也是一步步从原来的代码转到组件化的 缺点： 刷新数据需要重新计算整个Layout，此时会有性能损耗（这个要看数据量和视图复杂度，通常发生在页面切换，请求回来的时候，其实此时用户感知不到） 需要按照CollectionView的写法来组建，因此部分接口需要暴露indexPath，如果乱用，可能会导致崩溃 目前到目前为止，美学大部分页面，都是采用组件化组合而成，随意数数，已经有超过100个组件了，接下来可能需要整理下组件，增加单个组件的复用性了。 历经几个版本，组件化目前已经是比较完善和稳定的一个版本了，也满足了目前所有的需求和日常开发，期间也接受了各种奇怪的需求，目前来看扩展性还是可以的，有疑问可以直接私密我。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://djs66256.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"全局数据同步（二）UI篇","date":"2017-04-09T09:10:32.000Z","path":"2017/04/09/2017-04-09-全局数据同步（二）UI篇/","text":"上次讨论了如何让数据全局同步，但是在同步到UI层的时候还是有些麻烦。现在来解决UI层的问题。 之前的方案有两种： 在viewWillAppear的时候，reloadData，缺点是如果需要reload的数据太多，大量计算会导致阻塞主线程，虽然可能没有那么严重，但是有些时候还是能够感知出来。 使用KVO来监听变化，缺点是代码侵入性太强，而且严重影响了一些代码的统一性。 下面是使用KVO的一个例子： 123456789101112131415161718192021@weakify(self);[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(praiseCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.praiseCount = object.praiseCount;&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(praised)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); [self.recordTabbar setPraised:object.isPraised animated:self.view.window != nil];&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(collected)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); [self.recordTabbar setCollected:object.collected animated:self.view.window != nil];&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(collectCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.collectCount = object.collectCount;&#125;];[self.KVOController observe:_record keyPath:NSStringFromSelector(@selector(commentCount)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZRecord *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); self.recordTabbar.commentCount = object.commentCount;&#125;]; 上面是我们为了同步3个按钮的状态的代码，我们使用了一个第三方库来简化KVO的编写，但还是非常的冗余。 为此，开始思考有什么更简单的方法。 开始我们想要封装KVO，直接绑定数据和UI，但是很多数据并不是一一对应的，比如数字，状态，是需要转化的，而且状态变更很多情况下是需要动效的，所以无论如何都不免不了监听和转换这两个东西。 后来想，既然数据可以做全局同步，那么是否可以把视图也看作一种类型的资源，也自动同步该状态属性呢？按照这种思路，将视图改写支持这种方式来同步。 12345678@interface UIView (MZChannel) &lt;MZChannelProtocol&gt;// 我们需要在创建的时候就确定类型，而且不能修改，防止意料之外的情况- (instancetype)initWithFrame:(CGRect)frame channelType:(NSInteger)channelType;// 加入数据池中，并且内部增加了lock，保证线程安全- (void)bindId:(NSString *)id;// 为了避免与view自身属性冲突，增加了一个白名单配置- (NSArray&lt;NSString *&gt; *)channelWhiteList;@end 查看一下我们修改之后的状态 12345678910111213// RecordTabbar// 新增这两个方法，由于之前设计中的接口与该keyPath统一，所以其他内容不需要修改- (NSInteger)channelType &#123; return MZResourceTypeNote;&#125;- (NSArray&lt;NSString *&gt; *)channelWhiteList &#123; return @[NSStringFromSelector(@selector(praised)), NSStringFromSelector(@selector(praiseCount)), NSStringFromSelector(@selector(collected)), NSStringFromSelector(@selector(collectCount)), NSStringFromSelector(@selector(commentCount))];&#125; 12345678910111213141516171819// 部分对应的setter方法- (void)setPraised:(BOOL)praised &#123; _praised = praised; [self.praiseButton setPraised:praised animated:self.window != nil];&#125;- (void)setPraised:(BOOL)praised animated:(BOOL)animated &#123; _praised = praised; [self.praiseButton setPraised:praised animated:animated];&#125;- (void)setPraiseCount:(NSInteger)praiseCount &#123; _praiseCount = praiseCount; self.praiseButton.praiseCount = praiseCount;&#125;- (void)setCollected:(BOOL)collected &#123; [self setCollected:collected animated:self.window != nil];&#125; 由于该页面资源id并不会变化，所以只需要在初始化的时候绑定一次id就可以了。 1[self.recordTabbar bindId:self.record.id]; 这样我们的后半部分流程（从数据到显示）也完整了，整个流程都依赖于MZChannel进行。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"数据同步","slug":"数据同步","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"}]},{"title":"客户端全局数据同步方案(一)","date":"2017-04-02T13:14:27.000Z","path":"2017/04/02/2017-04-09-客户端全局数据同步方案一/","text":"很多时候产品们都有一些奇奇怪怪的想法和要求，这里我们就有一个需求，要求我们应用里面所有的用户行为数，比如阅读数、点赞数、评论数和关注、点赞状态等全局同步，一旦有变更要求全局更新显示。 准备开始我们考虑了一种方案，创建一个池子，所有同一类型的Model都存放在池子里面，使用时优先在池子里面取，不存在时创建并加入池子。这样我们就能够确保我们应用里面的所有“同一对象”，是真正的同一个对象。 但是这样做也存在很多问题： 当这个需求提出来开始做的时候我们的应用已经基本成型，很多接口和model并没有统一，如果要采用这种方案必然需要大改。 这样做势必会导致model的冗余属性。 接口有些时候放回相同字段，但是意义不一致。 第三方库的支持。比如YYModel的解析需要修改很多地方才能使用。 所以考虑了以下的方案。 方案思路保持一致，将需要同步的对象加入全局的池子。但是各自创建各自的对象，在需要全局同步的时候，提交该对应的keyPath，然后更新池子中拥有相同类的成员。在view层，使用KVO监听变化。 缺点： 由于根据了类名来作为判断该对象是否属于同一对象，所以继承或者拥有不同类名的“同一对象”并不能被识别为相同的。 在我们已经比较完善的项目中，要做这样的统一，几乎是不可能的，所以特例化了部分场景，来满足我们当前的需求。 方案优化版 我分析了我们应用中需要使用到全局同步的对象，可以分为几种类型（比如动态、评论等），并不会存在特别复杂的类型。而且每种类型必定会存在一个唯一的ID，所以觉得可以通过type和ID来唯一确定是“同一个对象”。 所以将结构修改为下，所有需要支持全局同步的类都需要实现下面的协议。 12345678910@protocol MZChannelProtocol &lt;NSObject&gt;@property (readonly, nonatomic) NSString *id;@property (readonly, nonatomic) NSInteger channelType;@optional// 提供一个keyPath转换的方法- (NSString *)translateKeyPath:(NSString *)keyPath;@end 接口设计如下 12345678910@interface MZChannel : NSObject+ (instancetype)sharedChannel;// 需要在类创建完之后加入池子，一般在init方法中- (void)addObject:(id&lt;MZChannelProtocol&gt;)obj;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value;@end 同时在使用KeyPath的过程中需要判断是否合法，防止某些对象不存在该成员而crash。 1234567891011121314151617181920212223242526// 这里使用set方法来判断是否可以同步，所以实际上只要实现了对应的set方法就可以了，并不需要实际的property。- (BOOL)canPerformKeyPath:(NSString *)keyPath newKeyPath:(out NSString **)aKeyPath &#123; if ([self conformsToProtocol:@protocol(MZChannelProtocol)] &amp;&amp; keyPath.length &gt; 0) &#123; id&lt;MZChannelProtocol&gt; cself = (id&lt;MZChannelProtocol&gt;)self; if ([cself channelType] &lt;= 0) &#123; return NO; &#125; NSString *selectorStr = [NSString stringWithFormat:@&quot;set%@%@:&quot;, keyPath.firstLetter.uppercaseString, [keyPath substringFromIndex:1]]; if ([self respondsToSelector:NSSelectorFromString(selectorStr)]) &#123; return YES; &#125; else if ([cself respondsToSelector:@selector(translateKeyPath:)]) &#123; NSString *transKeyPath = [cself translateKeyPath:keyPath]; if (transKeyPath) &#123; if (transKeyPath.length &gt; 0) &#123; selectorStr = [NSString stringWithFormat:@&quot;set%@%@:&quot;, transKeyPath.firstLetter.uppercaseString, [transKeyPath substringFromIndex:1]]; if ([self respondsToSelector:NSSelectorFromString(selectorStr)]) &#123; if (aKeyPath) *aKeyPath = selectorStr; return YES; &#125; &#125; &#125; &#125; &#125; return NO;&#125; 池子的实现，把整个池子分为若干桶，每个桶的key为相应的type，桶使用weak类型的hashTable来实现存储。 这里需要注意的是一些多线程可能导致的问题，所以在更新操作中使用了锁。由于我们应用内“同一对象”和“同类型对象”的数目预估应该存在不超过1000个，所以不需要考虑性能问题，也就可以在主线程中同步数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@interface MZChannelObject : NSObject@property (assign, nonatomic) NSInteger type;@property (strong, nonatomic) NSHashTable&lt;id&lt;MZChannelProtocol&gt;&gt; *hashTable;@property (strong, nonatomic) NSLock *lock;- (void)addObject:(id&lt;MZChannelProtocol&gt;)object;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value;@end@implementation MZChannelObject- (instancetype)init&#123; self = [super init]; if (self) &#123; _hashTable = [[NSHashTable alloc] initWithOptions:NSPointerFunctionsWeakMemory capacity:0]; _lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)addObject:(id&lt;MZChannelProtocol&gt;)object &#123; [self.lock lock]; [_hashTable addObject:object]; [self.lock unlock];&#125;- (void)emitType:(NSInteger)type id:(NSString *)id keyPath:(NSString *)keyPath forValue:(id)value &#123; if (type == self.type) &#123; [self.lock lock]; for (NSObject&lt;MZChannelProtocol&gt; *obj in _hashTable) &#123; NSString *aKeyPath = nil; if ([obj.id isEqualToString:id] &amp;&amp; [obj canPerformKeyPath:keyPath newKeyPath:&amp;aKeyPath]) &#123; dispatch_block_t updateValue =^() &#123; if (aKeyPath) &#123; [obj setValue:value forKey:aKeyPath]; &#125; else &#123; [obj setValue:value forKey:keyPath]; &#125; &#125;; if ([NSThread currentThread].isMainThread) &#123; updateValue(); &#125; else &#123; // 防止KVO刷新页面的时候的子线程操作UI dispatch_sync(dispatch_get_main_queue(), updateValue); &#125; &#125; &#125; [self.lock unlock]; &#125;&#125;@end 使用12345678910111213141516171819@interface MZUser : NSObject &lt;MZChannelProtocol&gt;@property (strong, nonatomic) NSString *id;@end@implementation MZUser- (instancetype)init&#123; self = [super init]; if (self) &#123; [[MZChannel sharedChannel] addObject:self]; &#125; return self;&#125;- (NSInteger)channelType &#123; return MZResourceTypeUser;&#125;@end 在请求关注或者取消关注的时候触发同步 123[user emitKeyPath:NSStringFromSelector(@selector(followed)) forValue:@(YES)];或者[[MZChannel sharedChannel] emitType:MZResourceTypeUser id:user.id keyPath:NSStringFromSelector(@selector(followed)) forValue:@(YES)]; 然后使用KVO来观察对象变化 123[self.KVOController observe:_user keyPath:NSStringFromSelector(@selector(followed)) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, MZUser *object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; // update UI ... &#125;]; 缺点虽然实现了全局同步，但是由于使用了统一的池子，会导致DEBUG困难。 需要实现人工判断更新的内容。 KVO不能判断该更新是用户操作引起的，还是由其他对象变更引起的。这里可能涉及到行为动画，但是我们的业务场景不可能一个页面出现两个相同的内容，所以并没有什么影响。 虽然可以使用KVO来实现同步UI的更新，但并没有做到和MVVM一样的同步更新，还是需要人工处理更新逻辑。 有一定的代码侵入性，需要继承协议，并且在初始化的时候加入池子。 总结这里限制了一部分的使用场景，来满足了特定环境下的需求，希望能给其他需要同步数据的场景一个方法。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"数据同步","slug":"数据同步","permalink":"http://djs66256.github.io/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"}]},{"title":"最近一年总结","date":"2017-04-01T13:14:27.000Z","path":"2017/04/01/2017-04-01-最近一年总结/","text":"2016年，加入了网易一个半创业项目。为什么会说是半创业项目呢？首先，这是一个从0开始的项目，网易内部也没有类似的产品线。但是依靠着丁磊爸爸，不像其他创业项目一样，至少不愁吃喝。 从最开始的4个人，现在已经发展到产品团队已经达到50人左右的规模了。期间也出现了很多创业团队类似的问题和弯路，到现在也算是平稳的发展了。 由于之前一直处于鸡血状态，最近才开始稍微闲下来，可以开始写一些东西，所以打算先把最近一年的事情慢慢总结一下。 工作方面跟随着项目进行，亲自从0开始构建一款应用，一步步探索，小心翼翼的技术选型，然后又进行了多次的重构。第一次能够从一个真正的创作者身份来看待很多问题，当自己的身份发生改变之后，自己的一些视野和观点也产生了一些变化。 技术技术很重要，一个厉害的程序员，真的有时候能顶好几个人，而且前期架构好的东西，到后期维护的成本就会很低，但是前期就是临时方案的东西，到后面维护成本会非常高。 专业的人做专业的事。虽然现在很流行全栈工程师，的确全栈的人可以是一个很厉害的程序员，但我还是推荐做自己擅长的事情。毕竟人的精力有限，一个经验丰富的普通程序员，会更适合，经验还是能够决定很多事情的。 想法，新的项目需要新的想法和创新，老的东西虽然可靠，但不一定合适，而且你要考虑到整个团队的接受程度，不能单纯的从自己的经验出发，每个人的想法都是有利弊的，除非你有自信自己的水平能够高几个等级。 重构，项目需要持续的重构，在不停的堆叠功能的时候，就会有很多的临时或者兼容方案，当这样的方案在你能够控制的时候，需要及时的进行重构，不然很快你就会陷入项目的泥潭。这需要领导者有足够的眼光和开发者有足够的魄力。我做的部分重构甚至不是在工作时间做的。 统一，每个开发组的成员需要尽可能的统一。老生常谈的命名，代码习惯，以及一些设计方案，如果能够在整个组的角度去做的统一，那么每个人的效率和提高很多，沟通成本也会降低很多。 理解力，一定要去看对方的代码！需要去了解同组其他人的一些习惯和风格，去理解其他人的想法。很多时候当看完了别人的代码才能知道别人设计的精妙以及其中存在的一些坑，这样才能在自己使用的时候不会出现什么问题。 管理需要一个有话语权的领导者，能够把当前的一些情况真实的反馈给上层，“翻译”基层员工的一些想法和困难。只是报喜不报忧，或者只会把压力转移到下级的都不会给项目带来好的影响。 领导者还需要引领团队，但需要考虑到整个团队的情况，不能仅仅按照自己的想法进行，因材施教，分别对待才是一个优秀领导者所具备的。 管理是一个非常大的话题，很多时候不同岗位之间出现的矛盾需要管理者能够很好的协调，不论哪一方拿自己的需求来说事，都是有很坏的影响的，解决这类问题才是管理者所需要做的。 生活方面越来越觉得自己的身体素质在逐渐的下降，感觉已经不能像以前那么的拼了。养了一只猫，希望能够有一间自己的房子。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[]},{"title":"社会化分享组件封装","date":"2016-07-03T13:14:27.000Z","path":"2016/07/03/2016-07-03-she-hui-hua-fen-xiang-zu-jian-feng-zhuang/","text":"社会化分享是大部分应用都会集成的模块，现在市场上也有很多的商业产品（友盟，shareSDK），但是很多时候我们还是需要自己的分享组件，同时也要支持第三方登录。 分享内容如果需要统一接口，必须首先统一分享内容，把几种比较常见的和共有的分享内容合并。以下是几种各个平台都比较统一的结构。构造分享内容的时候尽量填满所有的类型，来满足各个平台的不同需求。 12345678910111213141516171819typedef NS_ENUM (NSInteger, MZShareType) &#123; MZShareTypeUndefined = 0, MZShareTypeURL, MZShareTypeText, MZShareTypeImage&#125;;@property (assign, nonatomic) NSInteger shareType;@property (strong, nonatomic) NSString *title;@property (strong, nonatomic) NSString *detail;@property (strong, nonatomic) NSURL *URL;@property (strong, nonatomic) UIImage *image;@property (strong, nonatomic) UIImage *thumbImage;@property (strong, readonly, nonatomic) NSData *imageData; // &lt; 5M@property (strong, readonly, nonatomic) NSData *thumbImageData; 因为很多平台对缩略图有要求，而且大小不一致，这里我们可以在不影响质量的情况下取最小值。 12345678910111213141516- (UIImage *)thumbImageWithImage:(UIImage *)image maxPixelSize:(NSInteger)size forceCreated:(BOOL)forceCreated &#123; CFStringRef thumbnailCreatedKey = forceCreated ? kCGImageSourceCreateThumbnailFromImageAlways:kCGImageSourceCreateThumbnailFromImageIfAbsent; NSDictionary *options = @&#123;(__bridge NSString *)kCGImageSourceThumbnailMaxPixelSize: @(size), (__bridge NSString *)thumbnailCreatedKey : @YES&#125;; CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)UIImagePNGRepresentation(image), (__bridge CFDictionaryRef)options); CGImageRef thumbImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, (__bridge CFDictionaryRef)options); UIImage *UIThumbImage = [UIImage imageWithCGImage:thumbImage];CLEAR: CGImageRelease(thumbImage); if (imageSource) &#123; CFRelease(imageSource); &#125; return UIThumbImage;&#125; 第三方认证数据大部分都会有token和expireDate这两个参数，同样，也建立一个类来保存用户认证信息。 12@property (strong, nonatomic) NSString *token;@property (strong, nonatomic) NSDate *expireDate; 分享外观Manager这里我们采用尽可能的去分享的原则来处理。只要支持这种类型，并且安装了app的就显示分享。 1234567891011+ (BOOL)openURL:(NSURL *)url;// 所有对该分享对象可用的分享类型+ (NSArray&lt;ShareInterface *&gt; *)avaliableInterfacesForShareItem:(ShareItem *)item;+ (void)share:(ShareItem *)item delegate:(id&lt;ShareDelegate&gt;)delegate;// 所有可用的认证类型+ (NSArray&lt;AuthInterface *&gt; *)avaliableInterfacesForAuthentication;+ (void)authWithInterface:(AuthInterface *)interface delegate:(id&lt;ShareDelegate&gt;)delegate;+ (void)logout; // 注销所有的认证账号 分享接口我们需要统一不同类型的分享 12345678910111213141516171819+ (BOOL)canShareItem:(MZShareItem *)item; + (BOOL)canShareText;+ (BOOL)canShareImage;+ (BOOL)canShareURL;+ (BOOL)supportAppInnerShare;+ (BOOL)requiresAuthentication;+ (BOOL)isLogin;+ (BOOL)needLocalApplication;+ (BOOL)isApplicationInstall;- (BOOL)openURL:(NSURL *)URL;- (instancetype)initWithItem:(MZShareItem *)shareItem;- (void)send;- (void)notifySuccess;- (void)notifyFailureWithMessage:(NSString *)error; 123// Delegate- (void)shareDidSucceed:(MZShareInterface *)interface;- (void)shareDidFail:(MZShareInterface *)interface error:(NSError *)error; 认证接口注意事项这里最大的注意事项是，我们不能确保整个流程是否能够完全的走完。当跳转到其他应用的时候，用户并不一定回调回来，可能关闭或者做其他事情去了，这时候我们要在应用再次被唤起的时候，把当前的状态重置。由于这里我们不知道最终结构，所以我只能作为失败来处理。 123456789[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidBecomeActiveNotification:) name:UIApplicationDidBecomeActiveNotification object:nil];- (void)applicationDidBecomeActiveNotification:(NSNotification *)noti &#123; if (_status == MZShareInterfaceStatePendingShare) &#123; [self notifyFailureWithMessage:@&quot;分享失败&quot;]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/tags/iOS/"},{"name":"社会化分享","slug":"社会化分享","permalink":"http://djs66256.github.io/tags/%E7%A4%BE%E4%BC%9A%E5%8C%96%E5%88%86%E4%BA%AB/"}]},{"title":"从UITextView看文字绘制优化","date":"2016-06-23T01:39:50.000Z","path":"2016/06/23/2016-06-23-cong-uitextviewkan-wen-zi-hui-zhi-you-hua/","text":"最近有一个地方需要自定义文字编辑器，所以使用了iOS7开始支持的UITextKit来绘制，同时也遇到不少的坑，这里来说说我遇到的几个坑，以及解决方案。源码在Github。 UITextView 分段绘制原理分析首先，我们来看下NSLayoutManager里面的几个方法： 123456789- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin;- (void)invalidateDisplayForCharacterRange:(NSRange)charRange;- (void)invalidateDisplayForGlyphRange:(NSRange)glyphRange;- (void)ensureGlyphsForCharacterRange:(NSRange)charRange;- (void)ensureGlyphsForGlyphRange:(NSRange)glyphRange;- (void)ensureLayoutForCharacterRange:(NSRange)charRange;- (void)ensureLayoutForGlyphRange:(NSRange)glyphRange; 可以看出来，无论是绘制方法，还是布局方法，都是有个范围选择，由此可以知道，UITextView的绘制过程绝对不是一次性绘制（对比YYText)。重写该方法也可以看出来UITextView是分多段绘制的。 现在我们来简单的做几个实验： 重写- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin;,并使用该LayoutManager创建UITextView： 12345678DDAttachmentLayoutManager *layoutManager = [[DDAttachmentLayoutManager alloc] init];NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:CGSizeMake(frame.size.width, CGFLOAT_MAX)];textContainer.widthTracksTextView = YES;[layoutManager addTextContainer:textContainer];NSTextStorage *textStorage = [[NSTextStorage alloc] initWithString:@&quot;&quot;];[textStorage addLayoutManager:layoutManager];UITextView *textView = [[UITextView alloc] initWithFrame:frame textContainer:textContainer]; 放入一段足够长的文字，在我们滑动的过程中，UITextView会分多次调用draw方法，这样显著降低了损耗和提升了性能，把多次绘制过程分散到滑动的过程中。 以上是纯文本的结果，那如果我们放入其他类型的数据呢？在这里，我放入多个NSTextAttachment自定义类型的数据。重复以上的测试。 结果是，当缓慢下拉的时候，同样是分段载入的，而且attachment往往作为单独的一段来绘制。但是有个不同的地方就是，可以看到contentSize在变化，而且可以看到右边的进度条在接近底部的时候忽然间回到上面，并且变短了。 由此可知在开始的时候，UITextView会拥有一个预期的大小，在加载过程中如果碰到attachment导致这个大小不符合，就会将下面一段内容加入计算，重新得出contentSize。这样会给我们带来一些麻烦，不能准确的获得contentSize，导致一些bug，解决方案很简单，我们先看下面另一个问题。 如果我们进入的时候是在最后一行呢。同样也是有这样的逻辑，这样的逻辑对于自定义的AttachmentView来说会有很多的问题，最大的问题就是在contentSize变化的时候，subview位置错误。 如何解决这样的问题，只要我们强制让UITextView布局整个的富文本就行了。 1[self.textView.layoutManager ensureLayoutForCharacterRange:NSMakeRange(0, self.textView.textStorage.length)]; 自定义富文本编辑器首先我们需要实现自己的Attachment，主要功能是实现占位符的大小。 12345678910@interface DDTextAttachment : NSTextAttachment@property (copy, nonatomic) NSString *placeholderString;@property (strong, nonatomic) id data;@property (assign, nonatomic) BOOL fillWidth;@property (assign, nonatomic) UIEdgeInsets contentInset;@property (assign, nonatomic) CGSize size;@end 然后重写DDAttachmentLayoutManager 12- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin 在这里把需要展示的视图，按照位置贴到父视图上。 这样就是整个方案的思路，具体实现可以参考Github 内存优化方案最开始，我采用的是把所有的attachment view都实例化出来，再贴到textView上，但是当整个文章比较长，并且结构复杂的时候，会发现占用很多的内存，联想到苹果的分段绘制和tableView的reuse，我决定把整个框架改写为可重用的模式。 首先，我们模仿tableView定义接口。 12- (void)registerClass:(Class)cls forAttachmentViewWithReuseIdentifier:(NSString *)identifier;- (__kindof DDAttachmentReusableView *)dequeueReusableAttachmentViewWithIdentifier:(NSString *)identifier; 12// protocol- (DDAttachmentReusableView *)textView:(DDAttachmentTextView *)textView attachmentViewWithAttachment:(DDTextAttachment *)attachment; 然后，重写AttachmentLayoutManager绘制方法，在需要绘制的时候再去生成视图。 12345678910111213141516171819202122232425262728- (void)drawGlyphsForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin&#123; [super drawGlyphsForGlyphRange:glyphsToShow atPoint:origin]; NSUInteger start = [self characterIndexForGlyphAtIndex:glyphsToShow.location]; NSUInteger end = [self characterIndexForGlyphAtIndex:glyphsToShow.location + glyphsToShow.length]; [self.textStorage enumerateAttribute:NSAttachmentAttributeName inRange:NSMakeRange(start, end - start) options:NSAttributedStringEnumerationLongestEffectiveRangeNotRequired | NSAttributedStringEnumerationReverse usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123; DDTextAttachment *attachment = (DDTextAttachment *)value; if ([attachment isKindOfClass:[DDTextAttachment class]]) &#123; NSUInteger glyphIndex = [self glyphIndexForCharacterAtIndex:range.location]; CGRect rect = [self boundingRectForGlyphRange:NSMakeRange(glyphIndex, 1) inTextContainer:[self textContainerForGlyphAtIndex:glyphIndex effectiveRange:NULL]]; // 这里才去生成视图 UIView *attachmentView = [self.attachmentDelegate attachmentLayoutManager:self viewForAttachment:attachment]; attachmentView.frame = CGRectMake(origin.x + rect.origin.x + attachment.contentInset.left, origin.y + rect.origin.y + attachment.contentInset.top, rect.size.width - attachment.contentInset.left - attachment.contentInset.right, attachment.size.height); attachmentView.hidden = NO; &#125; &#125;];&#125; 然后，重写contentOffset，在其变化的时候检测是否有视图需要显示，或者是否有视图已经移出屏幕。 123456789101112131415161718192021222324252627282930- (void)setContentOffset:(CGPoint)contentOffset &#123; [super setContentOffset:contentOffset]; CGFloat visiblePadding = 10; // 让他稍微大一点，可以早一点载入 CGRect visibleRect = CGRectOffset((CGRect)&#123;0, -visiblePadding, self.frame.size.width, self.frame.size.height+2 * visiblePadding&#125;, self.contentOffset.x, self.contentOffset.y); for (DDAttachmentReusableView *view in _attachmentViews) &#123; if (view.superview) &#123; // [1] if (!CGRectIntersectsRect(visibleRect, view.frame)) &#123; [view removeFromSuperview]; &#125; &#125; &#125; NSRange range = [self.layoutManager glyphRangeForBoundingRect:CGRectMake(0, visibleRect.origin.y+self.textContainerInset.top, visibleRect.size.width, visibleRect.size.height) inTextContainer:self.textContainer]; NSRange charRage = [self.layoutManager characterRangeForGlyphRange:range actualGlyphRange:nil]; [self.textStorage enumerateAttribute:NSAttachmentAttributeName inRange:charRage options:0 usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123; if ([value isKindOfClass:[DDTextAttachment class]]) &#123; for (DDAttachmentReusableView *view in _attachmentViews) &#123; // [2] if (view.superview &amp;&amp; view.attachment == value) &#123; return ; &#125; &#125; // [3] [self.layoutManager invalidateDisplayForCharacterRange:range]; &#125; &#125;];&#125; [1] 当视图不在屏幕显示区域内的时候，移出父视图 [2] 当视图在显示区域并且没有变化的时候不需要重用操作。 [3] 重用视图，要求重绘这个占位符。 这样，又会转移到绘制的地方，最终会调用reuse的代码。经过实验测试，原来可能实例化的很多视图，现在同时存在的一般维持在2个左右，大大降低了内存占用。 这样的做法对性能的影响： 在我使用UIImageView的时候，完全感觉不出来。 在我使用UICollectionView的时候，在iPhone 4s手机上会有一点点的感觉，但是几乎难以察觉。 所以对这次的优化还是非常满意的。 ios8 deleteBackward这是应该是苹果的一个bug，从iOS8.0-8.3系统，重写UITextView，UIInput协议的deleteBackward的时候，发现删除的时候不能被触发，而且仅仅只在这几个系统下才有这样的问题。stackoverflow上提出的解决方案是重写一个私有api，这个不会被苹果AppStore拒绝。 1234567891011121314151617181920- (BOOL)keyboardInputShouldDelete:(TextField *)textField &#123; BOOL shouldDelete = YES; if ([TextField instancesRespondToSelector:_cmd]) &#123; BOOL (*keyboardInputShouldDelete)(id, SEL, UITextField *) = (BOOL (*)(id, SEL, UITextField *))[UITextField instanceMethodForSelector:_cmd]; if (keyboardInputShouldDelete) &#123; shouldDelete = keyboardInputShouldDelete(self, _cmd, textField); &#125; &#125; BOOL isIos8 = ([[[UIDevice currentDevice] systemVersion] intValue] == 8); BOOL isLessThanIos8_3 = ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 8.3f); if (![textField.text length] &amp;&amp; isIos8 &amp;&amp; isLessThanIos8_3) &#123; [self deleteBackward]; &#125; return shouldDelete;&#125; ios7 boudingRect在iOS7上，要计算文字的高度，被换成了新的方法boudingRect，但是在iOS7的系统上，还是会有错误的。 如果你是UILabel，那么没有问题，但是，如果你使用的是UITextView，那么，两者的实际高度为不一致的，可以看的出来，在iOS7上，Label的绘制方式和UITextView还是不一样的。 要解决这个问题，只能实例化一个UITextView对象了： 123456if ([[UIDevice currentDevice].systemVersion integerValue] == 7) &#123; UITextView *textView = self.templateRepoEditorTextView; textView.attributedText = [[NSAttributedString alloc] initWithString:realText attributes:attributes]; return [textView sizeThatFits:CGSizeMake(width, CGFLOAT_MAX)].height + paragraphSpacing;&#125; 在某些场合，为了避免频繁的动态生成，可以使用NSCache做一层缓存。 12345678910111213- (UITextView *)templateRepoEditorTextView &#123; static NSString * const key = @&quot;templateRepoEditorTextView&quot;; UITextView *textView = [_cache objectForKey:key]; if (textView == nil) &#123; textView = [[UITextView alloc] init]; textView.textContainer.widthTracksTextView = YES; textView.textContainer.lineFragmentPadding = 0; textView.textContainerInset = UIEdgeInsetsZero; [_cache setObject:textView forKey:key]; &#125; return textView;&#125; NSTextAlignmentJustified 两端对齐在UITextView和UILabel的对齐样式属性里面，虽然没有说明禁止使用两端对齐的方式，但是其实是不支持的，如果需要支持，需要使用NSAttributedString来设置，而且只设置了对齐方式还是不能对齐的，还需要一个下划线的属性（这可能也是一个系统缺陷）。 123456789101112NSMutableParagraphStyle *paragraph = [[NSMutableParagraphStyle defaultParagraphStyle] mutableCopy];paragraph.lineSpacing = 5;paragraph.paragraphSpacing = 15;paragraph.lineBreakMode = NSLineBreakByWordWrapping;paragraph.alignment = NSTextAlignmentJustified;NSDictionary *attribute = @&#123; NSFontAttributeName: [UIFont fontWithName:@&quot;Helvetica&quot; size:17], NSParagraphStyleAttributeName: paragraph, NSForegroundColorAttributeName: RGB(60, 60, 0), NSUnderlineStyleAttributeName: @0&#125;;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"UITextKit","slug":"UITextKit","permalink":"http://djs66256.github.io/tags/UITextKit/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://djs66256.github.io/tags/NSAttributedString/"}]},{"title":"讨论TDD为什么很少在项目中应用","date":"2016-06-03T09:44:09.000Z","path":"2016/06/03/2016-06-03-tao-lun-tddwei-shi-yao-hen-shao-zai-xiang-mu-zhong-ying-yong/","text":"测试驱动开发，一直以来都是很热门的讨论，但是在国内互联网行业中，大部分的项目还是拒绝使用TDD。我自己尝试了下TDD这种开发模式，感受到为什么大家虽然觉得他很好，但使用的人很少的部分原因了。 TDD 测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。 测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。 正面评价 可以有效的避免过度设计带来的浪费。但是也有人强调在开发前需要有完整的设计再实施可以有效的避免重构带来的浪费。 可以让开发者在开发中拥有更全面的视角。 负面评价 开发者可能只完成满足了测试的代码，而忽略了对实际需求的实现。有实践者认为用结对编程的方式可以有效的避免这个问题。 会放慢开发实际代码的速度，特别对于要求开发速度的原型开发造成不利。这里需要考虑开发速度需要包含功能和品质两个方面，单纯的代码速度可能不能完全代表开发速度。 对于GUI,资料库和Web应用而言。构造单元测试比较困难，如果强行构造单元测试，反而给维护带来额外的工作量。有开发者认为这个是由于设计方法，而不是开发方法造成的困难。 使得开发更为关注用例和测试案例，而不是设计本身。目前，对于这个观点有较多的争议。 测试驱动开发会导致单元测试的覆盖度不够，比如可能缺乏边界测试。在实际的操作中，和非测试驱动开发一样，当代码完成以后还是需要补充单元测试，提高测试的覆盖度。 以上是维基百科上面的解释。 从我个人的使用上来看，测试驱动开发虽然说是一种敏捷开发的终极形态，但是从某些角度上来看，更像是瀑布型和敏捷的一种妥协。更像是每个小迭代都是严格的瀑布型。 在瀑布型里，需求是确定的，在确定的需求下，开发和测试可以并行进行，从而保证最终的质量。在敏捷里面，需求是变更的，很多时候需要根据市场反馈进行调整，甚至在同一个开发周期内都可能发生变更，当敏捷里面使用测试驱动开发的时候，必定会浪费更多的时间在写测试上面，并且在需求变更的时候，不仅仅代码需要修改，测试代码也同时需要修改，这也有点违背了这个模式的初衷了。 现在大部分需要敏捷开发的都是业务型的产品，从我的了解，很多著名产品，都是没有白盒测试的，特别是客户端，主要进行黑盒测试。从这里面可以看出来，对测试的投入想必是非常庞大的，一般来说，测试和开发应该需要1:1的比例，但是在当前的互联网环境下，拥有如此庞大复杂的体系肯定不是一个能够快速反应的团队，也就不具备了在互联网行业的竞争优势。 在我的了解，大家叫好不叫卖的原因主要有如下几个： 本身白盒测试就是一个非常耗时耗资源的东西，很多情况下不可能投入如此多的资源在这上面。 黑盒测试已经能够满足90%的需求了，投入产出比不好看 产品是业务型的，对质量的要求并没有那么的高 缺陷的影响或者修复成本低 当然，我们要讨论的不是测试驱动开发的优劣，而是应该考虑如何利用他的优点，同时又避免他的缺点。 核心部分，重要部分，可以尝试使用测试驱动开发，特别是可能会用很长时间的，同时也方便未来可能的重构。 对于业务以及一些变动大的内容，尽量避免使用，以免未来代码改了，测试代码没有变 为了保证质量，除了更详细的黑盒测试以外，需要加入很多其他的措施，比如用户的反馈，奔溃异常日志的收集与统计，对于客户端产品，可能需要动态修复，来确保质量 在我自己的感觉上来说，写测试的时候的确会想到很多开发时候可能没有注意到的问题，但是在开发的时候也会感到测试没有覆盖到一些情况，这可能也是因为两种思维不停的切换吧，所以最好还是完全分开来做，不要写一块做一块。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://djs66256.github.io/tags/TDD/"},{"name":"测试驱动开发","slug":"测试驱动开发","permalink":"http://djs66256.github.io/tags/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"C方法的Method Swizzling","date":"2016-05-17T11:04:20.000Z","path":"2016/05/17/2016-05-17-cfang-fa-de-method-swizzling/","text":"不久前，Facebook开源了一个c方法的替换库fishhook，我好奇的去研究了下。 只需要很简单的一个方法调用就可以实现替换。 1234567rebind_symbols( (struct rebinding[2])&#123; &#123;&quot;close&quot;, my_close, (void *)&amp;orig_close&#125;, &#123;&quot;open&quot;, my_open, (void *)&amp;orig_open&#125; &#125;, 2); 根据官方的解释是， 当我们去链接动态链接库的时候，我们替换了重定向表里面的函数指针，使其指向我们想要替换的方法，所以调用的时候，自然调用到我们替换的方法中去了。 说起来简单，但还需要了解很多的东西。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"hook","slug":"hook","permalink":"http://djs66256.github.io/tags/hook/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"http://djs66256.github.io/tags/Method-Swizzling/"}]},{"title":"express+react解决方案 （三）","date":"2016-05-15T16:51:38.000Z","path":"2016/05/16/2016-05-15-express-plus-reactjie-jue-fang-an-3/","text":"React WEB 客户端实现。 React 语法这个网上的资料很多，使用也很简单，JSX 的语法也非常方便，和 HTML 差别不大，这里就不多做介绍。主要看看 React 项目里面一些技术和方案。 FluxReact 仅仅只是一套页面的解决方案，并不包含数据以及各个页面之间的交互，所以还需要一套业务框架。Facebook官方开源的是Flux，其他还有一套Redux，原理和结构大致都一样，我这里使用Flux。 上面是著名的flux架构关系图。里面主要由Action, dispatcher, store三个部分组成，数据流向单一，`view -&gt; action -&gt; dispatcher -&gt; store -&gt; view’，与一些双向绑定的框架来说，简单不少。 Webpack这里，还需要一个打包工具，我选择了webpack，由于配置比较麻烦，直接套用了别人的配置React-Starter。 12345678&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev-server&quot;: &quot;webpack-dev-server --config webpack-dev-server.config.js --progress --colors --port 2992 --inline&quot;, &quot;hot-dev-server&quot;: &quot;webpack-dev-server --config webpack-hot-dev-server.config.js --hot --progress --colors --port 2992 --inline&quot;, &quot;build&quot;: &quot;webpack --config webpack-production.config.js --progress --profile --colors&quot;, &quot;start-dev&quot;: &quot;node lib/server-development&quot;, &quot;start&quot;: &quot;node lib/server-production&quot;&#125; 查看React-Starter的包文件，可以看到除了开发服务器以外，还有一个实时监控文件变化的编译系统。这个配置已经比较完整，大部分功能都有了，但是还不是特别适合，比如实时debug等。 SEOReact比较困难的是做SEO，因为页面都是动态生成，所以被爬虫的时候并不能展现所有的页面，所以需要服务器渲染。 React只做服务端渲染，或者只做客户端渲染都比较简单，但是如果要两种都支持就比较麻烦。虽然React-Starter给与了我们预渲染的功能，但不太实用，所以我这里做了一套新的。 superagent因为有很多页面的数据都是需要请求Rest接口的，所以我选用了superagent这个服务器和客户端都支持的开源组件，作为请求数据的组件。 请求分类这里采用和express一样的方法，在路由里面做判断。如果命中，则获取数据并使用预渲染的方法，如果没有命中，则返回最原始的HTML。 123routes.get(&#x27;/*&#x27;, function (params) &#123; // get rest data&#125; 这部分的代码实现还比较混乱，还需要再优化和重构。Github","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"react","slug":"react","permalink":"http://djs66256.github.io/tags/react/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ES6","slug":"ES6","permalink":"http://djs66256.github.io/tags/ES6/"},{"name":"服务器","slug":"服务器","permalink":"http://djs66256.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"express+react解决方案 （二）","date":"2016-05-14T16:51:38.000Z","path":"2016/05/15/2016-05-15-express-plus-reactjie-jue-fang-an-2/","text":"这里来谈谈rest api服务构建。 ExpressExpress是node做http服务最有名的一个框架了，具体如何安装使用我不做介绍了，大家可以参考官方网站。 ES6由于ES6的新特性实在是太棒了，所以我选择使用ES6。可是node目前版本v6.0.0对ES6的支持还不够好。还好有babel这个开源库。ES6 语法可以参考阮一峰的这本书 &gt;&gt; 可以直接全局安装 npm install -g babel-cli ，启动时候把node替换为babel-node，就可以完全支持ES6了。 我为了调试方便，所以在代码中启用支持。 首先安装babel依赖库。 12345&quot;dependencies&quot;: &#123; &quot;babel-core&quot;: &quot;~6.5.2&quot;, &quot;babel-polyfill&quot;: &quot;~6.0.0&quot;, &quot;babel-preset-es2015&quot;: &quot;~6.0.0&quot;,&#125; 然后在app启动的时候导入 ES6 运行环境。 12345678require(&quot;babel-core&quot;);require(&#x27;babel-core/register&#x27;)(&#123; presets: [&quot;es2015&quot;], ignore: [&quot;node_modules/&quot;, &quot;app.js&quot;], extensions: [&quot;.js&quot;], cache: true&#125;);require(&#x27;babel-polyfill&#x27;); 启动参数可以加上方法缓存 BABEL_CACHE_PATH=./xxx。 好了我们的项目已经支持 ES6 了，只是启动的时候会有点慢，如果node能直接支持就好了，不过我相信很快就可以了。 MySql支持 ES6 以后，我们需要添加数据库层，首先安装依赖组件。 12&quot;mysql&quot;: &quot;~2.10.2&quot;,&quot;sequelize&quot;: &quot;~3.0&quot;, 这里我经过比较采用了 sequelize 这个ORM。 在添加配置文件 ./bin/config.js。最好的做法需要配置正式、开发等多套环境，这里我只做一套配置。 123456789const mysql = &#123; host: &quot;localhost&quot;, port: 3306, database: &quot;db&quot;, user: &quot;root&quot;, password: &quot;&quot; &#125;,export default mysql; 配置 sequelize 1234567891011121314151617import Sequelize from &#x27;sequelize&#x27;;import &#123;mysql as config&#125; from &#x27;../bin/config&#x27;;var sequelize = new Sequelize(config.database, config.user, config.password, &#123; host: config.host, port: config.port, dialect: &#x27;mysql&#x27;, freezeTableName: true, pool: &#123; max: 5, min: 0, idle: 10000 &#125;&#125;);export default sequelize; 好了，我们的数据库服务配置完成。 Redis同样，首先需要配置文件。这里我配置了2个分别作为数据缓存和 http 缓存使用。 123456789101112131415161718192021redisCache = &#123; host: &quot;localhost&quot;, port: 6379, user: &quot;&quot;, password: &quot;&quot;, db: 2, prefix: &quot;redis&quot;, expire: 60*60&#125;,httpCache = &#123; host: &quot;localhost&quot;, port: 6379, user: &quot;&quot;, password: &quot;&quot;, db: 3, prefix: &quot;redis&quot;, expire: 60*60&#125;;export &#123;redisCache, httpCache&#125;; 对数据缓存做一个简单的封装。使其支持key-value和key-hashtable这两种格式就够用了。在设置完后需要设置缓存时间expire。用于缓存token和验证码等服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Redis &#123; constructor(config) &#123; this._client = redis.createClient(config); this._expire = config.expire || 60; &#125; expire(key, expire = this._expire) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.expire(key, expire, (err) =&gt; &#123; if (err) reject(err); else resolve(); &#125;) &#125;) &#125; // set a hash table hset(key, value = &#123;&#125;, &#123;expire=this._expire&#125;) &#123; let _client = this._client; let _expire = this.expire; return new Promise((resolve, reject) =&gt; &#123; let arr = []; for (let [k, v] of value) &#123; arr.push(k, v); &#125; if (arr.length == 0) &#123; reject(new Error(&quot;value is empty&quot;)); &#125; _client.hset(key, arr, (err) =&gt; &#123; if (err) reject(err); else _expire(key, expire).then(resolve).catch(reject) &#125;); &#125;); &#125; // get a hash table hget(key) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.hgetall(key, (err, res) =&gt; &#123; if (err) reject(err); else resolve(res); &#125;) &#125;) &#125; set(key, value, &#123;expire=this.expire&#125;) &#123; let _client = this._client; let _expire = this.expire; return new Promise((resolve, reject) =&gt; &#123; _client.set(key, value, (err) =&gt; &#123; if (err) reject(err); else _expire(key, expire).then(resolve).catch(reject) &#125;) &#125;) &#125; get(key) &#123; let _client = this._client; return new Promise((resolve, reject) =&gt; &#123; _client.get(key, (err) =&gt; &#123; if (err) reject(err); else resolve(); &#125;) &#125;) &#125;&#125;export default Redis; 使用时只要创建一个具体对象就可以了。 另外，再创建一个http缓存的中间件，用来缓存一些接口变化比较缓慢，实时性要求不高，但需要大量计算的数据。 12345678910111213141516171819202122232425262728293031323334export default function(&#123; expire=config.expire, getKey=(req)=&gt;&#123; req.originalUrl &#125;&#125; = &#123;&#125;) &#123; return function (req, res, next) &#123; let key = getKey(req); new Promise((resolve, reject) =&gt; &#123; redis.hget(key).then((data) =&gt; &#123; if (data &amp;&amp; data.length &gt; 0) &#123; // TODO: set header &#x27;Content-Type&#x27; ect. //res.setHeader() res.setHeader(&#x27;Content-Length&#x27;, data.body.length); res.send(data.body); resolve(); &#125; else &#123; reject(); &#125; &#125;).catch(reject); &#125;).catch(() =&gt; &#123; // there is no cache next(); if (res.statusCode == 200 &amp;&amp; res.body.length &gt; 0) &#123; // add body to cache // TODO: validate res.body redis.hset(key, &#123; &#x27;Content-Type&#x27;: res.getHeader(&#x27;Content-Type&#x27;), body: res.body &#125;); &#125; &#125;); &#125;&#125; 这是一个比较简单的实现，key默认使用url。当然也可以自定义。使用场景： 12345678router.get(&#x27;/:id&#x27;, httpCache(&#123; expire:60, getKey(req) &#123; return &quot;POST:&quot; + req.path; &#125; &#125;), (req, res, next) =&gt; &#123; ......&#125;); 这样，我们的数据层都已经配置完毕，接下来需要开始进入实践。 结构目录结构： 123456|\\| \\model // 数据结构相关|\\| \\controller // 真正的业务处理层，像Spring里的service层|\\| \\routes // 路由控制，缓存以及行为控制 这里我为了简化，只把服务分为这些，来减少复杂度，同时又相对解耦。 首先看看model层，这里定义了整个表的结构和数据模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let User = sequelize.define(&#x27;user&#x27;, &#123; // name: Sequelize.STRING, password: &#123; type: Sequelize.STRING &#125;, salt: &#123; type: Sequelize.STRING(16) &#125;, nickName: &#123; type: Sequelize.STRING, field: &#x27;nick_name&#x27; &#125;, email: &#123; type: Sequelize.STRING, validate: &#123; isEmail: true &#125; &#125;, birthday: Sequelize.DATE, gender: Sequelize.INTEGER(8), createTime: &#123; type: Sequelize.DATE, defaultValue: Sequelize.NOW(), field: &#x27;nick_name&#x27; &#125;, updateTime: &#123; type: Sequelize.DATE, field: &#x27;update_time&#x27; &#125;, loginTime: &#123; type: Sequelize.DATE, field: &#x27;login_time&#x27; &#125;&#125;, &#123; timestamps: false, freezeTableName: true, defaultScope: &#123; attributes: [&#x27;nickName&#x27;,&#x27;email&#x27;,&#x27;birthday&#x27;,&#x27;gender&#x27;,&#x27;createTime&#x27;,&#x27;updateTime&#x27;] &#125;&#125;);// 这里提供给外部可以编辑的属性配置User.editableAttribute = [&#x27;nickName&#x27;, &#x27;birthday&#x27;, &#x27;gender&#x27;];// 这里我们可以选择让 sequelize 来建表if (process.env.SYNC_DATABASE) &#123; User.sync();&#125;export default User; controller定义所有的逻辑操作，提供包括验证的，但是独立的功能服务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let Controller = &#123; create(&#123;email=null, password=null&#125; = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; if (email &amp;&amp; password) &#123; validatePassword(password).then(() =&gt; &#123; User.findOne(&#123;email: email&#125;).then((user) =&gt; &#123; if (user) return reject(&quot;您已经注册,请直接登录&quot;); else &#123; let salt = salt(email); let encryptPassword = encryptPassword(password, salt); User.create(&#123; email: email, password:encryptPassword, salt: salt &#125;).then(resolve).catch(reject(err)); &#125; &#125;).catch(reject); &#125;).catch(reject); &#125; else &#123; reject(new Error(&quot;用户名或密码为空&quot;)); &#125; &#125;); &#125;, update(user) &#123; return new Promise((resolve, reject) =&gt; &#123; if (user.id) &#123; return reject(new Error(&quot;用户ID为空&quot;)); &#125; if (user.password &amp;&amp; user.salt) &#123; return reject(new Error(&quot;参数非法&quot;)); &#125; User.update(filterValidateKey(user, User.editableAttribute), &#123; where: &#123; id: user.id &#125; &#125;).then(resolve).catch(reject); &#125;) &#125;, findByIds(ids = []) &#123; return new Promise((resolve, reject) =&gt; &#123; User.findAll(&#123; where: &#123; id: &#123; $in: ids &#125; &#125;, include: &#123; model: Tag, as: &#x27;tags&#x27; &#125; &#125;).then(resolve).catch(reject) &#125;) &#125;, addTags(tagIds = []) &#123; &#125;&#125;export default Controller; 最后，路由来组合其中不同的业务逻辑。 123456789101112131415161718router.get(&#x27;/:id&#x27;, (req, res, next) =&gt; &#123; let id = req.params.id; if (id) &#123; UserController.findByIds([id]).then((users) =&gt; &#123; if (users.length &gt; 0) &#123; res.send(Success(users[0])); &#125; else &#123; res.send(Fail(&#x27;用户不存在&#x27;)); &#125; &#125;).catch((err) =&gt; &#123; res.send(Fail(err.message)); &#125;) &#125; else &#123; res.send(Fail(&quot;参数错误&quot;)); &#125;&#125;); 其他很多场景，我们需要判断用户登录情况以及一些其他情况，如果在每个请求里面去做判断会是一种非常麻烦的事情，而且也会导致代码冗余和复杂性，这些功能可以做成中间件形式，使用时也会方便很多。 123456789101112131415// NeedLogin 伪代码function NeedLogin() &#123; return function(req, res, next) &#123; if (req.isLogin()) &#123; next(); &#125; else &#123; res.send(Fail(&#x27;need login&#x27;); &#125; &#125;;&#125;;router.get(&#x27;/:id&#x27;, NeedLogin(), (req, res, next) =&gt; &#123; ......&#125;) 测试等待加入该模块 下一篇，我们来看看react来构建web应用的框架。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"ES6","slug":"ES6","permalink":"http://djs66256.github.io/tags/ES6/"},{"name":"mysql","slug":"mysql","permalink":"http://djs66256.github.io/tags/mysql/"},{"name":"redis","slug":"redis","permalink":"http://djs66256.github.io/tags/redis/"},{"name":"sequelize","slug":"sequelize","permalink":"http://djs66256.github.io/tags/sequelize/"},{"name":"服务器","slug":"服务器","permalink":"http://djs66256.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"express+react解决方案 (一)","date":"2016-05-13T16:51:38.000Z","path":"2016/05/14/2016-05-14-express-plus-reactjie-jue-fang-an-1/","text":"经常我们需要一个非常轻量级的框架，来满足我们很多非常简单的需求，同时又要求一定的扩展性、灵活性和松散性，要求快速开发，又有一定的承载能力，这里设计了一种简单的解决方案。 数据服务框架 &gt;&gt; Github 结构123456789|----------------------------------------|| web/HTML5 | mobile | ect. |-----------------------------------------|| React/Flux/React Native | ^ |-----------------------------------------|| rest api/node/express | socket.io || -----------------------------|| | database/redis/storage ||----------------------------------------| 为了更明晰的分层，这里分为多个服务，因为都是基于nodejs，所以要整合在一起也是非常简单。 Rest Api，提供基础数据服务，采用http协议，由node/express组成。 socket，提供长连接服务，采用socket.io，可以直接连接数据层，也可以通过http协议连接数据层。 表现层，React作为基础页面构建方法，结合原生方法，来构建具体应用，或者应用的一部分。 数据层这里我选择MySql作为基础数据存储格式，redis作为缓存。 大部分时候我们还是需要传统的关系型数据结构，MySql是最佳的选择，同时PostgreSQL, MariaDB也是一种选择。 作为NoSql的其中之一，mongoDB，也是非常热门，但是由于资源占用太高，不太适合小型项目。 Node为什么会选择node作为基础语言来构建整个框架呢？首先让我们比较比较其他几种语言。 JAVA / Spring现在最火热的spring架构，几乎所有大型企业的首选框架。优点多的不用说明了，但是作为我们需要快速开发以及快速上手的框架并不友好，有太多的坑，而且JAVA作为一门强类型的语言，太过于繁琐。分层明确(Model, DAO, Service, Controller)的同时，也降低了开发速度。 另外一个让我放弃Spring的原因在于资源占用太高，JAVA的运行环境就需要非常大的内存，如果你的开发机器上需要运行MySql, redis, IDE, tomcat等等，还是有一点压力的。 Python / django也是一个比较热门的开发框架，也有挺多的成熟应用，算是一个Ruby On Rail的Python版本。但是毕竟Python并不是专门为服务器开发出来的语言，而且和C语言有着一些联系，所以感觉并不太适合现在的时代，目前开源社区的支持也在逐渐下降。 django自己有一套ORM的系统，但是并不够灵活。 我比较喜欢的是Python的修饰方法，可以非常灵活的配置一些方法的过滤器。(听说ES7里也要有统一的特性？) PHP感觉PHP是专门为了WEB而设计的语言，虽然有一些像think php这样mvc的框架，但是感觉作为一个中间层还是不太稳定。 Node.jsNode是一个处理IO密集型业务非常好的选择，通常我们的中间层不会有大量的计算，多数为读取写入数据，其他的框架都是选择等待事务完成，而且每个请求会生成一个进程，导致一台机器的并发数直接由内存决定，Node在这方面可以使用更少的资源来获得同样的效果。 Node目前非常的火爆，开源社区也非常活跃，很多应用或框架都已经在node上面开发，而且开源模块非常完善，npm也非常好用。比如我在上层采用的React。 同时Javascript作为一门前端语言，简单易学，可以有很多前端开发人员进入。 在公布了ES6以后，Javascript感觉已经摆脱了脚本语言这一不太好的特性，更像一门专业面向对象语言。不过可惜的是，到目前为止，虽然v8已经基本支持了所有ES6特性，但是最新的node v6并没有完全支持，加上--harmony也只能支持一小部分，目前我们还需要借助第三方库。 只能说，感谢v8! 同时，可以看出这个框架的大部分都是由js来组成，所以选择Node来作为中间层的开发也是很理所应当的。 下一步整个中间层的构建。请见下一篇。 后记关于Node服务的效率问题，虽然官方说明以及很多自来水的吹捧，感觉非常的优秀，但是实际项目中还是需要根据实际情况来做判断。 不过如果遇到了效率问题，Node还是可以很方便的和其他语言混编的，找出最消耗时间的地方，用C/C++改写也是非常快速的。 稳定性是Node比较弱的一个方面。一个线程容易因为一个小错误而使整个服务崩溃，所以除了需要更仔细的错误处理，还需要均衡与热备来确保服务质量。 由于Node的异步语法会导致更多的嵌套关系，使用泛滥会导致代码难以理解，所以需要统一整个项目的规范与习惯。（比如使用Promise代替callback函数）","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"},{"name":"express","slug":"express","permalink":"http://djs66256.github.io/tags/express/"},{"name":"react","slug":"react","permalink":"http://djs66256.github.io/tags/react/"},{"name":"架构","slug":"架构","permalink":"http://djs66256.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"谈谈传统型互联网公司","date":"2016-04-26T16:48:20.000Z","path":"2016/04/27/2016-04-27-tan-tan-chuan-tong-xing-hu-lian-wang-gong-si/","text":"&nbsp;&nbsp;&nbsp;&nbsp;在最近的一段时间，接触了不少公司，都有一些传统公司的影子，在进军互联网方面或多或少都表现出了同样缺少的部分。 S网&nbsp;&nbsp;&nbsp;&nbsp;S网是一个招聘类网站，概念比较新颖，利用各种资源获得了一笔投资。然后开始各种宣传、推广，为了下一轮的融资。 &nbsp;&nbsp;&nbsp;&nbsp;但是，他们的宣传主要以企业形象宣传为主，推广的内容第一条必定是公司的形象工程。不惜花重金参加各类活动，在各大平台曝光。 &nbsp;&nbsp;&nbsp;&nbsp;然而，作为一个互联网公司，他们还没有一个真正属于自己的招聘平台，用户和职位也是屈指可数，运营推广也是最普通的提供职位资源。也没有想要组建属于自己的开发团队，做的产品完全依照老板的想法，没有用户调研，总是想要把自己能想到的所有功能一次性做出来才满意。 &nbsp;&nbsp;&nbsp;&nbsp;这是一个非常典型的传统型创业公司。虽然在创业初期，独权主义在公司的效率和团结上会有一定帮助，但是并不是所有的东西都要亲力亲为。老板如果不是产品运营开发这方面的全能型人物，很容易导致产品开发的整个流程被打断。需求朝令夕改，偶尔推倒重来，一次性开发太久等等这些产品开发最忌讳的事情。最后出来一个满是沧桑的老板满意的产品，用户需求没有了，早已经远离了初衷。 &nbsp;&nbsp;&nbsp;&nbsp;为什么现在创业项目并不被看好，除了资本寒冬的原因外，也有一部分是被中国创业的环境破坏了，所谓创业，在一部分人的眼里，仅仅只是获得一部分融资，做一个名头响亮的空头公司，玩转所谓的资本运作。或许在早几年，很多人会被骗，现在也有很多人傻傻的投钱，但是经过这一轮经济衰退，中国的投资者们已经开始意识到投资的风险了，慢慢的他们已经开始了解移动互联网的运作方式，开始聘用专业人士。同时互联网与移动互联网的巨头已经基本瓜分完市场，已经很难在这个鱼塘里面摸鱼了。 &nbsp;&nbsp;&nbsp;&nbsp;互联网本身并不能像传统行业那样，买点东西，有点品牌就能卖得好，卖得贵，目前的盈利方式主要是靠广告、服务、与传统行业对接等，靠导入流量来赚钱，既然如此，流量就是最重要的，所以为什么互联网公司都在强调自己的用户量、日活这些数字。那么，为了获得用户，自然靠的是你的服务和产品，而不是你的品牌与口碑。这也是互联网吸引人的地方，也是一个草根也能超越一个集团的地方。 &nbsp;&nbsp;&nbsp;&nbsp;所以既然要做互联网，那就按照一个互联网的规则来玩，真正做好自己的产品和服务，提升自己的用户量为首要目标，真正的去了解用户，贴近用户，这才是最重要的。 W公司&nbsp;&nbsp;&nbsp;&nbsp;这是一家传统的房子租赁公司，在这个行业也算是打下了一片天地。在链家全国性的铺开的时候，这块的竞争进入了一个白热化的程度。 &nbsp;&nbsp;&nbsp;&nbsp;我尝试了他们的应用，也了解了一些他们的未来打算。目前他们主要对租赁和过程进行互联网化，简单的来说，就是把线下的租赁活动转移到了线上。这是一个最初级的互联网化的过程，效果应该是最明显的一步吧。总的来说他们的这一步并不差，但是想要以此来对抗链家以及其他同类型的公司，还是差了很多。当我问他们未来的打算与发展的时候，他们并没有给出我觉得满意的答案。他们后续的打算仅仅是优化加强这个工具的实用性和功能，以及增加其他的实用性工具。我不知道他们的产品经理是怎么打算的，但是这样的回答让我很失望。 &nbsp;&nbsp;&nbsp;&nbsp;一个工具仅仅是一个工具，做的再好也不能够盈利。该公司真正有价值的是他的服务，但是他的服务是一种短暂性的，一次性的服务，虽然单次服务的价值很高，但是却没有抓住用户。作为互联网行业最重要的资源，仅仅走了个流水，多么可惜。所以我认为他们的下一步应该增加他们的后续服务，以及一些绑定用户的产品与服务。这个方法有很多，比如合同期内的服务，第二次服务咨询优惠，租赁论坛交流群等等，依靠一些长期的服务以及交流平台等绑定用户。这样才是他们下一步最需要的。 &nbsp;&nbsp;&nbsp;&nbsp;我了解到另外一家公司目前就在尝试这方面，但是他们的服务是要收费的，而且服务内容并不吸引人，而且强行绑定了用户，必须接受这个服务。虽然这么做并不好，但是也算是一种尝试。 &nbsp;&nbsp;&nbsp;&nbsp;在互联网化的时候，创造一个用户粘性强的平台是最急迫的，也是最长远的一种打算。 B公司&nbsp;&nbsp;&nbsp;&nbsp;他是一个比较成功的创业公司，也拥有了很多的用户，可以说完全已经占领了视频领率的一方垂直天地。 &nbsp;&nbsp;&nbsp;&nbsp;B公司没有上面我所说的问题，就是一个以用户为中心，组建了一个用户粘性非常强的平台。但是该公司在初期为了加强自己的技术以及管理能力，空降了一大批中层领导和技术人员。他们对这方面并不是很擅长，但是依靠以前的经验，开始了绩效目标等等。 &nbsp;&nbsp;&nbsp;&nbsp;他们的加入导致了原有员工的隔离，这个平台开始转向以营利为主的方向上。这本身并没有什么错误，但是营利的项目开始侵占原有的业务。所有的其他业务都要退让，导致最核心最重要，也是吸引用户的地方被迫退居2线。我觉得如果不是boss在这里，原有的业务可能已经被做成装饰了吧。 &nbsp;&nbsp;&nbsp;&nbsp;在整个平台需要盈利的时候，我觉得需要特别慎重，盈利必定会破坏原来的关系链，如果这个关系被破坏的太多，是否对原有的业务产生不好的影响。而且，需要好好考虑是否已经是盈利的时机了，因为资源总是有限，在视屏这个竞争也是非常激烈的领域，其他大平台已经慢慢开始扩充他们的领域，已经逐渐形成一个垄断的形式，但这同时也是一个机会，一个扩张自己领域的机会。 &nbsp;&nbsp;&nbsp;&nbsp;在选择盈利点和时机的时机的时候要特别注意，不要太过于挤压原有业务的空间，思考吸引用户的核心价值是什么，不要到最后用户流失导致双双死亡的结局。 &nbsp;&nbsp;&nbsp;&nbsp;做为一个互联网公司，必须以产品为中心，以用户为中心，创造一个用户粘性强的平台，而不是一个功能型应用，在不影响原有核心价值的时候慢慢导向盈利。这才是我心目中的一个比较正常发展互联网公司。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"公司","slug":"公司","permalink":"http://djs66256.github.io/tags/%E5%85%AC%E5%8F%B8/"},{"name":"互联网","slug":"互联网","permalink":"http://djs66256.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"},{"name":"运营","slug":"运营","permalink":"http://djs66256.github.io/tags/%E8%BF%90%E8%90%A5/"},{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"传统","slug":"传统","permalink":"http://djs66256.github.io/tags/%E4%BC%A0%E7%BB%9F/"}]},{"title":"关于产品经理需要的知识","date":"2016-04-26T13:29:44.000Z","path":"2016/04/26/2016-04-26-guan-yu-chan-pin-jing-li-xu-yao-de-zhi-shi/","text":"&nbsp;&nbsp;&nbsp;&nbsp;经常看到有人在网上讨论产品经理需不需要懂技术，然后各有各的说法，这里我说说我认为的一个好的产品所具备的一些知识。 技术&nbsp;&nbsp;&nbsp;&nbsp;产品需不需要懂技术，这个争论很久的话题。我认为产品一定要懂技术，但是可以不懂写代码。作为一个产品经理，并不是只需要知道做出什么东西来就完成了，还需要知道做的过程，所要付出的代价，以及最基本的可行性，这里并不是要由产品来决定这些东西，但是一个不懂技术的产品只会与最后的产品渐行渐远。 &nbsp;&nbsp;&nbsp;&nbsp;产品经理需要了解的并不是如何写代码，或者这个是如何实现的这么详细的点，更多的是理解工程师们可以实现的，以及愿意去攻破的，那些毫无头绪的想法还是老老实实问问开发人员吧，他们可能也需要很久的时间去考虑。 &nbsp;&nbsp;&nbsp;&nbsp;如果产品只是按照自己的想法一味的强加需求，而且对开发人员反映的种种问题视而不见。就像有些老板那样，总觉得是开发人员懒惰、在推卸责任，只要能想出来的，他们肯定能够实现。最后他们的确实现了，可是呢？第一，开发与产品方面产生了很大的隔阂与矛盾，同时也导致了整个团队的不稳定；第二，开发失去了一个比较主动的地位，整个团队的氛围变得更加的沉闷，对于一些产品经理看不到的优化、细节也得不到实施，导致产品的质量越来越差。 &nbsp;&nbsp;&nbsp;&nbsp;所以我认为产品一定要懂技术，不需要像开发人员一样去了解如何实现，但要知道能够实现到什么地步，需要什么样的代价。 心理学&nbsp;&nbsp;&nbsp;&nbsp;为什么我会提这个呢，因为开发人员很多都是有完美主义的，越优秀的开发越追求极致，有些时候甚至可能会觉得有些歇斯底里。所以如果不懂得一些性格学，心理学，傻乎乎的跑去找程序员改需求真有可能被砍。 &nbsp;&nbsp;&nbsp;&nbsp;开发是一个及其需要精神集中的工作，因为需要一步一步整理自己的思路，可能因为你2分钟的打断，别人2个小时的努力要重新开始。就像作家一样，在写作的时候不讨厌别人打断。当然也有必不可少的时候，肯定会有矛盾，这里就需要情商来安抚他们。 &nbsp;&nbsp;&nbsp;&nbsp;同样，了解用户心理对于产品来说也是一件非常好的事情。 &nbsp;&nbsp;&nbsp;&nbsp;所以懂一些心理知识是不是很重要？产品经理和开发之间的关系会直接影响开发效率和技术创新，最终也会影响产品。 项目管理&nbsp;&nbsp;&nbsp;&nbsp;很多时候，产品经理也是兼任项目经理的，就算没有兼任，也需要知道项目管理。软件开发已经有一套非常成熟的流程了，如果产品经理不是很懂项目管理和软件开发流程，只会让一个项目变成一个无尽的泥潭。 &nbsp;&nbsp;&nbsp;&nbsp;就像《人月神话》里面说的，为了赶进度而增加人手，增加工作时间，这些差的方法只会让一个项目越来越不可操作，最终陷入一个无尽的泥潭，从而导致项目失败。虽然平时开发一个功能的时候并不会暴露出这么严重的问题，但是多次的累积，终有一天会发现项目已经成为一个庞然大物，从而越来越难以维护和开发。 &nbsp;&nbsp;&nbsp;&nbsp;所以项目管理也是产品经理必备的技能，不需要项目经理控制的那么精细，但是整个流程需要知道，以及不要用打断这个流程来弥补自己的错误。 &nbsp;&nbsp;&nbsp;&nbsp;以上这些看似和产品经理毫无关系的，但是我认为一个好的产品经理必须具备的，当然最重要的是对产品的理解了。 &nbsp;&nbsp;&nbsp;&nbsp;另外，对于老板，首先需要成为一个产品经理，才能做好一个决策者。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"产品经理","slug":"产品经理","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"},{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF/"},{"name":"管理","slug":"管理","permalink":"http://djs66256.github.io/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"运营之道-买买菌模式","date":"2016-04-14T14:04:43.000Z","path":"2016/04/14/2016-04-14-yun-ying-zhi-dao-mai-mai-jun-mo-shi/","text":"前几天，有幸听到买买菌分享他们是如何在微博环境已经趋于没落，甚至饱和的情况下，用两年时间快速成长为一个拥有200万真实粉丝的博主。相比于现在很多的推广运营，形成鲜明的对比，也是我之前为什么会把公司归为传统型和互联网型的一个原因。这是对于目前我经历的一些思考。 现在很多的推广和运营的内容都相当的生硬，很多都类似这样： 啪啦啪啦，这个东西超好啦，超实惠啦，大家来花钱啊~ 打折啦，全场5折，买一送一啦~ 概括起来： 表现自己的产品，自己的服务很好，对用户有什么用处，可以从各个角度去描述美化，来吸引用户。 表明自己给与的优惠等，让用户感到占了便宜。 但是这样推广也有很多问题： 对于这类的宣传，需要： 产品或者服务真的很好 非常切合用户，属于刚需 问题： 容易被复制，对于竞争对手没有抵抗能力 用户没有粘滞性，用户使用以后并没有特别的再次使用的动力，完全依靠产品或服务来带动。 这种靠口碑和形象的推广，在这方面一旦受到损害，将导致非常严重的后果，比如聚美等。 如果企业是一个非常有实力，处于行业大哥位置，我认为这样做是一个比较快捷的方式，通过最简单的方式告诉大家自己的产品。 又或者是自己的产品属于一个比较新的领域，还没有特别多的竞争对手，可以满足用户的刚需，这样做也是非常省力的一种方式。 但是在一个竞争非常激烈的环境，有着众多的竞争对手和可选择余地的时候，这样的推广就会让人感觉很无力，每个人都在说自己的产品好，不管说的多好，大家总是保持者怀疑的态度。 所以我认为这是一种非常传统的推广方式，在新兴互联网，拥有众多选择余地的时候，效果可能并不好。 给与用户一些优惠政策，比如打折，礼品，包邮，积分等等 承受这样带来的经济消耗，甚至可能会导致价格战，比如打车行业 吸引力仅限于活动期间，用户没有粘滞性 如果这是一个新产品，需要吸引眼球或者仅仅需要带动销量，这是一个快捷的方式，可以一下子把东西暴露给大家。 但是如果把这个作为一个长远的推广计划就不太合适，同样对于用户没有任何的吸引力。就如每天给乞丐一个面包，只要你某一天没给他，他便会责怪你一样。 在互联网行业，需要考虑的是长远打算，在使用这种方式的时候必须在后续的时候加入其它方面的带动，才能让用户留住。 买买菌给我的一种启发是，内容才是王道，不断地鼓吹自己和给与利益都不是一个长久之道。大部分用户可能都不会消费一次产品，但是对于内容却大部分都会喜欢，而且不是短时间性的。所以必须不断的生成用户会喜欢的有价值的内容，才可以保证用户的留存。 内容的质量是非常重要的，一篇都是淘宝的图片和链接只能是一篇广告，没有人会看这样的东西，内容需要真实，可靠，对用户有帮助。 同时内容对应什么样的人群，就需要什么样的文章，让一个70岁国学大师写一篇小女生服装推广就不合适。需要作者能够真正理解用户的心理和需求。 但是仅仅有内容还是不够的，内容是留住用户的基础，现在的互联网还需要传播性。好的内容自然会让人去转发传播，但还是需要把用户往这方面引导，像买买菌采用的方式就是塑造一个贴近生活的形象，用一个活生生的人的形象来引起人们的共鸣。至于怎么做，会有很多方法，传播性是一个至关重要的运营点。 导流是运营的目的，不管是导向消费，还是用户导向，需要注意的是这样做的时候不能犯和内容同样的错误，看着就像广告，避免用户的流失。这是一个需要权衡的东西，毕竟这才是盈利的方法。 只有形成了一个以内容为中心，用户自行传播为途径这样一个生态圈，才会让一个互联网产品非常良性的发展。用传统方式去运营，虽然看似起效很快，但消耗和用户的忠诚度却不能完全保证。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"运营","slug":"运营","permalink":"http://djs66256.github.io/tags/%E8%BF%90%E8%90%A5/"},{"name":"产品","slug":"产品","permalink":"http://djs66256.github.io/tags/%E4%BA%A7%E5%93%81/"},{"name":"买买菌","slug":"买买菌","permalink":"http://djs66256.github.io/tags/%E4%B9%B0%E4%B9%B0%E8%8F%8C/"},{"name":"模式","slug":"模式","permalink":"http://djs66256.github.io/tags/%E6%A8%A1%E5%BC%8F/"}]},{"title":"公司与产品的一些想法","date":"2016-04-04T21:43:11.000Z","path":"2016/04/05/2016-04-05-gong-si-yu-chan-pin-de-yi-xie-xiang-fa/","text":"这里是我关于目前公司与产品的一些体会。 公司很久以前可以说软件公司，但现在已经几乎不存在这样的说法，我更倾向于把目前的互联网公司分为传统的互联网公司和纯粹的互联网公司。 传统互联网公司这些公司基本上是由为了适应新的互联网环境而成功转型的传统行业公司，包括目前非常火热的金融、房地产、车子等，这些公司的特点是拥有原有或者成型的业务模式，互联网仅仅作为一个工具而使用，仅仅为了满足他们现在的业务需求，提高效率或者压缩成本，他们的产品往往以业务为中心，从一个生产者的视角去审视这些需求。 这些公司的优点十分明显，有着固定的盈利模式，甚至在传统行业里面已经有非常雄厚的经济积累，因此一般是非常稳定的产品走向，也是非常明确的功能需求。显然，缺点也十分明显，产品的目的是服务于传统的业务，对真正互联网产品的发展、运营并不友好，而且也不会真正重视这一块的未来潜力，或者对这一块的潜力评估并不准确。 这类公司容易导致产品部门的地位低下，产品部门并不能掌控产品的真正走向，如果没有一个足够强力的人来掌控，很容易导致产品走向失败，或者走向一个死板的局面。而且容易导致产品部门会受到其他部门或者上司的越权干涉。同时产品部门内部会陷入无穷无尽的业务需求。 纯粹的互联网公司这些公司很多是由之前的软件公司转型过来，其特点是拥有大量的普通用户，同时用户群比较杂，各种各样的用户在这个平台上享受某种服务而形成一个特殊的群体，这些产品没有明确的盈利点，也没有固定的发展方向和产品走向，是一种完全根据用户和市场走向来决定产品走向的形态。 这类公司目前面临的最大的挑战是盈利，如何把他们的现有的服务和用户转化为盈利，如果做的不好，可能会因此而失去大量的用户。现在他们总是小心翼翼的在尝试，但这是一个漫长而严峻的挑战。 在这样的公司，产品永远是第一的，用户永远是第一的，他们服务的永远是用户，而不是其他部门或者老板。这样会形成一个非常完整统一、团结的局面，可以牵引出一个产品的巨大潜力。内部消耗也会相应的减少。 当然，这是对于只有一个产品的公司而言，航空母舰型的公司就相当于他们的一个事业部。 这些公司各有各的优劣，而且现在很多公司其实已经开始融合这两方面，对于未来的良好发展，这两者都必不可少。 产品对于产品，我更喜欢把他们分为业务型、用户型和平台型。 业务型产品 这类产品仅仅为业务服务，他们并不关心用户，也不是从用户角度来设计的产品，往往是根据现有业务来设计的产品。这样的产品发展的潜力并不高，增加用户量和传播都不占优势。他们过于依赖于现有的业务，一旦现有的业务出现什么问题，产品就会收到巨大的影响。 他们的当务之急应该是改变现有的观点，更加的从用户的角度去思考问题，去建立一个良好的生态圈，而不是固守于原来的业务。这么做的效果可能不会很明显，效益转换不能马上得到兑现，但是对未来市场的动荡和变革都作了足够的缓冲，以便有足够的时间来反应。 用户型产品他们往往先考虑用户量，再考虑盈利的问题。他们的优势是用户，拥有一个非常良好的用户群体，产品完全以用户为中心，非常的符合用户的需求。但是可能会遇到盈利的问题，不良的转化很可能导致用户的大量流失，需要寻找一个良性的平衡点。 平台型产品他们的大多数实际产品并不是自己开发的，他们仅仅提供了一个平台，第三方在这个平台上做二次开发和运营，是一个非常有高度的产品，盈利和潜在用户都不是问题，但是非常难以成型，需要一个巨大的实力背景和较长的时间来运营。 我认为，平台型产品才是现在互联网产品的最终发展形态，这样才能良性的发展，同时也会减少开发成本，让用户去获取新用户才是最廉价的推广途径。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"公司","slug":"公司","permalink":"http://djs66256.github.io/tags/%E5%85%AC%E5%8F%B8/"},{"name":"传统型","slug":"传统型","permalink":"http://djs66256.github.io/tags/%E4%BC%A0%E7%BB%9F%E5%9E%8B/"},{"name":"互联网","slug":"互联网","permalink":"http://djs66256.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"}]},{"title":"一个自娱自乐的小项目","date":"2016-03-28T11:13:43.000Z","path":"2016/03/28/2016-03-28-yi-ge-zi-yu-zi-le-de-xiao-xiang-mu/","text":"最近自己做了一个小项目，功能很简单，自己完成前后端的开发，还是有一些感受。 后端是由spring+nodejs来构成的。在此我不考虑执行效率等因素，快速开发才是我的目的。 SpringHTTP接口部分由spring mvc + hibernate，这样做的主要原因是开发简单快速，不用太过于注重数据结构。 由于自己做的项目，很多地方的考虑并没有那么周全，很多东西都没有那么确定，功能流程都是一个模糊的概念，所以数据结构这块的改动是非常大的，hibernate自己管理数据库和model以及之间的映射，这对于结构经常变更的情景实在是太符合了。至少从头到尾我都没怎么关心过数据库方面的事情。 但是spring最大的缺点就是内存占用，由于是java的项目，这也办法避免，对于小型项目来说这个的资源使用率就比较差了。我部署完观察看到spring的占用始终在几百M，加上其他一些服务，服务器要求还是需要配置挺好的，对于自己玩玩的小项目来说，有点利用率太低了。 spring作为快速开发还是非常好的，同时作为一门强类型语言，出错率也比较低，一些新手也很很好的参与。但是我应该不会再考虑作为我自己个人开发的语言了。 nodenode部分主要用作web服务和socket服务。 由于socket服务占用资源的问题，我决定使用node来做socket服务器，而且还有socket.io这个开源长连接库。这样也省去了很多协议和底层代码。 用这个写的一个即时聊天消息服务器用的代码也没有超过1k行，还是非常简单的。 node的具体性能怎么样我没有实际去测试过，但相比于其他创建进程的方式应该会优秀一些吧。作为自己的一个小项目来说也已经足够了。 现在总结起来，在做一个项目之前的准备实在是太不够充分了，而且现在也很难一个人来开发一个项目了。","categories":[{"name":"技术","slug":"技术","permalink":"http://djs66256.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://djs66256.github.io/tags/spring/"},{"name":"node","slug":"node","permalink":"http://djs66256.github.io/tags/node/"}]},{"title":"swift使用小结","date":"2016-03-28T11:13:17.000Z","path":"2016/03/28/2016-03-28-swiftshi-yong-zong-jie/","text":"目前为止swift已经到2.0版本了，使用swift来开发移动端项目已经成熟，现在很多的开源项目已经放弃Objective-C，转向swift，所以我也使用swift来做了一个新的小项目。现在来谈谈使用swift的感受。 语法swift不仅仅比OC更加的简洁，而且更加的容易看懂，同时在错误的控制上更加严谨，可以说是一门非常优秀的强类型面向对象语言。同时也比较类似Python，拥有脚本语言的部分特性。 同时api和OC几乎完全一样，这样也减少了很多学习的成本，当然一些新的思想还是要重新学习。 swift和OC混编也非常的简单，只要没有使用一些特殊方法的类库都可以无缝混编。(比如JSONObject这个类库使用了动态获取属性名，导致不能判断swift的属性) 新特性这里稍微列几个，如果你了解一些其他语言，那么你会感到非常的亲切。 空判断swift里面对象的类型可以分为Object和Optional&lt;Object&gt;两种类型，这样可以明确知道对象是否可以为空，同时使用?来处理Optional类型的调用，这样我们就不需要经常的使用if和断言了。 强类型swift强制类型比OC更加的严格，类型判断用is，类型转换使用as。 泛型也算是强类型的一部分，这样我们终于不用猜测Array和Dictionary里面存的对象是什么类型的了。 操作符重载从某些特定的角度看，这是一个非常有用的特性，但过度使用也会让代码更加难以理解。String终于支持+的操作了，终于告别OC里面让人奔溃的字符串连接。 enumswift允许枚举类型的对象“携带”其他的数据，这在某些情境下是非常便利的一个特性，但也让人一下子难以理解。 闭包相对应于OC里面的block，闭包更加的简洁与好用，有些时候不仅可以使用简化的闭包，甚至简单到省略了()和参数。 12345678910111213141516171819exe &#123; show($0)&#125;exe() &#123; show($0)&#125;exe(&#123; show($0)&#125;)exe(&#123; a in show(a)&#125;)exe(&#123; (a:String)-&gt;Void in show(a)&#125;) 以上的表述都是完全一样的。 defer &amp; guard算是一个锦上添花的东西吧，defer是函数返回前的调用，guard和if的作用是相同的，仅仅作为语义区分吧。 1234let x = open(&quot;file&quot;)defer &#123; close(x)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"},{"name":"swift","slug":"iOS/swift","permalink":"http://djs66256.github.io/categories/iOS/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://djs66256.github.io/tags/swift/"}]},{"title":"2013学年总结之语言篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之编程语言篇/","text":"本篇为总结之前了解的一些语言与特性，当然，我并不是语言专家，大部分都是走马观花，难免有纰漏之处。 java作为一个纯粹的面向对象语言，java应该是非常的典型的，而且不像c/c++，也不像Objective-c一样需要我们手动管理内存，这大大降低了我们学习和使用成本。同时有大量的完整的类库和跨平台的能力，所以Google选择java作为android的语言实在是完美。 先说说特性，因为所有类型都是对象，所以基本类型还是具有自动装箱拆箱的功能。最有意思的是java的内部类，它提供了另外一种回调的方式。 但是java也有很大的缺陷，最大的缺陷是性能，如果Google能够推广最新的JIT技术，那这个问题会减轻很多。同时，java也是一种非常啰嗦的语言，甚至比Objective-c还要啰嗦，OC只是名字比较啰嗦而已。 cppc++怎么说呢，本来就不是纯粹的面向对象语言，为了兼容c，在一些方面不得不做一些让步。但是也有很多有意思的特性，比如操作符重载，隐式转化，智能指针等等。同时c++强大的模板和模板元编程，又让c++成为了更加强大而有技巧的语言。当然，这也大大增加了学习成本和难度，同时写法上也不够简明易懂。 Sql这个什么都不用说了吧，应该算是基本技能。概括起来： 123456CREATE TABLESELECTINSERTDELETEUPDATEALTER lua这是一门特别轻量级的语言，以及及其简单的语法和数据结构，所有数据都是字典类型，同时又有一定的面向对象的能力。当然，缺点也是非常明显的，作为一门独立的语言，功能还是太弱，也缺少相应的类库，所以只能嵌入程序中使用。 虽然说是一门脚本语言，据说效率很高，至于它很快的原因，是否使用了JIT技术，这个还可以继续研究下。 javascript怎么说，最常见的脚本语言，大家都熟悉，语法上像极了java，所以用起来也可以说是得心应手，但是要用到javascript的面向对象却非常复杂，javascript是基于原型来描述面向对象的，所以javascript里面没有class，所有的class都是实例对象，导致看起来总感觉怪怪的。 javascript最好用的地方莫过于他的函数式编程了，可以说闭包和函数式编程才是javascript吸引人的地方。 Node.jsNode可以说是javascript服务端(也是本地)的实现，而且使用了V8引擎，不过这个标准目前还不那么稳定，不过他在服务器端优秀的表现，绝对是有值得了解的必要。 python这是我非常想学的语言，并不是说Python有多么完美，而是Python既拥有脚本语言的特性，又能够很容易的使用面向对象。他避免了shell脚本晦涩难懂的语句，同时增强了字符串等操作，所以完全可以使用Python来替代shell脚本，而Python一般是linux和unix的标配，所以应用也很广泛。 Python能够很好的支持面向对象，而且语法简单，所以除了做shell脚本外还能支持大型项目。完善的包管理机制也同样提供了很多方便。可以说在这方面Python完全可以代替java，但是由于Python是一门弱类型语言，所以在一些调试和代码检查方面可能会差一点。 Python中比较有意思的一个是函数装饰器，像@static_method，这个思想倒是值得我们借鉴。另外还有with的语法也比try...catch...简洁很多。可以说Python非常适合做模型。 Liquid这是一门模板语言，目前github上的page就是用jykell+liquid完成的，而且它还和django的模板语言特别相似。当然，模板语言的弱点十分明显，可以说都算不上一门语言。除此之外还有很多模板语言，使用也非常简单。 HTML/CSS/Less对于想了解网页方面知识，这个应该是基础的基础，作为标签语言，也非常简单，没有什么特别的技巧，但是对于布局却是一个启发，像android那样的布局，对多尺寸适配会方便很多。 Less作为对css的一个补充，还是非常不错的，可以减少很多的工作，还能编译完再发布。 Markdown作为一种简化版的富文本编辑方式，非常简单易懂，比使用html更简单，也比使用word之类的更灵活，还能直接转换为html，程序员必备。 django &amp; express这两个分别是基于Python和Node的一套网站框架，django比较成熟，已经有很多的人在使用，基本功能都已经包含。express比较新，一些功能可以通过包来安装。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://djs66256.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"总结","slug":"总结","permalink":"http://djs66256.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2013学年总结之iOS篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之iOS篇/","text":"这里并不是高深的ios的研究或者教程，相信这些东西查阅官方资料才是最靠谱的，仅仅只是对一些基本技能的总结和概括 Core Graphios绘图基本方法，遗憾的是该api是c的，不过api简单易懂，非常容易使用。除了在draw方法里面使用外，还可以使用UIGraphicsBeginImageContext生成一个图片的上下文，通过代码来获取一些图片，而不再需要UI提供图片。 基本使用方式，注意记得保存和恢复上下文即可: 1234CGContextSaveGState(ctx);[color set];CGContextDraw...CGContextRestoreGState(ctx); 有一个非常有意思的贝塞尔曲线，具体算法我还没怎么搞明白，不过只要有这个，可以说，我们可以画出任意的图形了！ 说到绘图，这里不仅仅能绘制和填充简单的线条、图片外，还能绘制PDF，但是在手机设备上必须放到异步绘制，可以有两种做法： 1. 异步绘制到ImageContext上，以图片的形式展现 2. 使用CATiledLayer，这个属于Core Animation部分了 Core Animation以CA开头的类很多，虽然看名字这个是一个动画的框架，但是不仅仅如此，所有的图层都属于该框架。 说到动画，不得不说不总结下几类动画的实现方式： 1. 基于UIView的动画，所有方法定义在UIView(UIViewAnimation)，这个是最简单，最常用的方法。 2. 基于CALayer的动画，基于UIView的动画还是有不少局限，只能实现比较简单的移动旋转等，当我们需要一些复杂的动画或者无限循环的动画时，就需要基于CALayer的动画 3. 基于定时器的自定义动画，值得注意的是，这里的定时器最好是使用CADisplayLink，这个才是真正基于帧的定时器 core animation是基于keyPath实现的，写法上有些怪异，但是仅仅比基于UIView的动画稍多一点工作量，但绝对物超所值。 123456789[UIView animateWithDuration:2 animations:^&#123; CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; anim.fromValue = [NSValue valueWithCGPoint:position1]; anim.toValue = [NSValue valueWithCGPoint:position2]; anim.duration = 3; anim.cumulative = YES; anim.repeatCount = HUGE_VAL; [view.layer addAnimation:anim forKey:@&quot;ps&quot;];&#125;]; 还有一个比较有意思的图层：CAShapeLayer；使用这个能够完成你意想不到的一些效果，专门为动画而生的图层！ Core Text苹果超级强大的文字绘制框架。core text绘制使用的是AttributeString，遗憾的是这个类在ios6以后才比较实用，很多属性是后面才加进来的，不过这以没什么关系。 首先我们来划分一下core text： 1. 绘制内容，即AttributeString 2. 布局系统，core text除了内容外大部分都是布局系统 3. 绘制系统，这个需要到最后一步才会真正的绘制到画布上，即`CTFrameDraw` 这里最有趣最值得研究的是布局系统，我们可以设置文字绘制的位置范围，还可以通过kCTRunDelegateAttributeName来实现图文混排，还能计算文字绘制完毕后所占用的大小，api比较多，但是实现起来确实非常简单。 123CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(attributeStr);CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), pathref, NULL);CTFrameDraw(frame, ctx); Core ImageCIImage的使用也是非常的简单，只是系统提供了很多的滤镜，要一个个的了解过来还是需要很多的时间。平时如果不需要有图片编辑功能，我们还真用不到。这个是在GPU的内存空间中转换的，如果你从用户内存空间拷贝到GPU内存，再做渲染，再拷回用户内存，这样的开销其实也很大。网上也有基于此的开源项目GPUImage。 1234CIFilter *filter = [CIFilter filterWithName:@&quot;CISepiaTone&quot;];[filter setValue:image forKey:kCIInputImageKey];[filter setValue:@0.8f forKey:kCIInputIntensityKey]; CIImage *result = [filter valueForKey:kCIOutputImageKey]; Core Data又是一个非常庞大而复杂的框架，如果要真正理解这个框架还真要费很大力气，毕竟官方教程就快上1k页了。除此之外还要了解一些keyPath、predicate表达式等等。但是学会使用确实非常简单。core data毕竟不是SQL，它还需要支持xml等格式，所以一些复杂的搜索逻辑或者优化分表什么的就不行了，如果你不需要如此复杂的功能，并且也不准备维护SQL语句，使用core data当然是没得选了。 说到数据库，core data是根据对象为单位的，而我们自己使用的时候却没有这个限制，在这个问题上，我更倾向于根据对象来操作，这样不仅能统一接口，还能避免很多错误和后期维护工作，我们大可不必担心那么点的性能损耗。 Image IO又是一个很有意思的接口，当我们从网络下载大图片的时候，是等我们下完再展现还是，下多少展现多少，这个接口正好适合你！它能够拼装不完整的图片，除此之外还能创建缩略图等等。 多线程说到多线程，我们可以总结下ios里面的几种实现方式： 1. Unix接口，pthread，这个我觉得除非是移植代码，应该没人使用吧 2. NSThread，相当于pthread的OC版，但是不仅仅如此 3. RunLoop，这个应该不算是多线程的实现方式，类似于轮询或者多路复用的结果，但从结果上来看是异步的 RunLoop一般与NSThread配合使用，需要一个事件源(NSPort)，这部分还是挺有意思的 4. GCD，可以说是系统级的线程池，除了单纯的多线程外，还能提供监听句柄(如file，socket)的状态变更（一种多路复用？） 但是GCD一旦触发，便不能取消，这也是值得注意的地方，而且Block的使用也存在一些自身的问题，使用不当可能造成线程的疯狂创建而崩溃。 在这方面还需要再多研究研究 Runtime在Objc Runtime中对我们比较有用的两条是： 1. objc_setAssociatedObject和objc_getAssociatedObject，可以给一个已存在的对象（比如我们无法修改的系统类和第三方库类），动态增加成员 2. method_exchangeImplementations，置换方法，比如置换系统方法，增加我们自定义的功能逻辑。这个方法虽然有些时候很方便，但是也会带来不必要的一些麻烦，而且改变的是全局的方法，所以也有一定的风险。 NSPredicate苹果有一个非常强大的匹配语言，就是谓词表达式，他甚至可以说是正则表达式的超集，缺点就是只能返回bool值。 它也是基于keyPath，不仅仅能匹配普通的正则表达式，还能够过滤数组等集合。 比如： 1234// 正则表达式SELF MATCHES ...// 对象是否是以下几个对象之中@&quot;SELF IN %@&quot;, @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;] 代码显得非常简洁易懂，所以在大部分时候我们都可以使用这个来代替复杂的编码 Blockblock是一种实现闭包的方式，但是并不完美，特别是内存泄露问题，使用不当非常容易造成内存泄露。 block主要分为： 1. 栈上的Block 2. 数据区的Block 3. 堆上的Block 如果你对这3种情况不是很了解的话，最好不要使用太多的block。 一般来说，block使用场景为明确知道结束点的逻辑中，比如GCD，alertView，http请求等等，这些具有明确结束点，而且回调内容也不可能很复杂，所以非常适合block的发挥，但比如不同的controller间，如果采用block，可能就会导致循环引用，因为block在没有被释放或者被执行过之前，block内所持有的对象就不会被释放。 block的使用需要特别小心，我们在页面编程中尽量不要选择block来回调。 NSFormatterNSDateFormatter是我们使用最多的格式化类，但是注意，创建这个比较损耗资源，所以尽量不要在循环中创建，有人甚至直接做一个单例来使用。 另外一个不常用但非常强大的格式化类是NSNumberFormatter 另外，我们可以自定义一些formatter，比如时间格式化为“今天”，“一周前”，“几个月前”等等之类的，还是比较符合理解和规范的。 NSScanner遍历字符串的一种方法，是实现词法分析等功能的基础。这个也能解析一些数字，不仅仅是10进制。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"core graph","slug":"core-graph","permalink":"http://djs66256.github.io/tags/core-graph/"},{"name":"core animation","slug":"core-animation","permalink":"http://djs66256.github.io/tags/core-animation/"},{"name":"core image","slug":"core-image","permalink":"http://djs66256.github.io/tags/core-image/"},{"name":"image IO","slug":"image-IO","permalink":"http://djs66256.github.io/tags/image-IO/"},{"name":"runtime","slug":"runtime","permalink":"http://djs66256.github.io/tags/runtime/"},{"name":"block","slug":"block","permalink":"http://djs66256.github.io/tags/block/"}]},{"title":"2013学年总结之工具篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之工具篇/","text":"####git/svn &amp; markdown &amp; vim &amp; dash/zeal Git/Svn在软件开发和很多场景下，我们都需要版本管理工具，现在最流行的就有svn和git，svn使用非常简单，最常用的命令如下： 1234svn checkoutsvn updatesvn commitsvn log 同时svn也拥有很多的图形客户端，对那些不是开发人员的人也比较友好。但是svn有个致命的弱点，就是不能脱离服务器，对于平时使用时还是有很多不便。而且svn对于分支开发支持也不太友好。 还好，我们有git来解决svn的问题。git的使用稍微比svn麻烦一些，需要了解一些分支等的概念，但是作为日常使用也和svn差不多，比较常用的命令有： 123456789git initgit clonegit checkoutgit addgit commitgit fetch/pullgit pushgit rebase / mergegit log 总体使用上感觉如果是一些比较复杂的需要多人开发的，而且项目比较大型，周期比较长，或者需要并行开发的都适合使用git。这是一个非常有用的工具。 git的图形软件有： 12SourceTreegithub Markdown作为富文本文件格式，markdown比word更加简单轻便，而且适用场景多，可以直接翻译为html，特别适合网络文档，同时对代码的支持也比较好。甚至可以直接支持html，对普通的文档博客来说已经足够了。 客户端程序有： 1haroopad/Mou VIM这个是UNIX环境必备的编辑工具，而且使用起来也不必使用鼠标慢。 VIMDIFF这个diff工具非常强大，但是全部使用键盘，感觉没有使用鼠标舒服，但是偶尔用用还是非常不错的 123]c / [cdp / dozo / zc 配合git的difftool和mergetool，还是不错的。 Dash/Zeal说到官方文档，mac下面有个非常好用的工具Dash，但是一直遗憾win和linux环境下一直没有一个适合的工具，直到有个开源项目的开始Zeal，现在Zeal已经比较完善了，几乎可以媲美Dash了。Zeal在github上有托管。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://djs66256.github.io/tags/git/"},{"name":"svn","slug":"svn","permalink":"http://djs66256.github.io/tags/svn/"},{"name":"markdown","slug":"markdown","permalink":"http://djs66256.github.io/tags/markdown/"},{"name":"vim","slug":"vim","permalink":"http://djs66256.github.io/tags/vim/"},{"name":"vimdiff","slug":"vimdiff","permalink":"http://djs66256.github.io/tags/vimdiff/"},{"name":"dash","slug":"dash","permalink":"http://djs66256.github.io/tags/dash/"}]},{"title":"2013学年总结之设计模式篇","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-03-2013学年总结之设计模式篇/","text":"总结一下了解的设计模式 工厂方法和抽象工厂这个是我们用的最多的设计模式也是最简单的设计模式，可能大家平时都用了。 需要注意的是，抽象工厂如果需要运行时类型判断的话，最好还是重新看下自己的设计，毕竟运行时类型是逼不得已的手段。 生成器 (Build)生成器主要用于拼装数据，典型的比如网络请求数据，二进制数据等，和工厂方法不一样的地方是可以慢慢瓶装。 生成器在我们需要比较复杂的数据而不想暴露数据结构和实现的时候比较适合。 原型 (prototype)原型模式其实OC这门语言可以说是基于原型的，还有一门非常典型的语言javascript，原型主要靠拷贝原型来实例化对象，实际应用中比较少。 单例 (singleton)这个是常见的不能再常见的模式，但是单例的缺陷也很大，首先是初始化循环问题，还有内存问题，破坏封装等等。由于单例就相当于全局变量，在不必要的地方最好不要使用单例。 适配器 (adapter) / 桥接 (bridge)适配器和桥接都是接口的适配，但是作用有些不一样。 适配器可以分为继承适配器和成员适配器，两者各有各的应用场景，主要是做接口的适配 桥接做了接口适配，但主要目的是为了动态配置和复用其他接口代码。 组合 (composite) / 响应链 (responder)组合和响应链可以说是天生的一对，组合模式是自顶向下的，比如UIView的结构，一层一层往下，而响应链刚好相反，是从最底层发起，一直把事件往上抛，直到有人能处理为止，比如touch事件。 装饰 (decorator) / 策略 (strategy)装饰和策略的目的都是一样的，都是改变一个对象的行为，比如给数据流加上缓存功能，给请求加上加密。 装饰主要是修饰一个方法或者一个类来改变行为，主要是添加一些其他行为，比如缓存等。这样既能保持原来的接口和代码，又能增加修饰。 而策略主要是配置不同的行为，比如不同的加密方式，一般策略是作为一个成员来控制行为，这样既能保证封装，又能在有限的范围内添加行为。 外观 (facade)外观非常简单，主要是为了提供给外部一个统一的接口，而隐藏内部实现。主要应用在类库中。 享元 (flyweight)享元主要是为了使用共享内存，比如字体等比较耗内存的地方。 命令 (command)命令模式主要把行为封装，可以动态的配置行为，这个用已有的多自己写比较少 解释器 (interpreter)这个主要用在解释语言上，比较少见 迭代器 (iterator)非常常见的模式，隐藏了内部实现来解决遍历问题。 中介者 (mediator)在很多场景下，我们并不能整理出层次关系，或者模块间本来就很独立，这样相互交互导致了网状结构，从而一片混乱。中介者把网状结构改变为星型结构，所有模块都与中介者交互，这样能够独立模块，减少耦合度。但同时也有个问题，就是中介者有可能成为一个很复杂的模块。 备忘录 (memento)这个相当于undo manager，一般用的比较少，往往和命令模式一起使用，只是命令中除了行为外还需要取消行为的方法，这是实现撤销功能的一种方法。 观察者 (observer)这个在ios中也非常常见，主要应用场景是接受者未知，而且数量未知。 状态 (state)这是个封装一般性行为的模式，比如网络连接，中间有很多状态，但连接、重连、断开行为都是一样的，使用状态模式来封装这些行为，而连接失败等业务行为放在子类中实现，从而避免了网络行为中参杂一些其他逻辑。 模板 (template)这个典型的时UIApplication和UIViewController，把公共的方法提取到父类，具体业务放到子类，相当于抽象类的作用 访问者 (visitor)访问者和迭代器在功能上很类似，但是从设计上很不同，迭代器如果遍历不同对象时，必须要用到运行时类型检查，从而导致一个问题，在对象类型越来越多的情况下，这里会越来越复杂，而且增加一种类型每个这种地方都要修改。visitor模式能够封装这些类型，如果增加一种类型，只要修改visitor类就可以了。好处显而易见，但坏处也是有的，增加了封装，导致更加抽象，对于一些不熟悉的人来说可能会有些麻烦。","categories":[{"name":"文章","slug":"文章","permalink":"http://djs66256.github.io/categories/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://djs66256.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂方法","slug":"工厂方法","permalink":"http://djs66256.github.io/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"},{"name":"生成器","slug":"生成器","permalink":"http://djs66256.github.io/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"单例","slug":"单例","permalink":"http://djs66256.github.io/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"UIScrollView动画效果模拟","date":"2014-08-02T16:00:00.000Z","path":"2014/08/03/2014-08-17-UIScrollView动画效果模拟/","text":"当年苹果手机发布的时候，大家都惊叹于流畅的滑动效果，也就是UIScrollView的效果。现在由于工作中有个需要，能够模拟系统的滑动效果，因此开始了研究。目前代码托管在github上。 首先这里肯定不是CAAnimation的效果，那么我们使用CADisplayLink来实现这个效果。 ##弹性效果 当我们拉出边界的时候，会有一个弹性的回弹效果。看系统的效果，应该是一个时间固定的动画效果。开始我想可能是模拟摩擦力的效果，demo中使用的也是摩擦力效果，但实际上和系统的效果做比较后发现有些细微的区别，系统可能使用的是双曲线的模型。但也有点像模像样了。 ##惯性效果 在我们拖动停止的时候，我们还有个惯性效果，同样的我们这里使用摩擦的效果。和系统对比后发现系统比摩擦效果更加的圆滑，系统应该用的还是双曲线效果。 还有惯性结束后的碰撞效果我也是模拟摩擦力，不过系统好像也是双曲线模型，感觉系统的效果更加的平滑，不过和系统的scrollView效果比起来也可以看看了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://djs66256.github.io/categories/iOS/"}],"tags":[{"name":"scrollView","slug":"scrollView","permalink":"http://djs66256.github.io/tags/scrollView/"}]},{"title":"code-snapshot","date":"2012-08-19T10:50:34.000Z","path":"2012/08/19/code-snapshot/","text":"Jailbroken123456789101112131415161718192021222324252627282930313233343536373839+ (BOOL)isJailBroken&#123; static const char * __jb_apps[] = &#123; &quot;/Application/Cydia.app&quot;, &quot;/Application/limera1n.app&quot;, &quot;/Application/greenpois0n.app&quot;, &quot;/Application/blackra1n.app&quot;, &quot;/Application/blacksn0w.app&quot;, &quot;/Application/redsn0w.app&quot;, NULL &#125;; __jb_app = NULL; // method 1 for ( int i = 0; __jb_apps[i]; ++i ) &#123; if ( [[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:__jb_apps[i]]] ) &#123; __jb_app = __jb_apps[i]; return YES; &#125; &#125; // method 2 if ( [[NSFileManager defaultManager] fileExistsAtPath:@&quot;/private/var/lib/apt/&quot;] ) &#123; return YES; &#125; // method 3 if ( 0 == system(&quot;ls&quot;) ) &#123; return YES; &#125; return NO;&#125; Color darkness or lightnesshttps://www.w3.org/WAI/ER/WD-AERT/#color-contrast ((Red value X 299) + (Green value X 587) + (Blue value X 114)) / 1000Note: This algorithm is taken from a formula for converting RGB values to YIQ values. This brightness value gives a perceived brightness for a color.","categories":[{"name":"temp","slug":"temp","permalink":"http://djs66256.github.io/categories/temp/"}],"tags":[]},{"title":"我的项目","date":"2012-08-05T15:23:44.000Z","path":"2012/08/05/my-project/","text":"我的 Github 项目，欢迎给我提意见。 DDComponent Star一个和IGList类似拆分CollectionView的扩展 相关介绍可见： 美学的表现层组件化之路 IGListKit简析与DDComponent DDSkin Star一个自认为相比于目前其他框架更好的实现方式 相关介绍可见： DDSkin做更好的换肤框架 DDKeyPathChannel Star自动同步不同对象间的属性值，也可以用作同步UI属性 相关介绍可见： 客户端全局数据同步方案(一) 全局数据同步（二）UI篇 全局数据同步（三）终极方案 ExDebug Star一个客户端debug扩展工具，你可以在pc端远程的查看log与设备状况了。 相关介绍可见： 疯狂日志系统 DDAttachmentTextView Star可自定义组件的富文本编辑器 相关介绍可见： 从UITextView看文字绘制优化 lily Star一个埋点管理系统 相关介绍可见： 自己写的一个埋点管理小工具 UIView-RelativeLayout Star在AutoLayout还没有普及的时候，可以利用这个进行陈述式布局，减轻布局复杂度。","categories":[{"name":"我的项目","slug":"我的项目","permalink":"http://djs66256.github.io/categories/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"开源项目列表-iOS & mac","date":"2012-07-16T17:57:37.000Z","path":"2012/07/17/project/","text":"收藏的开源项目以及部分分析。 AVPlayer ZFPlayer 3566 Stars Objective-C 功能比较完善的一个视频播放及界面，但是实现较为一般。 StreamingKit 1641 Stars Objective-C 基于流来构建音频播放，是一个思路，但可能不能满足特殊情景。 LFLiveKit 2677 Stars Objective-C 利用GPUImage做滤镜的一个直播录制系统，功能比较完善，可以作为参考。 TTAVPlayer 84 Stars Objective-C 比较简单的基于AVPlayerLayer的一个实现。 CTVideoPlayerView 499 Stars Objective-C 没太大参考意义。 EZAudio 4070 Stars Objective-C 音频的波形分析和展示，利用了accelerate，比较全面。 Cache YYCache 1490 Stars Objective-C 使用了LRU策略 内存缓存使用了线性链表+NSDictionary来实现，由于LRU的特性，插入永远在开始，而删除永远在结尾，所以拥有较高的性能。但是查找还是依赖于hash表来实现。 磁盘缓存使用了sqlite来保存文件缓存信息（filename, last_modify_time)，所以在读写小数据的时候（20KB）会直接在sqlite中读写，而不会生成一个独立的文件。所以在小文件和未命中的情况下效率会高很多。而读写大文件时，效率会降低一些，考虑到sqlite的缓存和执行，并不会降低太多。由于sqlite对时间创建了索引，所以在缓存过期查找上面会优秀一些。这种设计解决了小文件和未命中的效率问题，但是并不能实现高并发读写文件。 PINCache 1759 Stars Objective-C 使用了大量的Lock来处理读写，拥有异步读写接口，没有太多的特别优化。 磁盘缓存单纯使用了文件缓存，在初始化的时候就把整个目录及其元素的属性读到内存，来提高效率，但是使用的是数组存储，效率一般。 SPTPersistentCache 1139 Stars Objective-C 利用CRC32来校验文件，据说速度较快。 他将数据信息通过memory map的方式写到了文件头部，说是为了并发读写，但这也时每次更新updateTime需要写整个文件，这样必定会导致性能降低。个人建议还是把文件信息写到另一个文件中，方便内存缓存。 OSCache 184 Stars Objective-C 一个模仿NSCache的实现，内部使用NSDictionary。 Haneke 1775 Stars Objective-C 他和SDWebImage非常相似，个人看来，这个的代码及其结构会比SD好一些，但是功能太有限，就像作者自己说的是一个轻量级的实现。 SDWebImage 18607 Stars Objective-C 实现功能非常完善，是目前最好用的一个图片缓存库了。但是也有几个小问题。 图片读取全部在一个子线程中进行，在高并发读取的时候会阻塞线程，同样下载和解码也会有类似的问题。 图片的二次处理能力不够（比如手动加圆角，裁剪，滤镜），好在目前大部分工作CDN都会帮我们做掉。 预加载图片无法和正常加载使用同一套机制，预加载和正常加载如果同时触发会加载2次。 在扩展方法的时候，直接在UI组件上添加方法，这就导致了每次引入新特性的时候都需要增加一个系统类的扩展（比如UIImage），更好的方式应该是暴露一个代理对象： 123[view sd_setImageUrl:url];// 改为这样会更好一点[view.sd setImageUrl:url]; FastImageCache 7547 Stars Objective-C 该作者认为效率问题主要出现在图片从磁盘读取到内存，再进行解压，以及渲染前的内存拷贝。解决这类问题的最好方法就是进行memory map，作者也指出了这种方式会导致一张高压缩率的图片，进行内存映射后会变得很大这一非常大的缺陷。 123void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);int msync(void *addr, size_t len, int flags)int munmap(void *start, size_t length); 作者将图片按照图片size，rgba等信息进行分类，分别存储于不同的image table里面，同一个table里面会依次写入多张图片信息。但是这样会导致一个table过于庞大，而作者也没有给出非常好的过期策略以及删除部分缓存的策略。 作者将图片元信息metadata存储于另一个文件中，可惜的是使用了json序列化，导致每次更新必须全量更新，在数据量庞大的时候可能会产生性能问题吧。 这并不适用于大量图片以及图片尺寸较多的场景，但是可以用于部分频繁设置image的场景。 Component HubFramework 1746 Stars Objective-C 也是一款拆分CollectionView的设计，个人认为拆分的太细了，导致整个系统过于复杂，学习成本太高。 BeeHive 2236 Stars Objective-C 将客户端的架构和服务端service结合，从而实现整个app的组件化。本身服务端和客户端在很多方面就不一样，需要更多的情景考虑。他的实现在有些场景还是不够的灵活，但是其思想可以借鉴下。 IGListKit 6775 Stars Objective-C 事件驱动的collectionView组件化封装。具体参考IGListKit简析与DDComponent componentkit 4062 Stars Objective-C++ 类似于React方式，使用component来布局UI。完全颠覆了传统的架构和编码方式，学习成本高。项目复杂，由objective-C++编写，利用了大量隐式转换的特性，所以不适用于swift。 Crash Report KSCrash 1732 Stars Objective-C Encrypt MIHCrypto 272 Stars Objective-C 非常全面的加密库。 Markdown CocoaMarkdown 936 Stars Objective-C MMMarkdown 1083 Stars Objective-C macdown 6323 Stars Objective-C Kit AppDevKit 1317 Stars Objective-C 一些扩展，用处不大。 YYKit 10852 Stars Objective-C 包含了很多util方法，以及cache，image，text，json2model方面的类库。 EasyIOS 824 Stars Objective-C 没有参考价值 BlocksKit 可以将他的功能归为两类： 1, sequence，swift中自带的概念，和reactive的概念一致，是一种流式的写法。2, 动态delegate，实现动态delegate的转换，从而实现了大量UI层的回调简化。 功能比较多，除了sequence和UI层的事件外，还有associate object、perform以及KVO（和KVOController类似）。如果是objc开发，可以考虑使用。 Bolts-ObjC 5180 Stars Objective-C 主要提供了两个工具： 1, Task，类似于promise，以及reactive，个人觉得不如另外两者。2, AppLink，一种多平台兼容的跳转方案，同时兼容native和web等，应用面会比MGJRouter这种广一点，但实现上不是非常的完善和通用。 QMUI_iOS 1687 Stars Objective-C 一套非常完善的UI组件库，设计也比较精美，出自腾讯团队。本人认为他也有几个的缺点，那就是利用了大量的Runtime特性，导致很多系统方法都被hook了，这可能会带来某些隐患。由于很多方法都是在系统类上加的，所以api并不是很美观，总是有qmui_这样的前缀。同时hook了UI层的东西，所以如果使用原生的组件也势必会带上一些QMUI的东西。 NavigationBar交互动画的修正采用的是在controller.view上加上一个只设置了背景的navigationBar，同时隐藏原生的navigationBar来实现。相比于另一种使用navigationController再套一层每个controller，从而让每个controller的navigationBar相互独立，本人认为QMUI的方式更加优秀，影响面更加小，毕竟不会影响到整个controller的栈结构。 Util YOLOKit 628 Stars Objective-C 一个类似于reactive中sequence的工具类，建议直接使用Reactive。 libextobjc 3682 Stars Objective-C 非常有名的几个宏定义的出处，对宏的理解和运用都非常厉害，但是平常经常使用的也就那么几个。 123@strongify()@weakify()@onExit&#123;&#125; Data json-framework 3799 Stars Objective-C 原来的SBJson，建议使用系统方法。 jsonmodel 6307 Stars Objective-C JSON转model，缺点是必须继承于JSONModel基类。 ReactiveViewModel 1727 Stars Objective-C 增加了active事件，没什么用。 RestKit 10154 Stars Objective-C 包括了网络请求，json转model，以及到core data，如果有这些方面的需求可以尝试下。 JSONKit 6136 Stars Objective-C 建议使用系统方法。 Mantle 10744 Stars Objective-C JSON转model，但是要继承于基类。 Doppelganger 660 Stars Objective-C 一个diff工具，用于CollectionView的reload。 Diff.swift 794 Stars Swift 也是一个CollectionView reload的diff工具。 OrderedDictionary 253 Stars Objective-C 有序字典，意义是？ FastCoding 883 Stars C 自动NSCoding，还不是特别通用。 AutoCoding 969 Stars Objective-C 利用获取property来自动NSCoding。 KVO RZDataBinding 445 Stars Objective-C 对象绑定思想也是使用associate object，同时也hook了dealloc。但是很多地方使用了assign而不是weak。不推荐使用 他提出一个事务的概念，将众多变更一次性提交，但好像没什么太大的意义。 KVOController 5977 Stars Objective-C FB出品，使用associate object管理内存和负责移除KVO，非常良好的实现方式，推荐使用这个。 HTBKVObservation hook dealloc来负责移除，需要自己来保证observation的生命周期，使用上不如FB的方便。 MAKVONotificationCenter hook dealloc来负责移除监听。 DB YTKKeyValueStore 1759 Stars Objective-C 利用sqlite做的一个简单的KV存储。 YapDatabase 2919 Stars Objective-C 利用sqlite做的一个KV存储，会保存数据元信息和对象间的关系，优化了多线程读写。 realm-cocoa 11297 Stars Objective-C 和sqlite一样，也是一种关系型数据库（这里讨论本地的realm）。 数据保存方式为内存映射，按照realm的说法是sqlite在读取保存数据时候会产生内存拷贝而影响性能。 数据按照列（column）来保存，每一列的数据格式是固定的，在查找效率上也会提升。同时列拥有不同的chunk来同步到磁盘，这样在读写的时候可以只锁定目标chunk而达到高并发读写。 数据结构实现为B+树，与sqlite使用的B树不同，B+树保证了叶子节点存储的连续性。 CoreObject 280 Stars Objective-C ensembles 1536 Stars Objective-C MagicalRecord 10498 Stars Objective-C fmdb 11935 Stars Objective-C sqlite的轻量级封装，缺少ORM，但是也非常简单，容易debug。在少量场景的情况下推荐使用。 sequelpro 3695 Stars Objective-C GYDataCenter 608 Stars Objective-C sqlcipher 2505 Stars C SQLCipher is an SQLite extension that provides 256 bit AES encryption of database files. wcdb 4079 Stars C 微信封装的sqlite ORM。支持多线程和数据修复，支持数据加密，用接口的方式强制格式化sql语句，功能比较强大，缺点是必须使用c++来实现其model，实现也较为复杂。如果在这方面需求量不大的情况下，没有必要迁移。 其sql拼装是字符串累加，而不是从语法树生成，所以必须依赖底层sqlite的存储方式。 rocksdb 8645 Stars C++ 基于leveldb，对齐进行了多线程以及ssd的优化。 leveldb 10957 Stars C++ 是基于Google的big data实现的一套KV存储，原理简单的说就是每次操作（增删改），都是生成一条数据，存入文件，在一定的条件下，会对这些文件进行merge操作，来保证文件的大小。这种方案解决了高并发写的问题，但是增加了读的开销，是一种折中方案。在移动端的场景下好像没有这么高的并发写场景，应该没有必要使用。 数据结构使用跳跃链表（skip list）来实现，他比B/B+数的实现简单，同时也有不错的性能。 Notes iOS-Source-Code-Analyze 源码分析笔记，有些地方过于详细了。 trip-to-iOS 7187 Stars Objective-C 一些资源以及博客等整理，比较老了，偏向新手。 ParseSourceCodeStudy 2506 Stars Objective-C Parse的一些列分析文章。 iOSInterviewQuestions 5883 Stars Objective-C iOS面试题集锦 iOSBlogCN 4391 Stars Python iOS博客集合。 TomatoRead 458 Stars Objective-C iOS博客集合。 idev-recipes 3003 Stars Objective-C IosHackStudy IOS安全学习资料汇总 The-Art-Of-Programming-By-July 11813 Stars C Apple-OfficialTranslation-SourceAnnotation Halfrost-Field 592 Stars Objective-C Network AFNetworking 30057 Stars Objective-C NSURLProtocol-WebKitSupport WebViewProxy 793 Stars Objective-C MMLanScan 207 Stars Objective-C 网络质量检测 DFImageManager 1220 Stars Objective-C Nuke 2370 Stars Swift swift of DFImageManager OHHTTPStubs 3383 Stars Objective-C RTNetworking 1097 Stars Objective-C CocoaSPDY 2342 Stars Objective-C RealReachability 2399 Stars Objective-C XMNetworking 705 Stars Objective-C fastsocket 3466 Stars C In-App Purchase CargoBay 1772 Stars Objective-C Objc Runtime jrswizzle 2062 Stars Objective-C Method swizzling MAZeroingWeakRef 336 Stars Objective-C MRC时代的weak实现，可以作为参考。 Aspects 5436 Stars Objective-C 一个比较全面的hook库，一般用于测试。 DLIntrospection 587 Stars Objective-C runtime方法的objc封装。 fishhook 1999 Stars C 用来hook C方法。 JSPatch 10076 Stars C 非常有名的利用js来动态hook的库。主要通过将:转换为_来实现函数签名的通用，同时格式化js代码，使.调用变为.__c()的方法调用。 和其他（react-native等）的思想不同，不会收集oc的方法签名，然后转到js中生成函数，使用的是修改js代码的方式，但会让debug变得困难，个人更倾向于react-native这种方式。 Socket CocoaAsyncSocket 9204 Stars Objective-C Web Socket SocketRocket 7190 Stars Objective-C AZSocketIO 274 Stars Objective-C Template GRMustache 1318 Stars Objective-C CoreParse 358 Stars Objective-C Theme DKNightVersion 2809 Stars Objective-C 一种换肤框架实现，缺点也非常多，支持的属性也比较少，本人实现了一个更加简单完善的版本DDSkin Tweaks 4622 Stars Objective-C Util NSDate-TimeAgo 1681 Stars Objective-C NSDate的Helper类，比较简单。 DateTools 5763 Stars Objective-C NSDate的Helper类，比较全面。 Router routable-ios 1600 Stars Objective-C HHRouter 1393 Stars Objective-C这两个都是类似的实现，比较简单。 JLRoutes脱离UIKit，非常好用的一个实现，据说性较低，没有实际验证过。 MGJRouter 1040 Stars Objective-C蘑菇街的实现，算法经过优化的JLRoutes，实际没有验证过。 CTMediator 1212 Stars Objective-C使用中间人来解决路由系统，使用target-action方式注册行为， Hybrid Framework7 一款模仿ios和android原生特性的h5组件库，效果来看很不错，可以使用vue和react，如果是写纯网页应用可以考虑使用这个。 react-native 53996 Stars JavaScript 1.4k贡献者，社区非常活跃，目前最热门的方案。拥有非常完善的debug方式以及各种工具，同时React的发展也特别的好。可以完成整个app的功能，也可以作为app的一部分嵌入使用。首推。 大部分组件可以支持iOS和Android，也有很多定制化的组件，所以有些时候需要区分平台来写，也不能无缝降级h5。 incubator-weex 5496 Stars JavaScript 和react-native竞争的产品，由阿里出品。框架会比react-native小一点，但功能也会少很多，排版是受阉割的flex，和官方所说的无缝降级h5有出入。一份代码能够同时在iOS和Android上运行，但为了统一也失去了很多的系统特性，感觉没有官方吹的那样厉害。 [PhoneGap]cordova的商业版 WebViewJavascriptBridge 9454 Stars Objective-C webView中js与native交互的库。一种简单的实现，如果需要更复杂的实现可以使用cordova。 ng-cordova 3629 Stars JavaScript 利用webview js和native的通信实现web端调用native方法。 原理和JSWebviewBridge类似，利用的都是iframe和messageQueue，require组件是直接在head中插入script实现，不知道在组件变多的情况下是否会影响性能，考虑到lazy load的情况，可能会好一点。 组件需要自己根据需要添加，组件比较全面，该有的都有。 但是iOS端是基于UIWebView实现的，不知什么时候能够替换成WKWebView，来提升性能。 code-push 2993 Stars TypeScript 基于cordova和react的云端服务 BeeFramework 3378 Stars Objective-C 利用xml来实现布局，目前已经废弃。 samurai-native 2280 Stars HTML 利用css和html来实现布局和事件绑定，但是实现还是需要原生代码，所以不能独立的去实现一个页面的功能。 VasSonic 5742 Stars Java 腾讯的加速web载入速度的库，原理其实就是客户端增加native缓存管理，减少获取某些静态文件的请求时间。 iOS版依赖于NSURLProtocol，是基于UIWebView实现的，不能支持WKWebView。 其中获取js运行上下文用了黑科技。 1[self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; ionicframework 基于cordova的一款h5组件库，效果很不错，增加完善了很多native组件，使用的是Angular mobileangularui 也是一个UI组件库 Tangram-iOS 758 Stars Objective-C 阿里首页的实现方式，可以认为是一种模板技术，需要客户端开发业务模板，用在业务比较稳定的场景，局限性较大，但是版本更新成本较低，维护成本低。平时设计接口的时候可以参照这种模板方式来配置。 JASONETTE-iOS 4786 Stars Objective-C 可以认为是一种完整的DSL，功能还是挺强大的，列表使用UITableView，布局系统使用UIStackView，因此也有很大的局限性。 同时编辑JSON文件也是非常麻烦的事情，没有很好的工具可以支持。不太推荐使用，除非支持更灵活的布局和编辑。 UIImage GPUImage 16408 Stars Objective-C 是目前最好用的一个GPU计算的框架。利用OpenGL来处理图片，需要对OpenGL比较熟悉，会写GLSL，熟悉图片处理才能创建自己的filter。 架构是流式结构，filter也是流的一部分，既是input也是output 当存在多个filter的时候，优化工作也比较难以进行。比如scale和rotate可以合并为transform。 由于是顺序结构的方案，所以就不能采用多线程多render buffer来优化cpu部分的性能，如下。 123456CPU: filter1 | idle | filter2 | idle |GPU: idle | filter1 | idle | filter2 |优化：CPU: filter1 | filter2 | idle |GPU: idle | filter1 | filter2 | animation Keyframes 4632 Stars JavaScript 功能类似于Lottie。 lottie-ios 10787 Stars Objective-C 利用AE生成JSON文件来简化交互动画的编写。 AHEasing 989 Stars Objective-C 多种时间函数实现。 popping 5272 Stars Objective-C 依靠CADisplayLink来达到高帧率的动画效果。但是太依赖CPU，所以性能不一定比CA优秀。一般情况下感觉不太需要他来做动画。 RBBAnimation 1945 Stars Objective-C 一种动画的封装，意义不大。 Canvas 5233 Stars Objective-C 将动画集成到了View中，感觉没什么必要。 YapAnimator 1697 Stars Swift 和popping原理类似，使用CADisplayLink，实时去修改视图属性。12345YapAnimator(initialValue: square.frame, willBegin: &#123; [unowned self] in return self.square.frame&#125;, eachFrame: &#123; [unowned self] (animator) in self.square.frame = animator.current.value&#125;)看似比popping简单点，但是popping是模仿CoreAnimation做的，所以没有可比性。建议使用popping。 CRAnimation 306 Stars Objective-C 一系列的动画效果。 ActionSheet &amp; Menu JGActionSheet 865 Stars Objective-C JTSActionSheet 339 Stars Objective-C AHKActionSheet 1189 Stars Objective-C AMPopTip 1913 Stars Swift MMPopLabel 556 Stars Objective-C FTPopOverMenu 619 Stars Objective-C CMPopTipView 2612 Stars Objective-C CRToast 3942 Stars Objective-C GHContextMenu 520 Stars Objective-C path style menu AwesomeMenu 5125 Stars Objective-C path style menu Animation 各种动画 CBStoreHouseRefreshControl 3948 Stars Objective-C ZLSwipeableView 2620 Stars Objective-C YLLongTapShare 472 Stars Objective-C VBFJellyView 659 Stars Objective-C TinderSimpleSwipeCards CrossNavigation 353 Stars Objective-C 不同方向的转场动画 FastAnimationWithPOP 459 Stars Objective-C CXCardView ICGTransitionAnimation 347 Stars Objective-C ZFDragableModalTransition 2290 Stars Objective-C ESConveyorBelt 188 Stars Objective-C 开机启动画面方案，有点像ppt的动画方案 EAIntroView 3477 Stars Objective-C 启动引导页方案，样式比较固定 URBMediaFocusViewController 1009 Stars Objective-C 一个图片全屏展示的方案，问题多多。 RQShineLabel 1674 Stars Objective-C AMWaveTransition 2329 Stars Objective-C SCSiriWaveformView 830 Stars Objective-C AnimatedTransitionGallery 2220 Stars Objective-C 大量页面切换的动效。 MDCSwipeToChoose 2465 Stars Objective-C RPSlidingMenu 893 Stars Objective-C BRFlabbyTable 830 Stars Objective-C SVGKit 2866 Stars Objective-C web svg在iOS端的实现，挺有意思。 KMCGeigerCounter 1864 Stars Objective-C 一个点击音效。 POP-MCAnimate 948 Stars Objective-C 基于POP的动画扩展。 Button DownloadButton 1239 Stars Objective-C IGLDropDownMenu 1087 Stars Objective-C 可展开按钮集合 VBFPopFlatButton 2859 Stars Objective-C 有动效。 AYVibrantButton 1171 Stars Objective-C BFPaperButton 825 Stars Objective-C FRDLivelyButton 1317 Stars Objective-C Calendar &amp; DatePicker FSCalendar 5156 Stars Objective-C THCalendarDatePicker 630 Stars Objective-C SACalendar 228 Stars Objective-C MGConferenceDatePicker 391 Stars Objective-C FFCalendar 554 Stars Objective-C CollectionView LxGridView 777 Stars Objective-C 一个模仿iOS删除app界面，一个demo。 MGBoxKit 1855 Stars Objective-C 相当于flexbox的一个子实现，建议直接使用flex库，比如yoga。 CSStickyHeaderFlowLayout 4771 Stars Objective-C 粘性header footer，实现不好，比较卡。 CHTCollectionViewWaterfallLayout 3425 Stars Objective-C 一种瀑布流实现。 RACollectionViewReorderableTripletLayout 1389 Stars Objective-C 一个排序CollectionViewLayout实现，实现比较好可以作为参考。 MJParallaxCollectionView 1279 Stars Objective-C 图片列表，没什么参考意义。 DZNEmptyDataSet 9249 Stars Objective-C swizzle了reload方法来检测是否为空列表，从而来显示空状态。由于使用了黑科技，可能会对其他内容会有未知影响。 CCFoldCell 327 Stars Objective-C 折叠动画 Color Chameleon 9998 Stars Objective-C 扁平化颜色集合。 color 544 Stars Objective-C UIColor扩展。 Colours 2913 Stars Objective-C 一种比较漂亮的颜色集合，以及一些颜色转换方法。 UIController FDFullscreenPopGesture 4379 Stars Objective-C 全屏手势返回。通过KVC获取target，然后设置为第三方gesture的target，从而实现gesture替换的效果。 PKRevealController 3950 Stars Objective-C ECSlidingViewController 4447 Stars Objective-C Android风格侧滑抽屉 SWRevealViewController 4295 Stars Objective-C BTSimpleSideMenu 406 Stars Objective-C RESideMenu 7037 Stars Objective-C CYLTabBarController 3688 Stars Objective-C 利用KVC修改系统tabbar，由于是私有api，可能不安全，不是特别建议。 TLYShyNavBar 3373 Stars Objective-C AXWebViewController 220 Stars Objective-C VCTransitionsLibrary 4203 Stars Objective-C 多种页面切换动画。 PYSearch 2452 Stars Objective-C Chart iOS-Echarts 1306 Stars Objective-C YKLineChartView 611 Stars Objective-C 分时k线图 ANDLineChartView 410 Stars Objective-C BEMSimpleLineGraph 2631 Stars Objective-C PNChart 8828 Stars Objective-C JSQMessagesViewController 10786 Stars Objective-C Chat ChatKit-OC 1797 Stars Objective-C iosMath 661 Stars Objective-C 数学公式 Atlas-iOS 3672 Stars Objective-C ChatSecure-iOS 2462 Stars Objective-C Messenger 2819 Stars Objective-C JBChartView 3721 Stars Objective-C FishChat 715 Stars Objective-C LLWeChat 924 Stars Objective-C ImagePicker TZImagePickerController 3779 Stars Objective-C PYPhotoBrowser 1569 Stars Objective-C ZLPhotoBrowser 1239 Stars Objective-C MWPhotoBrowser 7740 Stars Objective-C RSKImageCropper 1835 Stars Objective-C UzysAssetsPickerController 747 Stars Objective-C DBCamera 1268 Stars Objective-C PhotoZoom TKImageView 261 Stars Objective-C 图片裁剪 ImageView FLAnimatedImage 6081 Stars Objective-C YLGIFImage 1676 Stars Objective-C Layout iCarousel 9837 Stars Objective-C MyLinearLayout 2373 Stars Objective-C OAStackView SDAutoLayout 4755 Stars Objective-C PureLayout 6640 Stars Objective-C Masonry 15454 Stars Objective-C FDStackView 2310 Stars Objective-C FlexBoxLayout 134 Stars C yoga 8424 Stars JavaScript layout 1029 Stars Swift Layout-DSL VKCssProtocol 64 Stars Objective-C Keyboard IHKeyboardAvoiding 1002 Stars Swift IQKeyboardManager 9988 Stars Objective-C CYRKeyboardButton 333 Stars Objective-C Map FBAnnotationClustering 730 Stars Objective-C NavigationBar BMYScrollableNavigationBar 642 Stars Objective-C 修改NavigationBar的frame来达到和滚动行为同步，没有参考价值。 KMNavigationBarTransition 2144 Stars Objective-C 将真正的NavigationBar的背景等转移到fake bar上，fake bar加在controller.view上，来达到这种效果。微信的实现 RTRootNavigationController 895 Stars Objective-C 使用UINavigationController包裹一层，从而达到每个controller的NavigationBar是独立的。云音乐的实现。 JZNavigationExtension 1194 Stars Objective-C 和KMNavigationBarTransition类似，只是并不是直接使用UINavigationBar来做fake bar，而是采用截屏+addLayer来做。 News TTNews 635 Stars Objective-C 一个demo性质的东西。 bilibili-mac-client 2954 Stars Objective-C Password SmileTouchID 513 Stars Objective-C 一个登录界面实现。 VENTouchLock 983 Stars Objective-C Touch ID和key chain共同实现验证的功能。 LTHPasscodeViewController 593 Stars Objective-C 密码及界面 onepassword-app-extension PDF GreatReader 542 Stars Objective-C 一个功能完善的PDF阅读器，但是有些小问题。 Reader 3907 Stars Objective-C 一个比较完善的PDF组件，包含图片、链接。利用了CATiledLayer来分块绘制，优化性能。 UXReader-iOS 同Reader，但是是基于PDFium的实现。 Progress MBProgressHUD 13760 Stars Objective-C 非常有名的loading。 SVProgressHUD 10193 Stars Objective-C 非常有名的loading。 SV与MB，MB功能更加多一些，SV设计上更好一点，各有优势。 MRProgress 2580 Stars Objective-C 多种样式loading。 JGProgressHUD 1911 Stars Objective-C NJKWebViewProgress 3733 Stars Objective-C M13ProgressSuite 3582 Stars Objective-C 非常丰富的多样式loading以及progress。 UAProgressView 971 Stars Objective-C MRCircularProgressView 113 Stars Objective-C ASProgressPopUpView 1124 Stars Objective-C ASValueTrackingSlider 1716 Stars Objective-C YLProgressBar 1041 Stars Objective-C Push Knuff 3875 Stars Objective-C 工具：The debug application for Apple Push Notification Service (APNs). Refresh MJRefresh 10994 Stars Objective-C INSPullToRefresh 846 Stars Objective-C UzysAnimatedGifPullToRefresh 1404 Stars Objective-C XHRefreshControl 700 Stars Objective-C EGOTableViewPullRefresh 3347 Stars Objective-C ScrollView SDCycleScrollView 4297 Stars Objective-C LazyScrollView 1089 Stars Objective-C CustomScrollView 135 Stars Objective-C TextView SlackTextViewController 7991 Stars Objective-C KIInPlaceEdit 124 Stars Objective-C ARAutocompleteTextView 259 Stars Objective-C HTAutocompleteTextField 1068 Stars Objective-C JVFloatLabeledTextField 6473 Stars Objective-C YetiCharacterLabelExample 361 Stars Objective-C AnimatedTextInput 481 Stars Swift ZSSRichTextEditor 2592 Stars Objective-C TTTAttributedLabel 7779 Stars Objective-C dynamiccharts 213 Stars Objective-C DTCoreText 5127 Stars Objective-C TableView UITableView-FDTemplateLayoutCell 8118 Stars Objective-C 利用[view sizeFittingSize:UILayoutFittingCompressedSize]来计算最小高度。 MGSwipeTableCell 5765 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 SWRevealTableViewCell 440 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 SWTableViewCell 6901 Stars Objective-C 左右滑动删除实现，需要继承于其cell。 FXForms 3020 Stars Objective-C 利用model直接布局tableView的方案，比如登录、注册这种页面，难以定制化。 Label UICountingLabel 1223 Stars Objective-C KILabel 412 Stars Objective-C 一个比较好用的扩展UILabel富文本支持，但是也有一些bug没有修复。 Other timeLineiOS 616 Stars Objective-C 时间线 DGCuteHelper 32 Stars Objective-C 粘性效果 MotionBlur 1481 Stars Objective-C 快速移动时候的模糊效果。利用了CoreImage的自定义Filter，利用了Core Image Kernel Language，有点像OpenGL的GLSL。 StackBluriOS 565 Stars Objective-C 近似高斯模糊算法 FXBlurView 4984 Stars Objective-C 利用vImage进行模糊。 AsyncDisplayKit Texture 2004 Stars Objective-C 就是AsyncDisplayKit KZLineDrawer 利用cocos2d来手指画图，达到流畅的效果。 UberSignature 337 Stars Objective-C 一种签名实现。 XXNibBridge 486 Stars Objective-C 一种在nib中动态load另一个nib中的内容的实现。 Debug FLEX 8426 Stars Objective-C 一款非常完善的内置debug工具。包含视图查看、log、查看沙盒数据等等功能。 RHObjectiveBeagle 已被删除 CocoaLumberjack 9483 Stars Objective-C 非常有名的log工具 BugshotKit 1369 Stars Objective-C bug反馈，截屏功能。 Clue 238 Stars Objective-C 在一个bug反馈前，收集用户信息，包括录制视频。 MLeaksFinder 依赖FBRetainCycleDetector来做的内存泄露分析。 GYBootingProtection 673 Stars Objective-C 开机启动自修复，判定开机崩溃，进入修复流程。微信就有这样的功能。 DBDebugToolkit 560 Stars Objective-C 一个比较完善的debug工具集。 IPAPatch 2003 Stars Objective-C 不需要越狱注入其他app的工具。 NetworkEye 1005 Stars Objective-C 利用NSURLProtocol来观察网络请求状况，是一个内置的查看工具。 FBSimulatorControl 2078 Stars Objective-C 多模拟器选择。 LifetimeTracker 621 Stars Swift 利用了associate object来监测对象生命周期，局限性太大。不过可能会持续更新 FBMemoryProfiler 2757 Stars Objective-C 利用FBRetainCycleDetector和FBAllocationTracker做的一款工具，增加UI界面。 FBRetainCycleDetector 2633 Stars Objective-C++ 利用objc的特性，利用Object、block等的属性布局收集强引用信息。 FBAllocationTracker 792 Stars Objective-C++ hook了+alloc和-dealloc来统计objc对象使用情况。 iOS-Hierarchy-Viewer 1305 Stars C iOS视图结构查看器，需要通过http查看，还包括core data查看。 libimobiledevice 1602 Stars C 和设备通信的类库。 Test ocmock 1558 Stars Objective-C 使用NSProxy对象替代原本的对象，在response和forward中记录和处理、转发消息来实现，是非常好用的mock类库。由于完全依赖oc的动态特性，所以对swift类无效。 OCMockito 类似于ocmock，关注度不高。 KIF 5049 Stars Objective-C 利用了私有方法，在非UI Unit test中进行UI测试。 expecta 1406 Stars Objective-C specta 2058 Stars Objective-C cedar 1141 Stars Objective-C++ Kiwi 3671 Stars Objective-C 以上几种都是BDD方式的封装。 OCHamcrest 638 Stars Objective-C 可以认为是一些语法糖 Nocilla 1789 Stars Objective-C hook http请求 Nimble 2403 Stars Swift 知名度比较高的测试断言库。 Quick 6876 Stars Swift 知名度比较高的BDD。 React react-native-maps 5462 Stars Objective-C Other MonkeyDev 847 Stars Objective-C CYLTabBarController 3688 Stars Objective-C detect.location 821 Stars Objective-C WeChatTweak-macOS 1165 Stars Objective-C FlatUIKit 7648 Stars Objective-C JLPermissions 403 Stars Objective-C 应用权限 ZXingObjC 2497 Stars Objective-C 二维码 SAMKeychain 4556 Stars Objective-C SimulateIDFA 229 Stars Objective-C ohana-ios 341 Stars Objective-C 通讯录 class-dump 1727 Stars Objective-C DarkLightning 168 Stars Swift 雷电口传输数据 peertalk 2042 Stars Objective-C USB数据传输 MMWormhole 3296 Stars Objective-C app和extension的数据传输 MALoggingViewController 51 Stars Objective-C ios-simulator-app-installer 238 Stars Objective-C KZPlayground Playground for Objective-C PunchClock 1707 Stars Objective-C PonyDebugger 5462 Stars Objective-C 使用Chrome来debug view MLPNeuralNet 917 Stars Objective-C GCDWebServer 3568 Stars Objective-C CocoaHTTPServer 4297 Stars Objective-C radiant-player-mac 3006 Stars Objective-C 音乐播放器for mac ARAnalytics 1674 Stars Objective-C Onboard 5774 Stars Objective-C electrino 2601 Stars Objective-C","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://djs66256.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[]},{"title":"开源项目列表-C++","date":"2012-07-16T17:57:36.000Z","path":"2012/07/17/project2/","text":"收藏的开源项目以及部分分析。C++相关部分。 protobuf 20416 Stars C++ Protocol Buffers - Google’s data interchange format 以一种流的形式编码数据，来达到更高的压缩率和更高的解码效率。通过.proto文件，严格约束各端的数据结构，并且生成代码，减少了各端的实现成本。其中也包含了rpc相关的实现。 grpc 13827 Stars C++ The C based gRPC (C++, Python, Ruby, Objective-C, PHP, C#) 利用protobuf实现的rpc通信，简单且通用。 folly 9279 Stars C++ An open-source C++ library developed and used at Facebook.","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://djs66256.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[]}]