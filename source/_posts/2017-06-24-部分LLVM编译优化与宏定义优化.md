---
title: 部分LLVM编译优化与宏定义优化
date: 2017-06-24 01:08:16
tags:
---

整理部分我用到的简单的宏定义以及编译优化。

<!--more-->

## 字符串常量化

平时可能会需要使用selector作为string来使用，通常使用的是NSStringFromSelector，但是却不知道在使用这种方法的时候产生了一次内存拷贝。为了能够充分利用内存，这里可以做一个优化。

```c
#if DEBUG
#define SelStr(sel) NSStringFromSelector(sel)
#else
#define SelStr(sel) @#sel
#endif
```

这里和RAC比有个缺点就是不能处理`sel1.sel2`这样的keypath，但是不需要依赖变量。

同样，class也可以这么做。很多时候在register cell的时候，我习惯使用class name，这样可以确保唯一性，也可以减少定义常量的麻烦。

```c
#if DEBUG
#define ClassStr(cls) NSStringFromClass(cls)
#else
#define ClassStr(cls) @#cls
#endif
```

这种方法简单，而且在开发的时候能够自动补全和校验正确性，但也存在着一些小问题，注意不要错误使用。比如：

```c
SEL sel = @selector(action:)
NSString *selName = SelStr(sel)

Class cls = [self class]
NSString *clsName = ClassStr(cls)
```

## Super

保护super的调用

```
NS_REQUIRE_SUPER
```

## Objc final关键字

禁止子类化

```
__attribute__((objc_subclassing_restricted))
```

## constructor & destructor

```
__attribute__((constructor))
__attribute__((destructor))
```

在程序或动态库载入和退出的时候调用，时机比`main()`要早。

## __DATA, name

```
__attribute((used, section("__DATA,sectname")))
```

可以将全局变量数据放到`sectname`数据段，以区分其他数据段。可以通过`getsectiondata`取出。

## format

```
__attribute__((format(printf, m, n)))
```

能够编译期识别format，提供warning信息

## Assertion

平时开发的时候很多人不注意的一点是不标明入参是否为空，或者其他一些临界情况，这是非常不好的一种习惯，而且很容易导致问题。

一种方法是使用编译器自带的检查`nonull`，但是这个需要在所有方法以及属性中标明，需要一定工作量，而且不能在.m中使用。

另一种方法是直接使用assert来断言参数，这种方法简单，而且只要看到第一行就能知道参数情况。并且能够在运行时帮助解决不合理调用的情况。而官方就提供了这类定义。

```c
NSParameterAssert(param != nil)
NSCParameterAssert(param != nil)
```

使用非常简单，实现也是非常巧妙。

## 编译优化

有时候考虑到性能，往往需要把函数定义为inline，编译器对于inline函数的行为是不确定的，也就是说inline函数最终编译结果可能不是inline的，这里可以强制使他成为inline。这种场景虽然少见，但也是一个优化点。

```c
__attribute__((__always_inline__))
```

对于像工厂方法，创建对象的方法，如果返回值没有被使用也是一种浪费，这里可以让编译器直接报警告。

```c
__attribute__((warn_unused_result))
```

## 宏编译

上面提到了很多宏，平时使用过程中可能也会产生很多宏。在开发宏的过程尤为痛苦，这里就需要编译器的预编译宏功能来帮助我们了。

```
clang -E
```

可以将宏编译为代码，这样就可以省去很多调试时间。
