---
title: SwiftData：深入了解继承和架构迁移
date: 2025-06-10 15:26:14
categories:
- wwdc2025
tags:
- wwdc2025
- ios
- ipados
- macos
- tvos
- visionos
- watchos
- app-服务
---
了解如何使用类继承对数据进行建模。了解如何优化查询，并无缝迁移你的 app 数据以便使用继承。探索如何通过子类归类来构建模型图形、编写高效的数据获取和查询，并实现顺畅平稳的架构迁移。了解如何使用可观测持久性历史记录来有效进行更改跟踪。
<!--more-->

![视频封面](https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9993/9993_wide_250x141_2x.jpg)
[视频地址](https://developer.apple.com/cn/videos/play/wwdc2025/291/)

# SwiftData 深度解析：类继承与架构迁移实战指南

## 引言
SwiftData 是苹果在 iOS 17 推出的强大数据持久化框架，它结合了 Swift 的现代语言特性，让开发者能够轻松建模和存储应用数据。本文将深入探讨 SwiftData 中类继承的运用场景、架构迁移策略以及查询优化技巧，并通过实际案例演示如何构建高效的数据模型。

## 类继承在 SwiftData 中的应用

### 何时使用类继承
类继承在以下场景特别有用：
1. 模型存在自然层级关系且共享共同特征（如旅行模型的基本属性）
2. 属于父模型的自然子域（如商务旅行和个人旅行）

```swift
@Model
class Trip {
  var name: String
  var destination: String
  var startDate: Date
  var endDate: Date
  
  var bucketList: [BucketListItem] = [BucketListItem]()
  var livingAccommodation: LivingAccommodation?
}

@available(iOS 26, *)
@Model
class BusinessTrip: Trip {
  var perdiem: Double = 0.0
}

@available(iOS 26, *)
@Model
class PersonalTrip: Trip {
  enum Reason: String, CaseIterable, Codable {
    case family
    case reunion
    case wellness
  }
  
  var reason: Reason
}
```

### 继承设计原则
- 适用于「is-a」关系（如 PersonalTrip IS-A Trip）
- 避免仅因共享单一属性而滥用继承，这种情况下协议更适合
- 考虑查询方式：如果需要同时查询父类和子类，继承架构更合适

## 数据架构迁移策略

### 版本化 Schema 管理
随着应用迭代，数据模型可能需要变更。SwiftData 提供了 Schema 版本化和迁移机制：

```swift
enum SampleTripsSchemaV2: VersionedSchema {
  static var versionIdentifier: Schema.Version { Schema.Version(2, 0, 0) }
  @Model
  class Trip {
    @Attribute(.unique) var name: String
    @Attribute(originalName: "start_date") var startDate: Date
    // ...
  }
}
```

### 自定义迁移阶段
对于复杂的迁移需求，可以定义自定义迁移逻辑：

```swift
static let migrateV1toV2 = MigrationStage.custom(
   willMigrate: { context in
      let fetchDesc = FetchDescriptor<SampleTripsSchemaV1.Trip>()
      // 执行去重等预处理逻辑
   })
```

## 查询优化技巧

### 高效数据查询
1. **复合谓词**：结合搜索条件和类型过滤
2. **属性预取**：只获取必要属性
3. **关系预加载**：提前加载关联对象
4. **限制结果数**：如只需获取最近记录

```swift
let searchPredicate = #Predicate<Trip> {
  searchText.isEmpty ? true : 
    $0.name.localizedStandardContains(searchText) ||              
    $0.destination.localizedStandardContains(searchText)
}

var fetchDesc = FetchDescriptor<SampleTripsSchemaV1.Trip>()
fetchDesc.propertiesToFetch = [\.name]
fetchDesc.relationshipKeyPathsForPrefetching = [\.livingAccommodation]
fetchDesc.fetchLimit = 1
```

## 数据变更观测

### 变更追踪方法
SwiftData 提供了两种数据变更观测方式：
1. **本地变更**：通过 Observable 跟踪属性变化
2. **外部变更**：使用持久化历史记录追踪

```swift
var historyDesc = HistoryDescriptor<DefaultHistoryTransaction>()
historyDesc.sortBy = [.init(\.transactionIdentifier, order: .reverse)]
historyDesc.fetchLimit = 1
let transactions = try context.fetchHistory(historyDesc)
```

## 结论

SwiftData 提供了一套完整的解决方案来处理数据建模、持久化和迁移。通过合理运用类继承、精心设计迁移计划以及优化查询性能，开发者可以构建高效、稳定的数据层。建议从简单模型开始，逐步应用这些高级特性。

## 相关视频
- [SwiftUI 的新功能](https://developer.apple.com/videos/play/wwdc2025/256)
- [使用 SwiftData 历史记录 API 跟踪模型更改](https://developer.apple.com/videos/play/wwdc2024/10075)

## 文档
- [SwiftData 官方文档](https://developer.apple.com/documentation/SwiftData)
> 此文章由AI生成，可能存在错误，如有问题，请联系[djs66256@163.com](djs66256@163.com)