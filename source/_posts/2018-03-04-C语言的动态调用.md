---
title: C语言的动态调用
date: 2018-03-04 01:05:22
categories:
- iOS
tags:
---

我们都认为C语言是一种非常`静态`的语言，几乎没有什么动态特性，同时往往在编译器就决定了整个运行方式，运行期是很难改变其运行状态的。其实C语言也是可以比较动态的，只是由于C语言是一个跨平台兼容语言，每个平台都有不同的实现，其动态化很难统一。这里我们看看在AArch64平台上的动态化实现。

<!--more-->

## 其他语言的动态化

脚本语言是非常具有动态特性的，其中典型的js就可以如下方式动态调用方法。

```js
function hello() {
  console.log('hello world')
}
eval('hello()')
```

平时开发常用的Objc也有一定的动态特性，比如`NSInvocation`和

```oc
- (id)performSelector:(SEL)aSelector;
```

都可以通过方法名称来调用。

那么我们来看看C语言的表现。

## C语言的动态化

根据上两篇内容，我们了解了iOS/Mac系统的执行文件格式MachO，而linux常用的ELF也是类似，执行代码都在`TEXT`段，如果我们要执行对应的方法，我们只需要拿到对应的地址（也就是函数指针）就行了。

那么如何从字符串找到对应的地址呢？这就涉及到函数符号表了，根据上篇的内容，不难找到其对应的函数指针，这里系统也给我们提供了一个封装好的方法。

```
NAME
     dlsym -- get address of a symbol

SYNOPSIS
     #include <dlfcn.h>

     void*
     dlsym(void* handle, const char* symbol);

DESCRIPTION
     dlsym() returns the address of the code or data location specified by the null-terminated character string symbol.  Which libraries and bundles are searched depends on the handle parameter.
```

有了函数指针之后，只需要将我们的参数填入对应位置，我们就可以实现方法调用了。如何填入参数呢？根据之前的讨论和[aapcs64](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf)ARM官方文档的说明，我们可以按照这种思路去填入参数。

这里我们简单的把所有参数都认为是int64（或者说void *)类型，这样我们可以把以上逻辑简化为：

1. 按x0-x7顺序填入寄存器
2. 剩下的都放入栈中

这里设计个简单的动态调用接口：

```c
extern void dynamic_call_func_name(const char *func, int64_t argc, int64_t *args) {
    void *funcPtr = dlsym(RTLD_DEFAULT, func);
    dynamic_call_func((uintptr_t)funcPtr, argc, args);
}
extern void dynamic_call_func(uintptr_t func, int64_t argc, int64_t *args);
```

以及测试函数：

```c
void one_arg(int64_t a1);
void two_arg(int64_t a1, int64_t a2);
void eight_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8);
void nine_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9);
void ten_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10);
void eleven_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8, int64_t a9, int64_t a10, int64_t a11);
void more_arg(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7, int64_t a8,
              int64_t aa1, int64_t aa2, int64_t aa3, int64_t aa4, int64_t aa5, int64_t aa6, int64_t aa7, int64_t aa8);
```

那么动态调用可以写作：

```c
int64_t args[] = {
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
};
dynamic_call_func_name("eleven_arg", sizeof(args)/sizeof(int64_t), args);
```

这样我们就实现了C语言的动态调用了。比如可以从其他端获得方法名和参数列表，就可以直接调用C方法了。这也是一些高级语言调用C语言的实现方式（cpython），以及一些rpc的实现方案。

接下来我们来看看如何填入参数，`dynamic_call_func`的实现方式。

## 动态设置参数

这里我们只能通过汇编来设置参数了。

```armasm
.align 4

// C方法会自动加上前缀`_`
.global _dynamic_call_func

_dynamic_call_func:
// if func == NULL then return
cbz x0, DCReturnZero

// 申请栈空间，0x10用于缓存fp和lr，剩下的用于临时变量
// 这里不能确定调用的方法是否会用到栈空间来传递参数，所以这里暂不考虑，fp == sp
sub sp, sp, #0x20
stp x29, x30, [sp]
mov x29, sp

// 栈参数长度，初始化为0
mov x15, #0
str x15, [x29, #0x18]

// 缓存一些入参，需要给下个方法腾出寄存器
// x9 = func
// x10 = x11 = argc
// x12 = x13 = args
mov x9, x0
mov x10, x1
mov x11, x1
mov x12, x2
mov x13, x2

// 没有参数直接 CALL
cbz x11, DCCallFunc

// 第一个参数
ldr x0, [x12]
sub x11, x11, #1
cbz x11, DCCallFunc

// 第二个参数
ldr x1, [x12, #0x8]
sub x11, x11, #1
cbz x11, DCCallFunc

ldr x2, [x12, #0x10]
sub x11, x11, #1
cbz x11, DCCallFunc

ldr x3, [x12, #0x18]
sub x11, x11, #1
cbz x11, DCCallFunc

ldr x4, [x12, #0x20]
sub x11, x11, #1
cbz x11, DCCallFunc

ldr x5, [x12, #0x28]
sub x11, x11, #1
cbz x11, DCCallFunc

ldr x6, [x12, #0x30]
sub x11, x11, #1
cbz x11, DCCallFunc

// 第八个参数
ldr x7, [x12, #0x38]
sub x11, x11, #1
cbz x11, DCCallFunc

// 栈参数
// 开始计算栈空间，由于我们的参数都是int64类型
// 所以栈空间x15 = x11(剩余参数个数) * 8
mov x16, #8
mul x15, x11, x16
// The NSAA is rounded up to the larger of 8 or the Natural Alignment of the argument’s type
// 这里需要对齐，我也不明白为什么
and x16, x15, #0x8
cbz x16, DCNoFixAlign
DCFixAlign:
add x15, x15, #0x8
DCNoFixAlign:

// 现在开始重新申请参数栈空间，并将栈空间大小存入临时变量`fp + 0x18`
DCStoreStackArgsLength:
str x15, [x29, #0x18]
sub sp, sp, x15

mov x15, sp
add x13, x12, #0x38

// 循环剩下的参数，逐个将其入栈:
// for arg in args+8:
//   push(arg)
DCPushStackArgs:
add x13, x13, #0x8
ldr x14, [x13]
str x14, [x15]
sub x11, x11, #1
add x15, x15, #0x8
cbnz x11, DCPushStackArgs


// CALL
DCCallFunc:
blr x9

// 这里首先销毁参数栈空间
ldr x15, [x29, #0x18]
cbz x15, DCRestoreStack
DCRestoreStackArgsLength:
add sp, sp, x15

// 然后还原fp, lr
// 销毁当前栈空间
DCRestoreStack:
ldp x29, x30, [sp]
add sp, sp, #0x20

ret

// ReturnZero:
DCReturnZero:
mov x0, 0
ret
```

经过测试，可以看到所有参数都被正确的传递过去了，说明这种思路是正确的。

## 总结

那么C语言动态调用能给我们一些什么好处呢。这是一种rpc的思想，而且这不需要额外的rpc支持，就可以直接调用几乎所有C方法，但是这样也给我们的程序带来了一定的风险，包括权限，参数类型等问题。

同时也是快速实现，或者说兼容C实现高级语言的一种方式，比如cpython就是利用了这种思想。

由于不同平台的差异性，可能会导致兼容工作非常庞大，那么我们可以设计几种类型的参数，或者固定几个参数，来简化我们的兼容工作，比如将所有的对象都放到堆上，使用指针来传递。

开源项目libffi实现了多平台的动态调用，有兴趣的人可以自己去了解其实现。
