---
title: 跟着视频学编程：使用 Swift 并发机制提升 App 性能
date: 2025-06-10 21:46:48
categories:
- wwdc2025
tags:
- wwdc2025
- ios
- ipados
- macos
- tvos
- visionos
- watchos
- 开发者工具
---
通过更新一个现有的示例 app，我们将向你介绍如何通过 swift 并发机制来优化 app 的用户体验。我们将从一个主 actor app 入手，然后根据需要逐步引入异步代码。我们将使用任务来优化主 actor 上运行的代码，并探索如何通过将工作转移到后台来实现代码并行运行。我们将探讨数据争用安全机制提供的功能，并讲解如何解读和修复数据争用安全错误。最后，我们将展示如何在 app 情境中充分利用结构化并发机制。
<!--more-->

![视频封面](https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9949/9949_wide_250x141_2x.jpg)
[视频地址](https://developer.apple.com/cn/videos/play/wwdc2025/270/)
> 此文章由AI生成，可能存在错误，如有问题，请联系[djs66256@163.com](djs66256@163.com)

# 利用 Swift 并发机制提升 App 性能：从主线程到结构化并发的演进之路

本文将深入剖析如何运用 Swift 并发机制优化 App 性能，通过一个贴纸生成应用的实例，展示从单线程到结构化并发的完整演进过程。

## 应用背景与架构

该示例应用是一个能将任意照片转为贴纸包的创意工具，包含两个核心组件：
- 贴纸轮播视图（StickerCarousel）：展示带有渐变色背景的照片贴纸
- 网格预览视图（StickerGrid）：提供贴纸包的导出分享功能

应用的底层架构采用 PhotoProcessor 结构体处理照片，执行两项核心操作：
1. 从照片中提取贴纸图像
2. 计算照片的主色调（用于生成渐变色背景）

## 性能优化演进路径

### 初始问题：主线程阻塞

最初的实现将所有逻辑放在主线程执行，导致以下问题：
- 照片加载时界面冻结
- 图像处理耗时超过10秒
- 滚动体验卡顿

```swift
// 初始同步实现（导致主线程阻塞）
struct PhotoProcessor {
    func process(data: Data) -> ProcessedPhoto? {
        let sticker = extractSticker(from: data) // 耗时操作
        let colors = extractColors(from: data)   // 耗时操作
        return ProcessedPhoto(sticker: sticker, colorScheme: colors)
    }
}
```

### 第一步：异步加载照片

通过引入 async/await 机制，将照片加载移至后台：

```swift
// 异步加载实现
func loadPhoto(_ item: SelectedPhoto) async {
    var data: Data? = try? await item.loadTransferable(type: Data.self)
    guard let data else { return }
    processedPhotos[item.id] = Image(data: data)
}
```

在视图中使用 task 修饰符触发异步加载：

```swift
StickerPlaceholder()
    .task {
        await viewModel.loadPhoto(selectedPhoto)
    }
```

### 第二步：后台图像处理

运用 Swift 6.1 的并发特性，将图像处理移至后台：

```swift
nonisolated struct PhotoProcessor {
    @concurrent
    func process(data: Data) async -> ProcessedPhoto? {
        // 后台执行的处理逻辑
    }
}
```

### 第三步：并行处理优化

通过 async let 并行执行相互独立的操作：

```swift
async let sticker = extractSticker(from: data)  // 并行执行
async let colors = extractColors(from: data)    // 并行执行
```

处理数据竞争问题的方法：

```swift
private func extractColors(from data: Data) -> PhotoColorScheme? {
    let colorExtractor = ColorExtractor()  // 每次创建新实例
    return colorExtractor.extractColors(from: data)
}
```

### 第四步：结构化并发与批量处理

使用 TaskGroup 实现高效的批量照片处理：

```swift
func processAllPhotos() async {
    await withTaskGroup { group in
        for item in selection {
            group.addTask {
                // 并行处理每个照片
            }
        }
        for await result in group {
            // 收集处理结果
        }
    }
}
```

## 关键技术与最佳实践

1. **主线程优化策略**
   - 使用 await 创建暂停点
   - 通过 task 修饰符管理异步任务生命周期

2. **后台执行控制**
   - nonisolated 标记脱离主线程
   - @concurrent 确保方法在后台执行

3. **并行处理模式**
   - async let 并行独立任务
   - 避免共享可变状态

4. **数据竞争防护**
   - Swift 6 编译时检查
   - 采用 Sendable 值类型
   - 必要时隔离到主线程

5. **结构化并发**
   - TaskGroup 批量任务管理
   - 结果有序收集机制

## 性能优化成果

经过上述优化步骤，应用实现了：
- 主线程保持高响应性
- 图像处理时间大幅缩短
- 滚动体验流畅
- 批量处理效率显著提升

## 相关资源

### 相关视频
[探索 SwiftUI 中的并发机制](https://developer.apple.com/videos/play/wwdc2025/266)  
[采用 Swift 并发](https://developer.apple.com/videos/play/wwdc2025/268)  
[使用 Instruments 分析挂起](https://developer.apple.com/videos/play/wwdc2023/10248)  
[超越结构化并发的基础](https://developer.apple.com/videos/play/wwdc2023/10170)  

### 文档
[Swift Migration Guide](https://www.swift.org/migration/documentation/migrationguide/)
