<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苍耳的技术博客</title>
  <icon>https://www.gravatar.com/avatar/2f748ebf01f37cc394aa692ef4bca1c2</icon>
  <subtitle>无悔的人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://djs66256.github.io/"/>
  <updated>2025-06-10T15:54:00.680Z</updated>
  <id>http://djs66256.github.io/</id>
  
  <author>
    <name>苍耳</name>
    <email>djs66256@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>支持 visionOS App 播放沉浸视频</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_296/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_296/</id>
    <published>2025-06-10T15:54:00.000Z</published>
    <updated>2025-06-10T15:54:00.680Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何在 visionos app 中播放沉浸视频。我们将介绍各种沉浸感十足的渲染模式、查看支持这些模式的框架，并讲解如何在你的 app 中渲染沉浸视频。为了充分利用好本次视频，我们建议你先观看 wwdc25 讲座“探索 visionos 的视频体验”。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/10057/10057_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/296/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="支持-visionOS-App-播放沉浸视频"><a href="#支持-visionOS-App-播放沉浸视频" class="headerlink" title="支持 visionOS App 播放沉浸视频"></a>支持 visionOS App 播放沉浸视频</h1><p>随着 visionOS 的不断发展，开发者现在可以利用多种框架在应用中实现沉浸式视频播放体验。本文将详细介绍如何在 visionOS 26 中通过 Quick Look、AVKit 和 RealityKit 支持沉浸式视频播放，并探讨相关技术实现和最佳实践。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 visionOS 26 中，Apple 引入了多种新的沉浸式媒体配置文件，包括 Apple Projected Media Profile (APMP) 和 Apple 沉浸视频。这些新特性为开发者提供了丰富的工具集，以创建引人入胜的沉浸式视频体验。Quick Look、AVKit 和 RealityKit 是三个主要框架，它们各自适用于不同的场景需求：从快速预览到完全自定义的沉浸式播放。</p><p>接下来的内容将分为几个部分：首先回顾支持的视频配置文件，然后逐步讲解如何使用 Quick Look 和 AVKit 实现沉浸式视频播放，最后深入探讨如何通过 RealityKit 创建高度定制化的沉浸体验。</p><h2 id="visionOS-26-中支持的视频配置文件"><a href="#visionOS-26-中支持的视频配置文件" class="headerlink" title="visionOS 26 中支持的视频配置文件"></a>visionOS 26 中支持的视频配置文件</h2><p>visionOS 26 支持多种视频配置文件，涵盖了从传统的 2D 和 3D 视频到更具沉浸感的 Apple Projected Media Profile（包括 180°、360° 和宽视场视频）以及 Apple 沉浸视频。不同类型的视频配置文件各有特点，例如 APMP 提供了广泛的沉浸视角选择，而 Apple 沉浸视频则专注于极致的沉浸体验。</p><p>为了充分利用这些视频配置文件，开发者需要根据应用的需求选择合适的框架。Quick Look 适合快速呈现媒体内容；AVKit 提供了一致且增强的播放控制功能；而 RealityKit 则专为需要高度定制化体验的应用设计，例如游戏环境中的视频播放。</p><h2 id="Quick-Look-中的沉浸视频播放"><a href="#Quick-Look-中的沉浸视频播放" class="headerlink" title="Quick Look 中的沉浸视频播放"></a>Quick Look 中的沉浸视频播放</h2><p>Quick Look 在 visionOS 26 中得到了显著增强，能够支持空间照片和视频的展示。QLPreviewController API 可用于在一个应用程序窗口或模态展示风格中预览媒体，同时支持 Apple 沉浸视频和 APMP 配置文件。</p><p>对于已经实现了 Quick Look API 的应用，所有新支持的沉浸式媒体配置文件将自动生效。开发者可以通过 WWDC 相关视频进一步了解如何实现 QLPreviewController 和 PreviewApplication API，从而提升应用的沉浸式媒体支持能力。</p><h2 id="使用-AVKit-进行沉浸视频播放"><a href="#使用-AVKit-进行沉浸视频播放" class="headerlink" title="使用 AVKit 进行沉浸视频播放"></a>使用 AVKit 进行沉浸视频播放</h2><p>AVKit 在 visionOS 26 中新增了对沉浸式视频播放的支持，通过 AVExperienceController API 可以实现向新沉浸体验的过渡。开发者可以选择使用 Expanded 或 Immersive 体验模式来满足不同需求。</p><h3 id="自动过渡与手动控制"><a href="#自动过渡与手动控制" class="headerlink" title="自动过渡与手动控制"></a>自动过渡与手动控制</h3><p>在 Expanded 模式下，<code>AutomaticTransitionToImmersive</code> 属性允许开发者控制是否自动切换到沉浸体验。以下代码展示了如何禁用自动过渡并手动管理沉浸体验：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller <span class="operator">=</span> <span class="type">AVPlayerViewController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> experienceController <span class="operator">=</span> controller.experienceController</span><br><span class="line">experienceController.allowedExperiences <span class="operator">=</span> .recommended(including: [.expanded, .immersive])</span><br><span class="line"></span><br><span class="line">experienceController.configuration.expanded.automaticTransitionToImmersive <span class="operator">=</span> .none</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> experienceController.transition(to: .expanded)</span><br></pre></td></tr></table></figure><h3 id="手动转换到沉浸模式"><a href="#手动转换到沉浸模式" class="headerlink" title="手动转换到沉浸模式"></a>手动转换到沉浸模式</h3><p>要显式地转换到沉浸模式，开发者可以使用 <code>configuration.placement</code> API 来指定沉浸式视频播放的位置。以下代码演示了如何通过指定目标窗口场景完成这一操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller <span class="operator">=</span> <span class="type">AVPlayerViewController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> experienceController <span class="operator">=</span> controller.experienceController</span><br><span class="line">experienceController.allowedExperiences <span class="operator">=</span> .recommended(including: [.immersive])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myScene <span class="operator">=</span> getMyPreferredWindowUIScene()</span><br><span class="line">experienceController.configuration.placement <span class="operator">=</span> .over(scene: myScene)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> experienceController.transition(to: .immersive)</span><br></pre></td></tr></table></figure><p>此外，AVExperienceController 的委托协议提供了灵活的状态管理方法，例如 <code>didChangeAvailableExperiences</code> 和 <code>prepareForTransitionUsing</code>，使开发者能够精确控制沉浸式体验的过渡过程。</p><h2 id="舒适缓解检测"><a href="#舒适缓解检测" class="headerlink" title="舒适缓解检测"></a>舒适缓解检测</h2><p>沉浸式视频可能会因显著的摄像机运动导致观众不适。为解决这一问题，visionOS 26 在 Quick Look 和 AVKit 中引入了舒适缓解检测功能，能够自动检测高运动并降低沉浸水平。用户还可以通过设置应用调整相关选项，确保播放行为符合个人偏好。</p><h2 id="RealityKit-中的自定义播放"><a href="#RealityKit-中的自定义播放" class="headerlink" title="RealityKit 中的自定义播放"></a>RealityKit 中的自定义播放</h2><p>对于需要更高定制化程度的应用，RealityKit 提供了强大的工具集来渲染和管理沉浸式视频播放。其核心组件 VideoPlayerComponent 能够根据当前 AVPlayer 的内容动态生成网格和材质，从而简化开发流程。</p><h3 id="渐进沉浸模式"><a href="#渐进沉浸模式" class="headerlink" title="渐进沉浸模式"></a>渐进沉浸模式</h3><p>在 RealityKit 中，渐进沉浸模式是一种全新的 API，允许用户通过数码表冠调整沉浸级别，从而在享受视频的同时保持与周围环境的联系。以下代码展示了如何在门户模式下渲染 180° 视频：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> RealityKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortalVideoView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">RealityView</span> &#123; content <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://cdn.example.com/My180.m3u8&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">let</span> player <span class="operator">=</span> <span class="type">AVPlayer</span>(playerItem: <span class="type">AVPlayerItem</span>(url: url))</span><br><span class="line">            <span class="keyword">let</span> videoEntity <span class="operator">=</span> <span class="type">Entity</span>()</span><br><span class="line">            <span class="keyword">var</span> videoPlayerComponent <span class="operator">=</span> <span class="type">VideoPlayerComponent</span>(avPlayer: player)</span><br><span class="line">            videoPlayerComponent.desiredImmersiveViewingMode <span class="operator">=</span> .portal</span><br><span class="line">            videoEntity.components.set(videoPlayerComponent)</span><br><span class="line">            videoEntity.scale <span class="operator">*=</span> <span class="number">0.4</span></span><br><span class="line">            content.add(videoEntity)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望切换到渐进沉浸模式，只需将 <code>desiredImmersiveViewingMode</code> 设置为 <code>.progressive</code>，并在 SwiftUI 场景中使用 <code>ImmersiveSpace</code> 包装视图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> RealityKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ImmersiveVideoApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">ImmersiveSpace</span> &#123;</span><br><span class="line">            <span class="type">ProgressiveVideoView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .immersionStyle(selection: .constant(.progressive(<span class="number">0.1</span><span class="operator">...</span><span class="number">1</span>, initialAmount: <span class="number">1.0</span>)), in: .progressive)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空间视频渲染"><a href="#空间视频渲染" class="headerlink" title="空间视频渲染"></a>空间视频渲染</h3><p>RealityKit 还支持空间视频的原生播放，并提供完全空间样式的渲染选项。通过设置 <code>desiredSpatialVideoMode</code> 属性，开发者可以灵活选择渲染方式。例如，以下代码展示了如何在门户模式下渲染空间视频：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> RealityKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortalSpatialVideoView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">RealityView</span> &#123; content <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;MySpatialVideo&quot;</span>, withExtension: <span class="string">&quot;mov&quot;</span>)<span class="operator">!</span></span><br><span class="line">            <span class="keyword">let</span> player <span class="operator">=</span> <span class="type">AVPlayer</span>(url: url)</span><br><span class="line">            <span class="keyword">let</span> videoEntity <span class="operator">=</span> <span class="type">Entity</span>()</span><br><span class="line">            <span class="keyword">var</span> videoPlayerComponent <span class="operator">=</span> <span class="type">VideoPlayerComponent</span>(avPlayer: player)</span><br><span class="line">            videoPlayerComponent.desiredViewingMode <span class="operator">=</span> .stereo</span><br><span class="line">            videoPlayerComponent.desiredSpatialVideoMode <span class="operator">=</span> .spatial</span><br><span class="line">            videoPlayerComponent.desiredImmersiveViewingMode <span class="operator">=</span> .portal</span><br><span class="line">            videoEntity.components.set(videoPlayerComponent)</span><br><span class="line">            videoEntity.scale <span class="operator">*=</span> <span class="number">0.4</span></span><br><span class="line">            content.add(videoEntity)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若需进一步扩展视频至全沉浸模式，可将 <code>desiredImmersiveViewingMode</code> 设置为 <code>.full</code> 并移除缩放操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> RealityKit</span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortalSpatialVideoView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">RealityView</span> &#123; content <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;MySpatialVideo&quot;</span>, withExtension: <span class="string">&quot;mov&quot;</span>)<span class="operator">!</span></span><br><span class="line">            <span class="keyword">let</span> player <span class="operator">=</span> <span class="type">AVPlayer</span>(url: url)</span><br><span class="line">            <span class="keyword">let</span> videoEntity <span class="operator">=</span> <span class="type">Entity</span>()</span><br><span class="line">            <span class="keyword">var</span> videoPlayerComponent <span class="operator">=</span> <span class="type">VideoPlayerComponent</span>(avPlayer: player)</span><br><span class="line">            videoPlayerComponent.desiredViewingMode <span class="operator">=</span> .stereo</span><br><span class="line">            videoPlayerComponent.desiredSpatialVideoMode <span class="operator">=</span> .spatial</span><br><span class="line">            videoPlayerComponent.desiredImmersiveViewingMode <span class="operator">=</span> .full</span><br><span class="line">            videoEntity.position <span class="operator">=</span> [<span class="number">0</span>, <span class="number">1.5</span>, <span class="operator">-</span><span class="number">1</span>]</span><br><span class="line">            videoEntity.components.set(videoPlayerComponent)</span><br><span class="line">            content.add(videoEntity)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过 Quick Look、AVKit 和 RealityKit，开发者可以在 visionOS 应用中实现丰富多样的沉浸式视频播放体验。无论是快速预览还是深度定制，Apple 提供的工具集都为开发者创造了无限可能。建议开发者进一步探索相关文档和示例代码，以充分发挥这些框架的潜力。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2025/403">了解 Apple 沉浸视频技术</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/297">了解 Apple Projected Media Profile</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/304">探索 visionOS 的视频体验</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/237">空间网页的新功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10153">深入探究空间容器和沉浸式空间</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10081">使用 RealityKit 增强你的空间计算 App</a>  </p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://developer.apple.com/documentation/AVFoundation">AVFoundation</a><br><a href="https://developer.apple.com/documentation/AVKit">AVKit</a><br><a href="https://developer.apple.com/streaming/examples/">HTTP Live Streaming Examples</a><br><a href="https://developer.apple.com/documentation/RealityKit">RealityKit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何在 visionos app 中播放沉浸视频。我们将介绍各种沉浸感十足的渲染模式、查看支持这些模式的框架，并讲解如何在你的 app 中渲染沉浸视频。为了充分利用好本次视频，我们建议你先观看 wwdc25 讲座“探索 visionos 的视频体验”。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="音频和视频" scheme="http://djs66256.github.io/tags/%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>深入探索 Metal 4 游戏</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_211/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_211/</id>
    <published>2025-06-10T15:53:59.000Z</published>
    <updated>2025-06-10T15:53:59.905Z</updated>
    
    <content type="html"><![CDATA[<p>深入了解 metal 4 的最新改进。我们将介绍全新光线追踪功能，助你将复杂度极高且视觉效果丰富的工作负载成功移植到 apple 芯片上。了解 metalfx 如何通过渲染画质提升、帧插值和场景去噪来扩展工作负载。</p><p>为了充分从这个讲座中获益，我们建议你先观看“探索 metal 4”和“探索 metal 4 游戏”。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9888/9888_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/211/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="深入探索-Metal-4-游戏"><a href="#深入探索-Metal-4-游戏" class="headerlink" title="深入探索 Metal 4 游戏"></a>深入探索 Metal 4 游戏</h1><p>Metal 4 的推出为 Apple 平台上的游戏开发者带来了全新的可能性，特别是在光线追踪、渲染性能和视觉效果提升方面。本次演讲由 Matias Koskela 主讲，深入探讨了如何利用 MetalFX 和 Metal 4 的新特性来优化游戏性能，并将复杂的工作负载成功移植到 Apple 芯片上。以下是对演讲内容的全面解析。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着游戏画质的不断提升，实时渲染的复杂性和计算成本也在显著增加。例如《赛博朋克2077》这样的现代游戏，通过实时路径追踪技术实现了令人惊叹的画面效果，但这也对硬件性能提出了更高的要求。Metal 提供了一系列工具和 API，帮助开发者在 iPhone 到 Mac 的所有 Apple 平台上实现高质量的图形渲染。MetalFX Upscaling 和帧插值等技术可以有效应对高分辨率和高帧率带来的挑战，而新的光线追踪功能则进一步提升了渲染的真实感。</p><p>为了更好地理解这些新技术，建议先观看“探索 Metal 4”和“探索 Metal 4 游戏”，以获得关于 Metal 4 基础知识及其游戏应用的背景信息。</p><h2 id="放大渲染"><a href="#放大渲染" class="headerlink" title="放大渲染"></a>放大渲染</h2><p>放大渲染是一种广泛使用的技术，它可以帮助开发者在不牺牲质量的前提下提高渲染性能。MetalFX 提供了一个基于机器学习的放大器，自 2022 年起便成为 Apple 平台的一部分，并逐年改进。以下是实现高质量放大的关键技术要点：</p><h3 id="曝光参数设置"><a href="#曝光参数设置" class="headerlink" title="曝光参数设置"></a>曝光参数设置</h3><p>正确设置曝光输入参数对于放大器的输出质量至关重要。如果传递的曝光值与色调映射器不匹配，可能会导致闪烁或鬼影现象。为此，MetalFX 提供了一个名为“曝光调试器”的工具，可以通过设置环境变量 <code>MTLFX_EXPOSURE_TOOL_ENABLED</code> 来启用。该工具会在帧上叠加一个灰色棋盘格图案，并根据曝光值调整其亮度。如果曝光值设置正确，棋盘格应保持恒定的中灰色。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主机代码中启用曝光调试器</span></span><br><span class="line">setenv(<span class="string">&quot;MTLFX_EXPOSURE_TOOL_ENABLED&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="动态分辨率支持"><a href="#动态分辨率支持" class="headerlink" title="动态分辨率支持"></a>动态分辨率支持</h3><p>许多游戏采用动态分辨率渲染以适应不同场景的复杂度。MetalFX 时间放大器现在支持动态大小的输入，允许每帧传递不同分辨率的纹理。在高缩放比率下，建议将最大缩放比例限制在 2 倍以内，以确保缩放质量。</p><h3 id="反应掩码"><a href="#反应掩码" class="headerlink" title="反应掩码"></a>反应掩码</h3><p>当渲染透明效果或粒子时（如烟花），这些元素通常不会被写入运动和深度纹理中，从而可能导致伪影或鬼影问题。MetalFX 引入了反应掩码功能，用于标记这些效果覆盖的区域。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在着色器中创建反应掩码设置</span></span><br><span class="line">out.reactivity <span class="operator">=</span> m_material_id <span class="operator">==</span> eRain <span class="operator">?</span> (m_material_id <span class="operator">==</span> eSpark <span class="operator">?</span> <span class="number">1</span>.0f : <span class="number">0</span>.0f) : <span class="number">0</span>.8f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主机上编码放大器之前设置反应掩码</span></span><br><span class="line">temporalUpscaler.reactiveMask <span class="operator">=</span> reactiveMaskTexture;</span><br></pre></td></tr></table></figure><p>通过合理使用反应掩码，可以显著改善透明效果的渲染质量。</p><h2 id="插值帧"><a href="#插值帧" class="headerlink" title="插值帧"></a>插值帧</h2><p>帧插值是提高刷新率的一种有效方法，特别适用于需要流畅体验的游戏。MetalFX 帧插值器能够通过已渲染的像素生成插值帧，从而实现更高的帧率。</p><h3 id="集成帧插值器"><a href="#集成帧插值器" class="headerlink" title="集成帧插值器"></a>集成帧插值器</h3><p>要使用 MetalFX 帧插值器，首先需要设置插值器对象并绑定必要的纹理输入，包括颜色、深度和运动矢量纹理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并配置插值器描述符</span></span><br><span class="line"><span class="type">MTLFXFrameInterpolatorDescriptor</span><span class="operator">*</span> desc <span class="operator">=</span> [<span class="type">MTLFXFrameInterpolatorDescriptor</span> new];</span><br><span class="line">desc.scaler <span class="operator">=</span> temporalScaler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建插值器并设置参数</span></span><br><span class="line">id<span class="operator">&lt;</span><span class="type">MTLFXFrameInterpolator</span><span class="operator">&gt;</span> interpolator <span class="operator">=</span> [desc newFrameInterpolatorWithDevice:device];</span><br><span class="line">interpolator.motionVectorScaleX <span class="operator">=</span> mvecScaleX;</span><br><span class="line">interpolator.motionVectorScaleY <span class="operator">=</span> mvecScaleY;</span><br><span class="line">interpolator.depthReversed <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置输入纹理</span></span><br><span class="line">interpolator.colorTexture <span class="operator">=</span> colorTexture;</span><br><span class="line">interpolator.prevColorTexture <span class="operator">=</span> prevColorTexture;</span><br><span class="line">interpolator.depthTexture <span class="operator">=</span> depthTexture;</span><br><span class="line">interpolator.motionTexture <span class="operator">=</span> motionTexture;</span><br><span class="line">interpolator.outputTexture <span class="operator">=</span> outputTexture;</span><br></pre></td></tr></table></figure><h3 id="UI-渲染策略"><a href="#UI-渲染策略" class="headerlink" title="UI 渲染策略"></a>UI 渲染策略</h3><p>在插值帧中渲染 UI 是一个关键步骤。常见的三种方法包括合成 UI、离屏 UI 和每帧 UI。每种方法都有其优缺点，开发者可以根据需求选择最适合的方案。</p><ul><li><strong>合成 UI</strong>：插值器会尝试移除原始帧中的 UI 并将其放置在插值帧中的正确位置。</li><li><strong>离屏 UI</strong>：将 UI 渲染到独立的纹理中，然后由插值器进行合成。</li><li><strong>每帧 UI</strong>：完全由开发者负责更新插值帧的 UI，可提供最流畅的体验。</li></ul><h3 id="帧节奏协调"><a href="#帧节奏协调" class="headerlink" title="帧节奏协调"></a>帧节奏协调</h3><p>插值帧的呈现顺序和间隔对游戏的整体流畅性至关重要。通过使用 Metal HUD 工具，开发者可以轻松识别帧节奏是否偏离目标刷新率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PresentThread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_timerQueue;</span><br><span class="line">    std::thread m_encodingThread, m_pacingThread;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_scheduleCV, m_threadCV, m_pacingCV;</span><br><span class="line">    <span class="type">float</span> m_minDuration;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> m_width, m_height;</span><br><span class="line">    MTLPixelFormat m_pixelFormat;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">uint32_t</span> kNumBuffers = <span class="number">3</span>;</span><br><span class="line">    <span class="type">uint32_t</span> m_bufferIndex, m_inputIndex;</span><br><span class="line">    <span class="type">bool</span> m_renderingUI, m_presentsPending;</span><br><span class="line">    </span><br><span class="line">    CAMetalLayer *m_metalLayer;</span><br><span class="line">    id&lt;MTLCommandQueue&gt; m_presentQueue;</span><br><span class="line"></span><br><span class="line">    id&lt;MTLEvent&gt; m_event;</span><br><span class="line">    id&lt;MTLSharedEvent&gt; m_paceEvent, m_paceEvent2;</span><br><span class="line">    <span class="type">uint64_t</span> m_eventValue;</span><br><span class="line">    <span class="type">uint32_t</span> m_paceCount;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int32_t</span> m_numQueued, m_framesInFlight;</span><br><span class="line">    </span><br><span class="line">    id&lt;MTLTexture&gt; m_backBuffers[kNumBuffers];</span><br><span class="line">    id&lt;MTLTexture&gt; m_interpolationOutputs[kNumBuffers];</span><br><span class="line">    id&lt;MTLTexture&gt; m_interpolationInputs[<span class="number">2</span>];</span><br><span class="line">    id&lt;MTLRenderPipelineState&gt; m_copyPipeline;</span><br><span class="line">    </span><br><span class="line">    std::function&lt;<span class="type">void</span>(id&lt;MTLRenderCommandEncoder&gt;)&gt; m_uiCallback = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PresentThreadFunction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PacingThreadFunction</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTexture</span><span class="params">(id&lt;MTLCommandBuffer&gt; commandBuffer, id&lt;MTLTexture&gt; dest, id&lt;MTLTexture&gt; src, NSString *label)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PresentThread</span>(<span class="type">float</span> minDuration, CAMetalLayer *metalLayer);</span><br><span class="line">    ~<span class="built_in">PresentThread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_numQueued = <span class="number">-1</span>;</span><br><span class="line">        m_threadCV.<span class="built_in">notify_one</span>();</span><br><span class="line">        m_encodingThread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartFrame</span><span class="params">(id&lt;MTLCommandBuffer&gt; commandBuffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        [commandBuffer encodeWaitForEvent:m_event value:m_eventValue++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartUI</span><span class="params">(id&lt;MTLCommandBuffer&gt; commandBuffer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(m_uiCallback == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span>(!m_renderingUI)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CopyTexture</span>(commandBuffer, m_interpolationInputs[m_inputIndex], m_backBuffers[m_bufferIndex], @<span class="string">&quot;Copy HUDLESS&quot;</span>);</span><br><span class="line">            m_renderingUI = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Present</span><span class="params">(id&lt;MTLFXFrameInterpolator&gt; frameInterpolator, id&lt;MTLCommandQueue&gt; queue)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">id&lt;MTLTexture&gt; <span class="title">GetBackBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_backBuffers[m_bufferIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, MTLPixelFormat pixelFormat)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrainPendingPresents</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(m_presentsPending)</span><br><span class="line">            m_scheduleCV.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">UICallbackEnabled</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_uiCallback != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUICallback</span><span class="params">(std::function&lt;<span class="type">void</span>(id&lt;MTLRenderCommandEncoder&gt;)&gt; callback)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_uiCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PresentThread::<span class="built_in">PresentThread</span>(<span class="type">float</span> minDuration, CAMetalLayer *metalLayer)</span><br><span class="line">    : <span class="built_in">m_encodingThread</span>(&amp;PresentThread::PresentThreadFunction, <span class="keyword">this</span>)</span><br><span class="line">    , <span class="built_in">m_pacingThread</span>(&amp;PresentThread::PacingThreadFunction, <span class="keyword">this</span>)</span><br><span class="line">    , <span class="built_in">m_minDuration</span>(minDuration)</span><br><span class="line">    , <span class="built_in">m_numQueued</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">m_metalLayer</span>(metalLayer)</span><br><span class="line">    , <span class="built_in">m_inputIndex</span>(<span class="number">0u</span>)</span><br><span class="line">    , <span class="built_in">m_bufferIndex</span>(<span class="number">0u</span>)</span><br><span class="line">    , <span class="built_in">m_renderingUI</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_presentsPending</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_framesInFlight</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">m_paceCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">m_eventValue</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    id&lt;MTLDevice&gt; device = metalLayer.device;</span><br><span class="line">    m_presentQueue = [device newCommandQueue];</span><br><span class="line">    m_presentQueue.label = @<span class="string">&quot;presentQ&quot;</span>;</span><br><span class="line">    m_timerQueue = <span class="built_in">kqueue</span>();</span><br><span class="line">    </span><br><span class="line">    metalLayer.maximumDrawableCount = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Resize</span>(metalLayer.drawableSize.width, metalLayer.drawableSize.height, metalLayer.pixelFormat);</span><br><span class="line">    </span><br><span class="line">    m_event = [device newEvent];</span><br><span class="line">    m_paceEvent = [device newSharedEvent];</span><br><span class="line">m_paceEvent2 = [device newSharedEvent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PresentThread::Present</span><span class="params">(id&lt;MTLFXFrameInterpolator&gt; frameInterpolator, id&lt;MTLCommandQueue&gt; queue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id&lt;MTLCommandBuffer&gt; commandBuffer = [queue commandBuffer];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_renderingUI)</span><br><span class="line">    &#123;</span><br><span class="line">        frameInterpolator.colorTexture = m_interpolationInputs[m_inputIndex];</span><br><span class="line">        frameInterpolator.prevColorTexture = m_interpolationInputs[m_inputIndex^<span class="number">1</span>];</span><br><span class="line">        frameInterpolator.uiTexture = m_backBuffers[m_bufferIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        frameInterpolator.colorTexture = m_backBuffers[m_bufferIndex];</span><br><span class="line">        frameInterpolator.prevColorTexture = m_backBuffers[(m_bufferIndex + kNumBuffers - <span class="number">1</span>) % kNumBuffers];</span><br><span class="line">        frameInterpolator.uiTexture = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    frameInterpolator.outputTexture = m_interpolationOutputs[m_bufferIndex];</span><br><span class="line"></span><br><span class="line">    [frameInterpolator encodeToCommandBuffer:commandBuffer];</span><br><span class="line">    [commandBuffer addCompletedHandler:^(id&lt;MTLCommandBuffer&gt; _Nonnull) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_framesInFlight--;</span><br><span class="line">        m_scheduleCV.<span class="built_in">notify_one</span>();</span><br><span class="line">        m_paceCount++;</span><br><span class="line">        m_pacingCV.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;];</span><br><span class="line">    [commandBuffer encodeSignalEvent:m_event value:m_eventValue++];</span><br><span class="line">    [commandBuffer commit];</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_framesInFlight++;</span><br><span class="line">    m_numQueued++;</span><br><span class="line">    m_presentsPending = <span class="literal">true</span>;</span><br><span class="line">    m_threadCV.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">while</span>((m_framesInFlight &gt;= <span class="number">2</span>) || (m_numQueued &gt;= <span class="number">2</span>))</span><br><span class="line">        m_scheduleCV.<span class="built_in">wait</span>(lock);</span><br><span class="line"></span><br><span class="line">    m_bufferIndex = (m_bufferIndex + <span class="number">1</span>) % kNumBuffers;</span><br><span class="line">    m_inputIndex = m_inputIndex^<span class="number">1u</span>;</span><br><span class="line">    m_renderingUI = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PresentThread::CopyTexture</span><span class="params">(id&lt;MTLCommandBuffer&gt; commandBuffer, id&lt;MTLTexture&gt; dest, id&lt;MTLTexture&gt; src, NSString *label)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MTLRenderPassDescriptor *desc = [MTLRenderPassDescriptor <span class="keyword">new</span>];</span><br><span class="line">    desc.colorAttachments[<span class="number">0</span>].texture = dest;</span><br><span class="line">    desc.colorAttachments[<span class="number">0</span>].loadAction = MTLLoadActionDontCare;</span><br><span class="line">    desc.colorAttachments[<span class="number">0</span>].storeAction = MTLStoreActionStore;</span><br><span class="line">    id&lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:desc];</span><br><span class="line">    [renderEncoder setFragmentTexture:src atIndex:<span class="number">0</span>];</span><br><span class="line">    [renderEncoder setRenderPipelineState:m_copyPipeline];</span><br><span class="line">    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:<span class="number">0</span> vertexCount:<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(m_uiCallback)</span><br><span class="line">        <span class="built_in">m_uiCallback</span>(renderEncoder);</span><br><span class="line">    renderEncoder.label = label;</span><br><span class="line">    [renderEncoder endEncoding];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PresentThread::PacingThreadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NSThread *thread = [NSThread currentThread];</span><br><span class="line">    [thread setName:@<span class="string">&quot;PacingThread&quot;</span>];</span><br><span class="line">    [thread setQualityOfService:NSQualityOfServiceUserInteractive];</span><br><span class="line">    [thread setThreadPriority:<span class="number">1.f</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">mach_timebase_info_data_t</span> info;</span><br><span class="line">    <span class="built_in">mach_timebase_info</span>(&amp;info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// maximum delta (0.1ms) in machtime units</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> maxDeltaInNanoSecs = <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> maxDelta = maxDeltaInNanoSecs * info.denom / info.numer;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> time = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> paceEventValue = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(m_paceCount == <span class="number">0</span>)</span><br><span class="line">            m_pacingCV.<span class="built_in">wait</span>(lock);</span><br><span class="line">        m_paceCount--;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// we get signal...</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> prevTime = time;</span><br><span class="line">        time = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">m_paceEvent.signaledValue = ++paceEventValue;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> delta = std::<span class="built_in">min</span>(time - prevTime, maxDelta);</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> timeStamp = time + ((delta*<span class="number">31</span>)&gt;&gt;<span class="number">6</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">kevent64_s</span> timerEvent, eventOut;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> timeout;</span><br><span class="line">        timeout.tv_nsec = maxDeltaInNanoSecs;</span><br><span class="line">        timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">EV_SET64</span>(&amp;timerEvent,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 EVFILT_TIMER,</span><br><span class="line">                 EV_ADD | EV_ONESHOT | EV_ENABLE,</span><br><span class="line">                 NOTE_CRITICAL | NOTE_LEEWAY | NOTE_MACHTIME | NOTE_ABSOLUTE,</span><br><span class="line">                 timeStamp,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">kevent64</span>(m_timerQueue, &amp;timerEvent, <span class="number">1</span>, &amp;eventOut, <span class="number">1</span>, <span class="number">0</span>, &amp;timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// main screen turn on...</span></span><br><span class="line">        m_paceEvent<span class="number">2.</span>signaledValue = ++paceEventValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PresentThread::PresentThreadFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NSThread *thread = [NSThread currentThread];</span><br><span class="line">    [thread setName:@<span class="string">&quot;PresentThread&quot;</span>];</span><br><span class="line">    [thread setQualityOfService:NSQualityOfServiceUserInteractive];</span><br><span class="line">    [thread setThreadPriority:<span class="number">1.f</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> eventValue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> bufferIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> paceEventValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_numQueued == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_presentsPending = <span class="literal">false</span>;</span><br><span class="line">            m_scheduleCV.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m_numQueued == <span class="number">0</span>)</span><br><span class="line">            m_threadCV.<span class="built_in">wait</span>(lock);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m_numQueued &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        @autoreleasepool</span><br><span class="line">        &#123;</span><br><span class="line">            id&lt;CAMetalDrawable&gt; drawable = [m_metalLayer nextDrawable];</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line">m_numQueued--;</span><br><span class="line">m_scheduleCV.<span class="built_in">notify_one</span>();</span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">            id&lt;MTLCommandBuffer&gt; commandBuffer = [m_presentQueue commandBuffer];</span><br><span class="line">            [commandBuffer encodeWaitForEvent:m_event value:++eventValue];</span><br><span class="line">            <span class="built_in">CopyTexture</span>(commandBuffer, drawable.texture, m_interpolationOutputs[bufferIndex], @<span class="string">&quot;Copy Interpolated&quot;</span>);</span><br><span class="line">            [commandBuffer encodeSignalEvent:m_event value:++eventValue];</span><br><span class="line">[commandBuffer encodeWaitForEvent:m_paceEvent value:++paceEventValue];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m_minDuration &gt; <span class="number">0.f</span>)</span><br><span class="line">                [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                [commandBuffer presentDrawable:drawable];</span><br><span class="line">            [commandBuffer commit];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool</span><br><span class="line">        &#123;</span><br><span class="line">            id&lt;MTLCommandBuffer&gt; commandBuffer = [m_presentQueue commandBuffer];</span><br><span class="line">            id&lt;CAMetalDrawable&gt; drawable = [m_metalLayer nextDrawable];</span><br><span class="line">            <span class="built_in">CopyTexture</span>(commandBuffer, drawable.texture, m_backBuffers[bufferIndex], @<span class="string">&quot;Copy Rendered&quot;</span>);</span><br><span class="line">[commandBuffer encodeWaitForEvent:m_paceEvent2 value:++paceEventValue];</span><br><span class="line">            <span class="keyword">if</span>(m_minDuration &gt; <span class="number">0.f</span>)</span><br><span class="line">                [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                [commandBuffer presentDrawable:drawable];</span><br><span class="line">            [commandBuffer commit];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        bufferIndex = (bufferIndex + <span class="number">1</span>) % kNumBuffers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PresentThread::Resize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, MTLPixelFormat pixelFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((m_width != width) || (m_height != height) || (m_pixelFormat != pixelFormat))</span><br><span class="line">    &#123;</span><br><span class="line">        id&lt;MTLDevice&gt; device = m_metalLayer.device;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_pixelFormat != pixelFormat)</span><br><span class="line">        &#123;</span><br><span class="line">            id&lt;MTLLibrary&gt; lib = [device newDefaultLibrary];</span><br><span class="line">            MTLRenderPipelineDescriptor *pipelineDesc = [MTLRenderPipelineDescriptor <span class="keyword">new</span>];</span><br><span class="line">            pipelineDesc.vertexFunction = [lib newFunctionWithName:@<span class="string">&quot;FSQ_VS_V4T2&quot;</span>];</span><br><span class="line">            pipelineDesc.fragmentFunction = [lib newFunctionWithName:@<span class="string">&quot;FSQ_simpleCopy&quot;</span>];</span><br><span class="line">            pipelineDesc.colorAttachments[<span class="number">0</span>].pixelFormat = pixelFormat;</span><br><span class="line">            m_copyPipeline = [device newRenderPipelineStateWithDescriptor:pipelineDesc error:nil];</span><br><span class="line">            m_pixelFormat = pixelFormat;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">DrainPendingPresents</span>();</span><br><span class="line">        </span><br><span class="line">        m_width = width;</span><br><span class="line">m_height = height;</span><br><span class="line">        </span><br><span class="line">        MTLTextureDescriptor *texDesc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat width:width height:height mipmapped:NO];</span><br><span class="line">texDesc.storageMode = MTLStorageModePrivate;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; kNumBuffers; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageShaderWrite|MTLTextureUsageRenderTarget;</span><br><span class="line">            m_backBuffers[i] = [device newTextureWithDescriptor:texDesc];</span><br><span class="line">            texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget;</span><br><span class="line">            m_interpolationOutputs[i] = [device newTextureWithDescriptor:texDesc];</span><br><span class="line">        &#125;</span><br><span class="line">        texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget;</span><br><span class="line">        m_interpolationInputs[<span class="number">0</span>] = [device newTextureWithDescriptor:texDesc];</span><br><span class="line">        m_interpolationInputs[<span class="number">1</span>] = [device newTextureWithDescriptor:texDesc];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正确的帧节奏表现为平坦的线或规律的重复模式，具体取决于目标刷新率。</p><h2 id="使用-Metal-4-追踪光线"><a href="#使用-Metal-4-追踪光线" class="headerlink" title="使用 Metal 4 追踪光线"></a>使用 Metal 4 追踪光线</h2><p>光线追踪技术在高端渲染场景中越来越普及，Metal 4 提供了多项新功能来简化光线追踪的实现和优化。</p><h3 id="交集函数缓冲区"><a href="#交集函数缓冲区" class="headerlink" title="交集函数缓冲区"></a>交集函数缓冲区</h3><p>交集函数缓冲区是一个包含指向场景交集函数句柄的参数缓冲区，允许开发者轻松管理多个交集函数。通过在实例和几何级别设置交集函数表偏移，可以灵活地定义每个几何体的交集行为。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主机端几何描述符上设置交集函数表偏移</span></span><br><span class="line"><span class="type">NSMutableArray</span>&lt;<span class="type">MTLAccelerationStructureGeometryDescriptor</span> *&gt; <span class="operator">*</span>geomDescs <span class="operator">...</span>;</span><br><span class="line"><span class="keyword">for</span> (auto g <span class="operator">=</span> <span class="number">0</span>; g <span class="operator">&lt;</span> geomList.size(); <span class="operator">++</span>g)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">MTLAccelerationStructureGeometryDescriptor</span> <span class="operator">*</span>descriptor <span class="operator">=</span> <span class="operator">...</span>;</span><br><span class="line">    descriptor.intersectionFunctionTableOffset <span class="operator">=</span> g;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    [geomDescs addObject:descriptor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加速结构构建优化"><a href="#加速结构构建优化" class="headerlink" title="加速结构构建优化"></a>加速结构构建优化</h3><p>Metal 4 提供了更多控制加速结构构建的选项，包括快速交集和最小化内存使用。这些选项可以通过标志按需设置，以满足不同场景的需求。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光线追踪交集函数缓冲区</span></span><br><span class="line">intersection_function_buffer_arguments ifb_arguments;</span><br><span class="line">ifb_arguments.intersection_function_buffer <span class="operator">=</span> raytracingResources.ifbBuffer;</span><br><span class="line">ifb_arguments.intersection_function_buffer_size <span class="operator">=</span> raytracingResources.ifbBufferSize;</span><br><span class="line">ifb_arguments.intersection_function_stride <span class="operator">=</span> raytracingResources.ifbBufferStride;</span><br><span class="line"></span><br><span class="line">metal::raytracing::ray r <span class="operator">=</span> &#123; origin, direction &#125;;</span><br><span class="line">auto result <span class="operator">=</span> trace.intersect(r, ads, ifb_arguments);</span><br></pre></td></tr></table></figure><h2 id="在放大时去噪"><a href="#在放大时去噪" class="headerlink" title="在放大时去噪"></a>在放大时去噪</h2><p>实时光线追踪的应用范围不断扩大，从混合光线追踪到复杂的路径追踪都得到了广泛应用。然而，光线追踪的性能和质量权衡始终是一个挑战。MetalFX 去噪放大器结合了去噪和放大功能，能够显著简化渲染管线的实现。</p><h3 id="去噪放大器集成"><a href="#去噪放大器集成" class="headerlink" title="去噪放大器集成"></a>去噪放大器集成</h3><p>去噪放大器的集成非常简单，只需在典型的时间放大器基础上添加额外的输入纹理，包括法线、漫反射反照率、粗糙度和镜面反照率。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置去噪放大器的输入纹理</span></span><br><span class="line">denoisingUpscaler.normalTexture <span class="operator">=</span> normalTexture;</span><br><span class="line">denoisingUpscaler.albedoTexture <span class="operator">=</span> albedoTexture;</span><br><span class="line">denoisingUpscaler.roughnessTexture <span class="operator">=</span> roughnessTexture;</span><br><span class="line">denoisingUpscaler.specularTexture <span class="operator">=</span> specularTexture;</span><br></pre></td></tr></table></figure><h3 id="提高质量的技巧"><a href="#提高质量的技巧" class="headerlink" title="提高质量的技巧"></a>提高质量的技巧</h3><p>去噪放大器的效果可以通过一些可选输入进一步提升，例如镜面命中距离、去噪强度掩码和透明度叠加。同时，需要注意避免输入过于嘈杂的问题，建议采用先进的采样技术，如重要性采样和下一次事件估计。</p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>Metal 4 和 MetalFX 的新功能为开发者提供了强大的工具，用以优化游戏性能和提升视觉效果。无论是通过帧插值实现更高的刷新率，还是通过去噪放大器减少光线预算，这些技术都能显著改善玩家的体验。如果你尚未开始使用 MetalFX 放大器，这是一个值得尝试的机会。</p><p>相关视频<br><a href="https://developer.apple.com/videos/play/wwdc2025/205">探索 Metal 4</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/254">探索 Metal 4 游戏</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/294">用于打造沉浸式 App 的 Metal 渲染的新功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10128">Metal 光线追踪指南</a><br><a href="https://developer.apple.com/videos/play/wwdc2022/10103">利用 MetalFX Upscaling 提升性能</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入了解 metal 4 的最新改进。我们将介绍全新光线追踪功能，助你将复杂度极高且视觉效果丰富的工作负载成功移植到 apple 芯片上。了解 metalfx 如何通过渲染画质提升、帧插值和场景去噪来扩展工作负载。&lt;/p&gt;
&lt;p&gt;为了充分从这个讲座中获益，我们建议你先观看“探索 metal 4”和“探索 metal 4 游戏”。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="图形和游戏" scheme="http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Platforms State of the Union</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_102/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_102/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.309Z</updated>
    
    <content type="html"><![CDATA[<p>深入了解 apple 平台上的最新进展。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/10371/10371_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/102/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="2025年Apple平台发展现状：Liquid-Glass设计与智能体验革新"><a href="#2025年Apple平台发展现状：Liquid-Glass设计与智能体验革新" class="headerlink" title="2025年Apple平台发展现状：Liquid Glass设计与智能体验革新"></a>2025年Apple平台发展现状：Liquid Glass设计与智能体验革新</h1><p>Apple在2025年WWDC大会上公布了平台发展现状，全面展示了硬件、软件和技术生态的最新进展，为开发者提供了丰富的工具和API来打造更卓越的应用体验。</p><h2 id="Apple芯片的强劲动力"><a href="#Apple芯片的强劲动力" class="headerlink" title="Apple芯片的强劲动力"></a>Apple芯片的强劲动力</h2><p>Apple芯片为所有平台带来了突破性的性能表现，具备以下关键特性：</p><ul><li>前所未有的性能与能效平衡</li><li>统一内存架构最大化硬件潜力</li><li>专用加速器优化视频处理与机器学习任务</li><li>安全隔离区确保系统完整性</li></ul><h2 id="软件技术生态"><a href="#软件技术生态" class="headerlink" title="软件技术生态"></a>软件技术生态</h2><p>这些强大的硬件基础支撑着Apple的软件技术栈：</p><ul><li><strong>Metal</strong>：底层API套件释放硬件全部潜能</li><li><strong>Apple智能</strong>：整合生成式模型与隐私保护功能</li><li><strong>Swift</strong>：提供系统级性能与安全性</li><li><strong>SwiftUI</strong>：助力构建丰富交互和自适应设计</li></ul><p>平台还深度整合了：</p><ul><li>隐私保护技术</li><li>无障碍功能</li><li>国际化支持</li></ul><h2 id="全新的Liquid-Glass设计"><a href="#全新的Liquid-Glass设计" class="headerlink" title="全新的Liquid Glass设计"></a>全新的Liquid Glass设计</h2><p>今年Apple推出了标志性的设计革新——Liquid Glass，开启了软件设计新纪元。这一设计理念融合了玻璃的光学特性与流体的灵动质感，将UI体验提升到新高度。</p><h3 id="设计三大目标"><a href="#设计三大目标" class="headerlink" title="设计三大目标"></a>设计三大目标</h3><ol><li><strong>优化核心内容体验</strong>：创造沉浸式的阅读、创作和观看体验</li><li><strong>统一设计语言</strong>：保持跨平台一致性同时保留产品个性</li><li><strong>创新交互设计</strong>：利用硬件技术进步打造新颖交互</li></ol><h3 id="三大指导原则"><a href="#三大指导原则" class="headerlink" title="三大指导原则"></a>三大指导原则</h3><ol><li><p><strong>层次感建立</strong></p><ul><li>控件和导航悬浮于应用上方</li><li>矩形元素适配设备圆角</li><li>内容可延伸至屏幕边缘</li><li>颜色智能调整</li></ul></li><li><p><strong>协调感营造</strong></p><ul><li>优化UI元素适应现代设备</li><li>新圆角符合手指几何形状</li><li>全面更新字体排版</li><li>组件形状更柔和</li></ul></li><li><p><strong>一致性保持</strong></p><ul><li>跨平台统一设计语言</li><li>macOS与iOS/iPadOS更协调</li><li>watchOS突出内容显示</li></ul></li></ol><h3 id="实现路径"><a href="#实现路径" class="headerlink" title="实现路径"></a>实现路径</h3><p>开发者可通过三个步骤实现Liquid Glass设计：</p><ol><li>用新版SDK重新编译应用</li><li>使用新API优化初始效果</li><li>运用Liquid Glass效果更新自定义视图</li></ol><p>常见视图会自动获得新设计：</p><ul><li>TabView呈现Liquid Glass标签栏</li><li>NavigationSplitView显示Liquid Glass边栏</li><li>工具栏项置于玻璃体中</li><li>菜单和弹出窗口自动变形</li></ul><p>新增API提供更多控制选项：</p><ul><li>工具栏项目分组和风格调整</li><li>ToolbarSpacer创建额外分组</li><li>为关键操作设置醒目风格</li><li>TabView底部自定义配件</li><li>搜索功能全面革新</li></ul><h2 id="应用图标革新"><a href="#应用图标革新" class="headerlink" title="应用图标革新"></a>应用图标革新</h2><p>Liquid Glass也为应用图标带来全新表现力：</p><ul><li>经典全色模式</li><li>更丰富的着色模式</li><li>全新透明模式</li></ul><p>Icon Composer新工具简化图标创作流程，支持：</p><ul><li>矢量内容导入</li><li>多种渲染模式</li><li>模糊和透明度效果</li><li>高光效果测试</li><li>单一源文件生成</li></ul><h2 id="Apple智能体验"><a href="#Apple智能体验" class="headerlink" title="Apple智能体验"></a>Apple智能体验</h2><p>Apple将AI和机器学习能力深度整合到所有平台中，提供：</p><ul><li>写作工具</li><li>智绘表情</li><li>图乐园</li></ul><h3 id="Foundation-Models框架"><a href="#Foundation-Models框架" class="headerlink" title="Foundation Models框架"></a>Foundation Models框架</h3><p>这一新框架让每个应用都能使用设备端基础模型，特点包括：</p><ul><li>隐私保护(数据永不离开设备)</li><li>离线可用</li><li>无需账户或API密钥</li></ul><p>仅需三行代码即可使用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FoundationModels</span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">LLMSession</span>()</span><br><span class="line"><span class="keyword">let</span> response <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> session.respond(to: <span class="string">&quot;提示文本&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>引导式生成功能让模型输出结构化数据，简化应用集成流程。</p><h3 id="机器学习增强"><a href="#机器学习增强" class="headerlink" title="机器学习增强"></a>机器学习增强</h3><p>所有机器学习API和工具都得到增强：</p><ul><li>语音API更新</li><li>Core ML优化性能</li><li>MLX开源库训练模型</li><li>App Intents提升功能可见性</li></ul><h2 id="开发者工具革新"><a href="#开发者工具革新" class="headerlink" title="开发者工具革新"></a>开发者工具革新</h2><h3 id="Xcode-26亮点"><a href="#Xcode-26亮点" class="headerlink" title="Xcode 26亮点"></a>Xcode 26亮点</h3><ul><li>预测代码补全增强</li><li>整合ChatGPT(与OpenAI合作)</li><li>编码助理快速实现功能</li><li>历史记录滑块回溯更改</li><li>性能工具定位瓶颈</li></ul><h3 id="Swift-6-2新功能"><a href="#Swift-6-2新功能" class="headerlink" title="Swift 6.2新功能"></a>Swift 6.2新功能</h3><ul><li>内联数组提升性能</li><li>span类型安全访问内存</li><li>增强C++互操作性</li><li>WebAssembly支持</li><li>简化单线程代码编写</li></ul><h3 id="Containerization新框架"><a href="#Containerization新框架" class="headerlink" title="Containerization新框架"></a>Containerization新框架</h3><p>简化服务器开发：</p><ul><li>本地创建和运行Linux容器</li><li>基于Apple芯片优化</li><li>开源提供</li></ul><h2 id="框架增强"><a href="#框架增强" class="headerlink" title="框架增强"></a>框架增强</h2><h3 id="SwiftUI增强"><a href="#SwiftUI增强" class="headerlink" title="SwiftUI增强"></a>SwiftUI增强</h3><ul><li>全新Web API</li><li>富文本编辑器支持</li><li>3D图表</li><li>性能大幅提升</li><li>更灵活的SwiftData</li></ul><h3 id="visionOS-26新功能"><a href="#visionOS-26新功能" class="headerlink" title="visionOS 26新功能"></a>visionOS 26新功能</h3><ul><li>视体API</li><li>共享体验增强</li><li>沉浸式媒体工具</li><li>企业功能</li><li>SwiftUI空间布局改进</li></ul><h3 id="游戏开发更新"><a href="#游戏开发更新" class="headerlink" title="游戏开发更新"></a>游戏开发更新</h3><ul><li>Metal 4支持神经网络渲染</li><li>游戏移植工具包增强</li><li>输入系统升级</li><li>GameSave云存档</li><li>低功耗模式优化</li></ul><h2 id="其他重要更新"><a href="#其他重要更新" class="headerlink" title="其他重要更新"></a>其他重要更新</h2><ul><li>iPad菜单栏支持</li><li>后台任务API增强</li><li>CarPlay实时活动</li><li>终端新外观</li><li>HTML 3D模型元素</li><li>企业visionOS功能</li></ul><p>值得注意的是，macOS Tahoe将是最后一个支持Intel的版本，Apple鼓励开发者完成向Apple芯片的迁移。</p><p>Apple准备了100多场深度讲座，开发者可通过实验室和开发者论坛获取更多信息。这些全面的平台革新为开发者提供了前所未有的机遇，期待看到开发社区创造出更多创新应用。</p><p>相关视频：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2025/101/">WWDC 2025 Keynote</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/102/">Introducing Liquid Glass Design</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/103/">Foundation Models Framework</a></li></ul><p>文档：</p><ul><li><a href="https://developer.apple.com/design/human-interface-guidelines/liquid-glass">Liquid Glass Design Guidelines</a></li><li><a href="https://developer.apple.com/documentation/foundationmodels">Foundation Models API Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入了解 apple 平台上的最新进展。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="技术介绍与最佳做法" scheme="http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>了解 ManagedApp 框架</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_203/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_203/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.103Z</updated>
    
    <content type="html"><![CDATA[<p>了解 managedapp 框架如何帮助你的 app 适应受管理环境。我们将介绍如何接收配置数据、如何安全地管理 app 密钥，以及如何根据组织提供的设置来定制 app 的行为。我们还将通过一些真实示例来说明如何为企业和教育环境打造更灵活、更易于管理的 app。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9876/9876_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/203/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="ManagedApp框架：打造无缝的企业级应用体验"><a href="#ManagedApp框架：打造无缝的企业级应用体验" class="headerlink" title="ManagedApp框架：打造无缝的企业级应用体验"></a>ManagedApp框架：打造无缝的企业级应用体验</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在当今企业IT环境中，Apple设备的普及率持续攀升，从办公室到教室，从零售店到创意工作室，这些设备正成为生产力工具的重要组成部分。然而，企业级应用的管理和部署过程往往充满挑战——复杂的初始配置、安全凭证分发、组织定制化需求等因素都可能导致用户体验下降。为应对这些挑战，Apple推出了ManagedApp框架，旨在为企业与教育机构提供更安全、更易用的应用管理解决方案。</p><h2 id="ManagedApp框架概述"><a href="#ManagedApp框架概述" class="headerlink" title="ManagedApp框架概述"></a>ManagedApp框架概述</h2><h3 id="框架定位与优势"><a href="#框架定位与优势" class="headerlink" title="框架定位与优势"></a>框架定位与优势</h3><p>ManagedApp框架是一个专为受管理环境设计的自动化配置系统，它允许管理员预先配置应用及其扩展，无需用户手动设置即可直接使用。该框架的核心价值在于：</p><ol><li><strong>消除复杂设置流程</strong>：应用从首次启动即可直接使用，提升用户采纳率</li><li><strong>降低支持成本</strong>：减少因配置错误导致的技术支持请求</li><li><strong>安全分发凭证</strong>：保护组织敏感数据免受泄露风险</li><li><strong>灵活定制</strong>：允许开发者定义自己的配置规范</li></ol><h3 id="技术基础与兼容性"><a href="#技术基础与兼容性" class="headerlink" title="技术基础与兼容性"></a>技术基础与兼容性</h3><p>该框架要求iOS 18.4、iPadOS 18.4和VisionOS 2.4及以上版本，并需要MDM服务器使用声明式设备管理来管理应用。它支持：</p><ul><li>所有MDM注册类型</li><li>绝大多数应用扩展类型</li><li>从应用安装或接管时开始工作</li><li>运行时配置更新通知</li></ul><h2 id="核心功能解析"><a href="#核心功能解析" class="headerlink" title="核心功能解析"></a>核心功能解析</h2><h3 id="数据类型支持"><a href="#数据类型支持" class="headerlink" title="数据类型支持"></a>数据类型支持</h3><p>ManagedApp框架提供四类关键数据：</p><ol><li><strong>应用特定配置</strong>：开发者自定义的任意数据结构（设置、选项、小型资源文件）</li><li><strong>密码</strong>：安全存储的字符串凭证</li><li><strong>证书</strong>：用于安全通信的加密材料</li><li><strong>身份凭证</strong>：包括PKCS #12文件、SCEP身份或ACME身份（支持硬件绑定密钥）</li></ol><h3 id="系统架构与流程"><a href="#系统架构与流程" class="headerlink" title="系统架构与流程"></a>系统架构与流程</h3><p>系统工作流程分为三个主要阶段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 管理员通过MDM服务器发送管理命令和配置数据</span><br><span class="line">2. 设备安全存储配置和机密数据</span><br><span class="line">3. 应用启动时请求数据并立即应用配置</span><br></pre></td></tr></table></figure></p><p>当配置更新时，框架会主动通知正在运行的应用，确保变更及时生效。</p><h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><h3 id="许可管理优化"><a href="#许可管理优化" class="headerlink" title="许可管理优化"></a>许可管理优化</h3><p>传统许可令牌方案存在安全风险，ManagedApp框架提供了更安全的解决方案：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用硬件绑定密钥替代传统令牌</span></span><br><span class="line"><span class="keyword">let</span> provider <span class="operator">=</span> <span class="type">ManagedAppIdentitiesProvider</span>()</span><br><span class="line"><span class="keyword">let</span> identity <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> provider.identity(for: <span class="string">&quot;license_auth&quot;</span>)</span><br></pre></td></tr></table></figure><p>优势对比：</p><ul><li>传统令牌：存储在文件系统，可能被提取</li><li>框架方案：私钥设备生成永不移动，支持硬件绑定</li></ul><h3 id="VPN扩展安全"><a href="#VPN扩展安全" class="headerlink" title="VPN扩展安全"></a>VPN扩展安全</h3><p>框架为VPN扩展提供了企业级安全认证能力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取VPN专用身份凭证</span></span><br><span class="line"><span class="keyword">let</span> vpnIdentity <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">ManagedAppIdentitiesProvider</span>()</span><br><span class="line">    .identity(for: <span class="string">&quot;org_vpn_auth&quot;</span>)</span><br></pre></td></tr></table></figure><p>该方案支持硬件绑定密钥和受管理设备证明，解决了VPN管理员最关心的认证安全问题。</p><h3 id="身份提供商集成"><a href="#身份提供商集成" class="headerlink" title="身份提供商集成"></a>身份提供商集成</h3><p>与可扩展单点登录(SSO)结合时，框架支持多种认证材料：</p><ul><li>硬件绑定身份</li><li>临时密码</li><li>组织绑定令牌</li><li>注册期间可用配置</li></ul><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><h3 id="配置接收与处理"><a href="#配置接收与处理" class="headerlink" title="配置接收与处理"></a>配置接收与处理</h3><p>以教学用Landmarks应用为例，展示配置处理流程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LandmarksManagedConfig</span>: <span class="title class_ inherited__">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> managedCollection: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> assetURL: <span class="type">URL</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> managedCollection <span class="operator">=</span> <span class="string">&quot;managed_collection&quot;</span></span><br><span class="line">        <span class="keyword">case</span> assetURL <span class="operator">=</span> <span class="string">&quot;asset_url&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> config <span class="keyword">in</span> <span class="type">ManagedAppConfigurationProvider</span>().configurations(</span><br><span class="line">        of: <span class="type">LandmarksManagedConfig</span>.<span class="keyword">self</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        modelData.managedCollection <span class="operator">=</span> config<span class="operator">?</span>.managedCollection</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键实现要点：</p><ul><li>定义符合Decodable的配置结构体</li><li>使用Swift并发接收异步配置更新</li><li>自动响应配置变更</li></ul><h3 id="身份凭证使用"><a href="#身份凭证使用" class="headerlink" title="身份凭证使用"></a>身份凭证使用</h3><p>实现mTLS连接时的身份获取：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identityProvider <span class="operator">=</span> <span class="type">ManagedAppIdentitiesProvider</span>()</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> identity <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> identityProvider.identity(for: <span class="string">&quot;asset_server_auth&quot;</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理无凭证情况</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SecIdentity建立安全连接</span></span><br><span class="line"><span class="keyword">let</span> credential <span class="operator">=</span> <span class="type">URLCredential</span>(identity: identity, certificates: <span class="literal">nil</span>, persistence: .forSession)</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><ol><li><strong>数据规模控制</strong>：配置数据保持KB级，大资源通过URL引用</li><li><strong>安全编程</strong>：机密数据用后即弃，每次重新获取</li><li><strong>配置设计</strong>：避免”万能开关”，提供细致控制项</li><li><strong>兼容性考虑</strong>：解码器应忽略未知键，支持渐进升级</li></ol><h3 id="迁移与审核"><a href="#迁移与审核" class="headerlink" title="迁移与审核"></a>迁移与审核</h3><p>对于使用旧版managed app configuration的应用：</p><ul><li>过渡期可双方案并行</li><li>优先采用ManagedApp框架</li><li>逐步淘汰旧实现</li></ul><p>App Store审核注意事项：</p><ul><li>提供演示模式或功能视频</li><li>在审核备注中说明管理配置方法</li><li>确保核心功能可被验证</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ManagedApp框架代表了企业应用管理的重要进化，它赋予开发者构建”零配置”体验的能力，同时满足组织级安全要求。通过灵活的配置机制和安全的凭证分发，该框架有望显著提升管理效率和使用体验。开发者应评估现有企业应用的配置方案，考虑迁移到ManagedApp框架以获取其安全与管理优势。</p><p>随着企业移动生态的持续发展，ManagedApp框架将帮助开发者创造更无缝、更安全的管理应用体验，最终实现用户满意度和IT管理效率的双赢。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2025/258">Apple 设备管理和身份管理方面的新动向</a></p><h1 id="文档资源"><a href="#文档资源" class="headerlink" title="文档资源"></a>文档资源</h1><p><a href="https://support.apple.com/guide/apple-school-manager/">Apple School Manager用户指南</a><br><a href="https://developer.apple.com/documentation/ManagedApp">ManagedApp框架文档</a><br><a href="https://support.apple.com/guide/deployment/welcome/">Apple平台部署支持</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 managedapp 框架如何帮助你的 app 适应受管理环境。我们将介绍如何接收配置数据、如何安全地管理 app 密钥，以及如何根据组织提供的设置来定制 app 的行为。我们还将通过一些真实示例来说明如何为企业和教育环境打造更灵活、更易于管理的 app。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="商务-&amp;-教育" scheme="http://djs66256.github.io/tags/%E5%95%86%E5%8A%A1-%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>Platforms State of the Union (ASL)</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_112/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_112/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.349Z</updated>
    
    <content type="html"><![CDATA[<p>深入了解 apple 平台上的最新进展。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/10372/10372_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/112/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="2025-年度苹果平台国情咨文：开发者全新机遇解析"><a href="#2025-年度苹果平台国情咨文：开发者全新机遇解析" class="headerlink" title="2025 年度苹果平台国情咨文：开发者全新机遇解析"></a>2025 年度苹果平台国情咨文：开发者全新机遇解析</h1><p>苹果在2025年度平台国情咨文中展示了一系列令人振奋的新技术、API和工具更新，为开发者提供了打造更卓越应用和游戏的全新可能性。本文将全面解析这些创新功能及其应用场景。</p><h2 id="革命性的液态玻璃设计语言"><a href="#革命性的液态玻璃设计语言" class="headerlink" title="革命性的液态玻璃设计语言"></a>革命性的液态玻璃设计语言</h2><p>苹果今年推出了全方位的设计革新，液态玻璃(Glassmorphism)成为这一代UI设计的核心特征。这种设计语言巧妙结合了玻璃光学特性和流体质感，通过镜面高光、折射和半透明效果，创造出前所未有的深度感和活力体验。</p><p>液态玻璃设计遵循三大原则：</p><ol><li>层次感构建：控件和导航栈悬浮显示，增加深度维度</li><li>协调感营造：元素形状与设备外形协调，提升一致性</li><li>跨平台一致性：确保用户在各个苹果设备上获得统一体验</li></ol><p>在具体实现上，开发者可以通过以下步骤轻松适配新设计：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用glassEffect修饰符实现液态玻璃效果</span></span><br><span class="line"><span class="type">Button</span>(action: &#123;&#125;) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;液态玻璃按钮&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.buttonStyle(.glass)</span><br><span class="line">.glassEffect()</span><br></pre></td></tr></table></figure></p><h2 id="Apple-Intelligence与设备端AI能力"><a href="#Apple-Intelligence与设备端AI能力" class="headerlink" title="Apple Intelligence与设备端AI能力"></a>Apple Intelligence与设备端AI能力</h2><p>苹果将生成式AI深度集成于操作系统中，推出了全新的Foundation Models框架。该框架让开发者能够轻松调用苹果优化的设备端基础模型，只需三行代码即可实现AI功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> model <span class="operator">=</span> <span class="type">FoundationModels</span>.shared.textGenerator</span><br><span class="line"><span class="keyword">let</span> prompt <span class="operator">=</span> <span class="string">&quot;写一篇关于苹果新技术的简短介绍&quot;</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> model.generateText(with: prompt)</span><br></pre></td></tr></table></figure><p>这项技术的亮点在于：</p><ul><li>完全设备端运行，确保用户隐私</li><li>无需API密钥或服务器配置</li><li>提供引导式生成功能，自动解析模型输出</li><li>支持工具调用，模型能识别需要额外信息的任务</li></ul><h2 id="Xcode-26与开发工具革新"><a href="#Xcode-26与开发工具革新" class="headerlink" title="Xcode 26与开发工具革新"></a>Xcode 26与开发工具革新</h2><p>Xcode 26引入了一系列提升开发效率的新功能：</p><ul><li>预测代码补全改进</li><li>ChatGPT集成，可直接在IDE中使用OpenAI模型</li><li>Coding Tools功能，可生成预览、文档或修复问题</li><li>Playground宏帮助探索非UI代码</li><li>历史记录滑块实现更改回溯</li></ul><p>演示代码展示了AI辅助开发的强大能力：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AI生成的统计视图代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StatisticsView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> model: <span class="type">DataModel</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;访问统计&quot;</span>)</span><br><span class="line">                .font(.title)</span><br><span class="line">            <span class="type">Chart</span>(model.visits) &#123; visit <span class="keyword">in</span></span><br><span class="line">                <span class="type">BarMark</span>(</span><br><span class="line">                    x: .value(<span class="string">&quot;日期&quot;</span>, visit.date),</span><br><span class="line">                    y: .value(<span class="string">&quot;访问量&quot;</span>, visit.count)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Swift-6-2与性能提升"><a href="#Swift-6-2与性能提升" class="headerlink" title="Swift 6.2与性能提升"></a>Swift 6.2与性能提升</h2><p>Swift语言迎来6.2版本，主要改进包括：</p><ul><li>内联数组和span类型，提升数据处理效率</li><li>增强的C++互操作性</li><li>WebAssembly官方工具链支持</li><li>并发模型改进，简化单线程代码编写</li><li>全新Containerization框架，简化服务器端开发</li></ul><h2 id="SwiftUI与visionOS增强功能"><a href="#SwiftUI与visionOS增强功能" class="headerlink" title="SwiftUI与visionOS增强功能"></a>SwiftUI与visionOS增强功能</h2><p>SwiftUI获得多项重大升级：</p><ul><li>强大的新Web API</li><li>富文本编辑支持</li><li>3D图表功能</li><li>列表加载速度提升6倍(macOS)</li><li>增量更改速度最高提升16倍</li></ul><p>visionOS 26的新特性包括：</p><ul><li>新的视图API和共享功能</li><li>沉浸式媒体工具</li><li>企业功能支持</li><li>附近窗口共享功能</li><li>ARKit共享现实场景锚点</li></ul><h2 id="Metal-4与游戏开发"><a href="#Metal-4与游戏开发" class="headerlink" title="Metal 4与游戏开发"></a>Metal 4与游戏开发</h2><p>游戏开发者将受益于Metal 4的先进功能：</p><ul><li>神经网络渲染支持</li><li>游戏移植工具包增强</li><li>PlayStation DualSense控制器支持</li><li>新的Touch Controller API</li><li>GameSave框架云存档功能</li></ul><p>特别值得注意的是，macOS Tahoe将是最后一个支持Intel Mac的版本，苹果强烈建议开发者尽快迁移到Apple芯片版本。</p><h2 id="其他重要更新"><a href="#其他重要更新" class="headerlink" title="其他重要更新"></a>其他重要更新</h2><p>平台国情咨文还提到了多项值得关注的改进：</p><ul><li>iPad菜单栏支持</li><li>iOS/iPadOS后台任务API增强</li><li>CarPlay实时活动功能</li><li>macOS终端新外观</li><li>HTML模型元素支持</li><li>视线滚动(Look to Scroll)功能</li><li>全新PermissionKit框架</li><li>App Store辅助功能展示区</li></ul><h2 id="开发者资源与展望"><a href="#开发者资源与展望" class="headerlink" title="开发者资源与展望"></a>开发者资源与展望</h2><p>苹果为这些新技术准备了100多场深度讲座，开发者可以通过实验室和开发者论坛获取更多支持。从液态玻璃设计到设备端AI，从Swift语言进化到Metal图形技术，2025年的苹果平台为开发者提供了前所未有的创新工具和可能性。</p><p>相关视频：</p><ul><li><a href="https://developer.apple.com/videos/glassmorphism">液态玻璃设计实践</a></li><li><a href="https://developer.apple.com/videos/foundation-models">Foundation Models框架详解</a></li><li><a href="https://developer.apple.com/videos/swift-6">Swift 6.2新特性</a></li></ul><p>文档：</p><ul><li><a href="https://developer.apple.com/design/human-interface-guidelines/glassmorphism">液态玻璃设计指南</a></li><li><a href="https://developer.apple.com/documentation/foundationmodels">Foundation Models API参考</a></li><li><a href="https://developer.apple.com/documentation/metal">Metal 4编程指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入了解 apple 平台上的最新进展。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="技术介绍与最佳做法" scheme="http://djs66256.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%81%9A%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入探索 MapKit</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_204/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_204/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.125Z</updated>
    
    <content type="html"><![CDATA[<p>了解 mapkit 和 mapkit js 的最新更新。我们将介绍一种新的路线类型——骑行路线，并向你展示如何在网页上启用 3d 环视图像。了解新的 geocoding api 如何支持坐标与地址之间的转换，以及如何使用 address representations api 来获取某一区域最恰当的地址。最后，我们将介绍一种新的地点引用方式，确保你的 app 能与 app intents 无缝协作。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9878/9878_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/204/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="MapKit-与-MapKit-JS-最新功能解析"><a href="#MapKit-与-MapKit-JS-最新功能解析" class="headerlink" title="MapKit 与 MapKit JS 最新功能解析"></a>MapKit 与 MapKit JS 最新功能解析</h1><p>在 WWDC 2024 上，Apple 为开发者带来了 MapKit 和 MapKit JS 的一系列重要更新。本文将详细介绍这些新功能，包括新的骑行路线、3D 环视图像支持、改进的地理编码 API 以及全新的地点引用方式。</p><h2 id="新功能概览"><a href="#新功能概览" class="headerlink" title="新功能概览"></a>新功能概览</h2><p>本次更新主要包含以下内容：</p><ul><li><strong>PlaceDescriptor</strong>：一种新型的地点查找和引用方式</li><li><strong>地理编码改进</strong>：将 CLGeocoder 功能迁移至 MapKit 框架</li><li><strong>地址表示优化</strong>：通过 Address Representations API 获取最适合显示的地址格式</li><li><strong>骑行路线支持</strong>：为地图应用新增骑行路线规划功能</li><li><strong>环视 API 增强</strong>：在网页中支持 3D 环视图像展示</li></ul><h2 id="PlaceDescriptor：灵活的地点引用方式"><a href="#PlaceDescriptor：灵活的地点引用方式" class="headerlink" title="PlaceDescriptor：灵活的地点引用方式"></a>PlaceDescriptor：灵活的地点引用方式</h2><p>PlaceDescriptor 是一种结构化地点描述方式，它包含三个核心组成部分：</p><ol><li><strong>commonName</strong>：地点的通用名称（如”埃菲尔铁塔”）</li><li><strong>representations</strong>：通用地理信息表示（地址、坐标或设备位置）</li><li><strong>supportingRepresentations</strong>：可选的非通用信息（如服务标识符）</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建带有坐标和名称的 PlaceDescriptor</span></span><br><span class="line"><span class="keyword">let</span> descriptor <span class="operator">=</span> <span class="type">PlaceDescriptor</span>(</span><br><span class="line">    representations: [.coordinate(coordinates)],</span><br><span class="line">    commonName: <span class="string">&quot;安娜利维娅喷泉&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>PlaceDescriptor 的优势在于：</p><ul><li>无需依赖 MapKit 特定标识符</li><li>可与 App Intents 无缝配合</li><li>支持多种地理信息表示方式</li><li>适用于跨框架交互场景</li></ul><h2 id="地理编码与地址表示"><a href="#地理编码与地址表示" class="headerlink" title="地理编码与地址表示"></a>地理编码与地址表示</h2><p>地理编码功能已从 CoreLocation 迁移至 MapKit，提供更一致的 API 体验：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆向地理编码示例</span></span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">MKReverseGeocodingRequest</span>(location: location)</span><br><span class="line"><span class="keyword">let</span> mapItems <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> request.mapItems</span><br></pre></td></tr></table></figure><p>MapItem 提供两种地址访问方式：</p><ol><li><strong>MKAddress</strong>：包含完整地址(fullAddress)和精简地址(shortAddress)</li><li><strong>MKAddressRepresentations</strong>：提供多种显示优化方案</li></ol><p>正向地理编码同样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向地理编码示例</span></span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">MKGeocodingRequest</span>(addressString: <span class="string">&quot;1 Ferry Building, San Francisco&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> mapItem <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> request<span class="operator">?</span>.mapItems.first</span><br></pre></td></tr></table></figure><h2 id="路线与环视功能"><a href="#路线与环视功能" class="headerlink" title="路线与环视功能"></a>路线与环视功能</h2><h3 id="骑行路线支持"><a href="#骑行路线支持" class="headerlink" title="骑行路线支持"></a>骑行路线支持</h3><p>MapKit 现在支持骑行路线规划：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取骑行路线</span></span><br><span class="line">request.transportType <span class="operator">=</span> .cycling</span><br><span class="line"><span class="keyword">let</span> directions <span class="operator">=</span> <span class="type">MKDirections</span>(request: request)</span><br><span class="line"><span class="keyword">let</span> response <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> directions.calculate()</span><br></pre></td></tr></table></figure><h3 id="环视功能扩展"><a href="#环视功能扩展" class="headerlink" title="环视功能扩展"></a>环视功能扩展</h3><p>MapKit JS 现在支持两种环视视图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建交互式环视视图</span></span><br><span class="line"><span class="keyword">const</span> lookAround = <span class="keyword">new</span> mapkit.<span class="title class_">LookAround</span>(containerElement, place, &#123;</span><br><span class="line">    <span class="attr">openDialog</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">showsDialogControl</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">showsCloseControl</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>开发者可以通过事件监听器管理视图生命周期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lookAround.<span class="title function_">addEventListener</span>(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    app.<span class="title function_">closeView</span>();</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>本次 MapKit 更新带来了诸多实用功能：</p><ul><li>PlaceDescriptor 提供了更灵活的地点引用方式</li><li>地理编码功能迁移至 MapKit 框架</li><li>地址表示优化提升了用户体验</li><li>新增的骑行路线丰富了导航选择</li><li>MapKit JS 的环视功能扩展了网页地图能力</li></ul><p>这些改进将使开发者能够创建更丰富、更灵活的地图应用。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2024/10097">使用 MapKit 充分优化位置相关功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10043">认识 SwiftUI 版 MapKit</a><br><a href="https://developer.apple.com/videos/play/wwdc2022/10035">MapKit 的新功能</a>  </p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://developer.apple.com/documentation/MapKit/Unified-Map-URLs">Adopting unified Maps URLs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 mapkit 和 mapkit js 的最新更新。我们将介绍一种新的路线类型——骑行路线，并向你展示如何在网页上启用 3d 环视图像。了解新的 geocoding api 如何支持坐标与地址之间的转换，以及如何使用 address representations api 来获取某一区域最恰当的地址。最后，我们将介绍一种新的地点引用方式，确保你的 app 能与 app intents 无缝协作。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="地图和位置" scheme="http://djs66256.github.io/tags/%E5%9C%B0%E5%9B%BE%E5%92%8C%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>探索 Metal 4</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_205/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_205/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.104Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何开始利用 metal 4 强大的新功能，让你的现有 metal app 更上一层楼。我们将介绍 metal 如何助你充分发挥 apple 芯片的优势，并以更高效的方式进行硬件编程。你还将了解如何借助 metal 4 的新功能，将机器学习整合到 metal 代码中。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9886/9886_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/205/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="Metal-4：Apple-芯片性能的全面释放"><a href="#Metal-4：Apple-芯片性能的全面释放" class="headerlink" title="Metal 4：Apple 芯片性能的全面释放"></a>Metal 4：Apple 芯片性能的全面释放</h1><p>Metal 是 Apple 平台上核心的低阶图形与计算 API，经过十余年的演进，Metal 4 为开发者带来了前所未有的性能优化与功能增强。本文将系统介绍 Metal 4 的关键技术创新点，帮助开发者理解如何将现有 Metal 应用升级至新高度。</p><h2 id="革命性的指令编码模型"><a href="#革命性的指令编码模型" class="headerlink" title="革命性的指令编码模型"></a>革命性的指令编码模型</h2><p>Metal 4 对指令编码系统进行了重新设计，引入了全新的 MTL4CommandQueue 和 MTL4CommandBuffer 架构。与旧版本不同，Metal 4 将命令缓冲区与队列解耦，使应用能够并行编码命令缓冲区，显著提升多线程环境下的编码效率。</p><p>新的统一计算编码器整合了位块传输和加速结构命令编码功能，减少了编码器切换的开销。MTL4RenderCommandEncoder 则引入了附件映射功能，允许动态切换颜色附件，无需创建额外编码器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 MTL4CommandQueue</span></span><br><span class="line"><span class="keyword">let</span> commandQueue <span class="operator">=</span> device.makeCommandQueue(type: .<span class="type">MTL4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 MTL4CommandBuffer</span></span><br><span class="line"><span class="keyword">let</span> commandBuffer <span class="operator">=</span> commandQueue.makeCommandBuffer()</span><br></pre></td></tr></table></figure><h2 id="高效资源管理机制"><a href="#高效资源管理机制" class="headerlink" title="高效资源管理机制"></a>高效资源管理机制</h2><p>现代图形应用使用的资源数量呈爆炸式增长，Metal 4 提供了全新的资源管理方案：</p><ol><li><strong>MTL4ArgumentTable</strong>：取代传统的固定资源绑定点，支持无绑定渲染模式，大幅减少CPU设置时间</li><li><strong>Residency集</strong>：明确指定GPU需要访问的资源集合，优化内存使用</li><li><strong>放置稀疏资源</strong>：允许动态控制资源的内存占用，支持更广泛的设备适配</li></ol><p>《Control Ultimate Edition》的案例表明，合理使用Residency集可以显著降低内存管理开销和内存使用量。</p><h2 id="着色器编译优化"><a href="#着色器编译优化" class="headerlink" title="着色器编译优化"></a>着色器编译优化</h2><p>Metal 4 引入了 MTL4Compiler 接口，使着色器编译过程更可控：</p><ol><li>编译器与设备分离，允许明确的编译时间控制</li><li>灵活渲染管线状态支持Metal IR重用，减少重复编译</li><li>编译器服务质量继承，确保关键着色器优先编译</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 MTL4Compiler</span></span><br><span class="line"><span class="keyword">let</span> compiler <span class="operator">=</span> device.makeCompiler()</span><br></pre></td></tr></table></figure><h2 id="机器学习无缝集成"><a href="#机器学习无缝集成" class="headerlink" title="机器学习无缝集成"></a>机器学习无缝集成</h2><p>Metal 4 将机器学习能力深度整合到图形管线中：</p><ol><li><strong>张量支持</strong>：原生支持多维数据容器，简化机器学习数据结构处理</li><li><strong>机器学习命令编码器</strong>：可直接执行CoreML转换的网络</li><li><strong>Metal性能原语</strong>：提供优化的着色器原语，支持小型网络嵌入</li></ol><p>这使得神经材质评估、升频等先进技术可以高效实现。</p><h2 id="MetalFX-性能加速套件"><a href="#MetalFX-性能加速套件" class="headerlink" title="MetalFX 性能加速套件"></a>MetalFX 性能加速套件</h2><p>MetalFX 是Metal 4配套的高性能解决方案：</p><ol><li><strong>升频技术</strong>：允许渲染低分辨率图像并智能放大，节省GPU时间</li><li><strong>帧插值</strong>：生成中间帧实现更高帧率</li><li><strong>光线追踪降噪</strong>：改善光线追踪效果</li></ol><h2 id="升级路径与开发工具"><a href="#升级路径与开发工具" class="headerlink" title="升级路径与开发工具"></a>升级路径与开发工具</h2><p>Metal 4 采用模块化设计，开发者可以分阶段升级：</p><ol><li>先从着色器编译优化开始</li><li>逐步采用新的命令编码模型</li><li>最后集成先进的资源管理功能</li></ol><p>Xcode 26 提供了新的Metal 4项目模板，Metal调试器和性能HUD等工具也全面支持Metal 4，为开发者提供完善的调试和优化支持。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>开发者可以参考以下资源深入了解Metal 4：</p><p>相关视频：</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2025/262">实现 Metal 4 机器学习与图形应用程序的完美融合</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/254">探索 Metal 4 游戏</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/211">深入探索 Metal 4 游戏</a></li></ul><p>文档：</p><ul><li><a href="https://developer.apple.com/documentation/Metal/understanding-the-metal-4-core-api">Understanding the Metal 4 core API</a></li><li><a href="https://developer.apple.com/documentation/Metal/using-the-metal-4-compilation-api">Using the Metal 4 compilation API</a></li></ul><p>Metal 4 为Apple平台上的图形和计算应用开辟了新的可能性，开发者现在就可以开始在新项目或现有应用中采用这些先进功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何开始利用 metal 4 强大的新功能，让你的现有 metal app 更上一层楼。我们将介绍 metal 如何助你充分发挥 apple 芯片的优势，并以更高效的方式进行硬件编程。你还将了解如何借助 metal 4 的新功能，将机器学习整合到 metal 代码中。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="图形和游戏" scheme="http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>开始使用 Game Center</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_214/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_214/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.238Z</updated>
    
    <content type="html"><![CDATA[<p>探索 game center 的功能并了解如何开始使用。我们将展示实现成就、挑战、排行榜和活动的最佳实践，助你最大限度地提高游戏的曝光度、吸引新玩家并提升用户参与度。</p><p>为了充分从这个讲座中获益，我们还建议你观看“通过 apple games app 吸引玩家”。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9892/9892_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/214/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="开始使用-Game-Center：提升游戏曝光与玩家参与度"><a href="#开始使用-Game-Center：提升游戏曝光与玩家参与度" class="headerlink" title="开始使用 Game Center：提升游戏曝光与玩家参与度"></a>开始使用 Game Center：提升游戏曝光与玩家参与度</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Game Center 作为苹果生态系统中的重要组件，为游戏开发者提供了一套完整的社交和竞争功能解决方案。通过集成 Game Center 功能，开发者不仅能提升玩家参与度，还能显著增加游戏在苹果平台上的曝光机会。</p><h2 id="Game-Center-的核心价值"><a href="#Game-Center-的核心价值" class="headerlink" title="Game Center 的核心价值"></a>Game Center 的核心价值</h2><p>Game Center 的核心功能包括成就系统、排行榜、挑战和活动。这些功能共同构建了一个完整的社交游戏生态系统：</p><ol><li><strong>成就系统</strong>：奖励玩家达成游戏里程碑，增加游戏成就感</li><li><strong>排行榜</strong>：促进玩家间的竞争，提高游戏重玩价值</li><li><strong>挑战功能</strong>：将单人游戏转化为社交体验</li><li><strong>活动功能</strong>：提供深度链接，引导玩家进入特定游戏内容</li></ol><p>特别值得注意的是，从今年秋季开始预装在苹果设备上的新 Games 应用，将进一步放大 Game Center 的曝光优势。游戏在”最常玩游戏”排行榜和”朋友正在玩”版块的展示，都将显著提升发现率。</p><h2 id="技术集成指南"><a href="#技术集成指南" class="headerlink" title="技术集成指南"></a>技术集成指南</h2><h3 id="项目初始配置"><a href="#项目初始配置" class="headerlink" title="项目初始配置"></a>项目初始配置</h3><p>集成 Game Center 只需两个关键步骤：</p><ol><li><p><strong>添加 Game Center 权限</strong>：</p><ul><li>在 Xcode 中通过”Signing and Capabilities”标签添加”Game Center”能力</li><li>Unity 开发者可使用苹果提供的专用插件简化流程</li></ul></li><li><p><strong>初始化 GameKit 框架</strong>：<br>通过简单的代码实现 Game Center 初始化：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GKLocalPlayer.local.authenticateHandler = &#123; _, error in</span><br><span class="line">    print(&quot;\(GKLocalPlayer.local.alias) is ready to play!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 版本的初始化同样简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var player = await GKLocalPlayer.Authenticate();</span><br><span class="line">Debug.Log($&quot;&#123;player.alias&#125; is ready to play!&quot;);</span><br></pre></td></tr></table></figure><h3 id="功能开发与测试"><a href="#功能开发与测试" class="headerlink" title="功能开发与测试"></a>功能开发与测试</h3><p>Xcode 26 引入的 GameKit 包为开发者带来了显著便利：</p><ol><li><strong>本地测试能力</strong>：可直接在 Xcode 中测试成就、排行榜和活动</li><li><strong>配置同步</strong>：与 App Store Connect 保持同步</li><li><strong>版本控制友好</strong>：配置自动包含在代码审查和版本控制中</li></ol><p>以”The Coast”游戏为例，添加”Capecod”排行榜的流程展示了 GameKit 包的高效性：</p><ol><li>通过模板选择器创建 GameKit 包</li><li>从 App Store Connect 拉取现有游戏信息</li><li>添加新排行榜并配置相关参数</li><li>设置多语言本地化支持</li></ol><h2 id="创新功能详解"><a href="#创新功能详解" class="headerlink" title="创新功能详解"></a>创新功能详解</h2><h3 id="挑战系统"><a href="#挑战系统" class="headerlink" title="挑战系统"></a>挑战系统</h3><p>挑战功能基于现有排行榜，无需额外代码即可实现：</p><ol><li><p><strong>特点</strong>：</p><ul><li>有时间限制的个性化竞赛</li><li>可自定义参与者和尝试次数</li><li>支持不同持续时间选项（1天、3天或1周）</li></ul></li><li><p><strong>实现方式</strong>：<br>通过现有的 submitScore() API 自动支持挑战：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GKLeaderboard.submitScore(points, </span><br><span class="line">         context: 0, </span><br><span class="line">         player: GKLocalPlayer.local,</span><br><span class="line">         leaderboardIDs: [&quot;thecoast.lb.capecod&quot;])</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>最佳实践</strong>：<ul><li>定期更新的排行榜可设为”不可重复”挑战</li><li>应在游戏关卡结束时提交分数</li><li>避免提交累计终身分数</li></ul></li></ol><h3 id="活动功能"><a href="#活动功能" class="headerlink" title="活动功能"></a>活动功能</h3><p>活动功能提供了深度链接能力，可直接将玩家引导至特定游戏内容：</p><ol><li><p><strong>应用场景</strong>：</p><ul><li>快速进入特定关卡</li><li>直接跳转到成就相关场景</li><li>精准定位游戏内活动</li></ul></li><li><p><strong>实现优势</strong>：</p><ul><li>提升玩家参与效率</li><li>增加特定内容的访问量</li><li>与 Game Center 其他功能无缝集成</li></ul></li></ol><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>Game Center 提供了一套完整的工具集，帮助开发者提升游戏社交性、竞争性和可发现性。通过合理配置成就、排行榜、挑战和活动功能，开发者可以：</p><ol><li>显著提升游戏在 App Store 和新 Games 应用中的曝光率</li><li>增强玩家留存率和参与度</li><li>创造更具吸引力的社交游戏体验</li></ol><p>随着苹果游戏生态的持续发展，Game Center 的功能和价值将进一步提升。开发者应充分利用这些工具，创造更具吸引力的游戏体验。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2024/101/">通过 Apple Games App 吸引玩家</a> </p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://developer.apple.com/documentation/gamekit">Game Center 开发者文档</a><br><a href="https://developer.apple.com/documentation/appstoreconnectapi">App Store Connect API 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探索 game center 的功能并了解如何开始使用。我们将展示实现成就、挑战、排行榜和活动的最佳实践，助你最大限度地提高游戏的曝光度、吸引新玩家并提升用户参与度。&lt;/p&gt;
&lt;p&gt;为了充分从这个讲座中获益，我们还建议你观看“通过 apple games app 吸引玩家”。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="开发者工具" scheme="http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>让游戏更上一层楼</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_209/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_209/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.106Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何让你的游戏在统一游戏平台上大放异彩。我们将介绍一些可用于让你的游戏更上一层楼并进一步提升玩家体验的技术。简要了解构建、调试和分析游戏所必需的基本工具。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9890/9890_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/209/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="让游戏更上一层楼：WWDC-2025游戏技术全面解析"><a href="#让游戏更上一层楼：WWDC-2025游戏技术全面解析" class="headerlink" title="让游戏更上一层楼：WWDC 2025游戏技术全面解析"></a>让游戏更上一层楼：WWDC 2025游戏技术全面解析</h1><p>在WWDC 2025中，苹果展示了如何通过统一游戏平台和最新技术提升游戏品质与玩家体验。本文将详细解读演讲中介绍的关键技术，帮助开发者充分利用苹果生态系统打造卓越游戏。</p><h2 id="系统体验优化"><a href="#系统体验优化" class="headerlink" title="系统体验优化"></a>系统体验优化</h2><p>游戏模式是提升游戏性能的核心功能。该模式通过优化系统行为为游戏分配更多资源，减少后台活动，使游戏获得更多CPU时间处理复杂任务。同时，它改善了蓝牙延迟，使输入设备和耳机响应更迅捷。</p><p>在macOS和iOS上，当玩家全屏启动游戏时即会启用游戏模式。开发者只需在info.plist中添加LSSupportsGameMode键并设为true即可启用。持续执行模式则进一步将性能限制在稳定状态，确保玩家获得稳定体验。</p><p>苹果还为开发者提供了低电量模式API，包括<code>static let NSProcessInfoPowerStateDidChange: NSNotification.Name</code>和<code>var isLowPowerModeEnabled: Bool &#123; get &#125;</code>，帮助游戏适应不同电源状态。</p><h2 id="增强玩家互动体验"><a href="#增强玩家互动体验" class="headerlink" title="增强玩家互动体验"></a>增强玩家互动体验</h2><p>Game Center作为苹果的社交游戏网络，连接玩家与好友，提供成就、排行榜、挑战和活动等功能。新版Game Center配置完全集成至Xcode，支持创建成就、设置本地化、配置挑战等操作。</p><p>全新的Apple Games应用为玩家提供了一站式游戏中心，预装在Mac、iPad和iPhone上，深度集成于操作系统各处，包括小组件、通知和App Store。</p><h2 id="关键技术实现"><a href="#关键技术实现" class="headerlink" title="关键技术实现"></a>关键技术实现</h2><h3 id="快速开玩技术"><a href="#快速开玩技术" class="headerlink" title="快速开玩技术"></a>快速开玩技术</h3><p>Managed Background Assets框架允许开发者将游戏内容分成两部分：玩家只需下载教程关卡必需的小部分内容，其余内容在后台下载。新版API改进并简化了工作流，提供高达200GB的苹果托管容量。</p><h3 id="跨设备云存档"><a href="#跨设备云存档" class="headerlink" title="跨设备云存档"></a>跨设备云存档</h3><p>GameSave框架基于iCloud构建，注重用户隐私和数据安全，自动同步同一iCloud账户下的设备数据。开发者可以通过以下步骤启用：</p><ol><li>在Xcode的”Signing &amp; Capabilities”工具中添加iCloud权限</li><li>勾选iCloud Documents选项并添加iCloud容器权限</li><li>登录开发者账户将该权限包含在配置文件中</li></ol><p>基础实现代码示例展示了如何用容器标识符开始iCloud同步，在后台同步期间调用finishSyncing完成处理程序。</p><h3 id="输入方式支持"><a href="#输入方式支持" class="headerlink" title="输入方式支持"></a>输入方式支持</h3><p>Game Controller框架支持键盘、鼠标和游戏控制器等外设输入。新的Touch Controls框架为现有游戏添加触控支持提供了简单方案，直接与Metal集成以确保最佳性能。</p><h2 id="图形性能突破"><a href="#图形性能突破" class="headerlink" title="图形性能突破"></a>图形性能突破</h2><p>Metal 4 API显著提升了图形表现，减少了图形命令编码的CPU开销，并允许在渲染管线中使用机器学习。MetalFX超采样支持空间和时间两种方式，结合帧插值可进一步提升帧率。</p><p>Metal 4还提供了全面的分析调试工具：</p><ul><li>运行时API和着色器验证工具</li><li>Metal性能HUD实时显示多种性能指标</li><li>Xcode中的Metal调试器展示GPU工作详细分析数据</li><li>Instruments中的Metal系统追踪洞察CPU和GPU使用情况</li></ul><p>游戏移植工具包3加入了Metal 4支持，Metal-cpp具备完整的Metal 4特性支持，Metal Shader Converter可将HLSL着色器转换为Metal。</p><h2 id="总结与资源"><a href="#总结与资源" class="headerlink" title="总结与资源"></a>总结与资源</h2><p>通过整合系统性能功能、社交功能以及最新游戏技术，开发者可以在苹果平台上打造具有稳定帧率、丰富社交体验和出色图形的游戏。</p><p>相关视频:</p><ul><li><a href="https://developer.apple.com/videos/play/wwdc2025/214">开始使用 Game Center</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/325">探索 Apple 托管的 Background Assets</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/205">探索 Metal 4</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2025/211">深入探索 Metal 4 游戏</a></li></ul><p>文档:</p><ul><li><a href="https://developer.apple.com/design/human-interface-guidelines/designing-for-games">Human Interface Guidelines: Designing for games</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何让你的游戏在统一游戏平台上大放异彩。我们将介绍一些可用于让你的游戏更上一层楼并进一步提升玩家体验的技术。简要了解构建、调试和分析游戏所必需的基本工具。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="图形和游戏" scheme="http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>针对 CarPlay 车载优化你的 App</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_216/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_216/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.719Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何将实时活动和小组件引入 carplay 车载和 carplay 车载 ultra，以便用户查看活动进度并一目了然地掌握相关信息。探索所有 carplay 车载 app 均可使用的新增模板选项，并了解导航类 app 如何提供逐向导航元数据，以便显示在车载仪表盘或 hud 上。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9903/9903_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/216/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="为-CarPlay-车载优化你的应用：iOS-26-新功能详解"><a href="#为-CarPlay-车载优化你的应用：iOS-26-新功能详解" class="headerlink" title="为 CarPlay 车载优化你的应用：iOS 26 新功能详解"></a>为 CarPlay 车载优化你的应用：iOS 26 新功能详解</h1><p>随着 iOS 26 的发布，苹果为 CarPlay 车载系统带来了一系列创新功能，使开发者能够为用户提供更加安全、便捷的车载体验。本文将详细介绍这些新功能及其实现方式。</p><h2 id="核心功能概述"><a href="#核心功能概述" class="headerlink" title="核心功能概述"></a>核心功能概述</h2><p>iOS 26 为 CarPlay 引入了三大关键改进：</p><ol><li>小组件支持 - 让驾驶者快速获取关键信息</li><li>实时活动 - 显示重要进度和状态更新</li><li>导航元数据 - 在仪表盘和HUD上显示转向信息</li></ol><p>这些功能不仅适用于专门开发的CarPlay应用，也支持仅提供小组件或实时活动的iPhone应用。</p><h2 id="小组件集成"><a href="#小组件集成" class="headerlink" title="小组件集成"></a>小组件集成</h2><p>CarPlay现在支持显示iPhone应用的小组件，即使该应用没有专门的CarPlay版本。驾驶者可以在CarPlay仪表盘左侧查看这些小组件。</p><h3 id="技术实现要点"><a href="#技术实现要点" class="headerlink" title="技术实现要点"></a>技术实现要点</h3><p>开发者为CarPlay添加小组件支持非常简单，只需满足以下条件：</p><ul><li>支持systemSmall小组件家族</li><li>遵循CarPlay特定的设计规范</li></ul><p>对于不适合CarPlay的小组件（如游戏类或需要复杂交互的），可以使用disfavoredLocations修饰符将其标记为”非优选”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WidgetConfiguration</span>()</span><br><span class="line">    .disfavoredLocations([.carPlay], for: [.systemSmall])</span><br></pre></td></tr></table></figure><h3 id="设计最佳实践"><a href="#设计最佳实践" class="headerlink" title="设计最佳实践"></a>设计最佳实践</h3><ol><li>内容简洁直观 - 避免高密度文本和与驾驶无关的信息</li><li>自动适应布局 - widgetContentMargins会根据CarPlay需求自动调整</li><li>使用系统字体和颜色 - 确保文本可读性</li><li>可选背景移除 - 通过containerBackgroundRemovable修饰符实现</li></ol><h2 id="实时活动支持"><a href="#实时活动支持" class="headerlink" title="实时活动支持"></a>实时活动支持</h2><p>iOS 26将iPhone的实时活动功能扩展到了CarPlay。当iPhone上开启支持的实时活动时，它会自动出现在CarPlay仪表盘。</p><h3 id="技术规格"><a href="#技术规格" class="headerlink" title="技术规格"></a>技术规格</h3><ol><li>显示尺寸 - CarPlay使用activity family small尺寸类</li><li>交互限制 - CarPlay中的实时活动不支持交互</li><li>通知机制 - 当仪表盘不可见时，会在屏幕底部显示通知提醒</li></ol><h3 id="实现建议"><a href="#实现建议" class="headerlink" title="实现建议"></a>实现建议</h3><ol><li>只传达关键状态信息</li><li>优先实现activity family small尺寸</li><li>无需考虑交互功能</li></ol><p>开发者可以使用macOS的CarPlay模拟器应用进行测试，无需实际车辆。</p><h2 id="CarPlay框架增强"><a href="#CarPlay框架增强" class="headerlink" title="CarPlay框架增强"></a>CarPlay框架增强</h2><p>CarPlay框架为各类车载应用提供了优化的UI模板。iOS 26带来了多项改进：</p><h3 id="列表模板升级"><a href="#列表模板升级" class="headerlink" title="列表模板升级"></a>列表模板升级</h3><ol><li>CPListImageRowItem新增自定义选项</li><li>支持禁用单个行元素</li><li>允许多行显示</li><li>引入pinned元素API用于显示重要元素</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headerGridButtons: [<span class="type">CPGridButton</span>]<span class="operator">?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPGridButton</span></span><br><span class="line"><span class="keyword">init</span>(titleVariants: [<span class="type">String</span>],</span><br><span class="line">     image: <span class="type">UIImage</span>,</span><br><span class="line">     handler: ((<span class="type">CPGridButton</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>)</span><br></pre></td></tr></table></figure><h3 id="音频应用新功能"><a href="#音频应用新功能" class="headerlink" title="音频应用新功能"></a>音频应用新功能</h3><p>体育赛事音频应用现在可以使用专门的”正在播放”模板变体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> clock <span class="operator">=</span> <span class="type">CPNowPlayingSportsClock</span>(elapsedTime: time, paused: <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> status <span class="operator">=</span> <span class="type">CPNowPlayingSportsEventStatus</span>(</span><br><span class="line">    eventStatusText: [<span class="string">&quot;1st&quot;</span>],</span><br><span class="line">    eventStatusImage: <span class="type">UIImage</span>(named: <span class="string">&quot;Semifinals&quot;</span>),</span><br><span class="line">    eventClock: clock</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sports <span class="operator">=</span> <span class="type">CPNowPlayingModeSports</span>(</span><br><span class="line">    leftTeam: getLeftTeam(),</span><br><span class="line">    rightTeam: getRightTeam(),</span><br><span class="line">    eventStatus: status,</span><br><span class="line">    backgroundArtwork: getBackgroundArtwork()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="type">CPNowPlayingTemplate</span>.sharedTemplate.nowPlayingMode <span class="operator">=</span> sports</span><br></pre></td></tr></table></figure><h3 id="导航应用改进"><a href="#导航应用改进" class="headerlink" title="导航应用改进"></a>导航应用改进</h3><ol><li>按钮自动获得Liquid Glass外观</li><li>支持多点触控交互</li><li>仪表盘地图显示</li><li>转向导航元数据支持</li></ol><p>转向导航元数据允许在车辆仪表盘或HUD上显示导航信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">mapTemplateShouldProvideNavigationMetadata</span>(<span class="keyword">_</span> <span class="params">mapTemplate</span>: <span class="type">CPMapTemplate</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cpNavigationSession.add(maneuvers)</span><br><span class="line">cpNavigationSession.add(laneGuidance)</span><br><span class="line"></span><br><span class="line">cpNavigationSession.pauseTrip(for: .rerouting, description: <span class="string">&quot;重新规划路线&quot;</span>)</span><br><span class="line">cpNavigationSession.resumeTrip(updatedRouteInformation: cpRouteInformation)</span><br></pre></td></tr></table></figure><h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><ol><li>观察设备温度级别，适当降低渲染细节</li><li>利用CADisplayLink的自动帧率调整</li><li>主屏幕和仪表盘地图可采用不同显示模式</li><li>预先提供转向信息优化性能</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iOS 26为CarPlay带来了显著的增强，使开发者能够创建更丰富、更智能的车载体验。通过小组件、实时活动和导航元数据等新功能，应用可以在不分散驾驶注意力的情况下，提供更多有价值的信息和服务。</p><p>开发者应充分利用这些新功能，同时遵循苹果的设计规范和性能建议，确保为用户提供安全、流畅的车载体验。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2025/278">小组件的新功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/308">通过 Instruments 优化 CPU 性能</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10111">了解新一代 CarPlay 车载架构</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10112">了解新一代 CarPlay 车载设计系统</a><br><a href="https://developer.apple.com/videos/play/wwdc2022/10016">利用 CarPlay 车载让您的 App 一日千里</a></p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://developer.apple.com/documentation/WidgetKit/adding-standby-and-carplay-support-to-your-widget">Adding StandBy and CarPlay support to your widget</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何将实时活动和小组件引入 carplay 车载和 carplay 车载 ultra，以便用户查看活动进度并一目了然地掌握相关信息。探索所有 carplay 车载 app 均可使用的新增模板选项，并了解导航类 app 如何提供逐向导航元数据，以便显示在车载仪表盘或 hud 上。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="系统服务" scheme="http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>通过 Apple Games App 吸引玩家</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_215/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_215/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.122Z</updated>
    
    <content type="html"><![CDATA[<p>认识一下 games app，这是一个全新的一站式平台，供玩家了解所玩游戏的最新动态、发现新游戏并与朋友一起玩。了解如何在 games app 中设置游戏以提升曝光度，如何整合 game center 以打造社交游戏，以及如何通过“app 内活动”来吸引玩家再次参与游戏。</p><p>为了充分从这个讲座中获益，我们还建议观看“开始使用 game center”。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9893/9893_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/215/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="通过-Apple-Games-App-吸引玩家：开发者指南"><a href="#通过-Apple-Games-App-吸引玩家：开发者指南" class="headerlink" title="通过 Apple Games App 吸引玩家：开发者指南"></a>通过 Apple Games App 吸引玩家：开发者指南</h1><p>Apple 在 WWDC 上隆重推出全新的 Games app，为游戏开发者提供了一个前所未有的平台来展示游戏、吸引玩家并维持用户参与度。本文将详细介绍如何充分利用这一全新平台的功能。</p><h2 id="Games-App-概览"><a href="#Games-App-概览" class="headerlink" title="Games App 概览"></a>Games App 概览</h2><p>Games app 是 Apple 生态系统中的全新一体化游戏中心，预装于 iPhone、iPad 和 Mac 设备上。这一应用深度集成于操作系统，会出现在小组件、通知和 App Store 中，将成为玩家每日娱乐的枢纽。</p><p>Games app 包含四个主要标签页：</p><ul><li><strong>首页</strong>：展示游戏中正在进行的活动、好友游戏动态、Game Center 好友动态和精选游戏合集</li><li><strong>一起玩</strong>：查看好友游戏动态、比较分数记录、发起挑战</li><li><strong>游戏库</strong>：管理已安装游戏和重新下载已购游戏</li><li><strong>搜索</strong>：发现新游戏的起点</li></ul><h2 id="游戏信息设置"><a href="#游戏信息设置" class="headerlink" title="游戏信息设置"></a>游戏信息设置</h2><p>要使游戏出现在 Games app 中，开发者需要确保：</p><ol><li>将游戏的主类别或次类别设为”游戏”</li><li>在 App Store Connect 中完善游戏信息，包括：<ul><li>名称和副标题</li><li>高质量图标（应用会自动生成背景）</li><li>年龄分级和子类别（如动作类）</li><li>支持手柄操作的需在 Xcode 添加 Game Controller 能力</li></ul></li></ol><p>示例代码（Swift）：</p><p>let controllerCapability = GKControllerCapability()<br>controllerCapability.isSupported = true</p><ol start="3"><li>上传吸引人的预览视频和截图</li><li>设置精准搜索关键词</li><li>考虑使用预购功能为未发布游戏造势</li></ol><h2 id="Game-Center-功能整合"><a href="#Game-Center-功能整合" class="headerlink" title="Game Center 功能整合"></a>Game Center 功能整合</h2><p>Game Center 是一套强大的工具，能够显著提升玩家参与度和游戏曝光度。主要功能包括：</p><h3 id="成就系统"><a href="#成就系统" class="headerlink" title="成就系统"></a>成就系统</h3><ul><li>追踪游戏进度</li><li>鼓励玩家探索全部内容</li><li>所有成就均可本地化</li></ul><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><ul><li>今年新增描述字段</li><li>支持循环排行榜（显示重置倒计时）</li><li>可使用分数后缀（如”pts”）</li></ul><h3 id="挑战赛"><a href="#挑战赛" class="headerlink" title="挑战赛"></a>挑战赛</h3><ul><li>将单人游戏转化为社交体验</li><li>支持设置尝试次数和持续时间</li><li>可在游戏中内置邀请流程</li></ul><h3 id="活动功能"><a href="#活动功能" class="headerlink" title="活动功能"></a>活动功能</h3><ul><li>定义游戏目的地并使用深度链接直达</li><li>特别适合多人游戏体验</li><li>支持生成跨平台分享的派对代码</li></ul><h2 id="保持玩家参与度的策略"><a href="#保持玩家参与度的策略" class="headerlink" title="保持玩家参与度的策略"></a>保持玩家参与度的策略</h2><p>长期维持玩家热情的关键在于：</p><ol><li><p><strong>App 内活动</strong>：突出限时内容、季节活动或特别促销</p><ul><li>会出现在首页、游戏库、搜索结果和游戏页面</li><li>支持设置优先级和预定时间</li><li>可使用深度链接直达游戏内活动</li></ul></li><li><p><strong>定期更新内容</strong>：策划新活动和挑战来保持游戏新鲜感</p></li><li><p><strong>高质量视觉素材</strong>：上传循环展示的视频和高清艺术图</p></li></ol><h2 id="开发者后续步骤"><a href="#开发者后续步骤" class="headerlink" title="开发者后续步骤"></a>开发者后续步骤</h2><p>已有游戏的开发者应：</p><ul><li>检查 Games app 中的展示信息</li><li>确保启用 Game Center 并整合未添加的功能</li><li>策划新活动来增添游戏活力</li><li>考虑设置季节性内容和限时挑战</li></ul><p>新的 Games app 为开发者提供了前所未有的机会来展示游戏、吸引新玩家并维持现有玩家的参与度。通过合理利用 Game Center 功能和 app 内活动，开发者可以显著提升游戏的可见性和玩家留存率。</p><h2 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h2><p><a href="https://developer.apple.com/videos/play/wwdc2025/214">开始使用 Game Center</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/209">让游戏更上一层楼</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10015">App Store 预定的新功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2021/10081">利用虚拟和物理游戏手柄</a><br><a href="https://developer.apple.com/videos/play/wwdc2021/10171">认识 App Store 上的 app 内活动</a></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://developer.apple.com/documentation/GameKit/creating-activities-for-your-game">为游戏创建活动</a><br><a href="https://developer.apple.com/documentation/GameKit/creating-engaging-challenges-from-leaderboards">从排行榜创建引人入胜的挑战</a><br><a href="https://developer.apple.com/design/human-interface-guidelines/game-center">人机界面指南：Game Center</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;认识一下 games app，这是一个全新的一站式平台，供玩家了解所玩游戏的最新动态、发现新游戏并与朋友一起玩。了解如何在 games app 中设置游戏以提升曝光度，如何整合 game center 以打造社交游戏，以及如何通过“app 内活动”来吸引玩家再次参与游戏。&lt;/p&gt;
&lt;p&gt;为了充分从这个讲座中获益，我们还建议观看“开始使用 game center”。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="图形和游戏" scheme="http://djs66256.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%92%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>针对辅助功能标签评估你的 App</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_224/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_224/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.794Z</updated>
    
    <content type="html"><![CDATA[<p>在你的 app store 产品页面上使用辅助功能标签，以突出展示你的 app 支持的辅助功能。你将了解如何评估 app 的辅助功能 (如“旁白”、“更大字体”、“字幕”等)，并选择准确且描述性的辅助功能标签。你还将了解如何在整个设计阶段解决辅助功能问题。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9917/9917_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/224/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="为你的应用评估辅助功能标签：全面指南"><a href="#为你的应用评估辅助功能标签：全面指南" class="headerlink" title="为你的应用评估辅助功能标签：全面指南"></a>为你的应用评估辅助功能标签：全面指南</h1><p>在当今数字时代，应用的可访问性已成为衡量产品质量的重要标准。Apple推出的辅助功能营养标签为开发者提供了展示应用包容性设计的绝佳机会，同时也帮助用户快速了解应用是否满足他们的特殊需求。</p><h2 id="辅助功能营养标签的重要性"><a href="#辅助功能营养标签的重要性" class="headerlink" title="辅助功能营养标签的重要性"></a>辅助功能营养标签的重要性</h2><p>辅助功能营养标签在App Store产品页面上清晰展示应用支持的辅助功能，如”旁白”、”更大字体”、”字幕”等。这些标签不仅为用户提供了关键信息，也体现了开发者对包容性设计的重视。</p><p>要准确评估应用的辅助功能支持情况，开发者首先需要明确应用的”常规任务”。这些任务包括用户下载应用的主要功能以及基础操作流程，如首次启动体验、登录、购买和设置等。只有确保用户能够无障碍地完成所有这些常规任务，才能标注应用对某项辅助功能的支持。</p><h2 id="评估应用的无障碍性"><a href="#评估应用的无障碍性" class="headerlink" title="评估应用的无障碍性"></a>评估应用的无障碍性</h2><p>评估过程应遵循几个核心原则：</p><ol><li><p><strong>视觉设计优化</strong>：确保颜色对比度达标，支持深色模式，并避免仅通过颜色传递重要信息。Landmarks应用的案例表明，即使特意使用了高对比配色，仍可能发现某些颜色未达到最低对比标准，需要进行调整。</p></li><li><p><strong>文本可读性</strong>：应用至少应支持文本放大到默认大小的200%。使用Dynamic Type是实现这一目标的最佳方式。开发者需注意文本截断和对齐问题，确保信息获取无障碍。</p></li><li><p><strong>动效控制</strong>：为对动效敏感的用户提供支持，避免可能引起眩晕或恶心的动画效果。如果应用没有已知触发因素，可以标注支持”减弱动效”。</p></li><li><p><strong>辅助技术集成</strong>：</p><ul><li>语音控制：确保所有可触摸元素都有适当的可访问性元数据</li><li>旁白支持：让用户无需看屏幕就能操作界面，准确描述元素并提供流畅的导航体验</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：为按钮添加可访问性标签</span></span><br><span class="line"><span class="type">Button</span> &#123;</span><br><span class="line">&#125; label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;square.arrow.up&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.accessibilityLabel(<span class="string">&quot;分享&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="媒体内容无障碍性"><a href="#媒体内容无障碍性" class="headerlink" title="媒体内容无障碍性"></a>媒体内容无障碍性</h2><p>对于包含视频或音频内容的应用，需要提供：</p><ul><li>字幕：为听障用户提供对话和声音的文字描述</li><li>音频描述：在媒体主音频的间隙描述视觉内容</li></ul><p>如果应用不包含这类媒体内容，则无需标注相关支持。</p><h2 id="实施与标注"><a href="#实施与标注" class="headerlink" title="实施与标注"></a>实施与标注</h2><p>完成评估后，开发者可以在App Store Connect中为产品页面添加辅助功能营养标签，并链接到网站提供更多无障碍详情。Landmarks应用经过评估后，确认支持了足够对比度、深色界面、不依赖颜色区分、减弱动效、语音控制和旁白等功能。</p><p>值得注意的是，与需要辅助功能的用户直接合作是了解应用可访问性的最有效方法之一。”没有我们的参与，就不要做关于我们的决定”这一残障社区的理念强调了用户参与测试的重要性。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过在设计中考虑无障碍性，使用辅助功能进行评估，并在产品页面上准确标注支持的功能，开发者可以创建更具包容性的应用。这不仅扩大了潜在用户群，也体现了对多元用户需求的尊重和关怀。</p><h1 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h1><p><a href="https://developer.apple.com/videos/play/wwdc2024/10074">动态字体体验入门</a></p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p><a href="https://developer.apple.com/documentation/swiftui/view-accessibility">Accessibility</a></p><p><a href="https://developer.apple.com/design/human-interface-guidelines/accessibility">Human Interface Guidelines: Accessibility</a></p><p><a href="https://developer.apple.com/help/app-store-connect/manage-app-accessibility/overview-of-accessibility-nutrition-labels">Overview of Accessibility Nutrition Labels</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在你的 app store 产品页面上使用辅助功能标签，以突出展示你的 app 支持的辅助功能。你将了解如何评估 app 的辅助功能 (如“旁白”、“更大字体”、“字幕”等)，并选择准确且描述性的辅助功能标签。你还将了解如何在整个设计阶段解决辅助功能问题。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="辅助功能和包容性" scheme="http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>完成后台任务</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_227/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_227/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.622Z</updated>
    
    <content type="html"><![CDATA[<p>探索后台任务执行方面的最新进展，并了解系统如何进行运行时调度。我们将讨论如何充分利用后台运行时，让你的 app 既能在后台提供功能，又能保持出色的前台体验。我们还将介绍各种 api 如何为你的 app 提供后台运行时环境，以及每个 api 是怎样针对不同用例量身定制的 — 其中包括 ios 和 ipados 26 中的新 api，这些 api 让你的 app 能够在从前台过渡到后台时顺利完成任务。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9921/9921_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/227/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="后台任务处理：iOS与iPadOS-26的后台运行时优化"><a href="#后台任务处理：iOS与iPadOS-26的后台运行时优化" class="headerlink" title="后台任务处理：iOS与iPadOS 26的后台运行时优化"></a>后台任务处理：iOS与iPadOS 26的后台运行时优化</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代移动操作系统中，后台任务处理一直是开发者面临的重要挑战。iOS系统以其严格的资源管理和卓越的电池优化著称，同时也为开发者提供了多种API来实现高效且用户友好的后台功能。WWDC演讲深入探讨了iOS和iPadOS 26中后台任务处理的最新进展，特别是新引入的BGContinuedProcessingTask API，为开发者提供了更灵活的后台任务管理工具。</p><h2 id="前台与后台的运行机制"><a href="#前台与后台的运行机制" class="headerlink" title="前台与后台的运行机制"></a>前台与后台的运行机制</h2><p>当应用在前台运行时，它拥有最高优先级，可以完全访问系统资源，包括CPU、内存和网络等。此时的应用界面是设备的焦点，用户可以享受开发者精心打造的交互体验。</p><p>但当用户离开应用时，该应用便进入后台状态。默认情况下，后台应用会被系统挂起，不再占用CPU资源。这种设计有效地保护了电池寿命，维护了用户隐私，并为前台应用释放了宝贵的系统资源。然而，在某些情况下，应用可以请求后台执行时间来完成关键任务。</p><h2 id="后台任务的行为约束"><a href="#后台任务的行为约束" class="headerlink" title="后台任务的行为约束"></a>后台任务的行为约束</h2><p>iOS系统对后台任务执行设定了明确的约束和原则：</p><ol><li><strong>能耗管理</strong>：系统会在设备唤醒时合并工作，减少全天的非必要后台活动。</li><li><strong>资源优先级</strong>：前台应用享有内存、CPU时间和网络带宽的优先使用权。</li><li><strong>弹性设计</strong>：后台任务必须能够处理提前终止的情况，并保存中间状态。</li><li><strong>用户控制</strong>：用户通过低电量模式、后台应用刷新等设置影响任务调度。</li></ol><p>iOS 26还引入了更详细的电池性能分析工具，让用户能够清晰地了解各个应用对电池寿命的影响。</p><h2 id="后台任务API概述"><a href="#后台任务API概述" class="headerlink" title="后台任务API概述"></a>后台任务API概述</h2><p>iOS提供了多种后台任务API，每种都针对特定用例进行了优化：</p><h3 id="1-BGAppRefreshTask"><a href="#1-BGAppRefreshTask" class="headerlink" title="1. BGAppRefreshTask"></a>1. BGAppRefreshTask</h3><p>此API最适合用于从服务器获取最新内容。系统会根据应用使用历史智能调度这些任务，频繁使用的应用更可能获得后台运行机会。</p><p>在SwiftUI中使用BGAppRefreshTask的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import BackgroundTasks</span><br><span class="line">import SwiftUI</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">struct ColorFeed: App &#123;</span><br><span class="line">    var body: some Scene &#123;</span><br><span class="line">        WindowGroup &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">        .backgroundTask(.appRefresh(&quot;com.colorfeed.wwdc25.appRefresh&quot;)) &#123;</span><br><span class="line">            await self.handleAppRefreshTask()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-后台推送通知"><a href="#2-后台推送通知" class="headerlink" title="2. 后台推送通知"></a>2. 后台推送通知</h3><p>与BGAppRefreshTask不同，后台推送通知是由服务器触发的内容更新机制。这些通知以低优先级发送并合并处理，以减少系统开销。</p><h3 id="3-BGProcessingTask"><a href="#3-BGProcessingTask" class="headerlink" title="3. BGProcessingTask"></a>3. BGProcessingTask</h3><p>此API设计用于非时间敏感的维护工作，如运行ML模型或数据库清理。开发者可以配置任务仅在特定条件下运行（如设备充电且联网时）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import BackgroundTasks</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line">    func application(</span><br><span class="line">        _ application: UIApplication,</span><br><span class="line">        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?</span><br><span class="line">    ) -&gt; Bool &#123;</span><br><span class="line">        BGTaskScheduler.shared.register(</span><br><span class="line">            forTaskWithIdentifier: &quot;com.example.apple-samplecode.ColorFeed.db_cleaning&quot;,</span><br><span class="line">            using: nil</span><br><span class="line">        ) &#123; task in</span><br><span class="line">            self.handleAppRefresh(task: task as! BGProcessingTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func submitProcessingTaskRequest() &#123;</span><br><span class="line">        let request = BGProcessingTaskRequest(</span><br><span class="line">            identifier: &quot;com.example.apple-samplecode.ColorFeed.db_cleaning&quot;</span><br><span class="line">        )</span><br><span class="line">        request.requiresNetworkConnectivity = true</span><br><span class="line">        request.requiresExternalPower = true</span><br><span class="line">        </span><br><span class="line">        BGTaskScheduler.shared.submit(request)! </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-开始和结束后台任务"><a href="#4-开始和结束后台任务" class="headerlink" title="4. 开始和结束后台任务"></a>4. 开始和结束后台任务</h3><p>对于需要在应用转入后台时完成的关键工作（如保存状态或关闭资源），可以使用beginBackgroundTask和endBackgroundTask API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line">class AppDelegate: UIResponder, UIApplicationDelegate &#123;</span><br><span class="line">    var backgroundTaskID: UIBackgroundTaskIdentifier = .invalid</span><br><span class="line">    </span><br><span class="line">    func saveState() &#123; /*  ... */ &#125;</span><br><span class="line">    </span><br><span class="line">    func handlePersistence() &#123;</span><br><span class="line">        let app = UIApplication.shared</span><br><span class="line">        guard backgroundTaskID != .invalid else &#123; return &#125;</span><br><span class="line">        backgroundTaskID = app.beginBackgroundTask(withName: &quot;Finish Export&quot;) &#123;</span><br><span class="line">            app.endBackgroundTask(self.backgroundTaskID)</span><br><span class="line">            self.backgroundTaskID = .invalid</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.saveState()</span><br><span class="line">        </span><br><span class="line">        app.endBackgroundTask(backgroundTaskID)</span><br><span class="line">        backgroundTaskID = .invalid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS-26新特性：BGContinuedProcessingTask"><a href="#iOS-26新特性：BGContinuedProcessingTask" class="headerlink" title="iOS 26新特性：BGContinuedProcessingTask"></a>iOS 26新特性：BGContinuedProcessingTask</h2><p>iPadOS和iOS 26引入了BGContinuedProcessingTask，这是专门为支持用户发起的后台操作而设计的新API。与之前的后台任务不同，持续处理任务具有以下特点：</p><ol><li><strong>明确用户意图</strong>：每个任务必须由明确的用户动作（如按钮点击）触发</li><li><strong>可视化进度</strong>：系统提供UI展示任务进度，用户可随时取消</li><li><strong>动态标识符</strong>：支持通配符形式的动态任务标识符</li><li><strong>GPU支持</strong>：在支持的设备上可进行后台GPU处理</li></ol><h3 id="持续处理任务的实现"><a href="#持续处理任务的实现" class="headerlink" title="持续处理任务的实现"></a>持续处理任务的实现</h3><p>首先需要在Info.plist中添加任务标识符。然后通过以下代码注册和管理任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import BackgroundTasks</span><br><span class="line"></span><br><span class="line">func handleDialogConfirmation() &#123;</span><br><span class="line">    BGTaskScheduler.shared.register(&quot;com.colorfeed.wwdc25.userTask&quot;) &#123; task in</span><br><span class="line">        let task = task as! BGContinuedProcessingTask</span><br><span class="line">                                                                      </span><br><span class="line">        var shouldContinue = true</span><br><span class="line">        task.expirationHandler = &#123;</span><br><span class="line">            shouldContinue = false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task.progress.totalUnitCount = 100</span><br><span class="line">        task.progress.completedUnitCount = 0</span><br><span class="line">        </span><br><span class="line">        while shouldContinue &#123;</span><br><span class="line">            // 执行某些工作</span><br><span class="line">            task.progress.completedUnitCount += 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        task.setTaskCompleted(success: true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交持续处理任务请求时需要提供清晰的任务描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import BackgroundTasks</span><br><span class="line"></span><br><span class="line">func submitContinuedProcessingTaskRequest() &#123;</span><br><span class="line">    let request = BGContinuedProcessingTaskRequest(</span><br><span class="line">        identifier: &quot;com.colorfeed.wwdc25.userTask&quot;,</span><br><span class="line">        title: &quot;简洁标题&quot;,</span><br><span class="line">        subtitle: &quot;实用且信息丰富的副标题&quot;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    request.strategy = .fail</span><br><span class="line">    </span><br><span class="line">    BGTaskScheduler.shared.submit(request)!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者还可以指定任务提交策略：</p><ul><li>默认策略：如果不能立即运行，任务将加入队列</li><li>.fail策略：如果不能立即运行，提交将失败</li></ul><h2 id="最佳实践与总结"><a href="#最佳实践与总结" class="headerlink" title="最佳实践与总结"></a>最佳实践与总结</h2><p>为了实现高效的后台任务处理，开发者应遵循以下原则：</p><ol><li><strong>明确任务目标</strong>：确保每个后台任务只做一件事并高效完成</li><li><strong>尊重系统约束</strong>：考虑电池状态、网络条件和用户偏好</li><li><strong>弹性设计</strong>：任务应能处理中断并保存中间状态</li><li><strong>合理使用新API</strong>：BGContinuedProcessingTask最适合用户明确发起的操作</li></ol><p>iOS的后台任务API生态系统为开发者提供了丰富的工具，从简单的状态保存到复杂的持续处理任务。iOS 26引入的BGContinuedProcessingTask特别适合那些需要将前台操作平滑过渡到后台完成的使用场景，如文件导出或内容发布。</p><p>通过合理利用这些API，开发者可以创造更智能、更高效的后台体验，同时保持iOS系统一贯的流畅性和电池效率。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p><a href="https://developer.apple.com/documentation/BackgroundTasks">Background Tasks</a><br><a href="https://developer.apple.com/documentation/BackgroundTasks/performing-long-running-tasks-on-ios-and-ipados">Performing long-running tasks on iOS and iPadOS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探索后台任务执行方面的最新进展，并了解系统如何进行运行时调度。我们将讨论如何充分利用后台运行时，让你的 app 既能在后台提供功能，又能保持出色的前台体验。我们还将介绍各种 api 如何为你的 app 提供后台运行时环境，以及每个 api 是怎样针对不同用例量身定制的 — 其中包括 ios 和 ipados 26 中的新 api，这些 api 让你的 app 能够在从前台过渡到后台时顺利完成任务。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="系统服务" scheme="http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>借助 Wi-Fi Aware 增强设备连接性能</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_228/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_228/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.806Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何使用 wi-fi aware 建立对等网络连接。我们还将介绍如何以带宽更高、延迟更低的网络连接性能实时共享视频、传输大文件，以及操控配件。此外，你将了解如何借助 devicediscoveryui、accessorysetupkit 和 network 框架，在自己的 app 中使用 wi-fi aware。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9922/9922_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/228/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="通过-Wi-Fi-Aware-实现高效设备间通信"><a href="#通过-Wi-Fi-Aware-实现高效设备间通信" class="headerlink" title="通过 Wi-Fi Aware 实现高效设备间通信"></a>通过 Wi-Fi Aware 实现高效设备间通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 WWDC 演讲中，苹果详细介绍了其最新推出的 Wi-Fi Aware 框架，该技术为 iOS 设备间的点对点通信提供了全新的解决方案。Wi-Fi Aware 允许设备之间建立高带宽、低延迟的直接连接，无需依赖路由器或互联网接入点，同时保持高安全性标准。本文将深入剖析该技术的实现原理与应用场景。</p><h2 id="技术特性"><a href="#技术特性" class="headerlink" title="技术特性"></a>技术特性</h2><p>Wi-Fi Aware 技术具有以下显著优势：</p><ul><li><strong>直接通信</strong>：设备间可建立点对点连接，不依赖任何中间设备</li><li><strong>并行工作</strong>：可同时保持常规 Wi-Fi 网络连接</li><li><strong>高安全性</strong>：全链路采用认证加密机制</li><li><strong>高吞吐量</strong>：支持大文件快速传输</li><li><strong>低延迟</strong>：适合实时媒体传输场景</li></ul><p>该技术基于 Wi-Fi 联盟制定的全球标准，确保不同厂商设备间的互操作性。典型应用场景包括媒体共享、配件控制、多人协作等，这些功能可同时运行而不相互干扰。</p><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><h3 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h3><p>Wi-Fi Aware 采用服务发现机制，每个服务由特定格式的名称标识：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_</span>服务名.<span class="keyword">_</span>协议</span><br></pre></td></tr></table></figure><p>开发者需要在应用的 Info.plist 文件中声明支持的服务类型，示例如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>key<span class="operator">&gt;</span><span class="type">WiFiAwareServices</span>&lt;/key&gt;</span><br><span class="line"><span class="operator">&lt;</span>dict<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>key<span class="operator">&gt;</span>_file<span class="operator">-</span>service._tcp<span class="operator">&lt;/</span>key<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>dict<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>key<span class="operator">&gt;</span><span class="type">Publishable</span>&lt;/key&gt;</span><br><span class="line">        <span class="operator">&lt;</span><span class="literal">true</span><span class="operator">/&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>key<span class="operator">&gt;</span><span class="type">Subscribable</span>&lt;/key&gt;</span><br><span class="line">        <span class="operator">&lt;</span><span class="literal">true</span><span class="operator">/&gt;</span></span><br><span class="line">    <span class="operator">&lt;/</span>dict<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;/</span>dict<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>服务名称需遵循特定规范：不超过15个字符，仅包含字母、数字和连字符。建议在IANA注册服务名称以避免冲突。</p><h3 id="设备配对"><a href="#设备配对" class="headerlink" title="设备配对"></a>设备配对</h3><p>配对过程分为三个关键步骤：</p><ol><li>从周边设备列表中选择目标设备</li><li>输入对方显示的PIN码进行授权</li><li>系统自动完成安全配对流程</li></ol><p>苹果提供了两种配对方案：</p><ul><li><code>DeviceDiscoveryUI</code>：适用于应用间的连接场景</li><li><code>AccessorySetupKit</code>：针对硬件配件优化的配对方案，支持多协议同时配对</li></ul><p>以下是使用DeviceDiscoveryUI的代码示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布方</span></span><br><span class="line"><span class="type">DevicePairingView</span>(.wifiAware(.connecting(to: .fileService, from: .selected([])))) &#123;</span><br><span class="line">    <span class="comment">// 前置视图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅方</span></span><br><span class="line"><span class="type">DevicePicker</span>(.wifiAware(.connecting(to: .selected([]), from: .fileService))) &#123; endpoint <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 处理配对端点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p>完整的连接流程分为四个阶段：</p><ol><li>发布方启动监听服务</li><li>订阅方扫描周边可用的服务设备</li><li>系统提供可连接的端点信息</li><li>应用建立实际的网络连接</li></ol><p>关键实现代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布方监听</span></span><br><span class="line"><span class="keyword">let</span> listener <span class="operator">=</span> <span class="keyword">try</span> <span class="type">NetworkListener</span>(for: </span><br><span class="line">    .wifiAware(.connecting(to: .fileService, from: .matching(deviceFilter)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅方连接</span></span><br><span class="line"><span class="keyword">let</span> connection <span class="operator">=</span> <span class="type">NetworkConnection</span>(to: endpoint, using: .parameters &#123;</span><br><span class="line">    <span class="type">TLS</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Wi-Fi Aware 提供了精细的性能调节选项：</p><h3 id="性能模式"><a href="#性能模式" class="headerlink" title="性能模式"></a>性能模式</h3><ul><li><code>Bulk</code>：默认模式，以节能为主要目标</li><li><code>Realtime</code>：优先保证低延迟</li></ul><h3 id="服务等级"><a href="#服务等级" class="headerlink" title="服务等级"></a>服务等级</h3><ul><li><code>Background</code>：后台任务</li><li><code>BestEffort</code>：默认平衡模式</li><li><code>InteractiveVideo/Voice</code>：实时交互应用</li></ul><p>配置示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.wifiAware &#123; <span class="variable">$0</span>.performanceMode <span class="operator">=</span> .realtime &#125;</span><br><span class="line">.serviceClass(.interactiveVideo)</span><br></pre></td></tr></table></figure><p>开发者可以获取性能报告来监控连接质量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> report <span class="operator">=</span> connection.currentPath<span class="operator">?</span>.wifiAware<span class="operator">?</span>.performance</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Wi-Fi Aware 框架为 iOS 设备间的直接通信提供了标准化、高性能的解决方案。通过简单的API集成，开发者即可为应用添加高效的设备间通信能力。该技术特别适合需要高带宽、低延迟的实时交互场景，同时保证了通信过程的安全性和可靠性。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><h3 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h3><p><a href="https://developer.apple.com/videos/play/wwdc2024/10203">了解 AccessorySetupKit</a></p><h3 id="文档资源"><a href="#文档资源" class="headerlink" title="文档资源"></a>文档资源</h3><p><a href="https://developer.apple.com/documentation/WiFiAware">Wi-Fi Aware</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何使用 wi-fi aware 建立对等网络连接。我们还将介绍如何以带宽更高、延迟更低的网络连接性能实时共享视频、传输大文件，以及操控配件。此外，你将了解如何借助 devicediscoveryui、accessorysetupkit 和 network 框架，在自己的 app 中使用 wi-fi aware。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="隐私与安全" scheme="http://djs66256.github.io/tags/%E9%9A%90%E7%A7%81%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>跟着视频学编程：使用 Xcode 探索本地化</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_225/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_225/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.268Z</updated>
    
    <content type="html"><![CDATA[<p>探索如何使用 xcode 将你的 app 本地化为其他语言。我们将逐步介绍创建 string catalog、翻译文本以及与外部翻译器交换文件的流程。你将了解为翻译器提供必要语境信息的最佳实践，以及 xcode 如何帮你自动提供这类信息。对于大型项目，我们将还深入探讨使用类型安全的 swift 代码来管理复杂度并简化字符串管理的实用技巧。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9914/9914_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/225/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="WWDC-课程：使用-Xcode-进行应用程序本地化实践指南"><a href="#WWDC-课程：使用-Xcode-进行应用程序本地化实践指南" class="headerlink" title="WWDC 课程：使用 Xcode 进行应用程序本地化实践指南"></a>WWDC 课程：使用 Xcode 进行应用程序本地化实践指南</h1><p>在全球化时代，应用程序的多语言支持已成为开发者必备技能。苹果在 WWDC 上展示了如何利用 Xcode 进行高效本地化的完整流程，从基础设置到复杂项目管理，本文将为您解析这些关键技术与最佳实践。</p><h2 id="本地化基础入门"><a href="#本地化基础入门" class="headerlink" title="本地化基础入门"></a>本地化基础入门</h2><p><strong>字符串目录（String Catalog）</strong> 是 Xcode 本地化的核心工具。开发者只需通过文件菜单添加一个名为 “Localizable” 的字符串目录并将其放置在 Resources 组中，Xcode 就会在每次构建后自动发现并添加可本地化的字符串。这种自动同步机制极大地简化了本地化流程。</p><p>在代码层面，大多数 SwiftUI API 如 Text 和 Button 默认支持本地化。对于非 SwiftUI 代码，开发者可以使用 <code>String(localized:)</code> 方法。示例代码展示了典型用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Featured Landmark&quot;</span>, comment: <span class="string">&quot;英雄图片中特色地标的大标题&quot;</span>)</span><br><span class="line"><span class="type">Button</span>(<span class="string">&quot;Keep&quot;</span>) &#123; &#125;</span><br><span class="line"><span class="type">String</span>(localized: <span class="string">&quot;New Collection&quot;</span>, comment: <span class="string">&quot;用户新建收藏的默认名称&quot;</span>)</span><br></pre></td></tr></table></figure><p>当涉及复数形式时，Xcode 提供了便捷的处理方式。开发者只需在字符串目录中选择”按复数变化”，即可分别设置单数和复数形式的翻译，系统会根据数量自动选择正确的显示形式。</p><h2 id="多语言协作流程"><a href="#多语言协作流程" class="headerlink" title="多语言协作流程"></a>多语言协作流程</h2><p>添加新语言只需点击字符串目录底部的加号按钮并选择目标语言（如德语）。开发者可以直接在目录中进行翻译，翻译完成后状态会从 NEW 变为 TRANSLATED。</p><p>对于专业翻译工作，Xcode 支持导出标准 XLIFF 格式文件。通过产品菜单的”导出本地化”功能，开发者可以生成包含所有待翻译字符串的文件包。翻译完成后，通过”导入本地化”功能即可将翻译结果导入项目。</p><p>测试特定语言版本时，开发者可以在方案编辑器的”运行 &gt; 选项”中将应用程序语言更改为目标语言（如德语）进行调试运行。</p><h2 id="翻译上下文优化"><a href="#翻译上下文优化" class="headerlink" title="翻译上下文优化"></a>翻译上下文优化</h2><p><strong>高质量的翻译依赖于充分的上下文</strong>。Xcode 提供了两种添加注释的方式：</p><ol><li><p>在代码中直接添加：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Delete&quot;</span>, comment: <span class="string">&quot;确认删除收藏的警报中显示的删除按钮&quot;</span>)</span><br><span class="line"><span class="type">String</span>(localized: <span class="string">&quot;Shared by Friends&quot;</span>, comment: <span class="string">&quot;朋友分享的帖子副标题&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>在字符串目录的注释列中添加</p></li></ol><p>Xcode 26 引入了<strong>自动注释生成</strong>功能，使用设备端模型分析代码并生成注释。开发者可以：</p><ul><li>对未注释的字符串使用”生成注释”上下文菜单选项</li><li>在设置中启用”自动生成字符串目录注释”以实现自动化</li></ul><p>注释应包含：</p><ul><li>界面元素类型（按钮、选项卡等）</li><li>周边UI环境描述</li><li>占位符内容解释</li></ul><p>生成的注释会被标注为”auto-generated”并包含在导出的XLIFF文件中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trans-unit</span> <span class="attr">id</span>=<span class="string">&quot;Grand Canyon&quot;</span> <span class="attr">xml:space</span>=<span class="string">&quot;preserve&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span>Grand Canyon<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">state</span>=<span class="string">&quot;new&quot;</span>&gt;</span>Grand Canyon<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">note</span> <span class="attr">from</span>=<span class="string">&quot;auto-generated&quot;</span>&gt;</span>地标搜索建议<span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trans-unit</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="大规模项目管理策略"><a href="#大规模项目管理策略" class="headerlink" title="大规模项目管理策略"></a>大规模项目管理策略</h2><p>当项目涉及多个模块时，<strong>bundle参数</strong>变得至关重要：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主应用</span></span><br><span class="line"><span class="type">Text</span>(<span class="string">&quot;My Collections&quot;</span>, comment: <span class="string">&quot;用户创建收藏的上方章节标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架/包</span></span><br><span class="line"><span class="type">Text</span>(<span class="string">&quot;My Collections&quot;</span>, bundle: #bundle, comment: <span class="string">&quot;用户创建收藏的上方章节标题&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>#bundle</code> 宏是Xcode的新功能，它能自动识别当前目标的资源包，兼容旧系统且无需开发者手动处理。</p><p><strong>字符串分组</strong>可以通过tableName参数实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;My Collections&quot;</span>, tableName: <span class="string">&quot;Discover&quot;</span>, comment: <span class="string">&quot;用户创建收藏的上方章节标题&quot;</span>)</span><br></pre></td></tr></table></figure><p>这会将字符串组织到指定的”Discover.xcstrings”目录中。建议按功能或屏幕分组字符串以提高可维护性。</p><h2 id="类型安全字符串管理"><a href="#类型安全字符串管理" class="headerlink" title="类型安全字符串管理"></a>类型安全字符串管理</h2><p>Xcode 26 引入了<strong>符号生成</strong>工作流程，开发者可以：</p><ol><li>手动添加字符串键值对</li><li>使用生成的类型安全符号引用字符串：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationSubtitle(.subtitle(friendsPosts: <span class="number">42</span>))</span><br></pre></td></tr></table></figure></li></ol><p>该功能特点包括：</p><ul><li>自动根据键和值生成Swift符号</li><li>对含占位符的字符串生成带参数标签的函数</li><li>生成的符号是LocalizedStringResource类型</li><li>支持SwiftUI视图、修饰符和Foundation API</li></ul><p>开发者可以通过构建设置”Generate String Catalog Symbols”启用此功能。Xcode还提供重构工具，可在提取字符串和符号引用两种工作流间轻松转换。</p><h2 id="工作流程选择建议"><a href="#工作流程选择建议" class="headerlink" title="工作流程选择建议"></a>工作流程选择建议</h2><p>苹果推荐：</p><ol><li><strong>初期开发</strong>：优先使用字符串提取工作流，便于快速迭代和理解代码</li><li><strong>项目成熟</strong>：考虑转向符号引用，获得更好的组织控制和类型安全</li><li><strong>大型项目</strong>：结合使用分组(tableName)、模块化(#bundle)和符号生成</li></ol><p>两种工作流各有优势，开发者应根据项目需求灵活选择。Xcode的重构功能使两者间的转换变得简单可靠。</p><h2 id="扩展学习资源"><a href="#扩展学习资源" class="headerlink" title="扩展学习资源"></a>扩展学习资源</h2><p>想深入了解字符串目录的更多细节，可以参考WWDC视频：<br><a href="https://developer.apple.com/videos/play/wwdc2023/10155">探索字符串目录</a></p><p>通过掌握这些本地化技术和工具，开发者可以构建真正全球化的应用程序，为世界各地的用户提供优质的本地体验。Xcode不断进化的本地化功能，正使这一过程变得更加高效和可靠。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探索如何使用 xcode 将你的 app 本地化为其他语言。我们将逐步介绍创建 string catalog、翻译文本以及与外部翻译器交换文件的流程。你将了解为翻译器提供必要语境信息的最佳实践，以及 xcode 如何帮你自动提供这类信息。对于大型项目，我们将还深入探讨使用类型安全的 swift 代码来管理复杂度并简化字符串管理的实用技巧。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="开发者工具" scheme="http://djs66256.github.io/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>让所有人都能更方便地使用你的 Mac App</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_229/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_229/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.794Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何整合那些可充分利用 macos 强大功能和灵活性的辅助功能。深入探索如何支持“旁白”和“语音控制”，如何改进视图的布局，以及辅助技术如何导航你的内容，等等。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9918/9918_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/229/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="让你的-Mac-应用对所有人都更易用：深入无障碍功能开发指南"><a href="#让你的-Mac-应用对所有人都更易用：深入无障碍功能开发指南" class="headerlink" title="让你的 Mac 应用对所有人都更易用：深入无障碍功能开发指南"></a>让你的 Mac 应用对所有人都更易用：深入无障碍功能开发指南</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在当今数字时代，确保应用对所有用户都具有可访问性已成为开发者的重要责任。WWDC 2024 演讲中，无障碍团队工程师 Nicholas 分享了如何充分利用 macOS 的强大功能和灵活性，将无障碍特性深度整合到 Mac 应用的开发中。本文将详细介绍这些专业技巧，帮助开发者创建更友好的应用体验。</p><h2 id="布局优化：构建高效的无障碍元素结构"><a href="#布局优化：构建高效的无障碍元素结构" class="headerlink" title="布局优化：构建高效的无障碍元素结构"></a>布局优化：构建高效的无障碍元素结构</h2><p>Mac 应用通常设计用于键盘和鼠标交互，具有密集的用户界面和强大的多任务处理能力。这些特性带来了独特的无障碍考量要点。SwiftUI 将应用中的各个视图呈现为无障碍元素，这些元素包含无障碍技术理解和与应用交互所需的关键信息。</p><p>旁白(VoiceOver)作为 macOS 内置的屏幕阅读器，能够将应用界面转化为语音或盲文输出。Mac 上的旁白主要通过键盘快捷键控制，用户可以通过快捷键在元素间移动。为了优化旁白导航体验，SwiftUI 提供了将无障碍元素分组到容器的功能。</p><p>开发者需要注意，Mac 上的容器通常包含嵌套容器，形成树状的无障碍元素结构。合理地将相关元素分组到容器中可以使旁白导航更高效，但过多的嵌套层级反而会降低使用体验。</p><p>SwiftUI 提供了三种主要的行为选项来优化容器：</p><ol><li><strong>包含子视图</strong>(<code>.contain</code>)：将子视图包含在无障碍容器中</li><li><strong>合并子视图</strong>(<code>.combine</code>)：将子视图合并为一个无障碍元素</li><li><strong>忽略子视图</strong>(<code>.ignore</code>)：从无障碍中隐藏子视图</li></ol><p>通过合理使用这些选项，开发者可以显著改善旁白用户的导航体验。例如，在文本编辑应用中，可以将样式预设视图分组为容器，避免用户必须遍历每个预设才能到达下一个功能区。</p><h2 id="导航增强：转子与焦点管理"><a href="#导航增强：转子与焦点管理" class="headerlink" title="导航增强：转子与焦点管理"></a>导航增强：转子与焦点管理</h2><p>优化应用的无障碍结构后，进一步改善导航体验的方法是利用转子和焦点管理功能。转子是旁白的重要功能，它允许用户定义应用中的视图或文本范围集合，实现快速导航。</p><p>在文本编辑应用的例子中，可以创建专门的书签转子，让旁白用户能够直接跳转到书签页面，而无需遍历每个页面检查是否有书签标记。这种设计实现了与视觉用户相似的便捷体验。</p><p>macOS 和 iOS 26 还引入了<code>accessibilityDefaultFocus</code>修饰符，允许应用为旁白等无障碍技术建议初始焦点位置。开发者可以使用<code>AccessibilityFocusState</code>属性包装器来管理旁白焦点状态，确保用户首次进入应用时能够直接访问最重要的内容。</p><h2 id="交互优化：超越鼠标与触控板"><a href="#交互优化：超越鼠标与触控板" class="headerlink" title="交互优化：超越鼠标与触控板"></a>交互优化：超越鼠标与触控板</h2><p>确保所有交互方式对所有用户都可用是开发无障碍应用的关键。许多 Mac 应用依赖鼠标悬停或触控板手势来触发特定功能，但这些交互方式对某些用户可能不可行。</p><p>针对这种情况，SwiftUI 提供了替代的交互实现方式。例如，可以为悬停显示的按钮添加无障碍动作，确保使用旁白的用户也能执行相同功能。开发者应该为应用中的常见任务添加快捷键，这不仅提升了高级用户的工作效率，也为无法使用鼠标的用户提供了替代交互方式。</p><p>对于自定义控件，开发者需要特别注意为其提供完整的无障碍信息。标准的 SwiftUI 控件通常已内置无障碍支持，但自定义控件可能需要额外的工作才能确保良好的可访问性。</p><h2 id="结论与后续资源"><a href="#结论与后续资源" class="headerlink" title="结论与后续资源"></a>结论与后续资源</h2><p>通过优化布局结构、增强导航体验和完善交互方式，开发者可以显著提升 Mac 应用的无障碍性。演讲中建议开发者使用旁白测试自己的应用，研究可以添加自定义转子的地方，并通过无障碍营养标签展示应用的无障碍特性。</p><p>如需深入了解相关内容，可以参考以下资源：</p><p>相关视频：<br><a href="https://developer.apple.com/videos/play/wwdc2024/10073">了解 SwiftUI 中的辅助功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2021/10119">SwiftUI 辅助功能：超越基础功能</a></p><p>文档：<br><a href="https://developer.apple.com/documentation/swiftui/view-accessibility">Accessibility</a><br><a href="https://developer.apple.com/design/human-interface-guidelines/accessibility">Human Interface Guidelines: Accessibility</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何整合那些可充分利用 macos 强大功能和灵活性的辅助功能。深入探索如何支持“旁白”和“语音控制”，如何改进视图的布局，以及辅助技术如何导航你的内容，等等。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="辅助功能和包容性" scheme="http://djs66256.github.io/tags/%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD%E5%92%8C%E5%8C%85%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>分析并优化 App 的功耗</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_226/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_226/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.609Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何优化你的 app，以充分延长电池续航时间。探索如何查明 app 功耗问题的根本原因，无论是在连接到 xcode 时还是出行期间遇到这类问题，都可以查明。了解如何测量功耗，以便你可以就新功能做出更明智的决策，并主动构建更高效的 app。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9920/9920_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/226/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="分析与优化应用的功耗"><a href="#分析与优化应用的功耗" class="headerlink" title="分析与优化应用的功耗"></a>分析与优化应用的功耗</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现代移动应用开发中，功耗优化是保证用户体验的关键因素之一。苹果公司软件工程师 Wiam 在本次演讲中分享了如何利用工具和技术来分析和优化应用的功耗表现。本文将详细介绍如何识别、诊断和解决应用功耗问题，帮助开发者构建更高效节能的应用程序。</p><h2 id="调试可复现的问题"><a href="#调试可复现的问题" class="headerlink" title="调试可复现的问题"></a>调试可复现的问题</h2><h3 id="发现功耗问题"><a href="#发现功耗问题" class="headerlink" title="发现功耗问题"></a>发现功耗问题</h3><p>开发者常常会遇到这样的情况：在Xcode的能耗报告中发现CPU使用率突然上升，导致性能下降和电池续航缩短。演讲中使用的案例是一款名为Destination Video的视频流应用，在添加Library面板功能后出现了明显的性能退化。</p><h3 id="使用Power-Profiler工具"><a href="#使用Power-Profiler工具" class="headerlink" title="使用Power Profiler工具"></a>使用Power Profiler工具</h3><p>Instruments中的Power Profiler是分析这类问题的理想工具。它允许开发者在应用运行时记录功耗轨迹，并进行可视化分析。使用步骤包括：</p><ol><li>无线连接iPhone设备</li><li>通过Xcode的Product菜单选择Profile</li><li>在Instruments中选择空白模板并勾选Power Profiler和CPU Profiler</li><li>开始录制并重现问题场景</li></ol><h3 id="分析功耗数据"><a href="#分析功耗数据" class="headerlink" title="分析功耗数据"></a>分析功耗数据</h3><p>Power Profiler提供两个关键指标：</p><ol><li>系统功耗使用轨道：显示整体能耗情况</li><li>应用级功耗影响指标：包括CPU、GPU、显示和网络等子系统的功耗影响</li></ol><p>在案例中，当打开Library面板时，CPU功耗影响从平均1跃升至21，这表明存在严重的CPU性能问题。</p><h3 id="定位问题根源"><a href="#定位问题根源" class="headerlink" title="定位问题根源"></a>定位问题根源</h3><p>通过CPU Profiler的Call Tree视图，分析显示大量时间花费在VideoCardView上。进一步检查发现LibraryThumbnailView为每个视频生成并加载所有缩略图视图，无论它们是否可见。这种实现方式导致了不必要的CPU负载。</p><h3 id="优化解决方案"><a href="#优化解决方案" class="headerlink" title="优化解决方案"></a>优化解决方案</h3><p>使用SwiftUI的LazyVStack替代普通VStack，实现了按需加载和渲染。优化后：</p><ul><li>应用响应速度提升</li><li>CPU功耗影响从21降至4.3</li><li>解决了性能退化问题</li></ul><h2 id="发现隐藏问题"><a href="#发现隐藏问题" class="headerlink" title="发现隐藏问题"></a>发现隐藏问题</h2><h3 id="真实场景中的功耗问题"><a href="#真实场景中的功耗问题" class="headerlink" title="真实场景中的功耗问题"></a>真实场景中的功耗问题</h3><p>有些问题在开发环境中难以复现，比如：</p><ul><li>CarPlay导航中的真实行为</li><li>AR功能的户外电力消耗</li><li>数小时后才出现的后台电池问题</li></ul><h3 id="设备端功耗分析"><a href="#设备端功耗分析" class="headerlink" title="设备端功耗分析"></a>设备端功耗分析</h3><p>Power Profiler支持在不连接Xcode的情况下收集数据：</p><ol><li>在设备设置中开启开发者模式</li><li>进入开发者设置的Performance Trace</li><li>启用Power Profiler并选择要分析的应用</li><li>通过控制中心开始/停止录制</li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>在Destination Video应用中，用户报告了严重的电池问题。通过收集的设备日志分析发现：</p><ul><li>CPU功耗呈现周期性波动</li><li>主要消耗源是videoSuggestionsForLocation函数</li><li>该函数在位置变化时频繁执行</li></ul><p>问题根源在于：</p><ol><li>每次位置变化都重新读取和解析JSON规则文件</li><li>文件I/O和JSON解析是资源密集型操作</li></ol><p>优化方案是懒加载并缓存规则数据，避免重复处理。</p><h2 id="比较功耗使用"><a href="#比较功耗使用" class="headerlink" title="比较功耗使用"></a>比较功耗使用</h2><h3 id="优化策略的选择"><a href="#优化策略的选择" class="headerlink" title="优化策略的选择"></a>优化策略的选择</h3><p>在发布前，开发者经常面临不同优化方案的选择。Power Profiler的比较功能可以帮助：</p><ol><li>分析不同实现方案的功耗影响</li><li>评估权衡因素（如CPU vs网络活动）</li><li>确定最优解决方案</li></ol><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><ol><li>分别分析不同方法的功耗数据</li><li>考虑温度、设备状态和系统压力等影响因素</li><li>在典型使用条件下进行测试</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过系统化的功耗分析和优化方法，开发者可以显著提升应用的电池使用效率。Power Profiler工具提供了从开发环境到真实场景的全面分析能力，帮助开发者：</p><ul><li>快速定位功耗问题根源</li><li>验证优化效果</li><li>选择最佳实现方案</li></ul><p>最终目标是构建既功能强大又高效节能的应用，为用户提供持久的优质体验。</p><h2 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h2><p><a href="https://developer.apple.com/videos/play/wwdc2023/10218/">通过 Instruments 优化 CPU 性能</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何优化你的 app，以充分延长电池续航时间。探索如何查明 app 功耗问题的根本原因，无论是在连接到 xcode 时还是出行期间遇到这类问题，都可以查明。了解如何测量功耗，以便你可以就新功能做出更明智的决策，并主动构建更高效的 app。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="系统服务" scheme="http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>借助 NetworkExtension 优化网络流量过滤和隧道</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_234/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_234/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.610Z</updated>
    
    <content type="html"><![CDATA[<p>了解 networkextension 框架中提供的 api，这些 api 让你的 app 能够灵活地扩展系统的核心网络功能 — 例如实现网络内容过滤器、创建和管理 vpn 配置等。在 ios、ipados 和 macos 26 中，你现在可以构建更为强大的内容过滤器，让它根据整个 url (而不仅是主机名) 来做出流量决策，同时确保隐私和安全丝毫不受影响。我们将首先简要介绍 networkextension 框架的一些主要用例，包括网络中继和 vpn。然后，我们将深入探讨这一全新的 url 过滤器 api 及其关键组件，包括 private information retrieval、privacy pass 等。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9924/9924_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/234/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="利用-NetworkExtension-优化网络流量过滤与隧道技术"><a href="#利用-NetworkExtension-优化网络流量过滤与隧道技术" class="headerlink" title="利用 NetworkExtension 优化网络流量过滤与隧道技术"></a>利用 NetworkExtension 优化网络流量过滤与隧道技术</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NetworkExtension 框架为开发者提供了一系列强大的 API，用于扩展和定制 Apple 平台的核心网络功能。在 iOS、iPadOS 和 macOS 26 中，该框架引入了全新的 URL 过滤器 API，使得开发者能够基于完整 URL 而不仅仅是主机名来进行流量过滤决策，同时确保了用户的隐私和安全。</p><h2 id="NetworkExtension-框架简介"><a href="#NetworkExtension-框架简介" class="headerlink" title="NetworkExtension 框架简介"></a>NetworkExtension 框架简介</h2><p>NetworkExtension 是一个功能丰富的框架，允许开发者构建能够扩展和定制 Apple 平台网络能力的应用。该框架与整个网络堆栈紧密集成，包括 Network 框架、CFNetwork、WebKit 和 Sockets API，同时也与系统级组件如路由、流量策略和各类系统管理深度整合。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>NetworkExtension 框架支持多种网络定制方式：</p><ul><li><strong>Wi-Fi 管理和热点 API</strong>（仅 iOS）：允许应用配置 Wi-Fi 设置并与 Wi-Fi 热点交互</li><li><strong>本地推送 API</strong>：适用于无法访问 Apple 推送通知服务的网络环境</li><li><strong>DNS 配置和代理 API</strong>：用于构建保护 DNS 流量免受攻击的安全应用</li><li><strong>透明代理 API</strong>（仅 macOS）：可将特定网站流量重定向至云端安全服务</li><li><strong>远程资源安全访问</strong>：通过隧道技术保护网络流量</li><li><strong>内容过滤</strong>：实现对网络流量的监控和过滤</li></ul><h2 id="远程资源访问技术"><a href="#远程资源访问技术" class="headerlink" title="远程资源访问技术"></a>远程资源访问技术</h2><p>NetworkExtension 提供了两种主要的方法来实现安全的远程资源访问：</p><h3 id="网络中继"><a href="#网络中继" class="headerlink" title="网络中继"></a>网络中继</h3><p>网络中继适合需要隧道传输 TCP 或 UDP 流量以访问特定应用的场景。MASQUE 协议提供了安全代理且性能优化，平台内置支持无需额外扩展。</p><h3 id="基于-IP-的-VPN"><a href="#基于-IP-的-VPN" class="headerlink" title="基于 IP 的 VPN"></a>基于 IP 的 VPN</h3><p>IP VPN 适合企业将公司网络扩展至远程员工，或高安全要求的组织需要将所有管理设备流量通过企业网络传输。</p><p>开发者可以通过以下方式创建 IP VPN 隧道：</p><ul><li>使用 NEVPNManager API 内置协议（IKEv2/IPsec）</li><li>使用 NEPacketTunnelProvider 实现自定义隧道协议</li></ul><p><strong>重要注意事项</strong>：</p><ul><li>NetworkExtension 是构建 VPN 应用的唯一官方支持 API</li><li>禁止使用 Packet Filter 或直接修改 Mac 路由表</li><li>NEPacketTunnelProvider 仅应用于 IP 层流量隧道传输</li></ul><h2 id="内容过滤技术"><a href="#内容过滤技术" class="headerlink" title="内容过滤技术"></a>内容过滤技术</h2><p>NetworkExtension 的内容过滤 API 允许开发者检查设备流量进行监控或过滤决策。传统的内容过滤器存在以下局限：</p><ul><li>只能基于流量级信息（如主机和端口）做决策</li><li>HTTPS 加密导致无法获取 URL 详细内容</li><li>无法精准过滤特定资源</li></ul><h2 id="iOS-26-全新-URL-过滤器"><a href="#iOS-26-全新-URL-过滤器" class="headerlink" title="iOS 26 全新 URL 过滤器"></a>iOS 26 全新 URL 过滤器</h2><p>iOS 26 引入了全新的 URL 过滤器功能，允许基于完整 URL 进行内容过滤决策。该技术具有以下特点：</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>家长控制应用屏蔽有害网站</li><li>学校应用限制社交媒体/赌博等内容</li><li>企业屏蔽与工作无关的内容</li></ul><h3 id="隐私保护设计"><a href="#隐私保护设计" class="headerlink" title="隐私保护设计"></a>隐私保护设计</h3><ul><li>采用最先进加密技术</li><li>URL 敏感信息不会泄露给应用</li><li>后端服务器查询完全匿名化</li><li>Apple 和服务器都无法获取内容与身份信息</li></ul><h3 id="技术实现四大支柱"><a href="#技术实现四大支柱" class="headerlink" title="技术实现四大支柱"></a>技术实现四大支柱</h3><ol><li><strong>Bloom 过滤器</strong>：快速预过滤（可能假阳性但无假阴性）</li><li><strong>私有信息检索 (PIR)</strong>：使用同态加密实现加密查询</li><li><strong>隐私通行证 (Privacy Pass)</strong>：匿名认证机制</li><li><strong>无感 HTTP 中继 (Oblivious HTTP Relay)</strong>：隐藏客户端 IP 地址</li></ol><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>开发者可以通过以下步骤实现 URL 过滤器：</p><ol><li><strong>设置 PIR 服务器</strong></li><li><strong>构建 Bloom 过滤器</strong></li><li><strong>构建 URL 过滤应用</strong></li><li><strong>构建应用扩展</strong></li></ol><p>示例代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">NEURLFilterManager</span>.shared</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">await</span> manager.loadFromPreferences()</span><br><span class="line"><span class="keyword">try</span> manager.setConfiguration(</span><br><span class="line">    pirServerURL: <span class="type">URL</span>(string:<span class="string">&quot;https://pir.example.com&quot;</span>)<span class="operator">!</span>,</span><br><span class="line">    pirPrivacyPassIssuerURL: <span class="type">URL</span>(string:<span class="string">&quot;https://privacypass.example.com&quot;</span>)<span class="operator">!</span>,</span><br><span class="line">    pirAuthenticationToken: <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">    controlProviderBundleIdentifier: <span class="string">&quot;com.example.myURLFilter.extension&quot;</span>)</span><br><span class="line">manager.prefilterFetchInterval <span class="operator">=</span> <span class="number">86400</span> <span class="comment">// 每日更新</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NetworkExtension 框架为开发者提供了强大的工具，使其能够：</p><ul><li>使用网络中继安全访问 TCP/UDP 流量</li><li>构建完整的 VPN 解决方案</li><li>通过 URL 过滤 API 创建强大的内容过滤器</li></ul><p>开发者可以立即查看相关示例和文档开始开发工作。</p><h2 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h2><p><a href="https://developer.apple.com/videos/play/wwdc2025/246">将隐私保护融入开发流程</a><br><a href="https://developer.apple.com/videos/play/wwdc2019/714">适用于现代 Mac 的网络扩展</a></p><h2 id="文档资源"><a href="#文档资源" class="headerlink" title="文档资源"></a>文档资源</h2><p><a href="https://developer.apple.com/documentation/NetworkExtension/filtering-traffic-by-url">按 URL 过滤流量</a><br><a href="https://developer.apple.com/documentation/NetworkExtension/NEHotspotManager">NEHotspotManager</a><br><a href="https://developer.apple.com/documentation/NetworkExtension">Network Extension</a><br><a href="https://developer.apple.com/documentation/NetworkExtension/NEURLFilterManager">NEURLFilterManager</a><br><a href="https://swiftpackageindex.com/apple/pir-service-example/main/documentation/pirservice">PIRService</a><br><a href="https://developer.apple.com/documentation/Technotes/tn3120-expected-use-cases-for-network-extension-packet-tunnel-providers">TN3120：网络扩展包隧道提供商的预期用例</a><br><a href="https://developer.apple.com/documentation/Technotes/tn3165-packet-filter-is-not-api">TN3165：包过滤器不是 API</a><br><a href="https://developer.apple.com/documentation/NetworkExtension/NEURLFilter/verdict(for:">verdict(for:)</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 networkextension 框架中提供的 api，这些 api 让你的 app 能够灵活地扩展系统的核心网络功能 — 例如实现网络内容过滤器、创建和管理 vpn 配置等。在 ios、ipados 和 macos 26 中，你现在可以构建更为强大的内容过滤器，让它根据整个 url (而不仅是主机名) 来做出流量决策，同时确保隐私和安全丝毫不受影响。我们将首先简要介绍 networkextension 框架的一些主要用例，包括网络中继和 vpn。然后，我们将深入探讨这一全新的 url 过滤器 api 及其关键组件，包括 private information retrieval、privacy pass 等。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="tvos" scheme="http://djs66256.github.io/tags/tvos/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="watchos" scheme="http://djs66256.github.io/tags/watchos/"/>
    
      <category term="系统服务" scheme="http://djs66256.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>空间网页的新功能</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_237/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_237/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.577Z</updated>
    
    <content type="html"><![CDATA[<p>了解 visionos 26 上适用于网页的最新空间功能。我们将介绍如何使用全新的 html 模型元素来显示内联 3d 模型。我们还将分享模型照明、交互和动画等强大功能。了解如何在你的网站上嵌入新支持的沉浸式媒体，例如 360 度视频和 apple 沉浸视频。另外，你还将抢先体验如何在网页中添加自定环境。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9935/9935_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/237/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="空间网页新功能：visionOS-26带来HTML模型元素与沉浸式体验"><a href="#空间网页新功能：visionOS-26带来HTML模型元素与沉浸式体验" class="headerlink" title="空间网页新功能：visionOS 26带来HTML模型元素与沉浸式体验"></a>空间网页新功能：visionOS 26带来HTML模型元素与沉浸式体验</h1><p>随着visionOS 26的发布，网页开发领域迎来了突破性的空间计算功能。这些创新技术将彻底改变用户在Web上浏览3D内容和沉浸式媒体的体验。</p><h2 id="3D模型嵌入的革命"><a href="#3D模型嵌入的革命" class="headerlink" title="3D模型嵌入的革命"></a>3D模型嵌入的革命</h2><p>传统的HTML Image元素在网页上展示二维图片已有数十年历史，而全新的HTML Model元素开启了3D内容展示的新篇章。这一标准提案经过多年发展，现在被visionOS的Safari浏览器原生支持。</p><h3 id="基础实现与准备工作"><a href="#基础实现与准备工作" class="headerlink" title="基础实现与准备工作"></a>基础实现与准备工作</h3><p>开发者可以通过简单的标记语言将3D模型嵌入网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">src</span>=<span class="string">&quot;teapot.usdz&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现这一功能首先需要准备USDZ格式的3D模型文件。获取途径包括：</p><ul><li>使用iPhone的Reality Composer应用或Object Capture API捕捉实物对象</li><li>通过macOS的Preview或命令行工具转换现有3D模型</li><li>使用专业3D软件如Blender、Houdini导出</li></ul><h3 id="技术细节与优化技巧"><a href="#技术细节与优化技巧" class="headerlink" title="技术细节与优化技巧"></a>技术细节与优化技巧</h3><p>为提升兼容性和性能表现，开发者可采用以下优化策略：</p><p><strong>服务器配置</strong>需正确识别USDZ文件类型：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NGINX mime.types配置</span></span><br><span class="line"><span class="section">types</span> &#123;</span><br><span class="line">  model/vnd.usdz+<span class="attribute">zip</span> usdz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>渐进增强策略</strong>可确保在不同设备上提供适当体验：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">src</span>=<span class="string">&quot;camera.usdz&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;camera.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;相机模型&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript检测支持情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">HTMLModelElement</span>) &#123;</span><br><span class="line">  <span class="comment">// 浏览器支持Model元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级渲染与交互功能"><a href="#高级渲染与交互功能" class="headerlink" title="高级渲染与交互功能"></a>高级渲染与交互功能</h3><p>模型元素支持立体渲染，用户可直接感知对象深度。通过环境光照设置可获得更真实的视觉效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">src</span>=<span class="string">&quot;camera.usdz&quot;</span> <span class="attr">environmentmap</span>=<span class="string">&quot;sunset.exr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br></pre></td></tr></table></figure><p>交互功能方面，开发者可以：</p><ul><li>启用内联旋转功能：<code>stagemode=&quot;orbit&quot;</code></li><li>通过JavaScript控制模型变换</li><li>管理内置动画播放</li></ul><h2 id="沉浸式媒体体验升级"><a href="#沉浸式媒体体验升级" class="headerlink" title="沉浸式媒体体验升级"></a>沉浸式媒体体验升级</h2><p>visionOS 26扩展了沉浸式媒体支持范围，包括：</p><ul><li>空间视频</li><li>180/360度视频</li><li>Apple沉浸式视频</li></ul><p>实现方式与传统视频元素一致：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;spatial_video.mov&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全景和空间照片新增<code>controls</code>属性，引导用户进入全屏沉浸体验：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;spatial.heic&quot;</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">controls</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="开发者预览：网站环境"><a href="#开发者预览：网站环境" class="headerlink" title="开发者预览：网站环境"></a>开发者预览：网站环境</h2><p>创新的网站环境功能允许开发者指定USDZ作为虚拟背景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;spatial-backdrop&quot;</span> <span class="attr">href</span>=<span class="string">&quot;office.usdz&quot;</span> <span class="attr">environmentmap</span>=<span class="string">&quot;lighting.hdr&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用户可通过页面菜单或数码表冠控制环境展示程度。</p><h2 id="技术展望与学习资源"><a href="#技术展望与学习资源" class="headerlink" title="技术展望与学习资源"></a>技术展望与学习资源</h2><p>这些新功能为Web开发开辟了全新可能。开发者可访问webkit.org查看具体示例，并通过Vision Pro设备亲身体验效果。随着空间计算技术的发展，网页体验正迈向更具沉浸感和交互性的未来。</p><p>相关视频：<br><a href="https://developer.apple.com/videos/play/wwdc2025/297">了解 Apple Projected Media Profile</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/304">探索 visionOS 的视频体验</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/296">支持 visionOS App 播放沉浸视频</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/233">Safari 浏览器和 WebKit 的新功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10087">为你的沉浸式 visionOS App 创建自定环境</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10086">探索 USD 生态系统</a><br><a href="https://developer.apple.com/videos/play/wwdc2023/10083">认识 Reality Composer Pro</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 visionos 26 上适用于网页的最新空间功能。我们将介绍如何使用全新的 html 模型元素来显示内联 3d 模型。我们还将分享模型照明、交互和动画等强大功能。了解如何在你的网站上嵌入新支持的沉浸式媒体，例如 360 度视频和 apple 沉浸视频。另外，你还将抢先体验如何在网页中添加自定环境。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="visionos" scheme="http://djs66256.github.io/tags/visionos/"/>
    
      <category term="空间计算" scheme="http://djs66256.github.io/tags/%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>了解 App Intents</title>
    <link href="http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_244/"/>
    <id>http://djs66256.github.io/2025/06/10/2025-06-10-wwdc2025_244/</id>
    <published>2025-06-10T13:46:48.000Z</published>
    <updated>2025-06-10T13:46:48.351Z</updated>
    
    <content type="html"><![CDATA[<p>了解 app intents 框架及其在 apple 开发者平台中愈显关键的作用。我们将向你全面介绍意图、实体、查询等核心概念。你将了解如何综合运用这些概念，以便使你的 app 与 apple 设备 (从“聚焦”和“快捷指令”等软件功能到操作按钮等硬件功能) 实现整合。我们还将介绍如何将 app intents 作为你 app 的入口，以便将来实现与 apple 智能的整合。<br><span id="more"></span></p><p><img src="https://devimages-cdn.apple.com/wwdc-services/images/3055294D-836B-4513-B7B0-0BC5666246B0/9971/9971_wide_250x141_2x.jpg" alt="视频封面"><br><a href="https://developer.apple.com/cn/videos/play/wwdc2025/244/">视频地址</a></p><blockquote><p>此文章由AI生成，可能存在错误，如有问题，请联系<a href="djs66256@163.com">djs66256@163.com</a></p></blockquote><h1 id="深度解析-App-Intents：打造全系统可用的应用功能"><a href="#深度解析-App-Intents：打造全系统可用的应用功能" class="headerlink" title="深度解析 App Intents：打造全系统可用的应用功能"></a>深度解析 App Intents：打造全系统可用的应用功能</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>App Intents 框架作为 Apple 开发者生态中的重要组成部分，正在为应用带来前所未有的系统级集成能力。本文将详细解析该框架的核心概念与实现方法，帮助开发者理解如何通过 App Intents 让应用功能突破自身边界，融入整个 Apple 生态系统。</p><h2 id="App-Intents-核心概念"><a href="#App-Intents-核心概念" class="headerlink" title="App Intents 核心概念"></a>App Intents 核心概念</h2><h3 id="框架定位与价值"><a href="#框架定位与价值" class="headerlink" title="框架定位与价值"></a>框架定位与价值</h3><p>App Intents 不仅仅是一个功能构建框架，更是一个应用能力辐射系统。通过该框架，开发者可以实现：</p><ul><li>聚焦搜索中的个性化结果展示</li><li>操作按钮的情境感知体验</li><li>小部件的可配置交互</li><li>控制中心的便捷控件</li><li>Apple Pencil Pro 的自定义操作</li></ul><p>特别值得注意的是，今年新增的 Mac 版聚焦搜索功能已能随处调用应用操作，进一步扩展了应用与系统的交互场景。</p><h3 id="基础元素解析"><a href="#基础元素解析" class="headerlink" title="基础元素解析"></a>基础元素解析</h3><p>在 App Intents 框架中，主要包含三类核心元素：</p><ol><li><strong>Intent（意图）</strong>：代表应用的”动词”，描述可执行的操作</li><li><strong>App Enum（枚举）</strong>：表示固定值集合的类型</li><li><strong>App Entity（实体）</strong>：表示动态类型</li></ol><p>这些元素共同构成了应用的语义模型，使其能够被系统理解和调用。</p><h2 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h2><h3 id="创建首个-App-Intent"><a href="#创建首个-App-Intent" class="headerlink" title="创建首个 App Intent"></a>创建首个 App Intent</h3><p>以一个全球地标旅行应用为例，创建一个导航至地标列表的 intent 需要以下步骤：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NavigateIntent</span>: <span class="title class_ inherited__">AppIntent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> title: <span class="type">LocalizedStringResource</span> <span class="operator">=</span> <span class="string">&quot;导航至地标&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> supportedModes: <span class="type">IntentModes</span> <span class="operator">=</span> .foreground</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainActor</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">perform</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="keyword">some</span> <span class="type">IntentResult</span> &#123;</span><br><span class="line">        <span class="type">Navigator</span>.shared.navigate(to: .landmarks)</span><br><span class="line">        <span class="keyword">return</span> .result()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了符合 AppIntent 协议的结构体，包含本地化标题和执行逻辑的 perform 方法。由于导航操作需要在主线程执行，perform 方法被标记为 @MainActor。</p><h3 id="参数化-Intent"><a href="#参数化-Intent" class="headerlink" title="参数化 Intent"></a>参数化 Intent</h3><p>为了扩展导航功能，可以创建 App Enum 定义导航选项：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NavigationOption</span>: <span class="title class_ inherited__">String</span>, <span class="title class_ inherited__">AppEnum</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> landmarks</span><br><span class="line">    <span class="keyword">case</span> map</span><br><span class="line">    <span class="keyword">case</span> collections</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> typeDisplayRepresentation <span class="operator">=</span> <span class="string">&quot;导航选项&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> caseDisplayRepresentations <span class="operator">=</span> [</span><br><span class="line">        .landmarks: <span class="string">&quot;地标&quot;</span>,</span><br><span class="line">        .map: <span class="string">&quot;地图&quot;</span>,</span><br><span class="line">        .collections: <span class="string">&quot;收藏集&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 intent 中添加参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NavigateIntent</span>: <span class="title class_ inherited__">AppIntent</span> &#123;</span><br><span class="line">    <span class="meta">@Parameter</span>(title: <span class="string">&quot;版块&quot;</span>, requestValueDialog: <span class="string">&quot;要导航到哪个版块？&quot;</span>) </span><br><span class="line">    <span class="keyword">var</span> navigationOption: <span class="type">NavigationOption</span></span><br><span class="line">    <span class="comment">//...其余实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化用户体验"><a href="#优化用户体验" class="headerlink" title="优化用户体验"></a>优化用户体验</h3><p>通过 ParameterSummary 提供流畅的语句式描述：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> parameterSummary: <span class="keyword">some</span> <span class="type">ParameterSummary</span> &#123;</span><br><span class="line">    <span class="type">Summary</span>(<span class="string">&quot;导航至<span class="subst">\(\.<span class="variable">$navigationOption</span>)</span>版块&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今年新增的功能是：当 intent 包含完整 ParameterSummary 时，用户可直接从 Mac 的聚焦搜索运行该操作。</p><h2 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h2><h3 id="App-Shortcuts-创建"><a href="#App-Shortcuts-创建" class="headerlink" title="App Shortcuts 创建"></a>App Shortcuts 创建</h3><p>对于核心 intent，可以通过 App Shortcuts 使其在安装后立即可用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TravelTrackingAppShortcuts</span>: <span class="title class_ inherited__">AppShortcutsProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> appShortcuts: [<span class="type">AppShortcut</span>] &#123;</span><br><span class="line">        <span class="type">AppShortcut</span>(</span><br><span class="line">            intent: <span class="type">NavigateIntent</span>(),</span><br><span class="line">            phrases: [</span><br><span class="line">                <span class="string">&quot;在<span class="subst">\(.applicationName)</span>中导航&quot;</span>,</span><br><span class="line">                <span class="string">&quot;在<span class="subst">\(.applicationName)</span>中导航到<span class="subst">\(\.<span class="variable">$navigationOption</span>)</span>&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            shortTitle: <span class="string">&quot;导航&quot;</span>,</span><br><span class="line">            systemImageName: <span class="string">&quot;arrowshape.forward&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些快捷方式会突出显示在聚焦搜索中，并支持通过 Siri 语音触发。</p><h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><h3 id="动态实体实现"><a href="#动态实体实现" class="headerlink" title="动态实体实现"></a>动态实体实现</h3><p>地标作为应用的核心概念，需要创建 App Entity 进行建模：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LandmarkEntity</span>: <span class="title class_ inherited__">AppEntity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span> &#123; landmark.id &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ComputedProperty</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; landmark.name &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> typeDisplayRepresentation <span class="operator">=</span> <span class="type">TypeDisplayRepresentation</span>(name: <span class="string">&quot;地标&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> displayRepresentation: <span class="type">DisplayRepresentation</span> &#123; <span class="operator">...</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> defaultQuery <span class="operator">=</span> <span class="type">LandmarkEntityQuery</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体必须提供查询机制（EntityQuery）来回答系统查询：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LandmarkEntityQuery</span>: <span class="title class_ inherited__">EntityQuery</span> &#123;</span><br><span class="line">    <span class="meta">@Dependency</span> <span class="keyword">var</span> modelData: <span class="type">ModelData</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">entities</span>(<span class="params">for</span> <span class="params">identifiers</span>: [<span class="type">Int</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">LandmarkEntity</span>] &#123;</span><br><span class="line">        modelData.landmarks(for: identifiers).map(<span class="type">LandmarkEntity</span>.<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="实体功能扩展"><a href="#实体功能扩展" class="headerlink" title="实体功能扩展"></a>实体功能扩展</h3><p>通过实现更多协议，可以扩展实体功能：</p><ol><li><strong>Transferable 协议</strong>：支持图像分享</li><li><strong>IndexedEntity 协议</strong>：实现聚焦搜索索引</li><li><strong>OpenIntent</strong>：实现深度链接</li></ol><p>例如实现深度链接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OpenLandmarkIntent</span>: <span class="title class_ inherited__">OpenIntent</span>, <span class="title class_ inherited__">TargetContentProvidingIntent</span> &#123;</span><br><span class="line">    <span class="meta">@Parameter</span>(title: <span class="string">&quot;地标&quot;</span>) </span><br><span class="line">    <span class="keyword">var</span> target: <span class="type">LandmarkEntity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 SwiftUI 中处理导航</span></span><br><span class="line">.onAppIntentExecution(<span class="type">OpenLandmarkIntent</span>.<span class="keyword">self</span>) &#123; intent <span class="keyword">in</span></span><br><span class="line">    path.append(intent.target.landmark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询增强"><a href="#查询增强" class="headerlink" title="查询增强"></a>查询增强</h3><p>通过实现更多查询协议，可以提供更丰富的实体发现方式：</p><ul><li>EnumerableEntityQuery：返回所有实体</li><li>EntityStringQuery：支持文本搜索</li><li>EntityPropertyQuery：支持属性过滤和排序</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>App Intents 采用编译时生成机制，应用源代码在构建时会被解析，生成的应用意图表示直接嵌入应用包中。这种设计使得系统在安装后即可理解应用能力，无需实际运行应用。</p><p>当在多个 target 间共享类型时，需要定义 AppIntentsPackage：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Swift包中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">TravelTrackingKitPackage</span>: <span class="title class_ inherited__">AppIntentsPackage</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主target中</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TravelTrackingPackage</span>: <span class="title class_ inherited__">AppIntentsPackage</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> includedPackages: [<span class="keyword">any</span> <span class="type">AppIntentsPackage</span>.<span class="keyword">Type</span>] &#123;</span><br><span class="line">        [<span class="type">TravelTrackingKitPackage</span>.<span class="keyword">self</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今年新增了对 Swift 包和静态库的支持。</p><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><p>App Intents 框架为开发者提供了强大的系统集成能力，建议从小处着手，先添加一个 App Shortcut，再逐步探索框架的其他功能。通过将应用的核心功能转化为系统可理解的意图和实体，开发者可以创造更加无缝的用户体验。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><h3 id="相关视频"><a href="#相关视频" class="headerlink" title="相关视频"></a>相关视频</h3><p><a href="https://developer.apple.com/videos/play/wwdc2025/260">使用 App Intents 针对”快捷指令”和”聚焦”进行开发</a><br><a href="https://developer.apple.com/videos/play/wwdc2025/281">设计交互式摘要卡片</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10210">利用 App Intents 为用户奉上 App 的核心功能</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10176">利用 App Intents 设计提升系统体验</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10133">带你的 App 登陆 Siri</a><br><a href="https://developer.apple.com/videos/play/wwdc2024/10134">App Intents 的新功能</a>  </p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><a href="https://developer.apple.com/documentation/AppIntents/app-intent-domains">App intent domains</a><br><a href="https://developer.apple.com/documentation/AppIntents">App Intents</a><br><a href="https://developer.apple.com/documentation/AppIntents/app-shortcuts">App Shortcuts</a><br><a href="https://developer.apple.com/documentation/AppIntents/Creating-your-first-app-intent">Creating your first app intent</a><br><a href="https://developer.apple.com/documentation/AppIntents/Integrating-actions-with-siri-and-apple-intelligence">Integrating actions with Siri and Apple Intelligence</a><br><a href="https://developer.apple.com/documentation/AppIntents/Making-actions-and-content-discoverable-and-widely-available">Making actions and content discoverable and widely available</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 app intents 框架及其在 apple 开发者平台中愈显关键的作用。我们将向你全面介绍意图、实体、查询等核心概念。你将了解如何综合运用这些概念，以便使你的 app 与 apple 设备 (从“聚焦”和“快捷指令”等软件功能到操作按钮等硬件功能) 实现整合。我们还将介绍如何将 app intents 作为你 app 的入口，以便将来实现与 apple 智能的整合。&lt;br&gt;
    
    </summary>
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/categories/wwdc2025/"/>
    
    
      <category term="wwdc2025" scheme="http://djs66256.github.io/tags/wwdc2025/"/>
    
      <category term="ios" scheme="http://djs66256.github.io/tags/ios/"/>
    
      <category term="ipados" scheme="http://djs66256.github.io/tags/ipados/"/>
    
      <category term="macos" scheme="http://djs66256.github.io/tags/macos/"/>
    
      <category term="机器学习与-ai" scheme="http://djs66256.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E-ai/"/>
    
  </entry>
  
</feed>
